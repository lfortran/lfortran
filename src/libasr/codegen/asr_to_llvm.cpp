#include "libasr/assert.h"
#include "libasr/string_utils.h"
#include <iostream>
#include <llvm/IR/Value.h>
#include <memory>
#include <unordered_map>
#include <utility>

#include <llvm/ADT/STLExtras.h>
#include <llvm/Analysis/Passes.h>
#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/ExecutionEngine/GenericValue.h>
#include <llvm/ExecutionEngine/MCJIT.h>
#include <llvm/IR/Argument.h>
#include <llvm/IR/Attributes.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/Intrinsics.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/Type.h>
#include <llvm/Support/Casting.h>
#include <llvm/Support/ManagedStatic.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/ADT/APFloat.h>
#include <llvm/ADT/STLExtras.h>
#include <llvm/IR/Verifier.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/ExecutionEngine/ObjectCache.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/Path.h>
#include <llvm/IR/DIBuilder.h>
#if LLVM_VERSION_MAJOR < 18
#   include <llvm/Transforms/Vectorize.h>
#endif

#include <libasr/asr.h>
#include <libasr/containers.h>
#include <libasr/codegen/asr_to_llvm.h>
#include <libasr/pass/pass_manager.h>
#include <libasr/exception.h>
#include <libasr/asr_utils.h>
#include <libasr/codegen/llvm_utils.h>
#include <libasr/codegen/llvm_array_utils.h>
#include <libasr/pass/intrinsic_function_registry.h>
#include <libasr/codegen/llvm_compat.h>

namespace LCompilers {

using ASR::is_a;
using ASR::down_cast;
using ASR::down_cast2;

using ASRUtils::expr_type;
using ASRUtils::symbol_get_past_external;
using ASRUtils::EXPR2VAR;
using ASRUtils::EXPR2FUN;
using ASRUtils::intent_local;
using ASRUtils::intent_return_var;
using ASRUtils::determine_module_dependencies;
using ASRUtils::is_arg_dummy;
using ASRUtils::is_argument_of_type_CPtr;

// Helper functions for LLVM function name mangling
namespace {

/**
 * Check if a function is an external interface function.
 * External interface functions are functions with:
 * - Interface deftype
 * - Not intrinsic ABI
 * - Not in a module
 */
static inline bool is_external_interface_function(ASR::FunctionType_t* ftype) {
    return ftype->m_deftype == ASR::deftypeType::Interface &&
           ftype->m_abi != ASR::abiType::Intrinsic &&
           !ftype->m_module;
}

/**
 * Compute the final mangled LLVM function name.
 *
 * This function encapsulates all mangling logic in one place:
 * 1. Determines base name (BindC, external interface, or prefixed)
 * 2. Adds parent function prefix if applicable
 *
 * @param sym_name Original symbol name from ASR
 * @param ftype Function type information
 * @param compiler_options Compiler options including mangling flags
 * @param mangle_prefix Prefix to add (typically "_lfortran_")
 * @param parent_function Parent function if this is a nested function
 * @return Final mangled name to use in LLVM
 */
static std::string compute_llvm_function_name(
    const std::string& sym_name,
    ASR::FunctionType_t* ftype,
    const CompilerOptions& compiler_options,
    const std::string& mangle_prefix,
    const ASR::Function_t* parent_function
) {
    (void)compiler_options;
    bool is_external_interface = is_external_interface_function(ftype);
    bool is_bindc = (ftype->m_abi == ASR::abiType::BindC);

    std::string fn_name;

    // Determine base name based on function type
    if (is_bindc) {
        fn_name = ftype->m_bindc_name ? ftype->m_bindc_name : sym_name;
    } else if (is_external_interface) {
        fn_name = sym_name;
    } else {
        fn_name = mangle_prefix + sym_name;
    }

    // Add parent function prefix for nested functions
    if (parent_function != nullptr &&
        !is_external_interface &&
        ftype->m_abi != ASR::abiType::Intrinsic &&
        !is_bindc) {
        fn_name = std::string(parent_function->m_name) + "." + fn_name;
    }

    return fn_name;
}

} // anonymous namespace

class ASRToLLVMVisitor : public ASR::BaseVisitor<ASRToLLVMVisitor>
{
private:
  //! To be used by visit_StructInstanceMember.
  std::string current_der_type_name;

    //! Helpful for debugging while testing LLVM code
    void print_util(llvm::Value* v, std::string fmt_chars, std::string endline) {
        // Usage:
        // print_util(tmp, "%d", "\n") // `tmp` is an integer type to match the format specifiers
        std::vector<llvm::Value *> args;
        std::vector<std::string> fmt;
        args.push_back(v);
        fmt.push_back(fmt_chars);
        std::string fmt_str;
        for (size_t i=0; i<fmt.size(); i++) {
            fmt_str += fmt[i];
            if (i < fmt.size()-1) fmt_str += " ";
        }
        fmt_str += endline;
        llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, fmt_str);
        std::vector<llvm::Value *> printf_args;
        printf_args.push_back(fmt_ptr);
        printf_args.insert(printf_args.end(), args.begin(), args.end());
        printf(context, *module, *builder, printf_args);
    }

    //! Helpful for debugging while testing LLVM code
    void print_util(llvm::Value* v, std::string endline="\n") {
        // Usage:
        // print_util(tmp)
        std::string buf;
        llvm::raw_string_ostream os(buf);
        v->print(os);
        std::cout << os.str() << endline;
    }

    //! Helpful for debugging while testing LLVM code
    void print_util(llvm::Type* v, std::string endline="\n") {
        // Usage:
        // print_util(tmp->getType())
        std::string buf;
        llvm::raw_string_ostream os(buf);
        v->print(os);
        std::cout << os.str() << endline;
    }

public:
    diag::Diagnostics &diag;
    llvm::LLVMContext &context;
    std::unique_ptr<llvm::Module> module;
    std::unique_ptr<llvm::IRBuilder<>> builder;
    std::string infile;
    Allocator &al;

    llvm::Value *tmp;
    llvm::BasicBlock *proc_return;
    std::string mangle_prefix;
    bool prototype_only;
    llvm::StructType *complex_type_4, *complex_type_8;
    llvm::StructType *complex_type_4_ptr, *complex_type_8_ptr;
    llvm::Type* string_descriptor;
    llvm::PointerType *character_type;
    llvm::PointerType *list_type;
    std::vector<std::string> struct_type_stack;

    std::unordered_map<std::uint32_t, std::unordered_map<std::string, llvm::Type*>> arr_arg_type_cache;

    std::map<std::string, std::pair<llvm::Type*, llvm::Type*>> fname2arg_type;

    // Maps for containing information regarding derived types
    std::map<std::string, llvm::StructType*> name2dertype, name2dercontext;
    std::map<std::string, std::string> dertype2parent;
    std::map<std::string, std::map<std::string, int>> name2memidx;

    std::map<uint64_t, llvm::Value*> llvm_symtab; // llvm_symtab_value
    std::map<std::pair<uint64_t, SymbolTable*>, llvm::Value*> llvm_symtab_deep_copy;
    std::map<uint64_t, llvm::Function*> llvm_symtab_fn;
    std::map<std::string, uint64_t> llvm_symtab_fn_names;
    std::map<uint64_t, llvm::Value*> llvm_symtab_fn_arg;
    std::map<uint64_t, llvm::BasicBlock*> llvm_goto_targets;
    std::unordered_map<const ASR::symbol_t*, llvm::BasicBlock*> symbol_to_returnBlock; /// Get Symbol's Return Block -- Used for Finalization. See LLVMFinalize
    std::set<uint32_t> global_string_allocated;
    const ASR::Function_t *parent_function = nullptr;

    std::vector<llvm::BasicBlock*> loop_head; /* For saving the head of a loop,
        so that we can jump to the head of the loop when we reach a cycle */
    std::vector<std::string> loop_head_names;
    std::vector<llvm::BasicBlock*> loop_or_block_end; /* For saving the end of a block,
        so that we can jump to the end of the block when we reach an exit */
    std::vector<std::string> loop_or_block_end_names;

    int64_t ptr_loads;
    bool lookup_enum_value_for_nonints;
    bool is_assignment_target;
    int64_t global_array_count;
    int64_t global_deep_count;

    CompilerOptions &compiler_options;
    LocationManager &location_manager;

    // For handling debug information
    std::unique_ptr<llvm::DIBuilder> DBuilder;
    llvm::DICompileUnit *debug_CU;
    llvm::DIScope *debug_current_scope;
    llvm::DIFile *debug_Unit;

    std::map<ASR::symbol_t*, std::map<SymbolTable*, llvm::Value*>> type2vtab;
    std::map<ASR::symbol_t*, std::map<SymbolTable*, std::vector<llvm::Value*>>> class2vtab;
    std::map<ASR::symbol_t*, llvm::Type*> type2vtabtype;
    std::map<ASR::symbol_t*, int> type2vtabid;
    std::map<ASR::symbol_t*, std::map<std::string, int64_t>> vtabtype2procidx;
    std::map<ASR::symbol_t*, std::map<std::string, int64_t>> struct_vtab_function_offset;



    llvm::Value* current_sret_arg;

    SymbolTable* current_scope;
    std::unique_ptr<LLVMUtils> llvm_utils;
    std::unique_ptr<LLVMList> list_api;
    std::unique_ptr<LLVMStruct> struct_api;
    std::unique_ptr<LLVMTuple> tuple_api;
    std::unique_ptr<LLVMDictInterface> dict_api_lp;
    std::unique_ptr<LLVMDictInterface> dict_api_sc;
    std::unique_ptr<LLVMSetInterface> set_api_lp;
    std::unique_ptr<LLVMSetInterface> set_api_sc;
    std::unique_ptr<LLVMArrUtils::Descriptor> arr_descr;
    LLVMFinalize llvm_symtab_finalizer;
    Vec<llvm::Value*> strings_to_be_deallocated;
    Vec<llvm::Value*> heap_fixed_size_arrays;  // Heap-allocated large fixed-size arrays for cleanup
    bool in_block_context = false;  // Flag to track if we're inside a BLOCK construct
    struct to_be_allocated_array{ // struct to hold details for the initializing pointer_to_array_type later inside main function.
        ASR::expr_t* expr;
        llvm::Constant* pointer_to_array_type;
        llvm::Type* array_type;
        LCompilers::ASR::ttype_t* var_type;
        size_t n_dims;
    };
    std::vector<to_be_allocated_array> allocatable_array_details;
    std::vector<std::pair<ASR::symbol_t*, llvm::Value*>> allocatable_struct_array_members_details;
    struct variable_inital_value { /* Saves information for variables that need to be initialized once. To be initialized in `program`*/
        ASR::Variable_t* v;
        llvm::Value* target_var; // Corresponds to variable `v` in llvm IR.
    };
    std::vector<variable_inital_value> variable_inital_value_vec; /* Saves information for variables that need to be initialized once. To be initialized in `program`*/

    // Pool of allocas for call arguments, keyed by LLVM type.
    // This avoids creating a new alloca for every expression argument at every
    // call site, which caused excessive stack usage (e.g., 217x more than
    // GFortran for LAPACK's ctfsm function). Instead, we reuse allocas of the
    // same type across different calls.
    std::map<llvm::Type*, std::vector<llvm::AllocaInst*>> call_arg_alloca_pool;
    std::map<llvm::Type*, size_t> call_arg_alloca_idx;
    int convert_call_args_depth = 0;

    // Get or create an alloca for a call argument of the given type.
    // Reuses allocas from the pool when possible.
    llvm::AllocaInst* get_call_arg_alloca(llvm::Type* type) {
        size_t& idx = call_arg_alloca_idx[type];
        std::vector<llvm::AllocaInst*>& pool = call_arg_alloca_pool[type];
        if (idx < pool.size()) {
            return pool[idx++];
        }
        // Need to create a new alloca
        llvm::AllocaInst* alloca = llvm_utils->CreateAlloca(type, nullptr, "call_arg_value");
        pool.push_back(alloca);
        idx++;
        return alloca;
    }

    // Reset alloca pool indices at the start of processing call arguments.
    // This allows reuse of allocas across different call sites.
    void reset_call_arg_alloca_pool() {
        for (auto& kv : call_arg_alloca_idx) {
            kv.second = 0;
        }
    }

    ASRToLLVMVisitor(Allocator &al, llvm::LLVMContext &context, std::string infile,
        CompilerOptions &compiler_options_, diag::Diagnostics &diagnostics, LocationManager &lm) :
    diag{diagnostics},
    context(context),
    builder(std::make_unique<llvm::IRBuilder<>>(context)),
    infile{infile},
    al{al},
    prototype_only(false),
    ptr_loads(2),
    lookup_enum_value_for_nonints(false),
    is_assignment_target(false),
    global_array_count(0),
    global_deep_count(0),
    compiler_options(compiler_options_),
    location_manager{lm},
    current_sret_arg(nullptr),
    current_scope(nullptr),
    llvm_utils(std::make_unique<LLVMUtils>(context, builder.get(),
        current_der_type_name, name2dertype, name2dercontext, struct_type_stack,
        dertype2parent, name2memidx, compiler_options, arr_arg_type_cache,
        fname2arg_type, llvm_symtab)),
    list_api(std::make_unique<LLVMList>(context, llvm_utils.get(), builder.get())),
    struct_api(std::make_unique<LLVMStruct>(context, llvm_utils.get(), builder.get(), llvm_symtab_fn,
                [this](ASR::Struct_t* s, llvm::Value* v, ASR::ttype_t* t, bool flag) {
                        allocate_array_members_of_struct(s, v, t, flag);
                })),
    tuple_api(std::make_unique<LLVMTuple>(context, llvm_utils.get(), builder.get())),
    dict_api_lp(std::make_unique<LLVMDictOptimizedLinearProbing>(context, llvm_utils.get(), builder.get())),
    dict_api_sc(std::make_unique<LLVMDictSeparateChaining>(context, llvm_utils.get(), builder.get())),
    set_api_lp(std::make_unique<LLVMSetLinearProbing>(context, llvm_utils.get(), builder.get())),
    set_api_sc(std::make_unique<LLVMSetSeparateChaining>(context, llvm_utils.get(), builder.get())),
    arr_descr(LLVMArrUtils::Descriptor::get_descriptor(context,
              builder.get(), llvm_utils.get(),
              LLVMArrUtils::DESCR_TYPE::_SimpleCMODescriptor, compiler_options_)),
    llvm_symtab_finalizer(*this, llvm_utils, builder, al)
    {
        llvm_utils->tuple_api = tuple_api.get();
        llvm_utils->list_api = list_api.get();
        llvm_utils->struct_api = struct_api.get();
        llvm_utils->dict_api = nullptr;
        llvm_utils->set_api = nullptr;
        llvm_utils->arr_api = arr_descr.get();
        llvm_utils->dict_api_lp = dict_api_lp.get();
        llvm_utils->dict_api_sc = dict_api_sc.get();
        llvm_utils->set_api_lp = set_api_lp.get();
        llvm_utils->set_api_sc = set_api_sc.get();
        llvm_utils->dim_descr_type_ = arr_descr->get_dimension_descriptor_type();
        strings_to_be_deallocated.reserve(al, 1);
        heap_fixed_size_arrays.reserve(al, 1);
    }

    #define load_non_array_non_character_pointers(expr, type, llvm_value) if( ASR::is_a<ASR::StructInstanceMember_t>(*expr) && \
        !ASRUtils::is_array(type) && \
        LLVM::is_llvm_pointer(*type) && \
        !ASRUtils::is_character(*type) ) { \
        llvm::Type *llvm_type = llvm_utils->get_type_from_ttype_t_util(expr, \
            ASRUtils::extract_type(type), module.get()); \
        llvm_value = llvm_utils->CreateLoad2(llvm_type, llvm_value); \
    } \

    // Inserts a new block `bb` using the current builder
    // and terminates the previous block if it is not already terminated
    void start_new_block(llvm::BasicBlock *bb) {
        llvm::BasicBlock *last_bb = builder->GetInsertBlock();
        llvm::Function *fn = last_bb->getParent();
        llvm::Instruction *block_terminator = last_bb->getTerminator();
        if (block_terminator == nullptr) {
            // The previous block is not terminated --- terminate it by jumping
            // to our new block
            builder->CreateBr(bb);
        }
        if (bb->getParent() == nullptr) {
#if LLVM_VERSION_MAJOR >= 16
            fn->insert(fn->end(), bb);
#else
            fn->getBasicBlockList().push_back(bb);
#endif
        } else {
            LCOMPILERS_ASSERT(bb->getParent() == fn);
        }
        builder->SetInsertPoint(bb);
    }

    void predeclare_goto_targets(llvm::Function *fn, ASR::stmt_t **body, size_t n) {
        for (size_t i = 0; i < n; i++) {
            if (body[i]->type != ASR::stmtType::GoToTarget) continue;
            ASR::GoToTarget_t *gt = ASR::down_cast<ASR::GoToTarget_t>(body[i]);
            if (llvm_goto_targets.find(gt->m_id) != llvm_goto_targets.end()) continue;
            llvm::BasicBlock *bb = llvm::BasicBlock::Create(context, "goto_target");
#if LLVM_VERSION_MAJOR >= 16
            fn->insert(fn->end(), bb);
#else
            fn->getBasicBlockList().push_back(bb);
#endif
            llvm_goto_targets[gt->m_id] = bb;
        }
    }

    template <typename Cond, typename Body>
    void create_loop(char *name, Cond condition, Body loop_body) {

        std::string loop_name;
        if (name) {
            loop_name = std::string(name);
        } else {
            loop_name = "loop";
        }

        std::string loophead_name = loop_name + ".head";
        std::string loopbody_name = loop_name + ".body";
        std::string loopend_name = loop_name + ".end";

        llvm::BasicBlock *loophead = llvm::BasicBlock::Create(context, loophead_name);
        llvm::BasicBlock *loopbody = llvm::BasicBlock::Create(context, loopbody_name);
        llvm::BasicBlock *loopend = llvm::BasicBlock::Create(context, loopend_name);

        loop_head.push_back(loophead);
        loop_head_names.push_back(loophead_name);
        loop_or_block_end.push_back(loopend);
        loop_or_block_end_names.push_back(loopend_name);

        // head
        start_new_block(loophead); {
            llvm::Value* cond = condition();
            builder->CreateCondBr(cond, loopbody, loopend);
        }

        // body
        start_new_block(loopbody); {
            loop_body();
            builder->CreateBr(loophead);
        }

        // end
        loop_head.pop_back();
        loop_head_names.pop_back();
        loop_or_block_end.pop_back();
        loop_or_block_end_names.pop_back();
        start_new_block(loopend);
    }

    void get_type_debug_info(ASR::ttype_t* t, std::string &type_name,
            uint32_t &type_size, uint32_t &type_encoding) {
        ASR::ttype_t* t_ = ASRUtils::extract_type(t);

        type_size = ASRUtils::extract_kind_from_ttype_t(t_)*8;
        switch( t_->type ) {
            case ASR::ttypeType::Integer: {
                type_name = "integer";
                type_encoding = llvm::dwarf::DW_ATE_signed;
                break;
            }
            case ASR::ttypeType::UnsignedInteger: {
                type_name = "integer";
                type_encoding = llvm::dwarf::DW_ATE_unsigned;
                break;
            }
            case ASR::ttypeType::Logical: {
                type_name = "boolean";
                type_encoding = llvm::dwarf::DW_ATE_boolean;
                break;
            }
            case ASR::ttypeType::Real: {
                if( type_size == 32 ) {
                    type_name = "float";
                } else if( type_size == 64 ) {
                    type_name = "double";
                }
                type_encoding = llvm::dwarf::DW_ATE_float;
                break;
            }
            case ASR::ttypeType::Complex: {
                type_name = "complex";
                type_size = 2 * ASRUtils::extract_kind_from_ttype_t(t_) * 8;
                type_encoding = llvm::dwarf::DW_ATE_complex_float;
                break;
            }
            case ASR::ttypeType::String: {
                type_name = "character";
                type_encoding = llvm::dwarf::DW_ATE_unsigned_char;
                break;
            }
            case ASR::ttypeType::CPtr: {
                type_name = "c_ptr";
                type_size = 64;
                type_encoding = llvm::dwarf::DW_ATE_address;
                break;
            }
            default : {
                type_name = "non-specified-debug-type-SIZE-set-to-ZERO";
                type_size = 0;
                type_encoding = llvm::dwarf::DW_ATE_unsigned;
                break;
            }
        }
    }

    void debug_get_line_column(const uint32_t &loc_first,
            uint32_t &line, uint32_t &column) {
        LocationManager lm;
        LocationManager::FileLocations fl;
        fl.in_filename = infile;
        lm.files.push_back(fl);
        std::string input;
        if (!read_file(infile, input)) {
            throw CodeGenError("File '" + infile + "' cannot be opened.");
        }
        lm.init_simple(input);
        lm.file_ends.push_back(input.size());
        lm.pos_to_linecol(lm.output_to_input_pos(loc_first, false),
            line, column, fl.in_filename);
    }

    template <typename T>
    void debug_emit_loc(const T &x) {
        Location loc = x.base.base.loc;
        uint32_t line, column;
        debug_get_line_column(loc.first, line, column);
        builder->SetCurrentDebugLocation(
            llvm::DILocation::get(debug_current_scope->getContext(),
                line, column, debug_current_scope));
    }

    template <typename T>
    void debug_emit_function(const T &x, llvm::DISubprogram *&SP) {
        debug_Unit = DBuilder->createFile(
            debug_CU->getFilename(),
            debug_CU->getDirectory());
        llvm::DIScope *FContext = debug_Unit;
        uint32_t line, column;
        debug_get_line_column(x.base.base.loc.first, line, column);
        std::string fn_debug_name = x.m_name;
        llvm::DIBasicType *return_type_info = nullptr;
        if constexpr (std::is_same_v<T, ASR::Function_t>){
            if(x.m_return_var != nullptr) {
                std::string type_name; uint32_t type_size, type_encoding;
                get_type_debug_info(ASRUtils::expr_type(x.m_return_var),
                    type_name, type_size, type_encoding);
                return_type_info = DBuilder->createBasicType(type_name,
                    type_size, type_encoding);
            }
        } else if constexpr (std::is_same_v<T, ASR::Program_t>) {
            return_type_info = DBuilder->createBasicType("integer", 32,
                llvm::dwarf::DW_ATE_signed);
        }
        llvm::DISubroutineType *return_type = DBuilder->createSubroutineType(
            DBuilder->getOrCreateTypeArray(return_type_info));
        SP = DBuilder->createFunction(
            FContext, fn_debug_name, llvm::StringRef(), debug_Unit,
            line, return_type, 0, // TODO: ScopeLine
            llvm::DINode::FlagPrototyped,
#if LLVM_VERSION_MAJOR >= 8
            llvm::DISubprogram::SPFlagDefinition);
#else
            // LLVM 7: SPFlag enum doesn't exist, use DIDescriptor::FlagPrototyped
            llvm::DINode::FlagZero);
#endif
        debug_current_scope = SP;
    }

    inline bool verify_dimensions_t(ASR::dimension_t* m_dims, int n_dims) {
        if( n_dims <= 0 ) {
            return false;
        }
        bool is_ok = true;
        for( int r = 0; r < n_dims; r++ ) {
            if( m_dims[r].m_length == nullptr ) {
                is_ok = false;
                break;
            }
        }
        return is_ok;
    }

    void fill_array_details(llvm::Type* arr_ty, llvm::Value* arr, llvm::Type* llvm_data_type,
                            ASR::dimension_t* m_dims, int n_dims, bool is_data_only=false,
                            bool reserve_data_memory=true) {
        std::vector<std::pair<llvm::Value*, llvm::Value*>> llvm_dims;
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 2;
        for( int r = 0; r < n_dims; r++ ) {
            ASR::dimension_t m_dim = m_dims[r];
            LCOMPILERS_ASSERT(m_dim.m_start != nullptr);
            visit_expr(*(m_dim.m_start));
            llvm::Value* start = tmp;
            LCOMPILERS_ASSERT(m_dim.m_length != nullptr);
            load_array_size_deep_copy(m_dim.m_length);
            llvm::Value* end = tmp;
            llvm_dims.push_back(std::make_pair(start, end));
        }
        ptr_loads = ptr_loads_copy;
        if( is_data_only ) {
            if( !ASRUtils::is_fixed_size_array(m_dims, n_dims) ) {
                // Use the descriptor's index type for consistent bit width (i32 or i64)
                llvm::Type* index_type = arr_descr->get_index_type();
                unsigned index_bit_width = index_type->getIntegerBitWidth();
                llvm::Value* const_1 = llvm::ConstantInt::get(context, llvm::APInt(index_bit_width, 1));
                llvm::Value* prod = const_1;
                for( int r = 0; r < n_dims; r++ ) {
                    llvm::Value* dim_size = llvm_dims[r].second;
                    // Ensure dim_size matches index_type
                    dim_size = builder->CreateSExtOrTrunc(dim_size, index_type);
                    prod = builder->CreateMul(prod, dim_size);
                }
                llvm::Value* arr_first = nullptr;
                if( !compiler_options.stack_arrays ) {
                    llvm::DataLayout data_layout(module->getDataLayout());
                    uint64_t size = data_layout.getTypeAllocSize(llvm_data_type);
                    prod = builder->CreateMul(prod,
                        llvm::ConstantInt::get(context, llvm::APInt(index_bit_width, size)));
                    llvm::Value* arr_first_i8 = LLVMArrUtils::lfortran_malloc(
                        context, *module, *builder, prod);
                    arr_first = builder->CreateBitCast(
                        arr_first_i8, llvm_data_type->getPointerTo());
                } else {
                    arr_first = llvm_utils->CreateAlloca(*builder, llvm_data_type, prod);
                    builder->CreateStore(arr_first, arr);
                }
            }
        } else {
            arr_descr->fill_array_details(arr_ty, arr, llvm_data_type, n_dims,
                llvm_dims, module.get(), reserve_data_memory);
        }
    }

    /*
        This function fills the descriptor
        (pointer to the first element, offset and descriptor of each dimension)
        of the array which are allocated memory in heap.
    */
    inline void fill_malloc_array_details(llvm::Value* arr, llvm::Type* arr_type, llvm::Type* llvm_data_type,
                                          ASR::ttype_t* asr_type, ASR::symbol_t* const variable_declaration,
                                          ASR::dimension_t* m_dims, int n_dims,
                                          ASR::expr_t* string_len_to_allocate,
                                          ASR::symbol_t* allocated_subclass=nullptr,
                                          bool realloc=false,
                                          ASR::ttype_t* alloc_type=nullptr) {
        std::vector<std::pair<llvm::Value*, llvm::Value*>> llvm_dims;
        int ptr_loads_copy = ptr_loads;
        ptr_loads = 2;
        for( int r = 0; r < n_dims; r++ ) {
            ASR::dimension_t m_dim = m_dims[r];
            visit_expr_wrapper(m_dim.m_start, true);
            llvm::Value* start = tmp;
            visit_expr_wrapper(m_dim.m_length, true);
            llvm::Value* end = tmp;
            llvm_dims.push_back(std::make_pair(start, end));
        }
        llvm::Value* string_len{};
        if(string_len_to_allocate){
            visit_expr(*string_len_to_allocate);
            string_len = tmp;
            tmp = nullptr;
        }
        ptr_loads = ptr_loads_copy;
        arr_descr->fill_malloc_array_details(arr, arr_type, llvm_data_type,
            asr_type, n_dims, llvm_dims, string_len, variable_declaration, module.get(), 
            allocated_subclass, realloc, alloc_type);
    }


    std::pair<llvm::Value*, llvm::Value*> get_string_data_and_length(ASR::expr_t* str_expr){
        LCOMPILERS_ASSERT(ASR::is_a<ASR::String_t>(*
            ASRUtils::extract_type(ASRUtils::expr_type(str_expr))))

        // Evaluate Expression
        ASR::String_t* str = ASR::down_cast<ASR::String_t>(
            ASRUtils::extract_type(expr_type(str_expr)));
        this->visit_expr_load_wrapper(str_expr, 0);
        std::pair<llvm::Value*, llvm::Value*> data_and_length;
        switch (str->m_physical_type)
        {
            case ASR::DescriptorString:{
                //Set data
                data_and_length.first = builder->CreateLoad(
                    character_type,
                    llvm_utils->create_gep2(string_descriptor, tmp, 0));

                // Set length (Length could be explicit OR implicit)
                if(str->m_len && ASR::is_a<ASR::IntegerConstant_t>(*str->m_len)){ // Explicit-Constant Length
                    ASR::IntegerConstant_t* len = ASR::down_cast<ASR::IntegerConstant_t>(str->m_len);
                    llvm::Value* len_value = llvm::ConstantInt::get(context, llvm::APInt(64, len->m_n));
                    data_and_length.second = len_value;
                } else { // Implicit Length
                    data_and_length.second = builder->CreateLoad(
                        llvm::Type::getInt64Ty(context),
                        llvm_utils->create_gep2(string_descriptor, tmp, 1));
                }
                break;
            }
            case ASR::CChar:{

                llvm::Value* char_ptr = builder->CreateAlloca(llvm::Type::getInt8Ty(context));
                data_and_length.first = builder->CreateStore(tmp, char_ptr);
                data_and_length.second = llvm::ConstantInt::get(context, llvm::APInt(64, 1));
                break;
            }
            default:
                throw LCompilersException("Unsupported string physical type.");
        }
        return data_and_length;
    }





    /*
        * Returns length of the string in an array of strings.
    */
    llvm::Value* get_string_length_in_array(ASR::expr_t* expr, llvm::Value* str){
        LCOMPILERS_ASSERT(llvm_utils->is_proper_array_of_strings_llvm_var(expr_type(expr), str))
        ASR::String_t* str_type = ASRUtils::get_string_type(expr_type(expr));
        switch(ASRUtils::extract_physical_type(expr_type(expr))){
            case ASR::DescriptorArray : {
                switch(str_type->m_physical_type){
                    case ASR::DescriptorString : {
                        llvm::Value* temp{};
                        temp = arr_descr->get_pointer_to_data(expr, ASRUtils::expr_type(expr), str, module.get());
                        temp = builder->CreateLoad(
                            llvm_utils->get_el_type(expr, ASRUtils::extract_type(expr_type(expr)), module.get())->getPointerTo(),
                            temp);
                        return builder->CreateLoad(llvm::Type::getInt64Ty(context),
                                llvm_utils->create_gep2(string_descriptor, temp, 1));
                    }
                    default:
                        throw LCompilersException("Unhandled string physicalType");
                }
            }
            case ASR::PointerArray:{
                switch(str_type->m_physical_type){
                    case ASR::DescriptorString : {
                        return builder->CreateLoad(llvm::Type::getInt64Ty(context),
                                llvm_utils->create_gep2(string_descriptor, str, 1));
                    }
                    default:
                        throw LCompilersException("Unhandled string physicalType");

                }
            default:
                throw LCompilersException("Unhandled Array Physical type");
            }

        }
    }


    /*
     * Returns length of the string (int64)
     * It handles string and array of strings.
    */
    llvm::Value* get_string_length(ASR::expr_t* str_expr){
        ASR::ttype_t* exp_type = ASRUtils::expr_type(str_expr);
        LCOMPILERS_ASSERT(ASR::is_a<ASR::String_t>(*
            ASRUtils::extract_type(exp_type)))

        ASR::String_t* str = ASR::down_cast<ASR::String_t>(
            ASRUtils::extract_type(exp_type));


        switch (str->m_physical_type)
        {
            case ASR::DescriptorString:{
                // Set length Length could be explicit
                if(str->m_len && ASR::is_a<ASR::IntegerConstant_t>(*str->m_len)){ // Explicit-Constant Length
                    ASR::IntegerConstant_t* len = ASR::down_cast<ASR::IntegerConstant_t>(str->m_len);
                    llvm::Value* len_value = llvm::ConstantInt::get(context, llvm::APInt(64, len->m_n));
                    return len_value;
                } else { // Implicit Length
                    if(ASRUtils::is_array(exp_type)){
                        visit_expr_load_wrapper(str_expr, ASRUtils::is_allocatable_or_pointer(exp_type) ? 1 : 0);
                        return get_string_length_in_array(str_expr, tmp);
                    } else {
                        // Handling Logic for ArrayItem accessing empty array
                        // In this case, return length from array descriptors
                        if (ASR::is_a<ASR::ArrayItem_t>(*str_expr)) {
                            ASR::expr_t* arr_expr = ASR::down_cast<ASR::ArrayItem_t>(str_expr)->m_v;
                            ASR::ttype_t* arr_type_asr = ASRUtils::expr_type(arr_expr);
                            if (ASRUtils::is_array(arr_type_asr)) {
                                ASR::Array_t* arr_t = ASR::down_cast<ASR::Array_t>(
                                    ASRUtils::type_get_past_allocatable_pointer(arr_type_asr));
                                if (arr_t->m_physical_type == ASR::array_physical_typeType::DescriptorArray) {
                                    visit_expr_load_wrapper(arr_expr, ASRUtils::is_allocatable_or_pointer(arr_type_asr) ? 1 : 0);
                                    llvm::Value* arr_desc = tmp;
                                    llvm::Type* arr_type_llvm = llvm_utils->get_type_from_ttype_t_util(arr_expr,
                                        ASRUtils::type_get_past_allocatable_pointer(arr_type_asr), module.get());
                                    llvm::Value* is_empty = builder->CreateICmpEQ(
                                        arr_descr->get_array_size(arr_type_llvm, arr_desc, nullptr, 4),
                                        llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 0)));

                                    llvm::Value* len_result = llvm_utils->CreateAlloca(llvm::Type::getInt64Ty(context), nullptr, "");
                                    llvm_utils->create_if_else(is_empty, [&]() {
                                        llvm::Value* str_desc = builder->CreateLoad(string_descriptor->getPointerTo(),
                                            llvm_utils->create_gep2(arr_type_llvm, arr_desc, 0));
                                        llvm::Value* len_val = builder->CreateLoad(llvm::Type::getInt64Ty(context),
                                            llvm_utils->create_gep2(string_descriptor, str_desc, 1));
                                        builder->CreateStore(len_val, len_result);
                                    }, [&]() {
                                        visit_expr_load_wrapper(str_expr, 0);
                                        llvm::Value* len_val = builder->CreateLoad(llvm::Type::getInt64Ty(context),
                                            llvm_utils->create_gep2(string_descriptor, tmp, 1));
                                        builder->CreateStore(len_val, len_result);
                                    });
                                    return llvm_utils->CreateLoad2(llvm::Type::getInt64Ty(context), len_result);
                                }
                            }
                        }
                        // Accessing Non-array string or non-empty ArrayItem
                        visit_expr_load_wrapper(str_expr, 0);
                        LCOMPILERS_ASSERT(llvm_utils->is_proper_string_llvm_variable(str, tmp))
                        return builder->CreateLoad(
                            llvm::Type::getInt64Ty(context),
                            llvm_utils->create_gep2(string_descriptor, tmp, 1));
                    }
                }
            }
            case ASR::CChar:
                return llvm::ConstantInt::get(context, llvm::APInt(64, 1));
            default:
                throw LCompilersException("Unsupported string physical type.");
        }

    }

    llvm::Value* get_string_data(ASR::expr_t* str_expr){
        LCOMPILERS_ASSERT(ASR::is_a<ASR::String_t>(*
            ASRUtils::extract_type(ASRUtils::expr_type(str_expr))))

        // Evaluate Expression
        ASR::String_t* str = ASR::down_cast<ASR::String_t>(
            ASRUtils::extract_type(expr_type(str_expr)));
        int ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        visit_expr(*str_expr);
        ptr_loads = ptr_loads_copy;
        switch (str->m_physical_type)
        {
            case ASR::DescriptorString:{
                return builder->CreateLoad(
                    character_type,
                    llvm_utils->create_gep2(string_descriptor, tmp, 0));
            }
            case ASR::CChar:{
                llvm::Value* char_ptr = builder->CreateAlloca(llvm::Type::getInt8Ty(context));
                return builder->CreateStore(tmp, char_ptr);
            }
            default:
                throw LCompilersException("Unsupported string physical type.");
        }
        return nullptr;
    }

    void setup_string_length(llvm::Value* str,
        ASR::String_t* str_type, ASR::expr_t* len){
        LCOMPILERS_ASSERT(str)
        switch(str_type->m_len_kind){
            case ASR::ExpressionLength:{
                LCOMPILERS_ASSERT(len);
                int ptr_load_cpy = ptr_loads;ptr_loads = 1;
                visit_expr(*len);
                ptr_loads = ptr_load_cpy;
                tmp = llvm_utils->convert_kind(tmp, llvm::Type::getInt64Ty(context));
                llvm::Value* len_ptr = llvm_utils->get_string_length(str_type, str, true);
                builder->CreateStore(tmp, len_ptr);
                tmp = nullptr;
                break;
            }
            case ASR::AssumedLength:
                LCOMPILERS_ASSERT_MSG(false,
                    "Shouldn't define assumed length string variable (They're only arguments) ")
                break;
            case ASR::DeferredLength:
                // Do nothing, deferred length strings doesn't have information to set it up with.
                break;
            default:
                throw LCompilersException("Unhandled string length kind");
                break;
        }
    }
    /*
        Setup a string variable declaration.
        Sets up string's information (data and length)
        based on ASR::String node details.
        - Everything is set to its inital value at first (nullptr, 0).
        - Length is set, if not deferred.
        - Memory gets allocated, if not allocatable.
    */
    void setup_string(llvm::Value* str, ASR::ttype_t* type){
        if(ASRUtils::is_descriptorString(type)){
            builder->CreateStore(llvm::Constant::getNullValue(string_descriptor), str);
            ASR::String_t *t = down_cast<ASR::String_t>(ASRUtils::extract_type(type));
            setup_string_length(str, t, t->m_len);
            // Handle Memory
            if(!ASRUtils::is_allocatable_or_pointer(type)){
                llvm_utils->set_string_memory_on_heap(t->m_physical_type, str, llvm_utils->get_string_length(t, str));
            }
        } else {
            throw LCompilersException("Unhandled string physicalType");
        }
    }

    /*
        *Creates the string (based on stringPhysicalType) used for arrays of strings.
        *This sets the initial state of the array's string.
        - Creates a single string (based on the physical type).
        - If not allocatable, set data member with (array_size * string_length)
        - If not deferred length, Set length member.
        It doesn't handle the array itself, only the string data it contains.
    */
    llvm::Value* create_and_setup_string_for_array(ASR::ttype_t* var_type, llvm::Value* array_size, bool stack_allocation=false, std::string name = "") {
        LCOMPILERS_ASSERT(ASRUtils::is_array(var_type) && ASRUtils::is_character(*var_type))
        ASR::String_t* str = ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(var_type));

        if(str->m_physical_type == ASR::DescriptorString){
            llvm::Value* str_desc = llvm_utils->create_empty_string_descriptor(name); // StringDesc with initial state.
            // Setup Length
            setup_string_length(str_desc, str, str->m_len);
            // Setup memory
            if(!ASRUtils::is_allocatable_or_pointer(var_type) /*Length is Fixed*/){
                LCOMPILERS_ASSERT(str->m_len_kind == ASR::ExpressionLength)
                LCOMPILERS_ASSERT( array_size )
                LCOMPILERS_ASSERT( str->m_len )

                tmp = nullptr;
                visit_expr_load_wrapper(str->m_len, 1);
                llvm::Value* str_len = tmp;

                // Arrays are allocated on heap by default.
                stack_allocation ?
                    llvm_utils->set_array_of_strings_memory_on_stack(str, str_desc, str_len, array_size)
                    :llvm_utils->set_array_of_strings_memory_on_heap(str, str_desc, str_len, array_size);
            }
            return str_desc;
        } else {
            throw LCompilersException("Unhandled string physicalType");
        }
        return nullptr;
    }
    /*
    * Dispatches the required function from runtime library to
    * perform the specified binary operation.
    *
    * @param left_arg llvm::Value* The left argument of the binary operator.
    * @param right_arg llvm::Value* The right argument of the binary operator.
    * @param runtime_func_name std::string The name of the function to be dispatched
    *                                      from runtime library.
    * @returns llvm::Value* The result of the operation.
    *
    * Note
    * ====
    *
    * Internally the call to this function gets transformed into a runtime call:
    * void _lfortran_complex_add(complex* a, complex* b, complex *result)
    *
    * As of now the following values for func_name are supported,
    *
    * _lfortran_complex_add
    * _lfortran_complex_sub
    * _lfortran_complex_div
    * _lfortran_complex_mul
    */
    // Convert a complex value from vector type (e.g. <2 x float>) to struct type
    // (e.g. {float, float}) if needed. BindC functions return complex as vectors
    // on non-macOS ARM platforms, but we use struct types internally.
    llvm::Value* convert_complex_vector_to_struct(llvm::Value* val, llvm::Type* complex_type) {
        llvm::Type* val_type = val->getType();
        if (!llvm::isa<FIXED_VECTOR_TYPE>(val_type)) {
            return val;
        }
        llvm::Value* result = llvm::UndefValue::get(complex_type);
        llvm::Value* idx0 = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0);
        llvm::Value* idx1 = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 1);
        llvm::Value* re = builder->CreateExtractElement(val, idx0);
        llvm::Value* im = builder->CreateExtractElement(val, idx1);
        result = builder->CreateInsertValue(result, re, {0});
        result = builder->CreateInsertValue(result, im, {1});
        return result;
    }

    llvm::Value* lfortran_complex_bin_op(llvm::Value* left_arg, llvm::Value* right_arg,
                                         std::string runtime_func_name,
                                         llvm::Type* complex_type=nullptr)
    {
        if( complex_type == nullptr ) {
            complex_type = complex_type_4;
        }

        // Convert vector types to struct types if needed (BindC ABI compatibility)
        left_arg = convert_complex_vector_to_struct(left_arg, complex_type);
        right_arg = convert_complex_vector_to_struct(right_arg, complex_type);

        // Extract real and imaginary parts: complex is {float, float} or {double, double}
        llvm::Value* left_real = builder->CreateExtractValue(left_arg, {0});
        llvm::Value* left_imag = builder->CreateExtractValue(left_arg, {1});
        llvm::Value* right_real = builder->CreateExtractValue(right_arg, {0});
        llvm::Value* right_imag = builder->CreateExtractValue(right_arg, {1});

        llvm::Value* result_real = nullptr;
        llvm::Value* result_imag = nullptr;

        // Inline arithmetic for add, sub, mul, div; fallback to runtime for pow
        if (runtime_func_name == "_lfortran_complex_add_32" ||
            runtime_func_name == "_lfortran_complex_add_64") {
            // (a+bi) + (c+di) = (a+c) + (b+d)i
            result_real = builder->CreateFAdd(left_real, right_real);
            result_imag = builder->CreateFAdd(left_imag, right_imag);
        } else if (runtime_func_name == "_lfortran_complex_sub_32" ||
                   runtime_func_name == "_lfortran_complex_sub_64") {
            // (a+bi) - (c+di) = (a-c) + (b-d)i
            result_real = builder->CreateFSub(left_real, right_real);
            result_imag = builder->CreateFSub(left_imag, right_imag);
        } else if (runtime_func_name == "_lfortran_complex_mul_32" ||
                   runtime_func_name == "_lfortran_complex_mul_64") {
            // (a+bi) * (c+di) = (ac-bd) + (ad+bc)i
            llvm::Value* ac = builder->CreateFMul(left_real, right_real);
            llvm::Value* bd = builder->CreateFMul(left_imag, right_imag);
            llvm::Value* ad = builder->CreateFMul(left_real, right_imag);
            llvm::Value* bc = builder->CreateFMul(left_imag, right_real);
            result_real = builder->CreateFSub(ac, bd);
            result_imag = builder->CreateFAdd(ad, bc);
        } else if (runtime_func_name == "_lfortran_complex_div_32" ||
                   runtime_func_name == "_lfortran_complex_div_64") {
            auto create_fabs = [&](llvm::Value* value) -> llvm::Value* {
#if LLVM_VERSION_MAJOR >= 12
                return builder->CreateUnaryIntrinsic(llvm::Intrinsic::fabs, value);
#elif LLVM_VERSION_MAJOR >= 8
                return builder->CreateIntrinsic(llvm::Intrinsic::fabs,
                    {value->getType()}, {value});
#else
                llvm::Function *fn = llvm::Intrinsic::getDeclaration(module.get(),
                    llvm::Intrinsic::fabs, {value->getType()});
                return builder->CreateCall(fn, {value});
#endif
            };

            llvm::Value* abs_right_real = create_fabs(right_real);
            llvm::Value* abs_right_imag = create_fabs(right_imag);
            llvm::Value* cond = builder->CreateFCmpOGE(
                abs_right_real, abs_right_imag);

            llvm::Function* parent_fn = builder->GetInsertBlock()->getParent();
            llvm::BasicBlock* r_ge_s_bb = llvm::BasicBlock::Create(
                context, "complex_div_r_ge_s", parent_fn);
            llvm::BasicBlock* r_lt_s_bb = llvm::BasicBlock::Create(
                context, "complex_div_r_lt_s", parent_fn);
            llvm::BasicBlock* div_cont_bb = llvm::BasicBlock::Create(
                context, "complex_div_cont", parent_fn);

            builder->CreateCondBr(cond, r_ge_s_bb, r_lt_s_bb);

            builder->SetInsertPoint(r_ge_s_bb);
            llvm::Value* ratio_r_ge = builder->CreateFDiv(
                right_imag, right_real);
            llvm::Value* denom_r_ge = builder->CreateFAdd(right_real,
                builder->CreateFMul(right_imag, ratio_r_ge));
            llvm::Value* num_real_r_ge = builder->CreateFAdd(left_real,
                builder->CreateFMul(left_imag, ratio_r_ge));
            llvm::Value* num_imag_r_ge = builder->CreateFSub(left_imag,
                builder->CreateFMul(left_real, ratio_r_ge));
            llvm::Value* res_real_r_ge = builder->CreateFDiv(
                num_real_r_ge, denom_r_ge);
            llvm::Value* res_imag_r_ge = builder->CreateFDiv(
                num_imag_r_ge, denom_r_ge);
            builder->CreateBr(div_cont_bb);

            builder->SetInsertPoint(r_lt_s_bb);
            llvm::Value* ratio_r_lt = builder->CreateFDiv(
                right_real, right_imag);
            llvm::Value* denom_r_lt = builder->CreateFAdd(right_imag,
                builder->CreateFMul(right_real, ratio_r_lt));
            llvm::Value* num_real_r_lt = builder->CreateFAdd(
                builder->CreateFMul(left_real, ratio_r_lt), left_imag);
            llvm::Value* num_imag_r_lt = builder->CreateFSub(
                builder->CreateFMul(left_imag, ratio_r_lt), left_real);
            llvm::Value* res_real_r_lt = builder->CreateFDiv(
                num_real_r_lt, denom_r_lt);
            llvm::Value* res_imag_r_lt = builder->CreateFDiv(
                num_imag_r_lt, denom_r_lt);
            builder->CreateBr(div_cont_bb);

            builder->SetInsertPoint(div_cont_bb);
            llvm::PHINode* result_real_phi = builder->CreatePHI(
                left_real->getType(), 2);
            result_real_phi->addIncoming(res_real_r_ge, r_ge_s_bb);
            result_real_phi->addIncoming(res_real_r_lt, r_lt_s_bb);
            llvm::PHINode* result_imag_phi = builder->CreatePHI(
                left_real->getType(), 2);
            result_imag_phi->addIncoming(res_imag_r_ge, r_ge_s_bb);
            result_imag_phi->addIncoming(res_imag_r_lt, r_lt_s_bb);
            result_real = result_real_phi;
            result_imag = result_imag_phi;
        } else {
            // Fallback to runtime call for pow and any other operations
            llvm::Function *fn = module->getFunction(runtime_func_name);
            if (!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), {
                            complex_type->getPointerTo(),
                            complex_type->getPointerTo(),
                            complex_type->getPointerTo()
                        }, false);
                fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, runtime_func_name, module.get());
            }
            llvm::AllocaInst *pleft_arg = llvm_utils->CreateAlloca(complex_type);
            builder->CreateStore(left_arg, pleft_arg);
            llvm::AllocaInst *pright_arg = llvm_utils->CreateAlloca(complex_type);
            builder->CreateStore(right_arg, pright_arg);
            llvm::AllocaInst *presult = llvm_utils->CreateAlloca(complex_type);
            std::vector<llvm::Value*> args = {pleft_arg, pright_arg, presult};
            builder->CreateCall(fn, args);
            return llvm_utils->CreateLoad2(complex_type, presult);
        }

        // Construct result complex value
        llvm::Value* result = llvm::UndefValue::get(complex_type);
        result = builder->CreateInsertValue(result, result_real, {0});
        result = builder->CreateInsertValue(result, result_imag, {1});
        return result;
    }


    llvm::Value* lfortran_strConcat(
        llvm::Value* left_arg, llvm::Value* left_len,
        llvm::Value* right_arg, llvm::Value* right_len)
    {
        std::string runtime_func_name = "_lfortran_strcat";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    character_type, {
                        character_type, llvm::Type::getInt64Ty(context),
                        character_type, llvm::Type::getInt64Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        std::vector<llvm::Value*> args = {left_arg, left_len, right_arg, right_len};
        return builder->CreateCall(fn, args);
    }

    llvm::Value* lfortran_str_cmp(
        llvm::Value* left_arg, llvm::Value* left_arg_len,
        llvm::Value* right_arg, llvm::Value* right_arg_len)
    {
        std::string runtime_func_name = "str_compare";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if(!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getInt32Ty(context), {
                        character_type, llvm::Type::getInt64Ty(context),
                        character_type, llvm::Type::getInt64Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        std::vector<llvm::Value*> args = {left_arg, left_arg_len, right_arg, right_arg_len};
        return builder->CreateCall(fn, args);
    }

    llvm::Value* lfortran_strrepeat(llvm::Value* left_arg, llvm::Value* right_arg)
    {
        std::string runtime_func_name = "_lfortran_strrepeat";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        character_type->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        character_type->getPointerTo()
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        llvm::AllocaInst *pleft_arg = llvm_utils->CreateAlloca(*builder, character_type);
        builder->CreateStore(left_arg, pleft_arg);
        llvm::AllocaInst *presult = llvm_utils->CreateAlloca(*builder, character_type);
        std::vector<llvm::Value*> args = {pleft_arg, right_arg, presult};
        builder->CreateCall(fn, args);
        return llvm_utils->CreateLoad2(character_type, presult);
    }

    llvm::Value* lfortran_str_len(llvm::Type* type, llvm::Value* str, bool use_descriptor=false)
    {
        if (use_descriptor) {
            str = llvm_utils->CreateLoad2(character_type->getPointerTo(), arr_descr->get_pointer_to_data(type, str));
        }
        std::string runtime_func_name = "_lfortran_str_len";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getInt64Ty(context), {
                        character_type
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        return builder->CreateCall(fn, {str});
    }

    llvm::Value* lfortran_str_to_int(llvm::Value* str)
    {
        std::string runtime_func_name = "_lfortran_str_to_int";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getInt32Ty(context), {
                        character_type->getPointerTo()
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        return builder->CreateCall(fn, {str});
    }

    llvm::Value* lfortran_str_ord(llvm::Value* str)
    {
        std::string runtime_func_name = "_lfortran_str_ord";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getInt32Ty(context), {
                        character_type->getPointerTo()
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        return builder->CreateCall(fn, {str});
    }

    llvm::Value* lfortran_str_chr(llvm::Value* str)
    {
        std::string runtime_func_name = "_lfortran_str_chr";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    character_type, {
                        llvm::Type::getInt8Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        return builder->CreateCall(fn, {str});
    }

    llvm::Value* lfortran_str_item(llvm::Value* str, llvm::Value* str_len, llvm::Value* idx1)
    {
        std::string runtime_func_name = "_lfortran_str_item";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    character_type,
                    {
                        character_type /*str*/,
                        llvm::Type::getInt64Ty(context) /*str_len*/,
                        llvm::Type::getInt64Ty(context) /*idx*/
                    },
                    false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        idx1 = builder->CreateSExt(idx1, llvm::Type::getInt64Ty(context));
        return builder->CreateCall(fn, {str, str_len, idx1});
    }

    llvm::Value* lfortran_str_slice(
        llvm::Value* str, llvm::Value* str_len,
        llvm::Value* idx1, llvm::Value* idx2,
        llvm::Value* step, llvm::Value* left_present, llvm::Value* right_present)
    {
        std::string runtime_func_name = "_lfortran_str_slice";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    character_type, {
                        character_type, llvm::Type::getInt64Ty(context),
                        llvm::Type::getInt64Ty(context),
                        llvm::Type::getInt64Ty(context), llvm::Type::getInt64Ty(context),
                        llvm::Type::getInt1Ty(context), llvm::Type::getInt1Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        // Make sure they're int64 integers
        idx1 = llvm_utils->convert_kind(idx1, llvm::Type::getInt64Ty(context));
        idx2 = llvm_utils->convert_kind(idx2, llvm::Type::getInt64Ty(context));
        step = llvm_utils->convert_kind(step, llvm::Type::getInt64Ty(context));
        return builder->CreateCall(fn, {str, str_len, idx1, idx2, step, left_present, right_present});
    }

    // Specific For Fortran Strings
    llvm::Value* lfortran_str_slice_fortran(
        llvm::Value* str,
        llvm::Value* start, llvm::Value* end){
        std::string runtime_func_name = "_lfortran_str_slice_fortran";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    character_type, {
                        character_type,
                        llvm::Type::getInt64Ty(context), // Start
                        llvm::Type::getInt64Ty(context) // End
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        // Make sure they're int64 integers
        start = llvm_utils->convert_kind(start, llvm::Type::getInt64Ty(context));
        end = llvm_utils->convert_kind(end, llvm::Type::getInt64Ty(context));
        return builder->CreateCall(fn, {str, start, end});
    }



    llvm::Value* lfortran_type_to_str(llvm::Value* arg, llvm::Type* value_type, std::string type, int value_kind) {
        std::string func_name = "_lfortran_" + type + "_to_str" + std::to_string(value_kind);
         llvm::Function *fn = module->getFunction(func_name);
         if(!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                 character_type, {
                     value_type
                 }, false);
            fn = llvm::Function::Create(function_type,
                     llvm::Function::ExternalLinkage, func_name, module.get());
         }
         llvm::Value* res = builder->CreateCall(fn, {arg});
         return res;
    }

    llvm::Value* lfortran_dynamic_cast(llvm::Value* static_ptr,
                                       llvm::Value* dst_type,
                                       bool match_exact_type)
    {
        static_ptr = builder->CreateBitCast(static_ptr, llvm_utils->i8_ptr);
        dst_type = builder->CreateBitCast(dst_type, llvm_utils->i8_ptr);

        std::string runtime_func_name = "__lfortran_dynamic_cast";
        llvm::Function* fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType* function_type = llvm::FunctionType::get(
                llvm_utils->i8_ptr,
                { llvm_utils->i8_ptr, llvm_utils->i8_ptr, llvm::Type::getInt1Ty(context) },
                false);
            fn = llvm::Function::Create(
                function_type, llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        std::vector<llvm::Value*> args
            = { static_ptr,
                dst_type,
                match_exact_type ? llvm::ConstantInt::getTrue(context)
                                 : llvm::ConstantInt::getFalse(context) };
        return builder->CreateCall(fn, args);
    }

    // This function is called as:
    // float complex_re(complex a)
    // And it extracts the real part of the complex number
    llvm::Value *complex_re(llvm::Value *c, llvm::Type* complex_type=nullptr) {
        if( complex_type == nullptr ) {
            complex_type = complex_type_4;
        }
        llvm::Value *val = c;
        llvm::Type *val_type = c->getType();
        if (val_type->isPointerTy()) {
            val = llvm_utils->CreateLoad2(complex_type, c);
            val_type = complex_type;
        }
        if (llvm::isa<FIXED_VECTOR_TYPE>(val_type)) {
            llvm::Value* idx0 = llvm::ConstantInt::get(
                llvm::Type::getInt32Ty(context), 0);
            return builder->CreateExtractElement(val, idx0);
        }
        return builder->CreateExtractValue(val, {0});
    }

    llvm::Value *complex_im(llvm::Value *c, llvm::Type* complex_type=nullptr) {
        if( complex_type == nullptr ) {
            complex_type = complex_type_4;
        }
        llvm::Value *val = c;
        llvm::Type *val_type = c->getType();
        if (val_type->isPointerTy()) {
            val = llvm_utils->CreateLoad2(complex_type, c);
            val_type = complex_type;
        }
        if (llvm::isa<FIXED_VECTOR_TYPE>(val_type)) {
            llvm::Value* idx1 = llvm::ConstantInt::get(
                llvm::Type::getInt32Ty(context), 1);
            return builder->CreateExtractElement(val, idx1);
        }
        return builder->CreateExtractValue(val, {1});
    }

    llvm::Value *complex_from_floats(llvm::Value *re, llvm::Value *im,
                                     llvm::Type* complex_type=nullptr) {
        if( complex_type == nullptr ) {
            complex_type = complex_type_4;
        }
        if (llvm::isa<FIXED_VECTOR_TYPE>(complex_type)) {
            llvm::Value* result = llvm::UndefValue::get(complex_type);
            llvm::Value* idx0 = llvm::ConstantInt::get(
                llvm::Type::getInt32Ty(context), 0);
            llvm::Value* idx1 = llvm::ConstantInt::get(
                llvm::Type::getInt32Ty(context), 1);
            result = builder->CreateInsertElement(result, re, idx0);
            result = builder->CreateInsertElement(result, im, idx1);
            return result;
        }
        llvm::Value* result = llvm::UndefValue::get(complex_type);
        result = builder->CreateInsertValue(result, re, {0});
        result = builder->CreateInsertValue(result, im, {1});
        return result;
    }

    llvm::Value *nested_struct_rd(std::vector<llvm::Value*> vals,
            llvm::StructType* rd) {
        llvm::AllocaInst *pres = llvm_utils->CreateAlloca(*builder, rd);
        llvm::Value *pim = llvm_utils->CreateGEP2(rd, pres, vals);
        llvm::Type* elem_type = rd->getStructElementType(vals.size() - 1);
        return llvm_utils->CreateLoad2(elem_type, pim);
    }

    /**
     * @brief This function generates the
     * @detail This is converted to
     *
     *     float lfortran_KEY(float *x)
     *
     *   Where KEY can be any of the supported intrinsics; this is then
     *   transformed into a runtime call:
     *
     *     void _lfortran_KEY(float x, float *result)
     */
    llvm::Value* lfortran_intrinsic(llvm::Function *fn, llvm::Value* pa, int a_kind)
    {
        llvm::Type *presult_type = llvm_utils->getFPType(a_kind);
        llvm::AllocaInst *presult = llvm_utils->CreateAlloca(*builder, presult_type);
        llvm::Value* a = llvm_utils->CreateLoad2(presult_type, pa);
        std::vector<llvm::Value*> args = {a, presult};
        builder->CreateCall(fn, args);
        return llvm_utils->CreateLoad2(presult_type, presult);
    }

    llvm::Type* get_llvm_struct_data_type(ASR::Struct_t* st, bool is_pointer) {
        std::string struct_name = (std::string)st->m_name;
        if (ASRUtils::is_unlimited_polymorphic_type(st)) {
            if (!compiler_options.new_classes) {
                if (is_pointer) {
                    return llvm::Type::getVoidTy(context)->getPointerTo();
                } else {
                    return llvm::Type::getVoidTy(context);
                }
            } else {
                if (is_pointer) {
                    return llvm_utils->getClassType(st)->getPointerTo();
                } else {
                    return llvm_utils->getClassType(st);
                }
            }
        } else {
            return llvm_utils->getStructType(st, module.get(), is_pointer);
        }
    }

    void visit_TranslationUnit(const ASR::TranslationUnit_t &x) {
        module = std::make_unique<llvm::Module>("LFortran", context);
        module->setDataLayout("");
        llvm_utils->set_module(module.get());

        if (compiler_options.emit_debug_info) {
            DBuilder = std::make_unique<llvm::DIBuilder>(*module);
            debug_CU = DBuilder->createCompileUnit(
                llvm::dwarf::DW_LANG_C, DBuilder->createFile(infile, "."),
                "LPython Compiler", false, "", 0);
        }

        // All loose statements must be converted to a function, so the items
        // must be empty:
        LCOMPILERS_ASSERT(x.n_items == 0);

        // Define LLVM types that we might need
        // Complex type is represented as an identified struct in LLVM
        // %complex = type { float, float }
        complex_type_4 = llvm_utils->complex_type_4;
        complex_type_8 = llvm_utils->complex_type_8;
        complex_type_4_ptr = llvm_utils->complex_type_4_ptr;
        complex_type_8_ptr = llvm_utils->complex_type_8_ptr;
        character_type = llvm_utils->character_type;
        string_descriptor = llvm_utils->string_descriptor;
        list_type = llvm::Type::getInt8Ty(context)->getPointerTo();

        llvm::Type* bound_arg = static_cast<llvm::Type*>(arr_descr->get_dimension_descriptor_type(true));
        fname2arg_type["lbound"] = std::make_pair(bound_arg, bound_arg->getPointerTo());
        fname2arg_type["ubound"] = std::make_pair(bound_arg, bound_arg->getPointerTo());

        // Process Variables first:
        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Variable_t>(*item.second) ||
                is_a<ASR::Enum_t>(*item.second)) {
                visit_symbol(*item.second);
            }
        }

        prototype_only = false;
        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Module_t>(*item.second) &&
                item.first.find("lfortran_intrinsic_optimization") != std::string::npos) {
                ASR::Module_t* mod = ASR::down_cast<ASR::Module_t>(item.second);
                for( auto &moditem: mod->m_symtab->get_scope() ) {
                    ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(moditem.second);
                    if (is_a<ASR::Function_t>(*sym)) {
                        visit_Function(*ASR::down_cast<ASR::Function_t>(sym));
                    }
                }
            }
        }

        prototype_only = true;
        // Generate function prototypes
        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Function_t>(*item.second)) {
                visit_Function(*ASR::down_cast<ASR::Function_t>(item.second));
            }
        }
        prototype_only = false;

        // TODO: handle dependencies across modules and main program

        // Then do all the modules in the right order
        std::vector<std::string> build_order
            = determine_module_dependencies(x);
        for (auto &item : build_order) {
            if (!item.compare("_lcompilers_mlir_gpu_offloading")) continue;
            LCOMPILERS_ASSERT(x.m_symtab->get_symbol(item)
                != nullptr);
            ASR::symbol_t *mod = x.m_symtab->get_symbol(item);
            visit_symbol(*mod);
        }

        // Then do all the procedures
        for (auto &item : x.m_symtab->get_scope()) {
            if( ASR::is_a<ASR::Function_t>(*item.second) ) {
                visit_symbol(*item.second);
            }
        }

        // Then the main program
        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Program_t>(*item.second)) {
                visit_symbol(*item.second);
            }
        }
        LCOMPILERS_ASSERT_MSG(llvm_utils->stringFormat_return.all_clean(),
                        "`_lcompilers_string_format_fortran()` Return Not Freed");
    }

    template <typename T>
    void visit_AllocateUtil(const T& x, ASR::expr_t* m_stat, bool realloc, ASR::expr_t* m_source = nullptr) {
        for( size_t i = 0; i < x.n_args; i++ ) {
            ASR::alloc_arg_t curr_arg = x.m_args[i];
            ASR::expr_t* tmp_expr = x.m_args[i].m_a;
            LCOMPILERS_ASSERT(
                ASRUtils::is_allocatable(tmp_expr)||
                ASRUtils::is_pointer(expr_type(tmp_expr)));
            visit_expr_load_wrapper(tmp_expr, 0);
            llvm::Value* x_arr = tmp;
            ASR::ttype_t* curr_arg_m_a_type = ASRUtils::type_get_past_pointer(
                ASRUtils::type_get_past_allocatable(
                ASRUtils::expr_type(tmp_expr)));
            size_t n_dims = ASRUtils::extract_n_dims_from_ttype(curr_arg_m_a_type);
            curr_arg_m_a_type = ASRUtils::type_get_past_array(curr_arg_m_a_type);
            if( n_dims == 0 ) {
                if (ASRUtils::is_character(*curr_arg_m_a_type)) {
                    ASR::String_t* str = ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(ASRUtils::expr_type(tmp_expr)));
                    llvm::Value* amount_to_allocate{};
                    if(curr_arg.m_len_expr){ // Visit desired length to be allocated.
                        visit_expr_load_wrapper(curr_arg.m_len_expr, 1, true);
                        amount_to_allocate = tmp;
                    } else {
                        amount_to_allocate = nullptr;
                    }
                    llvm_utils->allocate_allocatable_string(str, x_arr, amount_to_allocate);
                } else if(ASR::is_a<ASR::Integer_t>(*curr_arg_m_a_type) ||
                          ASR::is_a<ASR::Real_t>(*curr_arg_m_a_type) ||
                          ASR::is_a<ASR::Complex_t>(*curr_arg_m_a_type) ||
                          ASR::is_a<ASR::Logical_t>(*curr_arg_m_a_type)) {
                    llvm::Type* llvm_arg_type = llvm_utils->get_type_from_ttype_t_util(curr_arg.m_a, curr_arg_m_a_type, module.get());
                    if (!realloc && compiler_options.po.bounds_checking) {
                        llvm::Value* current_ptr = llvm_utils->CreateLoad2(llvm_arg_type->getPointerTo(), x_arr);
                        llvm::Value* is_allocated = builder->CreateICmpNE(
                            builder->CreatePtrToInt(current_ptr, llvm::Type::getInt64Ty(context)),
                            builder->CreatePtrToInt(llvm::ConstantPointerNull::get(llvm_arg_type->getPointerTo()),
                                llvm::Type::getInt64Ty(context)));
                        std::string var_name = "";
                        if (ASR::is_a<ASR::Var_t>(*tmp_expr)) {
                            ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(
                                ASR::down_cast<ASR::Var_t>(tmp_expr)->m_v);
                            var_name = ASRUtils::symbol_name(sym);
                        }
                        llvm::Value* var_name_llvm = LCompilers::create_global_string_ptr(context, *module, *builder, var_name);
                        llvm_utils->generate_runtime_error(is_allocated,
                            "Attempting to allocate already allocated variable '%s'",
                            {LLVMUtils::RuntimeLabel("Cannot allocate '%s' because it is already allocated", {tmp_expr->base.loc}, {var_name_llvm})},
                            infile,
                            location_manager,
                            var_name_llvm);
                    }
                    llvm::Value* malloc_size = SizeOfTypeUtil(curr_arg.m_a, curr_arg_m_a_type, llvm_utils->getIntType(4),
                    ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                    llvm::Value* malloc_ptr = LLVMArrUtils::lfortran_malloc(
                        context, *module, *builder, malloc_size);
                    builder->CreateMemSet(malloc_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)), malloc_size, llvm::MaybeAlign());
                    builder->CreateStore(builder->CreateBitCast(
                        malloc_ptr, llvm_arg_type->getPointerTo()), x_arr);
                } else if (ASR::is_a<ASR::StructType_t>(*curr_arg_m_a_type)) {
                    ASR::ttype_t* source_expr_type = nullptr;
                    ASR::ttype_t* source_underlying_type = nullptr;
                    if (m_source) {
                        source_expr_type = ASRUtils::expr_type(m_source);
                        ASR::ttype_t* source_no_alloc = ASRUtils::type_get_past_allocatable(source_expr_type);
                        source_underlying_type = ASRUtils::type_get_past_pointer(source_no_alloc);
                    }
                    bool m_source_is_class = source_underlying_type && ASRUtils::is_class_type(source_underlying_type);

                    if (m_source && m_source_is_class && compiler_options.new_classes) {
                        llvm::Value* target_addr = x_arr;

                        int64_t saved_ptr_loads = ptr_loads;
                        ptr_loads = 0;
                        this->visit_expr(*m_source);
                        llvm::Value* source_handle = tmp;
                        ptr_loads = saved_ptr_loads;
                        tmp = nullptr;

                        ASR::ttype_t* source_type = source_expr_type;
                        llvm::Type* source_wrapper_type = llvm_utils->get_type_from_ttype_t_util(
                            m_source, ASRUtils::extract_type(source_type), module.get());

                        if (source_type && LLVM::is_llvm_pointer(*source_type)) {
                            source_handle = llvm_utils->CreateLoad2(
                                source_wrapper_type->getPointerTo(), source_handle);
                        }

                        llvm::FunctionType* alloc_fn_type = llvm::FunctionType::get(
                            llvm::Type::getVoidTy(context), { llvm_utils->i8_ptr->getPointerTo() }, false);
                        llvm::PointerType* alloc_fn_ptr_type = llvm::PointerType::get(alloc_fn_type, 0);
                        llvm::PointerType* alloc_fn_ptr_ptr_type = llvm::PointerType::get(alloc_fn_ptr_type, 0);
                        llvm::PointerType* alloc_fn_ptr_ptr_ptr_type = llvm::PointerType::get(alloc_fn_ptr_ptr_type, 0);

                        llvm::Value* vtable_alloc_ptr = builder->CreateBitCast(
                            source_handle, alloc_fn_ptr_ptr_ptr_type);
                        vtable_alloc_ptr = llvm_utils->CreateLoad2(alloc_fn_ptr_ptr_type, vtable_alloc_ptr);
                        llvm::Value* alloc_fn_slot = llvm_utils->create_ptr_gep2(
                            alloc_fn_ptr_type, vtable_alloc_ptr, 1);
                        alloc_fn_slot = llvm_utils->CreateLoad2(alloc_fn_ptr_type, alloc_fn_slot);

                        llvm::Value* target_addr_as_i8pp = builder->CreateBitCast(
                            target_addr, llvm_utils->i8_ptr->getPointerTo());
                        builder->CreateCall(alloc_fn_type, alloc_fn_slot, { target_addr_as_i8pp });

                        llvm::Value* target_struct_i8 = llvm_utils->CreateLoad2(
                            llvm_utils->i8_ptr, target_addr_as_i8pp);
                        llvm::Type* target_struct_type = llvm_utils->get_type_from_ttype_t_util(
                            curr_arg.m_a, curr_arg_m_a_type, module.get());
                        llvm::Value* target_struct = builder->CreateBitCast(
                            target_struct_i8, target_struct_type->getPointerTo());

                        // Only deepcopy for source=, not for mold=
                        // mold= allocates with type but doesn't copy data
                        if (!curr_arg.m_type) {
                            llvm_utils->deepcopy(m_source, source_handle, target_struct,
                                ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(m_source)),
                                curr_arg_m_a_type, module.get());
                        }

                        continue;
                    }

                    if (ASR::down_cast<ASR::StructType_t>(curr_arg_m_a_type)->m_is_cstruct) {
                        llvm::Value* malloc_size = SizeOfTypeUtil(curr_arg.m_a, curr_arg_m_a_type, llvm_utils->getIntType(4),
                        ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                        llvm::Value* malloc_ptr = LLVMArrUtils::lfortran_malloc(
                            context, *module, *builder, malloc_size);
                        builder->CreateMemSet(malloc_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)), malloc_size, llvm::MaybeAlign());
                        llvm::Type* llvm_arg_type = llvm_utils->get_type_from_ttype_t_util(curr_arg.m_a, curr_arg_m_a_type, module.get());
                        llvm::Value* bitcasted_malloc_ptr = builder->CreateBitCast(
                                            malloc_ptr, llvm_arg_type->getPointerTo());
                        builder->CreateStore(bitcasted_malloc_ptr, x_arr);

                        x_arr = llvm_utils->CreateLoad2(llvm_arg_type->getPointerTo(), x_arr);

                        allocate_array_members_of_struct(
                            ASR::down_cast<ASR::Struct_t>(
                                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(tmp_expr))),
                            x_arr,
                            curr_arg_m_a_type);
                        if (m_source && !m_source_is_class && !curr_arg.m_type) {
                            int64_t ptr_loads_copy = ptr_loads;
                            if (ASRUtils::is_allocatable(m_source)) {
                                ptr_loads = 1;
                            } else {
                                ptr_loads = 0;
                            }
                            this->visit_expr(*m_source);
                            ptr_loads = ptr_loads_copy;

                            llvm_utils->deepcopy(m_source, tmp, x_arr, ASRUtils::expr_type(m_source), curr_arg_m_a_type, module.get());
                        }
                    } else {
                        ASR::ttype_t* dest_asr_type = curr_arg.m_type;
                        ASR::symbol_t* dest_class_sym = nullptr;
                        llvm::Value* malloc_size = nullptr;
                        ASR::Struct_t* src_struct_sym = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
                            ASRUtils::get_struct_sym_from_struct_expr(curr_arg.m_a)));
                        llvm::Type* src_struct_type = get_llvm_struct_data_type(src_struct_sym, true);
                        bool is_arg_unlimited_poly = ASRUtils::is_unlimited_polymorphic_type(&src_struct_sym->base);
                        // If no type specified then use curr_arg_m_a_type as default
                        if (m_source && !m_source_is_class) {
                            dest_asr_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(m_source));
                            dest_class_sym = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(m_source));
                            malloc_size = SizeOfTypeUtil(m_source, dest_asr_type, llvm_utils->getIntType(4),
                                ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                        } else if (curr_arg.m_sym_subclass == nullptr) {
                            dest_class_sym = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(curr_arg.m_a));
                            dest_asr_type = ASRUtils::make_StructType_t_util(al, curr_arg_m_a_type->base.loc, dest_class_sym, true);
                            malloc_size = SizeOfTypeUtil(curr_arg.m_a, dest_asr_type, llvm_utils->getIntType(4),
                                ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                        } else {
                            llvm::Type* llvm_type = nullptr;
                            dest_class_sym = ASRUtils::symbol_get_past_external(curr_arg.m_sym_subclass);
                            ASR::Struct_t* dest_struct = ASR::down_cast<ASR::Struct_t>(dest_class_sym);
                            llvm_type = llvm_utils->getStructType(dest_struct, module.get());
                            llvm::DataLayout data_layout(module->getDataLayout());
                            int64_t type_size = data_layout.getTypeAllocSize(llvm_type);
                            malloc_size = llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(
                                ASRUtils::extract_kind_from_ttype_t(ASRUtils::TYPE(
                                    ASR::make_Integer_t(al, x.base.base.loc, 4))) * 8, type_size));
                        }

                        llvm::Value* malloc_ptr = LLVMArrUtils::lfortran_malloc(
                            context, *module, *builder, malloc_size);
                        builder->CreateMemSet(malloc_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)),
                                    malloc_size, llvm::MaybeAlign());
                        if(ASRUtils::is_string_only(dest_asr_type)) { // String type has a state to be cloned.
                            // NOTE : dest_asr_type == source_type (They both refelect the type the class will be)
                            this->visit_expr_load_wrapper(m_source, 0);
                            auto* const dest__source_t = llvm_utils->get_type_from_ttype_t_util(m_source, dest_asr_type, module.get());
                            llvm_utils->clone_string_state(
                                        builder->CreateBitCast(malloc_ptr, dest__source_t->getPointerTo()),
                                        tmp /*m_source*/,
                                        ASRUtils::get_string_type(dest_asr_type));
                            tmp = nullptr;
                        }
                        if (!compiler_options.new_classes) {
                            // Set class hash in polymorphic struct
                            llvm::Value* class_hash = nullptr;
                            if (dest_class_sym) {
                                class_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                                    llvm::APInt(64, get_class_hash(dest_class_sym)));
                            } else {
                                class_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                                    llvm::APInt(64, -((int) dest_asr_type->type) -
                                        ASRUtils::extract_kind_from_ttype_t(dest_asr_type), true));
                            }
                            llvm::Type* src_class_type = llvm_utils->get_type_from_ttype_t_util(tmp_expr, curr_arg_m_a_type, module.get());
                            llvm::Value* t = llvm_utils->create_gep2(src_class_type, x_arr, 0);
                            builder->CreateStore(class_hash, t);
    
                            // Store and bitcast allocated memory into polymorphic struct's struct pointer
                            x_arr = llvm_utils->create_gep2(src_class_type, x_arr, 1);
                        } else if (compiler_options.new_classes
                                   && is_arg_unlimited_poly
                                   && !dest_class_sym) {
                            // This is the case of an unlimited polymorphic type being allocated an intrinsic type.
                            struct_api->create_vtab_for_intrinsic_type(dest_asr_type, 
                                ASRUtils::extract_kind_from_ttype_t(dest_asr_type), module.get());
                        }

                        llvm::Value* bitcasted_malloc_ptr = malloc_ptr;
                        if (compiler_options.new_classes
                              && ASRUtils::is_class_type(ASRUtils::extract_type(ASRUtils::expr_type(tmp_expr)))) {
                            llvm::Type* src_struct_type_ = llvm_utils->get_type_from_ttype_t_util(
                                ASRUtils::expr_type(tmp_expr), &src_struct_sym->base, module.get());
                            // Allocate class wrapper first
                            llvm::Value* wrapper_size = SizeOfTypeUtil(curr_arg.m_a, curr_arg_m_a_type,
                                llvm_utils->getIntType(4), ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                            llvm::Value* wrapper_ptr = LLVMArrUtils::lfortran_malloc(
                                context, *module, *builder, wrapper_size);
                            builder->CreateMemSet(wrapper_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)),
                                wrapper_size, llvm::MaybeAlign());
                            wrapper_ptr = builder->CreateBitCast(wrapper_ptr, src_struct_type_);
                            builder->CreateStore(wrapper_ptr, x_arr);
                            
                            // Now allocate its data
                            x_arr = llvm_utils->CreateLoad2(src_struct_type_, x_arr);
                            x_arr = llvm_utils->create_gep2(llvm_utils->get_type_from_ttype_t_util(
                                ASRUtils::extract_type(curr_arg_m_a_type), &src_struct_sym->base, module.get()), x_arr, 1);
                            if (!is_arg_unlimited_poly) {
                                bitcasted_malloc_ptr = builder->CreateBitCast(bitcasted_malloc_ptr, 
                                    llvm_utils->getStructType(src_struct_sym, module.get(), true));
                            }
                            builder->CreateStore(bitcasted_malloc_ptr, x_arr);
                            bitcasted_malloc_ptr = wrapper_ptr;
                        } else {
                            bitcasted_malloc_ptr = builder->CreateBitCast(malloc_ptr, src_struct_type);
                            builder->CreateStore(bitcasted_malloc_ptr, x_arr);
                        }

                        // Initialize members
                        llvm::Type* dest_type = nullptr;
                        if (curr_arg.m_sym_subclass) {
                            dest_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(dest_class_sym), module.get());
                        } else if (m_source && !m_source_is_class) {
                            dest_type = llvm_utils->get_type_from_ttype_t_util(m_source, dest_asr_type, module.get());
                        } else {
                            dest_type = llvm_utils->get_type_from_ttype_t_util(curr_arg.m_a, dest_asr_type, module.get());
                        }
                        
                        if (compiler_options.new_classes
                              && ASRUtils::is_unlimited_polymorphic_type(&src_struct_sym->base)) {
                            x_arr = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, x_arr);
                        } else {
                            x_arr = llvm_utils->CreateLoad2(src_struct_type, x_arr);
                        }
                        x_arr = builder->CreateBitCast(x_arr, dest_type->getPointerTo());

                        if (compiler_options.new_classes && 
                                ASRUtils::is_class_type(ASRUtils::extract_type(curr_arg_m_a_type))) {
                            // Store vptr after allocation
                            if (dest_class_sym) {
                                struct_api->store_class_vptr(ASRUtils::symbol_get_past_external(dest_class_sym), bitcasted_malloc_ptr, module.get());
                            } else if (ASRUtils::is_unlimited_polymorphic_type(&src_struct_sym->base)
                                   && !dest_class_sym) {
                                struct_api->store_intrinsic_type_vptr(
                                    dest_asr_type,
                                    ASRUtils::extract_kind_from_ttype_t(dest_asr_type),
                                    bitcasted_malloc_ptr, module.get());
                            } else {
                                struct_api->store_class_vptr(&src_struct_sym->base, bitcasted_malloc_ptr, module.get());
                            }
                        }

                        if (ASR::is_a<ASR::StructType_t>(*dest_asr_type)) {
                            allocate_array_members_of_struct(ASR::down_cast<ASR::Struct_t>(dest_class_sym), x_arr, ASRUtils::symbol_type(dest_class_sym));
                        }
                        if (m_source && !m_source_is_class && !curr_arg.m_type) {
                            llvm::Value* src = nullptr; {
                                const auto load = ASRUtils::is_allocatable(m_source) && !ASRUtils::is_string_only(ASRUtils::expr_type(m_source)) ? 1 : 0;
                                this->visit_expr_load_wrapper(m_source, load);
                                src = tmp;
                                tmp = nullptr;
                            }
                            llvm::Value* dest = x_arr;
                            if (!ASRUtils::is_value_constant(m_source) && 
                                !ASRUtils::is_struct(*ASRUtils::expr_type(m_source)) &&
                                !ASRUtils::is_string_only(ASRUtils::expr_type(m_source))) {
                                src = llvm_utils->CreateLoad2(dest_type, src);
                            }
                            llvm_utils->deepcopy(m_source, src, dest, dest_asr_type, dest_asr_type, module.get());
                        }
                    }
                }
            } else {
                ASR::ttype_t* asr_data_type = ASRUtils::duplicate_type_without_dims(al,
                    curr_arg_m_a_type, curr_arg_m_a_type->base.loc);
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                llvm::Type* llvm_data_type = llvm_utils->get_el_type(curr_arg.m_a, asr_data_type, module.get());
                llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(tmp_expr,
                    ASRUtils::type_get_past_pointer(ASRUtils::type_get_past_allocatable(
                        ASRUtils::expr_type(tmp_expr))), module.get());
                llvm::Value* ptr_val = x_arr;
#if LLVM_VERSION_MAJOR >= 17
                llvm::Type* i8_ptr_ty
                    = llvm::PointerType::getUnqual(llvm::Type::getInt8Ty(context));
#else
                llvm::Type* i8_ptr_ty = llvm::Type::getInt8PtrTy(context);
#endif

                if (x_arr && x_arr->getType() == nullptr) {
                    ptr_val = llvm::ConstantPointerNull::get(static_cast<llvm::PointerType*>(i8_ptr_ty));
                }
                if (!realloc && compiler_options.po.bounds_checking && x_arr && x_arr->getType() != nullptr) {
                    llvm::Value* desc_ptr = llvm_utils->CreateLoad2(type->getPointerTo(), x_arr);
                    llvm::Value* is_allocated = arr_descr->get_is_allocated_flag(desc_ptr, tmp_expr);
                    std::string var_name = "";
                    if (ASR::is_a<ASR::Var_t>(*tmp_expr)) {
                        ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(
                            ASR::down_cast<ASR::Var_t>(tmp_expr)->m_v);
                        var_name = ASRUtils::symbol_name(sym);
                    }
                    llvm::Value* var_name_llvm = LCompilers::create_global_string_ptr(context, *module, *builder, var_name);
                    llvm_utils->generate_runtime_error(is_allocated,
                        "Attempting to allocate already allocated variable '%s'",
                        {LLVMUtils::RuntimeLabel("Cannot allocate '%s' because it is already allocated", {tmp_expr->base.loc}, {var_name_llvm})},
                        infile,
                        location_manager,
                        var_name_llvm);
                }
                ASR::ttype_t* array_type = ASRUtils::type_get_past_allocatable_pointer(
                    ASRUtils::expr_type(tmp_expr));
                // Only generate descriptor allocation check for struct members or in strict bounds checking mode
                // For regular allocatable variables, the descriptor is always properly initialized on declaration
                // For struct/derived type members, the descriptor may be NULL and needs initialization
                bool is_struct_member = ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr);
                bool is_dummy_arg = false;
                if (ASR::is_a<ASR::Var_t>(*tmp_expr)) {
                    ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(
                        ASR::down_cast<ASR::Var_t>(tmp_expr)->m_v);
                    if (ASR::is_a<ASR::Variable_t>(*sym)) {
                        ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(sym);
                        is_dummy_arg = ASRUtils::is_arg_dummy(v->m_intent);
                    }
                }
                if (is_struct_member || is_dummy_arg || compiler_options.po.strict_bounds_checking) {
                    llvm_utils->create_if_else(
                        builder->CreateICmpEQ(
                            builder->CreatePtrToInt(llvm_utils->CreateLoad2(type->getPointerTo(), (x_arr && x_arr->getType() != nullptr) ? x_arr : ptr_val), llvm::Type::getInt32Ty(context)),
                            builder->CreatePtrToInt(
                                llvm::ConstantPointerNull::get((x_arr && x_arr->getType() != nullptr) ? x_arr->getType()->getPointerTo() : ptr_val->getType()->getPointerTo()),
                                llvm::Type::getInt32Ty(context))),
                        [&]() {
                            llvm::Value* ptr_;

                            if (is_struct_member || is_dummy_arg) {
                                ptr_ = arr_descr->allocate_descriptor_on_heap(type, n_dims);
                                if (ASRUtils::is_array(array_type) && ASRUtils::is_character(*array_type)) {
                                    llvm::Type* llvm_str_desc_type = llvm_utils->get_type_from_ttype_t_util(
                                        tmp_expr, ASRUtils::extract_type(array_type), module.get());
                                    llvm::Value* str_desc = llvm_utils->allocate_string_descriptor_on_heap(
                                        llvm_str_desc_type);
                                    builder->CreateStore(str_desc, arr_descr->get_pointer_to_data(type, ptr_));
                                }
                            } else {
                                ptr_ = llvm_utils->CreateAlloca(*builder, type);
                                arr_descr->fill_dimension_descriptor(type, ptr_, n_dims);
                            }

                            LLVM::CreateStore(
                                *builder, ptr_, (x_arr && x_arr->getType() != nullptr) ? x_arr : ptr_val);
                        },
                        []() {});
                }
                if (ASRUtils::is_array(array_type) && ASRUtils::is_character(*array_type)) {
                    llvm::Value* desc_ptr = llvm_utils->CreateLoad2(
                        type->getPointerTo(), (x_arr && x_arr->getType() != nullptr) ? x_arr : ptr_val);
                    llvm::Type* llvm_str_desc_type = llvm_utils->get_type_from_ttype_t_util(
                        tmp_expr, ASRUtils::extract_type(array_type), module.get());
                    llvm_utils->ensure_string_descriptor_on_heap(type, desc_ptr, llvm_str_desc_type);
                }
                fill_malloc_array_details((x_arr && x_arr->getType() != nullptr) ? x_arr : ptr_val,
                                        type, llvm_data_type,
                                        expr_type(x.m_args[i].m_a),
                                        ASRUtils::get_struct_sym_from_struct_expr(x.m_args[i].m_a),
                                        curr_arg.m_dims, curr_arg.n_dims, curr_arg.m_len_expr, 
                                        curr_arg.m_sym_subclass, realloc, curr_arg.m_type);
                if( ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(ASRUtils::expr_type(tmp_expr)))
                    && !ASRUtils::is_unlimited_polymorphic_type(tmp_expr) ) {
                    llvm::Value* x_arr_ = llvm_utils->CreateLoad2(type->getPointerTo(), x_arr);
                    allocate_array_members_of_struct_arrays(tmp_expr, x_arr_,
                        ASRUtils::expr_type(tmp_expr));
                }
            }
        }
        if (m_stat) {
            ASR::Variable_t *asr_target = EXPR2VAR(m_stat);
            uint32_t h = get_hash((ASR::asr_t*)asr_target);
            if (llvm_symtab.find(h) != llvm_symtab.end()) {
                llvm::Value *target, *value;
                target = llvm_symtab[h];
                // Store 0 (success) in the stat variable
                ASR::ttype_t* stat_type = ASRUtils::expr_type(m_stat);
                int kind = ASRUtils::extract_kind_from_ttype_t(stat_type);
                value = llvm::ConstantInt::get(context, llvm::APInt(8*kind, 0));
                builder->CreateStore(value, target);
            } else {
                throw CodeGenError("Stat variable in allocate not found in LLVM symtab");
            }
        }
    }

    void visit_Allocate(const ASR::Allocate_t& x) {
        visit_AllocateUtil(x, x.m_stat, false, x.m_source);
    }

    void visit_ReAlloc(const ASR::ReAlloc_t& x) {
        LCOMPILERS_ASSERT(x.n_args == 1);
        handle_allocated(x.m_args[0].m_a);
        llvm::Value* is_allocated = tmp;
        llvm::Type* index_type = arr_descr->get_index_type();
        unsigned index_bit_width = index_type->getIntegerBitWidth();
        int index_kind = index_bit_width / 8;
        llvm::Value* size = llvm::ConstantInt::get(
            index_type, llvm::APInt(index_bit_width, 1));
        int64_t ptr_loads_copy = ptr_loads;
        for( size_t i = 0; i < x.m_args[0].n_dims; i++ ) {
            ptr_loads = 2 - !LLVM::is_llvm_pointer(*
                ASRUtils::expr_type(x.m_args[0].m_dims[i].m_length));
            this->visit_expr_wrapper(x.m_args[0].m_dims[i].m_length, true);
            tmp = builder->CreateSExtOrTrunc(tmp, index_type);
            size = builder->CreateMul(size, tmp);
        }
        ptr_loads = ptr_loads_copy;
        llvm::Value* arg_array_size = nullptr;
        // Avoid touching the descriptor if the array is not allocated
        {
            llvm::Type* index_type = arr_descr->get_index_type();
            llvm::Value* size_var = llvm_utils->CreateAlloca(*builder, index_type, nullptr, "arg_array_size_tmp");
            builder->CreateStore(llvm::ConstantInt::get(index_type, 0), size_var);
            llvm_utils->create_if_else(is_allocated, [&]() {
                visit_ArraySizeUtil(x.m_args[0].m_a,
                    ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, index_kind)));
                builder->CreateStore(tmp, size_var);
            }, [](){});
            arg_array_size = llvm_utils->CreateLoad2(index_type, size_var);
        }
        llvm::Value* realloc_condition = builder->CreateOr(
            builder->CreateNot(is_allocated), builder->CreateAnd(
                is_allocated, builder->CreateICmpNE(size, arg_array_size)));
        // Add more condition if it's array of characters (check lengths)
        if(ASRUtils::is_character(*expr_type(x.m_args[0].m_a))){
            llvm::Value* current_str_len = get_string_length(x.m_args[0].m_a);
            LCOMPILERS_ASSERT(current_str_len->getType() == llvm::Type::getInt64Ty(context));
            /* Set `desired_str_len` */
            llvm::Value* desired_str_len {};
            if(x.m_args[0].m_len_expr){ // Provided length in allocation statment.
                visit_expr(*(x.m_args[0].m_len_expr));
                desired_str_len = llvm_utils->convert_kind(tmp, llvm::Type::getInt64Ty(context));
                tmp = nullptr;
            } else { // array's string length is fixed (compile-time or run-time value) -- No need to be provided within the allocation statement.
                LCOMPILERS_ASSERT_MSG(  ASRUtils::get_string_type(x.m_args[0].m_a)->m_len_kind != ASR::DeferredLength,
                                        "Deferred length strings must have length provided when allocating")
                llvm::Value* array {};
                { visit_expr_load_wrapper(x.m_args[0].m_a, 1);   array = tmp;    tmp = nullptr; } // Visit + Set
                desired_str_len = llvm_utils->get_stringArray_length(ASRUtils::expr_type(x.m_args[0].m_a), array);
            }
            realloc_condition = builder->CreateOr(realloc_condition,
                builder->CreateICmpNE(current_str_len, desired_str_len));
        }
        llvm_utils->create_if_else(realloc_condition, [=]() {
            visit_AllocateUtil(x, nullptr, true);
        }, [](){});
    }

    void visit_Nullify(const ASR::Nullify_t& x) {
        for( size_t i = 0; i < x.n_vars; i++ ) {
            ASR::symbol_t* tmp_sym;
            llvm::Value *target;
            if (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_vars[i])) {
                tmp_sym = ASR::down_cast<ASR::StructInstanceMember_t>(x.m_vars[i])->m_m;
                this->visit_expr(*x.m_vars[i]);
                target = tmp;
            } else if (ASR::is_a<ASR::Var_t>(*x.m_vars[i])) {
                tmp_sym = ASR::down_cast<ASR::Var_t>(x.m_vars[i])->m_v;
                tmp_sym = ASRUtils::symbol_get_past_external(tmp_sym);
                std::uint32_t h = get_hash((ASR::asr_t*)tmp_sym);
                target = llvm_symtab[h];
            } else {
                throw CodeGenError("Only StructInstanceMember and Variable are supported Nullify type");
            }

            llvm::Type* tp = llvm_utils->get_type_from_ttype_t_util(x.m_vars[i],
                ASRUtils::type_get_past_pointer(
                ASRUtils::type_get_past_allocatable(
                ASRUtils::symbol_type(tmp_sym))), module.get());

            llvm::Type* dest_type = tp->getPointerTo();
            if (ASR::is_a<ASR::FunctionType_t>(*ASRUtils::symbol_type(tmp_sym)) ||
                (ASRUtils::is_class_type(ASRUtils::extract_type(
                    ASRUtils::symbol_type(tmp_sym))) && !compiler_options.new_classes)) {
                // functions are pointers in LLVM, so we do not need to get the pointer to it
                // Class type target is already pointer, so we dont need to get the pointer for dest
                dest_type = tp;
            }


            if(ASRUtils::is_array(ASRUtils::expr_type(x.m_vars[i]))){
                llvm::Type* x_m_vars_type = llvm_utils->get_type_from_ttype_t_util(x.m_vars[i],
                    ASRUtils::expr_type(x.m_vars[i]), module.get());
                llvm::Value* target_ = llvm_utils->CreateLoad2(x_m_vars_type, target);
                llvm::Value* data_ptr = arr_descr->get_pointer_to_data(x.m_vars[i], ASRUtils::expr_type(x.m_vars[i]), target_ , module.get());
                builder->CreateStore(
                    llvm::ConstantPointerNull::get(llvm_utils->get_el_type(x.m_vars[i],
                        ASRUtils::extract_type(ASRUtils::expr_type(x.m_vars[i])), module.get())->getPointerTo())
                    , data_ptr);
            } else if(ASRUtils::is_string_only(ASRUtils::expr_type(x.m_vars[i]))) {
                llvm::Value* np = llvm::ConstantPointerNull::get(llvm::Type::getInt8Ty(context)->getPointerTo());
                llvm::Value* data_target = llvm_utils->create_gep2(llvm_utils->get_type_from_ttype_t_util(x.m_vars[i],
                    ASRUtils::expr_type(x.m_vars[i]), module.get()), target, 0);
                llvm::Value* len = llvm_utils->create_gep2(llvm_utils->get_type_from_ttype_t_util(x.m_vars[i],
                    ASRUtils::expr_type(x.m_vars[i]), module.get()), target, 1);
                builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(64, 0)), len);
                builder->CreateStore(np, data_target);
            } else {
                llvm::Value* np = builder->CreateIntToPtr(
                    llvm::ConstantInt::get(context, llvm::APInt(32, 0)), dest_type);
                builder->CreateStore(np, target);
            }
        }
    }

    inline void call_lfortran_free(llvm::Function* fn, llvm::Type* tmp_typ,  llvm::Type* llvm_data_type) {
        llvm::Value* arr = llvm_utils->CreateLoad2(llvm_data_type->getPointerTo(), arr_descr->get_pointer_to_data(tmp_typ, tmp));
        std::vector<llvm::Value*> args = { builder->CreateBitCast(arr, character_type) };
        builder->CreateCall(fn, args);
        arr_descr->reset_is_allocated_flag(tmp_typ, tmp, llvm_data_type);
    }

    llvm::Function* _Deallocate() {
        std::string func_name = "_lfortran_free";
        llvm::Function *free_fn = module->getFunction(func_name);
        if (!free_fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        character_type
                    }, false);
            free_fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, func_name, module.get());
        }
        return free_fn;
    }

    llvm::Function* _Allocate() {
        std::string func_name = "_lfortran_allocate_string";
        llvm::Function *alloc_fun = module->getFunction(func_name);
        if (!alloc_fun) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        character_type->getPointerTo(),
                        llvm::Type::getInt64Ty(context),
                        llvm::Type::getInt64Ty(context)->getPointerTo(),
                        llvm::Type::getInt64Ty(context)->getPointerTo()
                    }, false);
            alloc_fun = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, func_name, module.get());
        }
        return alloc_fun;
    }

    template <typename T>
    void visit_Deallocate(const T& x) {
        llvm::Function* free_fn = llvm_utils->_Deallocate();
        for( size_t i = 0; i < x.n_vars; i++ ) {
            ASR::expr_t* tmp_expr = x.m_vars[i];
            ASR::symbol_t* curr_obj = nullptr;
            ASR::abiType abt = ASR::abiType::Source;
            if( ASR::is_a<ASR::Var_t>(*tmp_expr) ) {
                const ASR::Var_t* tmp_var = ASR::down_cast<ASR::Var_t>(tmp_expr);
                curr_obj = tmp_var->m_v;
                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(
                                    symbol_get_past_external(curr_obj));
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                if (!ASRUtils::is_class_type(ASRUtils::extract_type(v->m_type))) {
                    fetch_var(v);
                } else {
                    uint32_t h = get_hash((ASR::asr_t*)v);
                    tmp = llvm_symtab[h];
                }
                ptr_loads = ptr_loads_copy;
                abt = v->m_abi;
            } else if (ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr)) {
                ASR::StructInstanceMember_t* sm = ASR::down_cast<ASR::StructInstanceMember_t>(tmp_expr);
                ASR::ttype_t* caller_type = ASRUtils::type_get_past_allocatable(
                        ASRUtils::expr_type(sm->m_v));
                int64_t ptr_loads_copy = ptr_loads;
                if (ASRUtils::is_class_type(ASRUtils::extract_type(caller_type)) &&
                        !compiler_options.new_classes) {
                    ptr_loads = 0;
                } else {
                    ptr_loads = 1;
                }
                this->visit_expr_wrapper(sm->m_v, ASRUtils::is_class_type(ASRUtils::extract_type(caller_type)));
                ptr_loads = ptr_loads_copy;
                llvm::Value* dt = tmp;
                ASR::symbol_t *struct_sym = nullptr;
                llvm::Type* dt_type = llvm_utils->getStructType(
                    ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(sm->m_v))),
                    module.get());
                struct_sym = ASRUtils::symbol_get_past_external(
                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(sm->m_v)));
                if (ASRUtils::is_class_type(ASRUtils::extract_type(caller_type))) {
                    llvm::Type* dt_type_poly = llvm_utils->get_type_from_ttype_t_util(sm->m_v,
                        ASRUtils::type_get_past_pointer(ASRUtils::type_get_past_allocatable(caller_type)),
                        module.get());
                    llvm::Value* dt_ptr = llvm_utils->create_gep2(dt_type_poly, dt, 1);
                    dt = llvm_utils->CreateLoad2(dt_type->getPointerTo(), dt_ptr);
                } else if (ASR::is_a<ASR::StructInstanceMember_t>(*sm->m_v)) {
                    dt = llvm_utils->CreateLoad2(dt_type->getPointerTo(), dt);
                }

                std::string curr_struct = ASRUtils::symbol_name(struct_sym);
                std::string member_name = ASRUtils::symbol_name(ASRUtils::symbol_get_past_external(sm->m_m));
                while( name2memidx[curr_struct].find(member_name) == name2memidx[curr_struct].end() ) {
                    if( dertype2parent.find(curr_struct) == dertype2parent.end() ) {
                        throw CodeGenError(curr_struct + " doesn't have any member named " + member_name,
                                            x.base.base.loc);
                    }
                    dt = llvm_utils->create_gep2(name2dertype[curr_struct], dt, 0);
                    curr_struct = dertype2parent[curr_struct];
                }
                int dt_idx = 0;
                dt_idx = name2memidx[curr_struct][member_name];
                std::vector<llvm::Value*> idx_vars = {llvm::ConstantInt::get(context, llvm::APInt(32, 0)),
                    llvm::ConstantInt::get(context, llvm::APInt(32, dt_idx))};
                if (dt->getType() != name2dertype[curr_struct]->getPointerTo()) {
                    llvm::Value* dt_val = dt;
                    llvm::Value* alloca_tmp = builder->CreateAlloca(name2dertype[curr_struct]);
                    builder->CreateStore(dt_val, alloca_tmp);
                    dt = alloca_tmp;
                }
                LCOMPILERS_ASSERT(dt->getType()->isPointerTy());
                llvm::Value* dt_1 = builder->CreateGEP(name2dertype[curr_struct], dt, idx_vars);
                tmp = dt_1;
            } else {
                throw CodeGenError("Cannot deallocate variables in expression " +
                                    ASRUtils::type_to_str_python_expr(ASRUtils::expr_type(tmp_expr), tmp_expr),
                                    tmp_expr->base.loc);
            }
            ASR::ttype_t *cur_type = ASRUtils::expr_type(tmp_expr);
            ASR::ttype_t *cur_type_past = ASRUtils::type_get_past_allocatable_pointer(cur_type);
            bool in_struct = ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr);
            ASR::Struct_t* struct_sym = nullptr;
            if (cur_type_past->type == ASR::StructType ||
                (cur_type_past->type == ASR::Array &&
                 ASR::down_cast<ASR::Array_t>(cur_type_past)->m_type->type == ASR::StructType)) {
                ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(
                    ASRUtils::get_struct_sym_from_struct_expr(tmp_expr));
                struct_sym = ASR::down_cast<ASR::Struct_t>(sym);
            }
            int dims = ASRUtils::extract_n_dims_from_ttype(cur_type);
            if(ASRUtils::is_character(*cur_type)) { // Handle Strings (array of strings or just string)
                tmp = LLVM::is_llvm_pointer(*cur_type) ?
                    builder->CreateLoad(llvm_utils->get_type_from_ttype_t_util(tmp_expr, cur_type, module.get()), tmp)
                    : tmp ;
                llvm_utils->free_strings(tmp_expr, tmp);
            } else {
                if (dims == 0) {
                    llvm::Type* llvm_data_type;
                    llvm::Value* tmp_ = tmp;
                    if (LLVM::is_llvm_pointer(*cur_type)) {
                        llvm::Type* typ = llvm_utils->get_type_from_ttype_t_util(tmp_expr, cur_type, module.get());
                        tmp = llvm_utils->CreateLoad2(typ, tmp);
                    }
                    if (ASRUtils::is_class_type(ASRUtils::extract_type(cur_type))) {
                        // If it is a class type, we need to get the pointer to the struct
                        llvm::Type* class_type = llvm_utils->get_type_from_ttype_t_util(
                            tmp_expr,
                            ASRUtils::type_get_past_pointer(ASRUtils::type_get_past_allocatable(cur_type)),
                            module.get());
                        llvm::Value* class_ptr = tmp;

                        ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(tmp_expr));
                        // ASR::Struct_t* st = ASR::down_cast<ASR::Struct_t>(struct_sym);
                        llvm::Value* class_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                            llvm::APInt(64, get_class_hash(struct_sym)));

                        if (!compiler_options.new_classes) {
                            // Store back the original hash
                            llvm::Value* t = llvm_utils->create_gep2(class_type, class_ptr, 0);
                            builder->CreateStore(class_hash, t);
                            tmp_ = llvm_utils->create_gep2(class_type, class_ptr, 1);
                        }
                        llvm_data_type = class_type;
                        tmp = llvm_utils->CreateLoad2(llvm_data_type->getPointerTo(), tmp_);
                    } else {
                        llvm_data_type = llvm_utils->get_type_from_ttype_t_util(tmp_expr,
                            ASRUtils::type_get_past_array(
                                ASRUtils::type_get_past_pointer(
                                    ASRUtils::type_get_past_allocatable(cur_type))),
                            module.get(), abt);
                    }
                    llvm::Value *cond = builder->CreateICmpNE(
                        builder->CreatePtrToInt(tmp, llvm::Type::getInt64Ty(context)),
                        builder->CreatePtrToInt(
                            llvm::ConstantPointerNull::get(llvm_data_type->getPointerTo()),
                            llvm::Type::getInt64Ty(context)) );
                    llvm_utils->create_if_else(cond, [=]() {
                        llvm_symtab_finalizer.finalize_before_deallocate(tmp, cur_type, struct_sym, in_struct);
                        // Deallocate data of class first
                        if (compiler_options.new_classes &&
                                ASRUtils::is_class_type(ASRUtils::extract_type(cur_type))) {
                            llvm::Value* data = llvm_utils->create_gep2(llvm_data_type, tmp, 1);
                            llvm::Value* data_ptr;
                            if (ASRUtils::is_unlimited_polymorphic_type(tmp_expr)) {
                                data_ptr = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, data);
                            } else {
                                ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(tmp_expr));
                                data_ptr = llvm_utils->CreateLoad2(llvm_utils->getStructType(
                                    ASR::down_cast<ASR::Struct_t>(struct_sym), module.get(), true), data);
                                data_ptr = builder->CreateBitCast(data_ptr, llvm_utils->i8_ptr);
                            }
                            llvm::Value* cond_data = builder->CreateICmpNE(
                            builder->CreatePtrToInt(data_ptr, llvm::Type::getInt64Ty(context)),
                            builder->CreatePtrToInt(
                                llvm::ConstantPointerNull::get(llvm_utils->i8_ptr),
                                llvm::Type::getInt64Ty(context)) );
                            llvm_utils->create_if_else(cond_data, [=]() {
                                llvm::AllocaInst *data_arg_tmp = llvm_utils->CreateAlloca(*builder, character_type);
                                builder->CreateStore(data_ptr, data_arg_tmp);
                                std::vector<llvm::Value*> data_args = {llvm_utils->CreateLoad2(character_type, data_arg_tmp)};
                                builder->CreateCall(free_fn, data_args);
                                builder->CreateStore(
                                    llvm::ConstantPointerNull::get(llvm_utils->i8_ptr),
                                    builder->CreateBitCast(data, llvm_utils->i8_ptr->getPointerTo()));
                            }, [](){});
                        }
                        llvm::AllocaInst *arg_tmp = llvm_utils->CreateAlloca(*builder, character_type);
                        builder->CreateStore(builder->CreateBitCast(tmp, character_type), arg_tmp);
                        std::vector<llvm::Value*> args = {llvm_utils->CreateLoad2(character_type, arg_tmp)};
                        builder->CreateCall(free_fn, args);
                        builder->CreateStore(
                            llvm::ConstantPointerNull::get(llvm_data_type->getPointerTo()), tmp_);
                    }, [](){});
                } else {
                    if( LLVM::is_llvm_pointer(*cur_type) ) {
                        llvm::Type* typ = llvm_utils->get_type_from_ttype_t_util(tmp_expr, cur_type, module.get());
                        tmp = llvm_utils->CreateLoad2(typ, tmp);
                    }
                    llvm::Type* typ = llvm_utils->get_type_from_ttype_t_util(tmp_expr,
                        ASRUtils::type_get_past_pointer(
                            ASRUtils::type_get_past_allocatable(cur_type)),
                    module.get(), abt);
                    ASR::ttype_t* element_type = ASRUtils::type_get_past_array(
                        ASRUtils::type_get_past_pointer(
                            ASRUtils::type_get_past_allocatable(cur_type)));
                    // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                    llvm::Type* llvm_data_type = llvm_utils->get_el_type(tmp_expr, element_type, module.get());
                    llvm::Value *cond = arr_descr->get_is_allocated_flag(tmp, tmp_expr);
                    llvm_utils->create_if_else(cond, [=]() {
                        llvm_symtab_finalizer.finalize_before_deallocate(tmp, cur_type, struct_sym, in_struct);
                        call_lfortran_free(free_fn, typ,  llvm_data_type);
                    }, [](){});
                }
            }
        }
    }

    void visit_ImplicitDeallocate(const ASR::ImplicitDeallocate_t& x) {
        visit_Deallocate(x);
    }

    void visit_ExplicitDeallocate(const ASR::ExplicitDeallocate_t& x) {
        visit_Deallocate(x);
    }

    void visit_ListConstant(const ASR::ListConstant_t& x) {
        ASR::List_t* list_type = ASR::down_cast<ASR::List_t>(x.m_type);
        bool is_array_type_local = false, is_malloc_array_type_local = false;
        bool is_list_local = false;
        ASR::dimension_t* m_dims_local = nullptr;
        int n_dims_local = -1, a_kind_local = -1;

        llvm::Type* llvm_el_type = llvm_utils->get_type_from_ttype_t(const_cast<ASR::expr_t*>(&x.base), list_type->m_type,
                                    nullptr, ASR::storage_typeType::Default, is_array_type_local,
                                    is_malloc_array_type_local, is_list_local, m_dims_local,
                                    n_dims_local, a_kind_local, module.get());
        std::string type_code = ASRUtils::get_type_code(list_type->m_type);
        int32_t type_size = -1;
        if( ASR::is_a<ASR::String_t>(*list_type->m_type) ||
            LLVM::is_llvm_struct(list_type->m_type) ||
            ASRUtils::is_allocatable_descriptor_string(list_type->m_type) ||
            ASR::is_a<ASR::Complex_t>(*list_type->m_type) ) {
            llvm::DataLayout data_layout(module->getDataLayout());
            type_size = data_layout.getTypeAllocSize(llvm_el_type);
        } else {
            type_size = ASRUtils::extract_kind_from_ttype_t(list_type->m_type);
        }
        llvm::Type* const_list_type = list_api->get_list_type(llvm_el_type, type_code, type_size);
        llvm::Value* const_list = llvm_utils->CreateAlloca(*builder, const_list_type, nullptr, "const_list");
        list_api->list_init(type_code, const_list, module.get(), x.n_args, x.n_args);
        for( size_t i = 0; i < x.n_args; i++ ) {
            visit_expr_load_wrapper(
                x.m_args[i],
                is_argument_of_type_CPtr(x.m_args[i]) || ASRUtils::is_character(*expr_type(x.m_args[i])) ? 0 : 1);
            llvm::Value* item = tmp;
            llvm::Value* pos = llvm::ConstantInt::get(context, llvm::APInt(32, i));
            list_api->write_item(const_cast<ASR::expr_t*>(&x.base), const_list, pos, item, list_type->m_type,
                                 false, module.get());
        }
        tmp = const_list;
    }

    void visit_DictConstant(const ASR::DictConstant_t& x) {
        llvm::Type* const_dict_type = llvm_utils->get_dict_type(const_cast<ASR::expr_t*>(&x.base), x.m_type, module.get());
        llvm::Value* const_dict = llvm_utils->CreateAlloca(*builder, const_dict_type, nullptr, "const_dict");
        ASR::Dict_t* x_dict = ASR::down_cast<ASR::Dict_t>(x.m_type);
        llvm_utils->set_dict_api(x_dict);
        llvm_utils->dict_api->dict_init(x_dict, const_dict, module.get(), x.n_keys);
        int64_t ptr_loads_key = !LLVM::is_llvm_struct(x_dict->m_key_type);
        int64_t ptr_loads_value = !LLVM::is_llvm_struct(x_dict->m_value_type);
        int64_t ptr_loads_copy = ptr_loads;
        for( size_t i = 0; i < x.n_keys; i++ ) {
            ptr_loads = ptr_loads_key;
            visit_expr_wrapper(x.m_keys[i], ASRUtils::is_character(*expr_type(x.m_keys[i])) ? 0 : 1);
            llvm::Value* key = tmp;
            ptr_loads = ptr_loads_value;
            visit_expr_wrapper(x.m_values[i], ASRUtils::is_character(*expr_type(x.m_values[i])) ? 0 : 1);
            llvm::Value* value = tmp;
            llvm_utils->dict_api->write_item(const_cast<ASR::expr_t*>(&x.base), const_dict, key, value, module.get(),
                                 x_dict->m_key_type, x_dict->m_value_type);
        }
        ptr_loads = ptr_loads_copy;
        tmp = const_dict;
    }

    void visit_SetConstant(const ASR::SetConstant_t& x) {
        llvm::Type* const_set_type = llvm_utils->get_set_type(const_cast<ASR::expr_t*>(&x.base), x.m_type, module.get());
        llvm::Value* const_set = llvm_utils->CreateAlloca(*builder, const_set_type, nullptr, "const_set");
        ASR::Set_t* x_set = ASR::down_cast<ASR::Set_t>(x.m_type);
        llvm_utils->set_set_api(x_set);
        std::string el_type_code = ASRUtils::get_type_code(x_set->m_type);
        llvm_utils->set_api->set_init(el_type_code, const_set, module.get(), x.n_elements);
        int64_t ptr_loads_el = !LLVM::is_llvm_struct(x_set->m_type);
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = ptr_loads_el;
        for( size_t i = 0; i < x.n_elements; i++ ) {
            visit_expr_wrapper(x.m_elements[i], true);
            llvm::Value* element = tmp;
            llvm_utils->set_api->write_item(const_cast<ASR::expr_t*>(&x.base), const_set, element, module.get(),
                                            x_set->m_type);
        }
        ptr_loads = ptr_loads_copy;
        tmp = const_set;
    }

    void visit_TupleConstant(const ASR::TupleConstant_t& x) {
        ASR::Tuple_t* tuple_type = ASR::down_cast<ASR::Tuple_t>(x.m_type);
        std::string type_code = ASRUtils::get_type_code(tuple_type->m_type,
                                                        tuple_type->n_type);
        std::vector<llvm::Type*> llvm_el_types;
        ASR::storage_typeType m_storage = ASR::storage_typeType::Default;
        bool is_array_type = false, is_malloc_array_type = false;
        bool is_list = false;
        ASR::dimension_t* m_dims = nullptr;
        int n_dims = 0, a_kind = -1;
        for( size_t i = 0; i < tuple_type->n_type; i++ ) {
            llvm_el_types.push_back(llvm_utils->get_type_from_ttype_t(const_cast<ASR::expr_t*>(&x.base), tuple_type->m_type[i],
                nullptr, m_storage, is_array_type, is_malloc_array_type,
                is_list, m_dims, n_dims, a_kind, module.get()));
        }
        llvm::Type* const_tuple_type = tuple_api->get_tuple_type(type_code, llvm_el_types);
        llvm::Value* const_tuple = llvm_utils->CreateAlloca(*builder, const_tuple_type, nullptr, "const_tuple");
        std::vector<llvm::Value*> init_values;
        int64_t ptr_loads_copy = ptr_loads;
        for( size_t i = 0; i < x.n_elements; i++ ) {
            if(ASRUtils::is_character(*tuple_type->m_type[i])){
                ptr_loads = 0;
            } else if(!LLVM::is_llvm_struct(tuple_type->m_type[i])) {
                ptr_loads = 2;
            }
            else {
                ptr_loads = ptr_loads_copy;
            }
            this->visit_expr(*x.m_elements[i]);
            init_values.push_back(tmp);
        }
        ptr_loads = ptr_loads_copy;
        tuple_api->tuple_init(const_cast<ASR::expr_t*>(&x.base), const_tuple, init_values, tuple_type,
                              module.get());
        tmp = const_tuple;
    }

    void visit_IntegerBitLen(const ASR::IntegerBitLen_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr(*x.m_a);
        llvm::Value *int_val = tmp;
        int int_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
        std::string runtime_func_name = "_lpython_bit_length" + std::to_string(int_kind);
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getInt32Ty(context), {
                        llvm_utils->getIntType(int_kind)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, {int_val});
    }

    void visit_Ichar(const ASR::Ichar_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        llvm::Value *c = llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_arg), tmp);
        std::string runtime_func_name = "_lfortran_ichar";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                llvm::Type::getInt32Ty(context), {
                    llvm::Type::getInt8Ty(context)->getPointerTo()
                }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, {c});
    }

    void visit_Iachar(const ASR::Iachar_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_load_wrapper(x.m_arg, 0);
        llvm::Value *c = llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_arg), tmp);
        std::string runtime_func_name = "_lfortran_iachar";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                llvm::Type::getInt32Ty(context), {
                    llvm::Type::getInt8Ty(context)->getPointerTo()
                }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, {c});
        if( ASRUtils::extract_kind_from_ttype_t(x.m_type) == 8 ) {
            tmp = builder->CreateSExt(tmp, llvm_utils->getIntType(8));
        }
    }

    void visit_RealSqrt(const ASR::RealSqrt_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr(*x.m_arg);
        if (tmp->getType()->isPointerTy()) {
            llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_arg, x.m_type, module.get());
            tmp = llvm_utils->CreateLoad2(llvm_type, tmp);
        }
        llvm::Value *c = tmp;
        int64_t kind_value = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(x.m_arg));
        std::string func_name;
        if (kind_value ==4) {
            func_name = "llvm.sqrt.f32";
        } else {
            func_name = "llvm.sqrt.f64";
        }
        llvm::Type *type = llvm_utils->getFPType(kind_value);
        llvm::Function *fn_sqrt = module->getFunction(func_name);
        if (!fn_sqrt) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    type, {type}, false);
            fn_sqrt = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, func_name,
                    module.get());
        }
        tmp = builder->CreateCall(fn_sqrt, {c});
    }

    void visit_ListAppend(const ASR::ListAppend_t& x) {
        ASR::List_t* asr_list = ASR::down_cast<ASR::List_t>(ASRUtils::expr_type(x.m_a));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        llvm::Value* plist = tmp;

        ptr_loads = !(LLVM::is_llvm_struct(asr_list->m_type) || ASRUtils::is_character(*asr_list->m_type)) ? 1 : 0;
        this->visit_expr_wrapper(x.m_ele, true);
        llvm::Value *item = tmp;
        ptr_loads = ptr_loads_copy;
        list_api->append(x.m_a, plist, item, asr_list->m_type, module.get());
    }

    void visit_UnionInstanceMember(const ASR::UnionInstanceMember_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_v);
        ptr_loads = ptr_loads_copy;
        llvm::Value* union_llvm = tmp;
        ASR::Variable_t* member_var = ASR::down_cast<ASR::Variable_t>(
            ASRUtils::symbol_get_past_external(x.m_m));
        ASR::ttype_t* member_type_asr = ASRUtils::get_contained_type(member_var->m_type);
        if( ASR::is_a<ASR::StructType_t>(*member_type_asr) && !ASRUtils::is_class_type(member_type_asr) ) {
            current_der_type_name = ASRUtils::symbol_name(member_var->m_type_declaration);
        }
        member_type_asr = member_var->m_type;
        llvm::Type* member_type_llvm = llvm_utils->getMemberType(member_type_asr, member_var, module.get())->getPointerTo();
        tmp = builder->CreateBitCast(union_llvm, member_type_llvm);
        if( is_assignment_target ) {
            return ;
        }
        if( ptr_loads > 0 ) {
            llvm::Type* value_type = llvm_utils->getMemberType(member_type_asr, member_var, module.get());
            tmp = llvm_utils->CreateLoad2(value_type, tmp);
        }
    }

    void visit_ListItem(const ASR::ListItem_t& x) {
        ASR::ttype_t* el_type = ASRUtils::get_contained_type(
                                        ASRUtils::expr_type(x.m_a));
        visit_expr_load_wrapper(x.m_a, 0);
        llvm::Value* plist = tmp;

        visit_expr_load_wrapper(x.m_pos, 1, true);
        llvm::Value *pos = tmp;

        tmp = list_api->read_item_using_ttype(el_type, plist, pos, compiler_options.po.bounds_checking, module.get(),
                (LLVM::is_llvm_struct(el_type) || ptr_loads == 0));
    }

    void visit_DictItem(const ASR::DictItem_t& x) {
        ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(
                                    ASRUtils::expr_type(x.m_a));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        llvm::Value* pdict = tmp;

        ptr_loads = !(LLVM::is_llvm_struct(dict_type->m_key_type) || ASRUtils::is_character(*dict_type->m_key_type)) ? 1 : 0;
        this->visit_expr_wrapper(x.m_key, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *key = tmp;
        if (x.m_default) {
            llvm::Type *val_type = llvm_utils->get_type_from_ttype_t_util(x.m_a, dict_type->m_value_type, module.get());
            llvm::Value *def_value_ptr = llvm_utils->CreateAlloca(*builder, val_type);
            ptr_loads = !LLVM::is_llvm_struct(dict_type->m_value_type);
            this->visit_expr_wrapper(x.m_default, true);
            ptr_loads = ptr_loads_copy;
            builder->CreateStore(tmp, def_value_ptr);
            llvm_utils->set_dict_api(dict_type);
            tmp = llvm_utils->dict_api->get_item(x.m_a, pdict, key, module.get(), dict_type, def_value_ptr,
                                  LLVM::is_llvm_struct(dict_type->m_value_type) ||
                                  ASRUtils::is_allocatable_descriptor_string(dict_type->m_value_type));
        } else {
            llvm_utils->set_dict_api(dict_type);
            tmp = llvm_utils->dict_api->read_item(x.m_a, pdict, key, module.get(), dict_type,
                                    compiler_options.po.bounds_checking,
                                    LLVM::is_llvm_struct(dict_type->m_value_type) ||
                                    ASRUtils::is_allocatable_descriptor_string(dict_type->m_value_type));
        }
    }

    void visit_DictPop(const ASR::DictPop_t& x) {
        ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(
                                    ASRUtils::expr_type(x.m_a));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        llvm::Value* pdict = tmp;

        ptr_loads = !(LLVM::is_llvm_struct(dict_type->m_key_type) || ASRUtils::is_character(*dict_type->m_key_type)) ? 1 : 0;
        this->visit_expr_wrapper(x.m_key, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *key = tmp;

        llvm_utils->set_dict_api(dict_type);
        tmp = llvm_utils->dict_api->pop_item(x.m_a, pdict, key, module.get(), dict_type,
                                 LLVM::is_llvm_struct(dict_type->m_value_type));
    }

    void visit_ListLen(const ASR::ListLen_t& x) {
        if (x.m_value) {
            this->visit_expr(*x.m_value);
        } else {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_arg);
            ptr_loads = ptr_loads_copy;
            llvm::Value* plist = tmp;

            std::string type_code = ASRUtils::get_type_code(
                ASRUtils::get_contained_type(ASRUtils::expr_type(x.m_arg)));
            llvm::Type* list_type = list_api->get_list_type(nullptr, type_code, 0);
            tmp = list_api->len_using_type(list_type, plist);
        }
    }

    void visit_ListCompare(const ASR::ListCompare_t x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_left);
        llvm::Value* left = tmp;
        this->visit_expr(*x.m_right);
        llvm::Value* right = tmp;
        ptr_loads = ptr_loads_copy;

        ASR::ttype_t* int32_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));

        if(x.m_op == ASR::cmpopType::Eq || x.m_op == ASR::cmpopType::NotEq) {
            tmp = llvm_utils->is_equal_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left));
            if (x.m_op == ASR::cmpopType::NotEq) {
                tmp = builder->CreateNot(tmp);
            }
        }
        else if(x.m_op == ASR::cmpopType::Lt) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 0, int32_type);
        }
        else if(x.m_op == ASR::cmpopType::LtE) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 1, int32_type);
        }
        else if(x.m_op == ASR::cmpopType::Gt) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 2, int32_type);
        }
        else if(x.m_op == ASR::cmpopType::GtE) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 3, int32_type);
        }
    }

    void visit_DictLen(const ASR::DictLen_t& x) {
        if (x.m_value) {
            this->visit_expr(*x.m_value);
            return ;
        }

        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_arg);
        ptr_loads = ptr_loads_copy;
        llvm::Value* pdict = tmp;
        ASR::Dict_t* x_dict = ASR::down_cast<ASR::Dict_t>(ASRUtils::expr_type(x.m_arg));
        llvm_utils->set_dict_api(x_dict);
        llvm::Type* dict_type = llvm_utils->get_dict_type(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
        tmp = llvm_utils->dict_api->len(dict_type, pdict);
    }

    void visit_SetLen(const ASR::SetLen_t& x) {
        if (x.m_value) {
            this->visit_expr(*x.m_value);
            return ;
        }

        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_arg);
        ptr_loads = ptr_loads_copy;
        llvm::Value* pset = tmp;
        ASR::Set_t* x_set = ASR::down_cast<ASR::Set_t>(ASRUtils::expr_type(x.m_arg));
        llvm_utils->set_set_api(x_set);
        llvm::Type* set_type = llvm_utils->get_set_type(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
        tmp = llvm_utils->set_api->len(set_type, pset);
    }

    void visit_ListInsert(const ASR::ListInsert_t& x) {
        ASR::List_t* asr_list = ASR::down_cast<ASR::List_t>(
                                    ASRUtils::expr_type(x.m_a));

        this->visit_expr_load_wrapper(x.m_a, 0);
        llvm::Value* plist = tmp;

        this->visit_expr_load_wrapper(x.m_pos, 1, true);
        llvm::Value *pos = tmp;

        visit_expr_load_wrapper(x.m_ele,
            !(LLVM::is_llvm_struct(asr_list->m_type) || ASRUtils::is_character(*asr_list->m_type)) ? 1 : 0,
            true);
        llvm::Value *item = tmp;

        list_api->insert_item(x.m_a, plist, pos, item, asr_list->m_type, module.get());
    }

    void visit_DictInsert(const ASR::DictInsert_t& x) {
        ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(
                                    ASRUtils::expr_type(x.m_a));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        llvm::Value* pdict = tmp;

        ptr_loads = !(LLVM::is_llvm_struct(dict_type->m_value_type) || ASRUtils::is_character(*dict_type->m_value_type));
        visit_expr_load_wrapper(x.m_key,
            !(LLVM::is_llvm_struct(dict_type->m_key_type) || ASRUtils::is_character(*dict_type->m_key_type)));
        llvm::Value *key = tmp;
        visit_expr_load_wrapper(x.m_value,
            !(LLVM::is_llvm_struct(dict_type->m_value_type) || ASRUtils::is_character(*dict_type->m_value_type)) ? 1 : 0,
            true);
        llvm::Value *value = tmp;
        ptr_loads = ptr_loads_copy;

        llvm_utils->set_dict_api(dict_type);
        llvm_utils->dict_api->write_item(x.m_a, pdict, key, value, module.get(),
                             dict_type->m_key_type,
                             dict_type->m_value_type);
    }

    void visit_Expr(const ASR::Expr_t& x) {
        this->visit_expr_wrapper(x.m_expression, false);
    }

    void visit_ListRemove(const ASR::ListRemove_t& x) {
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(x.m_a));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        llvm::Value* plist = tmp;

        ptr_loads = !LLVM::is_llvm_struct(asr_el_type);
        this->visit_expr_wrapper(x.m_ele, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *item = tmp;
        list_api->remove(plist, item, asr_el_type, module.get());
    }

    void visit_ListCount(const ASR::ListCount_t& x) {
        ASR::ttype_t *asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(x.m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_arg);
        llvm::Value* plist = tmp;

        ptr_loads = !LLVM::is_llvm_struct(asr_el_type);
        this->visit_expr_wrapper(x.m_ele, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *item = tmp;
        tmp = list_api->count(plist, item, asr_el_type, module.get());
    }

    void generate_ListIndex(ASR::expr_t* m_arg, ASR::expr_t* m_ele,
            ASR::expr_t* m_start=nullptr, ASR::expr_t* m_end=nullptr) {
        ASR::ttype_t *asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* plist = tmp;

        ptr_loads = !LLVM::is_llvm_struct(asr_el_type);
        this->visit_expr_wrapper(m_ele, true);
        llvm::Value *item = tmp;

        llvm::Value* start = nullptr;
        llvm::Value* end = nullptr;
        if(m_start) {
            ptr_loads = 2;
            this->visit_expr_wrapper(m_start, true);
            start = tmp;
        }
        if(m_end) {
            ptr_loads = 2;
            this->visit_expr_wrapper(m_end, true);
            end = tmp;
        }

        ptr_loads = ptr_loads_copy;
        tmp = list_api->index(plist, item, start, end, asr_el_type, module.get());
    }

    void generate_Exp(ASR::expr_t* m_arg) {
        this->visit_expr_wrapper(m_arg, true);
        llvm::Value *item = tmp;
#if LLVM_VERSION_MAJOR >= 12
        tmp = builder->CreateUnaryIntrinsic(llvm::Intrinsic::exp, item);
#elif LLVM_VERSION_MAJOR >= 8
        tmp = builder->CreateIntrinsic(llvm::Intrinsic::exp, {item->getType()}, {item});
#else
        // LLVM 7: CreateIntrinsic(ID, Args, FMFSource)
        llvm::Function *fn = llvm::Intrinsic::getDeclaration(module.get(), llvm::Intrinsic::exp, {item->getType()});
        tmp = builder->CreateCall(fn, {item});
#endif
    }

    void generate_Exp2(ASR::expr_t* m_arg) {
        this->visit_expr_wrapper(m_arg, true);
        llvm::Value *item = tmp;
#if LLVM_VERSION_MAJOR >= 12
        tmp = builder->CreateUnaryIntrinsic(llvm::Intrinsic::exp2, item);
#elif LLVM_VERSION_MAJOR >= 8
        tmp = builder->CreateIntrinsic(llvm::Intrinsic::exp2, {item->getType()}, {item});
#else
        // LLVM 7: CreateIntrinsic(ID, Args, FMFSource)
        llvm::Function *fn = llvm::Intrinsic::getDeclaration(module.get(), llvm::Intrinsic::exp2, {item->getType()});
        tmp = builder->CreateCall(fn, {item});
#endif
    }

    void generate_Expm1(ASR::expr_t* m_arg) {
        this->visit_expr_wrapper(m_arg, true);
        llvm::Value *item = tmp;
#if LLVM_VERSION_MAJOR >= 12
        llvm::Value* exp = builder->CreateUnaryIntrinsic(llvm::Intrinsic::exp, item);
#elif LLVM_VERSION_MAJOR >= 8
        llvm::Value* exp = builder->CreateIntrinsic(llvm::Intrinsic::exp, {item->getType()}, {item});
#else
        // LLVM 7: CreateIntrinsic(ID, Args, FMFSource)
        llvm::Function *fn = llvm::Intrinsic::getDeclaration(module.get(), llvm::Intrinsic::exp, {item->getType()});
        llvm::Value* exp = builder->CreateCall(fn, {item});
#endif
        llvm::Value* one = llvm::ConstantFP::get(builder->getFloatTy(), 1.0);
        tmp = builder->CreateFSub(exp, one);
    }

    void generate_Abs(ASR::expr_t* m_arg) {
        this->visit_expr_wrapper(m_arg, true);
        llvm::Value *item = tmp;
        llvm::Type *item_type = item->getType();
        if (item_type->isFloatingPointTy()) {
#if LLVM_VERSION_MAJOR >= 12
            tmp = builder->CreateUnaryIntrinsic(llvm::Intrinsic::fabs, item);
#elif LLVM_VERSION_MAJOR >= 8
            tmp = builder->CreateIntrinsic(llvm::Intrinsic::fabs, {item_type}, {item});
#else
            llvm::Function *fn = llvm::Intrinsic::getDeclaration(module.get(),
                llvm::Intrinsic::fabs, {item_type});
            tmp = builder->CreateCall(fn, {item});
#endif
        } else if (item_type->isIntegerTy()) {
            // abs(x) = x >= 0 ? x : -x (branchless with select)
            llvm::Value *zero = llvm::ConstantInt::get(item_type, 0);
            llvm::Value *neg = builder->CreateNeg(item);
            llvm::Value *cmp = builder->CreateICmpSGE(item, zero);
            tmp = builder->CreateSelect(cmp, item, neg);
        }
    }

    void generate_MinMax(ASR::expr_t** m_args, size_t n_args, bool is_max) {
        LCOMPILERS_ASSERT(n_args >= 2);
        this->visit_expr_wrapper(m_args[0], true);
        llvm::Value *result = tmp;
        llvm::Type *val_type = result->getType();
        for (size_t i = 1; i < n_args; i++) {
            this->visit_expr_wrapper(m_args[i], true);
            llvm::Value *arg = tmp;
            if (val_type->isFloatingPointTy()) {
                // Use ordered comparison for Fortran-compatible NaN propagation
                // If either operand is NaN, comparison returns false, preserving result
                llvm::Value *cmp = is_max
                    ? builder->CreateFCmpOGT(arg, result)
                    : builder->CreateFCmpOLT(arg, result);
                result = builder->CreateSelect(cmp, arg, result);
            } else if (val_type->isIntegerTy()) {
                llvm::Value *cmp = is_max
                    ? builder->CreateICmpSGT(result, arg)
                    : builder->CreateICmpSLT(result, arg);
                result = builder->CreateSelect(cmp, result, arg);
            }
        }
        tmp = result;
    }

    void generate_ListReverse(ASR::expr_t* m_arg) {
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* plist = tmp;

        ptr_loads = !LLVM::is_llvm_struct(asr_el_type);
        ptr_loads = ptr_loads_copy;

        list_api->reverse(asr_el_type, plist, module.get());
    }

    void generate_ListPop_0(ASR::expr_t* m_arg) {
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* plist = tmp;

        ptr_loads = !LLVM::is_llvm_struct(asr_el_type);
        ptr_loads = ptr_loads_copy;
        tmp = list_api->pop_last(plist, asr_el_type, module.get());
    }

    void generate_ListPop_1(ASR::expr_t* m_arg, ASR::expr_t* m_ele) {
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* plist = tmp;

        ptr_loads = 2;
        this->visit_expr_wrapper(m_ele, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *pos = tmp;
        tmp = list_api->pop_position(m_arg, plist, pos, asr_el_type, module.get());
    }

    void generate_ListReserve(ASR::expr_t* m_arg, ASR::expr_t* m_ele) {
        // For now, this only handles lists
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* plist = tmp;

        ptr_loads = 2;
        this->visit_expr_wrapper(m_ele, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value* n = tmp;
        list_api->reserve(plist, n, asr_el_type, module.get());
    }

    void generate_DictElems(ASR::expr_t* m_arg, bool key_or_value) {
        ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(
                                    ASRUtils::expr_type(m_arg));
        ASR::ttype_t* el_type = key_or_value == 0 ?
                                    dict_type->m_key_type : dict_type->m_value_type;

        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* pdict = tmp;

        ptr_loads = ptr_loads_copy;

        bool is_array_type_local = false, is_malloc_array_type_local = false;
        bool is_list_local = false;
        ASR::dimension_t* m_dims_local = nullptr;
        int n_dims_local = -1, a_kind_local = -1;
        llvm::Type* llvm_el_type = llvm_utils->get_type_from_ttype_t(m_arg, el_type, nullptr,
                                    ASR::storage_typeType::Default, is_array_type_local,
                                    is_malloc_array_type_local, is_list_local, m_dims_local,
                                    n_dims_local, a_kind_local, module.get());
        std::string type_code = ASRUtils::get_type_code(el_type);
        int32_t type_size = -1;
        if( ASR::is_a<ASR::String_t>(*el_type) ||
            LLVM::is_llvm_struct(el_type) ||
            ASR::is_a<ASR::Complex_t>(*el_type) ) {
            llvm::DataLayout data_layout(module->getDataLayout());
            type_size = data_layout.getTypeAllocSize(llvm_el_type);
        } else {
            type_size = ASRUtils::extract_kind_from_ttype_t(el_type);
        }
        llvm::Type* el_list_type = list_api->get_list_type(llvm_el_type, type_code, type_size);
        llvm::Value* el_list = llvm_utils->CreateAlloca(*builder, el_list_type, nullptr, key_or_value == 0 ?
                                                    "keys_list" : "values_list");
        list_api->list_init(type_code, el_list, module.get(), 0, 0);

        llvm_utils->set_dict_api(dict_type);
        llvm_utils->dict_api->get_elements_list(m_arg, pdict, el_list, dict_type->m_key_type,
                                                dict_type->m_value_type, module.get(), key_or_value);
        tmp = el_list;
    }

    void generate_SetAdd(ASR::expr_t* m_arg, ASR::expr_t* m_ele) {
        ASR::Set_t* set_type = ASR::down_cast<ASR::Set_t>(
                                    ASRUtils::expr_type(m_arg));
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* pset = tmp;

        ptr_loads = 2;
        this->visit_expr_wrapper(m_ele, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *el = tmp;
        llvm_utils->set_set_api(set_type);
        llvm_utils->set_api->write_item(m_arg, pset, el, module.get(), asr_el_type);
    }

    void generate_SetRemove(ASR::expr_t* m_arg, ASR::expr_t* m_ele) {
        ASR::Set_t* set_type = ASR::down_cast<ASR::Set_t>(
                                    ASRUtils::expr_type(m_arg));
        ASR::ttype_t* asr_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(m_arg));
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*m_arg);
        llvm::Value* pset = tmp;

        ptr_loads = 2;
        this->visit_expr_wrapper(m_ele, true);
        ptr_loads = ptr_loads_copy;
        llvm::Value *el = tmp;
        llvm_utils->set_set_api(set_type);
        llvm_utils->set_api->remove_item(pset, el, module.get(), asr_el_type);
    }

    void visit_IntrinsicElementalFunction(const ASR::IntrinsicElementalFunction_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        switch (static_cast<ASRUtils::IntrinsicElementalFunctions>(x.m_intrinsic_id)) {
            case ASRUtils::IntrinsicElementalFunctions::ListIndex: {
                ASR::expr_t* m_arg = x.m_args[0];
                ASR::expr_t* m_ele = x.m_args[1];
                ASR::expr_t* m_start = nullptr;
                ASR::expr_t* m_end = nullptr;
                switch (x.m_overload_id) {
                    case 0: {
                        break ;
                    }
                    case 1: {
                        m_start = x.m_args[2];
                        break ;
                    }
                    case 2: {
                        m_start = x.m_args[2];
                        m_end = x.m_args[3];
                        break ;
                    }
                    default: {
                        throw CodeGenError("list.index accepts at most four arguments",
                                            x.base.base.loc);
                    }
                }
                generate_ListIndex(m_arg, m_ele, m_start, m_end);
                break ;
            }
            case ASRUtils::IntrinsicElementalFunctions::ListReverse: {
                generate_ListReverse(x.m_args[0]);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::ListPop: {
                switch(x.m_overload_id) {
                    case 0:
                        generate_ListPop_0(x.m_args[0]);
                        break;
                    case 1:
                        generate_ListPop_1(x.m_args[0], x.m_args[1]);
                        break;
                }
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::ListReserve: {
                generate_ListReserve(x.m_args[0], x.m_args[1]);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::DictKeys: {
                generate_DictElems(x.m_args[0], 0);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::DictValues: {
                generate_DictElems(x.m_args[0], 1);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::SetAdd: {
                generate_SetAdd(x.m_args[0], x.m_args[1]);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::SetRemove: {
                generate_SetRemove(x.m_args[0], x.m_args[1]);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::Exp: {
                switch (x.m_overload_id) {
                    case 0: {
                        ASR::expr_t* m_arg = x.m_args[0];
                        generate_Exp(m_arg);
                        break ;
                    }
                    default: {
                        throw CodeGenError("exp() only accepts one argument",
                                            x.base.base.loc);
                    }
                }
                break ;
            }
            case ASRUtils::IntrinsicElementalFunctions::Exp2: {
                switch (x.m_overload_id) {
                    case 0: {
                        ASR::expr_t* m_arg = x.m_args[0];
                        generate_Exp2(m_arg);
                        break ;
                    }
                    default: {
                        throw CodeGenError("exp2() only accepts one argument",
                                            x.base.base.loc);
                    }
                }
                break ;
            }
            case ASRUtils::IntrinsicElementalFunctions::CommandArgumentCount: {
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::Expm1: {
                switch (x.m_overload_id) {
                    case 0: {
                        ASR::expr_t* m_arg = x.m_args[0];
                        generate_Expm1(m_arg);
                        break ;
                    }
                    default: {
                        throw CodeGenError("expm1() only accepts one argument",
                                            x.base.base.loc);
                    }
                }
                break ;
            }
            case ASRUtils::IntrinsicElementalFunctions::FlipSign: {
                Vec<ASR::call_arg_t> args;
                args.reserve(al, 2);
                ASR::call_arg_t arg0_, arg1_;
                arg0_.loc = x.m_args[0]->base.loc, arg0_.m_value = x.m_args[0];
                args.push_back(al, arg0_);
                arg1_.loc = x.m_args[1]->base.loc, arg1_.m_value = x.m_args[1];
                args.push_back(al, arg1_);
                generate_flip_sign(args.p);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::FMA: {
                Vec<ASR::call_arg_t> args;
                args.reserve(al, 3);
                ASR::call_arg_t arg0_, arg1_, arg2_;
                arg0_.loc = x.m_args[0]->base.loc, arg0_.m_value = x.m_args[0];
                args.push_back(al, arg0_);
                arg1_.loc = x.m_args[1]->base.loc, arg1_.m_value = x.m_args[1];
                args.push_back(al, arg1_);
                arg2_.loc = x.m_args[2]->base.loc, arg2_.m_value = x.m_args[2];
                args.push_back(al, arg2_);
                generate_fma(args.p);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::SignFromValue: {
                Vec<ASR::call_arg_t> args;
                args.reserve(al, 2);
                ASR::call_arg_t arg0_, arg1_;
                arg0_.loc = x.m_args[0]->base.loc, arg0_.m_value = x.m_args[0];
                args.push_back(al, arg0_);
                arg1_.loc = x.m_args[1]->base.loc, arg1_.m_value = x.m_args[1];
                args.push_back(al, arg1_);
                generate_sign_from_value(args.p);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::Abs: {
                generate_Abs(x.m_args[0]);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::Max: {
                generate_MinMax(x.m_args, x.n_args, true);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::Min: {
                generate_MinMax(x.m_args, x.n_args, false);
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::SameTypeAs: {
                if (x.m_value) {
                    this->visit_expr(*x.m_value);
                    break;
                }
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr(*x.m_args[0]);
                llvm::Value* arg0 = tmp;
                this->visit_expr(*x.m_args[1]);
                llvm::Value* arg1 = tmp;
                ptr_loads = ptr_loads_copy;

                ASR::symbol_t* struct_sym0 = ASRUtils::symbol_get_past_external(
                    ASRUtils::get_struct_sym_from_struct_expr(x.m_args[0]));
                ASR::symbol_t* struct_sym1 = ASRUtils::symbol_get_past_external(
                    ASRUtils::get_struct_sym_from_struct_expr(x.m_args[1]));
                llvm::Type* class_type0 = llvm_utils->getClassType(
                    ASR::down_cast<ASR::Struct_t>(struct_sym0), false);
                llvm::Type* class_type1 = llvm_utils->getClassType(
                    ASR::down_cast<ASR::Struct_t>(struct_sym1), false);

                // For allocatable/pointer class(*), the alloca holds a pointer
                // to the polymorphic struct. Load the pointer first.
                ASR::ttype_t* arg_type0 = ASRUtils::expr_type(x.m_args[0]);
                ASR::ttype_t* arg_type1 = ASRUtils::expr_type(x.m_args[1]);
                if (ASRUtils::is_allocatable(arg_type0) ||
                    ASR::is_a<ASR::Pointer_t>(*arg_type0)) {
                    arg0 = llvm_utils->CreateLoad2(class_type0->getPointerTo(), arg0);
                }
                if (ASRUtils::is_allocatable(arg_type1) ||
                    ASR::is_a<ASR::Pointer_t>(*arg_type1)) {
                    arg1 = llvm_utils->CreateLoad2(class_type1->getPointerTo(), arg1);
                }

                // Extract field 0 (type hash or vtable pointer) from both args
                llvm::Value* id0_ptr = llvm_utils->create_gep2(class_type0, arg0, 0);
                llvm::Value* id1_ptr = llvm_utils->create_gep2(class_type1, arg1, 0);
                // Load and compare
                llvm::Type* field0_type = llvm::cast<llvm::StructType>(class_type0)->getElementType(0);
                llvm::Value* id0 = llvm_utils->CreateLoad2(field0_type, id0_ptr);
                llvm::Value* id1 = llvm_utils->CreateLoad2(field0_type, id1_ptr);
                if (field0_type->isPointerTy()) {
                    // new_classes: compare vtable pointers
                    tmp = builder->CreateICmpEQ(
                        builder->CreatePtrToInt(id0, llvm::Type::getInt64Ty(context)),
                        builder->CreatePtrToInt(id1, llvm::Type::getInt64Ty(context)));
                } else {
                    // old classes: compare integer type hashes
                    tmp = builder->CreateICmpEQ(id0, id1);
                }
                break;
            }
            case ASRUtils::IntrinsicElementalFunctions::ExtendsTypeOf: {
                if (x.m_value) {
                    this->visit_expr(*x.m_value);
                    break;
                }
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr(*x.m_args[0]);
                llvm::Value* arg0 = tmp;
                this->visit_expr(*x.m_args[1]);
                llvm::Value* arg1 = tmp;
                ptr_loads = ptr_loads_copy;

                ASR::symbol_t* struct_sym0 = ASRUtils::symbol_get_past_external(
                    ASRUtils::get_struct_sym_from_struct_expr(x.m_args[0]));
                ASR::symbol_t* struct_sym1 = ASRUtils::symbol_get_past_external(
                    ASRUtils::get_struct_sym_from_struct_expr(x.m_args[1]));
                llvm::Type* class_type0 = llvm_utils->getClassType(
                    ASR::down_cast<ASR::Struct_t>(struct_sym0), false);
                llvm::Type* class_type1 = llvm_utils->getClassType(
                    ASR::down_cast<ASR::Struct_t>(struct_sym1), false);

                // For allocatable/pointer class(*), load the pointer first.
                ASR::ttype_t* arg_type0 = ASRUtils::expr_type(x.m_args[0]);
                ASR::ttype_t* arg_type1 = ASRUtils::expr_type(x.m_args[1]);
                if (ASRUtils::is_allocatable(arg_type0) ||
                    ASR::is_a<ASR::Pointer_t>(*arg_type0)) {
                    arg0 = llvm_utils->CreateLoad2(class_type0->getPointerTo(), arg0);
                }
                if (ASRUtils::is_allocatable(arg_type1) ||
                    ASR::is_a<ASR::Pointer_t>(*arg_type1)) {
                    arg1 = llvm_utils->CreateLoad2(class_type1->getPointerTo(), arg1);
                }

                // Extract field 0 (type hash or vtable pointer)
                llvm::Value* id0_ptr = llvm_utils->create_gep2(class_type0, arg0, 0);
                llvm::Value* id1_ptr = llvm_utils->create_gep2(class_type1, arg1, 0);
                llvm::Type* field0_type = llvm::cast<llvm::StructType>(class_type0)->getElementType(0);
                llvm::Value* id0 = llvm_utils->CreateLoad2(field0_type, id0_ptr);
                llvm::Value* id1 = llvm_utils->CreateLoad2(field0_type, id1_ptr);

                if (field0_type->isPointerTy()) {
                    // new_classes: walk parent chain via TypeInfo
                    // TypeInfo layout: { i8* name, i8* size, i8* parent_typeinfo }
                    // vptr[-1] = TypeInfo pointer
                    llvm::Type* i8_ptr = llvm::Type::getInt8Ty(context)->getPointerTo();
                    llvm::Type* i64_type = llvm::Type::getInt64Ty(context);
                    llvm::StructType* type_info_type = llvm::StructType::get(
                        context, {i8_ptr, i8_ptr, i8_ptr}, false);

                    // Get TypeInfo for MOLD (arg1)
                    llvm::Value* vptr1_i8 = builder->CreateBitCast(id1, i8_ptr->getPointerTo());
                    llvm::Value* ti1_ptr_ptr = llvm_utils->create_ptr_gep2(
                        i8_ptr, vptr1_i8, llvm::ConstantInt::get(i64_type, -1, true));
                    llvm::Value* ti_mold = llvm_utils->CreateLoad2(i8_ptr, ti1_ptr_ptr);

                    // Get TypeInfo for A (arg0)
                    llvm::Value* vptr0_i8 = builder->CreateBitCast(id0, i8_ptr->getPointerTo());
                    llvm::Value* ti0_ptr_ptr = llvm_utils->create_ptr_gep2(
                        i8_ptr, vptr0_i8, llvm::ConstantInt::get(i64_type, -1, true));
                    llvm::Value* ti_a_init = llvm_utils->CreateLoad2(i8_ptr, ti0_ptr_ptr);

                    // Create loop to walk A's parent chain
                    llvm::Function* fn = builder->GetInsertBlock()->getParent();
                    llvm::BasicBlock* loop_bb = llvm::BasicBlock::Create(context, "eto.loop", fn);
                    llvm::BasicBlock* found_bb = llvm::BasicBlock::Create(context, "eto.found", fn);
                    llvm::BasicBlock* not_found_bb = llvm::BasicBlock::Create(context, "eto.notfound", fn);
                    llvm::BasicBlock* merge_bb = llvm::BasicBlock::Create(context, "eto.merge", fn);

                    builder->CreateBr(loop_bb);
                    builder->SetInsertPoint(loop_bb);
                    llvm::PHINode* ti_current = builder->CreatePHI(i8_ptr, 2, "eto.ti");
                    ti_current->addIncoming(ti_a_init, loop_bb->getSinglePredecessor());

                    // Compare current TypeInfo with MOLD's TypeInfo
                    llvm::Value* eq = builder->CreateICmpEQ(
                        builder->CreatePtrToInt(ti_current, i64_type),
                        builder->CreatePtrToInt(ti_mold, i64_type));
                    builder->CreateCondBr(eq, found_bb, not_found_bb);

                    // Not equal: check parent
                    builder->SetInsertPoint(not_found_bb);
                    llvm::Value* ti_cast = builder->CreateBitCast(
                        ti_current, type_info_type->getPointerTo());
                    llvm::Value* parent_ptr = llvm_utils->create_gep2(type_info_type, ti_cast, 2);
                    llvm::Value* parent_ti = llvm_utils->CreateLoad2(i8_ptr, parent_ptr);
                    llvm::Value* parent_null = builder->CreateICmpEQ(
                        parent_ti, llvm::ConstantPointerNull::get(
                            llvm::cast<llvm::PointerType>(i8_ptr)));
                    // If parent is null, no more ancestors -> false
                    // Otherwise, continue loop with parent
                    builder->CreateCondBr(parent_null, merge_bb, loop_bb);
                    ti_current->addIncoming(parent_ti, not_found_bb);

                    // Found: result = true
                    builder->SetInsertPoint(found_bb);
                    builder->CreateBr(merge_bb);

                    // Merge
                    builder->SetInsertPoint(merge_bb);
                    llvm::PHINode* result = builder->CreatePHI(
                        llvm::Type::getInt1Ty(context), 2, "eto.result");
                    result->addIncoming(llvm::ConstantInt::getTrue(context), found_bb);
                    result->addIncoming(llvm::ConstantInt::getFalse(context), not_found_bb);
                    tmp = result;
                } else {
                    // old classes: compare integer type hashes
                    tmp = builder->CreateICmpEQ(id0, id1);
                }
                break;
            }
            default: {
                throw CodeGenError("Either the '" + ASRUtils::IntrinsicElementalFunctionRegistry::
                        get_intrinsic_function_name(x.m_intrinsic_id) +
                        "' intrinsic is not implemented by LLVM backend or "
                        "the compile-time value is not available", x.base.base.loc);
            }
        }
    }

    void visit_IntrinsicImpureFunction(const ASR::IntrinsicImpureFunction_t &x) {
        switch (static_cast<ASRUtils::IntrinsicImpureFunctions>(x.m_impure_intrinsic_id)) {
            case ASRUtils::IntrinsicImpureFunctions::IsIostatEnd : {
                this->visit_expr(*x.m_args[0]);
                tmp = builder->CreateICmpEQ(tmp, llvm::ConstantInt::get(context, llvm::APInt(32, -1, true)));
                break ;
            } case ASRUtils::IntrinsicImpureFunctions::IsIostatEor : {
                this->visit_expr(*x.m_args[0]);
                tmp = builder->CreateICmpEQ(tmp, llvm::ConstantInt::get(context, llvm::APInt(32, -2, true)));
                break ;
            } case ASRUtils::IntrinsicImpureFunctions::Allocated : {
                handle_allocated(x.m_args[0]);
                break ;
            } default: {
                throw CodeGenError( ASRUtils::get_impure_intrinsic_name(x.m_impure_intrinsic_id) +
                        " is not implemented by LLVM backend.", x.base.base.loc);
            }
        }
    }

    void visit_TypeInquiry(const ASR::TypeInquiry_t &x) {
        this->visit_expr(*x.m_value);
    }

    void visit_ListClear(const ASR::ListClear_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        llvm::Value* plist = tmp;
        ptr_loads = ptr_loads_copy;
        llvm::Type* list_type = llvm_utils->get_type_from_ttype_t_util(x.m_a, ASRUtils::expr_type(x.m_a), module.get());
        list_api->list_clear_using_type(list_type, plist);
    }

    void visit_ListRepeat(const ASR::ListRepeat_t& x) {
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left = tmp;
        ptr_loads = 2;      // right is int always
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right = tmp;

        ASR::List_t* list_type = ASR::down_cast<ASR::List_t>(x.m_type);
        bool is_array_type_local = false, is_malloc_array_type_local = false;
        bool is_list_local = false;
        ASR::dimension_t* m_dims_local = nullptr;
        int n_dims_local = -1, a_kind_local = -1;
        llvm::Type* llvm_el_type = llvm_utils->get_type_from_ttype_t(const_cast<ASR::expr_t*>(&x.base), list_type->m_type,
            nullptr, ASR::storage_typeType::Default, is_array_type_local,
            is_malloc_array_type_local, is_list_local, m_dims_local,
            n_dims_local, a_kind_local, module.get());
        std::string type_code = ASRUtils::get_type_code(list_type->m_type);
        int32_t type_size = -1;
        if( ASR::is_a<ASR::String_t>(*list_type->m_type) ||
            LLVM::is_llvm_struct(list_type->m_type) ||
            ASR::is_a<ASR::Complex_t>(*list_type->m_type) ) {
            llvm::DataLayout data_layout(module->getDataLayout());
            type_size = data_layout.getTypeAllocSize(llvm_el_type);
        } else {
            type_size = ASRUtils::extract_kind_from_ttype_t(list_type->m_type);
        }
        llvm::Type* repeat_list_type = list_api->get_list_type(llvm_el_type, type_code, type_size);
        llvm::Value* repeat_list = llvm_utils->CreateAlloca(*builder, repeat_list_type, nullptr, "repeat_list");
        llvm::Value* left_len = list_api->len_using_type(repeat_list_type, left);
        llvm::Value* capacity = builder->CreateMul(left_len, right);
        list_api->list_init(type_code, repeat_list, module.get(), capacity, capacity);
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 1;
        list_api->list_repeat_copy(list_type, repeat_list, left, right, left_len, module.get());
        ptr_loads = ptr_loads_copy;
        tmp = repeat_list;
    }

    void visit_TupleCompare(const ASR::TupleCompare_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_left);
        llvm::Value* left = tmp;
        this->visit_expr(*x.m_right);
        llvm::Value* right = tmp;
        ptr_loads = ptr_loads_copy;
        if(x.m_op == ASR::cmpopType::Eq || x.m_op == ASR::cmpopType::NotEq) {
            tmp = llvm_utils->is_equal_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left));
            if (x.m_op == ASR::cmpopType::NotEq) {
                tmp = builder->CreateNot(tmp);
            }
        }
        else if(x.m_op == ASR::cmpopType::Lt) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 0);
        }
        else if(x.m_op == ASR::cmpopType::LtE) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 1);
        }
        else if(x.m_op == ASR::cmpopType::Gt) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 2);
        }
        else if(x.m_op == ASR::cmpopType::GtE) {
            tmp = llvm_utils->is_ineq_by_value(left, right, module.get(),
                    ASRUtils::expr_type(x.m_left), 3);
        }
    }

    void visit_TupleLen(const ASR::TupleLen_t& x) {
        LCOMPILERS_ASSERT(x.m_value);
        this->visit_expr(*x.m_value);
    }

    void visit_TupleItem(const ASR::TupleItem_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_a);
        ptr_loads = ptr_loads_copy;
        llvm::Value* ptuple = tmp;

        this->visit_expr_wrapper(x.m_pos, true);
        llvm::Value *pos = tmp;

        llvm::Type* el_type = llvm_utils->get_type_from_ttype_t_util(x.m_a, x.m_type, llvm_utils->module);
        tmp = tuple_api->read_item_using_pos_value(el_type, ptuple, ASR::down_cast<ASR::Tuple_t>(ASRUtils::expr_type(x.m_a)), pos, 
                                                            LLVM::is_llvm_struct(x.m_type) || ASRUtils::is_allocatable_descriptor_string(x.m_type));
    }

    void visit_TupleConcat(const ASR::TupleConcat_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_left);
        llvm::Value* left = tmp;
        this->visit_expr(*x.m_right);
        llvm::Value* right = tmp;
        ptr_loads = ptr_loads_copy;

        ASR::Tuple_t* tuple_type_left = ASR::down_cast<ASR::Tuple_t>(ASRUtils::expr_type(x.m_left));
        std::string type_code_left = ASRUtils::get_type_code(tuple_type_left->m_type,
                                                        tuple_type_left->n_type);
        ASR::Tuple_t* tuple_type_right = ASR::down_cast<ASR::Tuple_t>(ASRUtils::expr_type(x.m_right));
        std::string type_code_right = ASRUtils::get_type_code(tuple_type_right->m_type,
                                                        tuple_type_right->n_type);
        Vec<ASR::ttype_t*> v_type;
        v_type.reserve(al, tuple_type_left->n_type + tuple_type_right->n_type);
        std::string type_code = type_code_left + type_code_right;
        std::vector<llvm::Type*> llvm_el_types;
        ASR::storage_typeType m_storage = ASR::storage_typeType::Default;
        bool is_array_type = false, is_malloc_array_type = false;
        bool is_list = false;
        ASR::dimension_t* m_dims = nullptr;
        int n_dims = 0, a_kind = -1;
        for( size_t i = 0; i < tuple_type_left->n_type; i++ ) {
            llvm_el_types.push_back(llvm_utils->get_type_from_ttype_t(x.m_left, tuple_type_left->m_type[i],
                nullptr, m_storage, is_array_type, is_malloc_array_type,
                is_list, m_dims, n_dims, a_kind, module.get()));
            v_type.push_back(al, tuple_type_left->m_type[i]);
        }
        is_array_type = false; is_malloc_array_type = false;
        is_list = false;
        m_dims = nullptr;
        n_dims = 0; a_kind = -1;
        for( size_t i = 0; i < tuple_type_right->n_type; i++ ) {
            llvm_el_types.push_back(llvm_utils->get_type_from_ttype_t(x.m_right, tuple_type_right->m_type[i],
                nullptr, m_storage, is_array_type, is_malloc_array_type,
                is_list, m_dims, n_dims, a_kind, module.get()));
            v_type.push_back(al, tuple_type_right->m_type[i]);
        }
        llvm::Type* concat_tuple_type = tuple_api->get_tuple_type(type_code, llvm_el_types);
        llvm::Value* concat_tuple = llvm_utils->CreateAlloca(*builder, concat_tuple_type, nullptr, "concat_tuple");
        ASR::Tuple_t* tuple_type = (ASR::Tuple_t*)(ASR::make_Tuple_t(
                                    al, x.base.base.loc, v_type.p, v_type.n));
        tuple_api->concat(x.m_left, left, right, tuple_type_left, tuple_type_right, concat_tuple,
                          tuple_type, module.get());
        tmp = concat_tuple;
    }

    void visit_ArrayItem(const ASR::ArrayItem_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        ASR::ttype_t* x_mv_type = ASRUtils::expr_type(x.m_v);
        llvm::Value* array = nullptr;
        ASR::Variable_t *v = nullptr;
        bool is_intent_in = false;
        std::string array_name;
        if( ASR::is_a<ASR::Var_t>(*x.m_v) ) {
            v = ASRUtils::EXPR2VAR(x.m_v);
            array_name = v->m_name;
            uint32_t v_h = get_hash((ASR::asr_t*)v);
            if (v->m_intent == ASRUtils::intent_in) {
                is_intent_in = true;
            }
            array = llvm_symtab[v_h];
            if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(v->m_type))) {
                ASR::Struct_t* der_symbol = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(v->m_type_declaration));
                current_der_type_name = std::string(der_symbol->m_name);
            }
        } else {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_v);
            ptr_loads = ptr_loads_copy;
            array = tmp;
            if (!array->getType()->isPointerTy()) {
                llvm::Value* val = array;
                llvm::AllocaInst* alloc = llvm_utils->CreateAlloca(*builder, val->getType());
                builder->CreateStore(val, alloc);
                array = alloc;
            }
        }

        ASR::dimension_t* m_dims;
        int n_dims = ASRUtils::extract_dimensions_from_ttype(x_mv_type, m_dims);
        {
            // Array indexing:
            std::vector<llvm::Value*> indices;
            for( size_t r = 0; r < x.n_args; r++ ) {
                ASR::array_index_t curr_idx = x.m_args[r];
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 2;
                this->visit_expr_wrapper(curr_idx.m_right, true);
                ptr_loads = ptr_loads_copy;
                indices.push_back(tmp);
            }

            ASR::ttype_t* x_mv_type_ = ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(x_mv_type));
            LCOMPILERS_ASSERT(ASR::is_a<ASR::Array_t>(*x_mv_type_));
            ASR::Array_t* array_t = ASR::down_cast<ASR::Array_t>(x_mv_type_);
            bool is_bindc_array = ASRUtils::expr_abi(x.m_v) == ASR::abiType::BindC;
            if ( LLVM::is_llvm_pointer(*x_mv_type) ||
               ((is_bindc_array && !ASRUtils::is_fixed_size_array(m_dims, n_dims)) &&
                ASR::is_a<ASR::StructInstanceMember_t>(*x.m_v)) ) {
                llvm::Type *array_type = llvm_utils->get_type_from_ttype_t_util(x.m_v, x_mv_type_, module.get());
                array = llvm_utils->CreateLoad2(array_type->getPointerTo(), array);
            }
            if (compiler_options.po.bounds_checking && ASRUtils::is_allocatable(x_mv_type)) {
                llvm::Value* is_allocated = arr_descr->get_is_allocated_flag(array, x.m_v);
                llvm::Value* cond = builder->CreateNot(is_allocated);
                llvm_utils->generate_runtime_error(cond,
                    "Array '%s' is indexed but not allocated.",
                    {LLVMUtils::RuntimeLabel("", {x.m_v->base.loc})},
                    infile,
                    location_manager,
                    LCompilers::create_global_string_ptr(context, *module, *builder, array_name));
            }

            Vec<llvm::Value*> llvm_diminfo;
            llvm_diminfo.reserve(al, 2 * x.n_args + 1);
            bool check_for_bounds = compiler_options.po.bounds_checking;
            if( array_t->m_physical_type == ASR::array_physical_typeType::PointerArray ||
                array_t->m_physical_type == ASR::array_physical_typeType::UnboundedPointerArray ||
                array_t->m_physical_type == ASR::array_physical_typeType::FixedSizeArray ||
                array_t->m_physical_type == ASR::array_physical_typeType::SIMDArray ||
                (array_t->m_physical_type == ASR::array_physical_typeType::StringArraySinglePointer && ASRUtils::is_fixed_size_array(x_mv_type)) ) {
                int ptr_loads_copy = ptr_loads;
                for( size_t idim = 0; idim < x.n_args; idim++ ) {
                    llvm::Value* dim_start = nullptr;
                    if (m_dims[idim].m_start) {
                        ptr_loads = 2 - !LLVM::is_llvm_pointer(*ASRUtils::expr_type(m_dims[idim].m_start));
                        this->visit_expr_wrapper(m_dims[idim].m_start, true);
                        dim_start = tmp;
                    } else {
                        llvm::Type* idx_type = arr_descr->get_index_type();
                        unsigned idx_bits = idx_type->getIntegerBitWidth();
                        dim_start = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1));
                    }
                    llvm::Value* dim_size = nullptr;
                    if (m_dims[idim].m_length) {
                        ptr_loads = 2 - !LLVM::is_llvm_pointer(*ASRUtils::expr_type(m_dims[idim].m_length));
                        if (is_intent_in) {
                            this->visit_expr_wrapper(m_dims[idim].m_length, true);
                        } else {
                            load_array_size_deep_copy(m_dims[idim].m_length);
                        }
                        dim_size = tmp;
                    } else {
                        llvm::Type* idx_type = arr_descr->get_index_type();
                        unsigned idx_bits = idx_type->getIntegerBitWidth();
                        dim_size = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 0));
                        check_for_bounds = false;
                    }
                    llvm_diminfo.push_back(al, dim_start);
                    llvm_diminfo.push_back(al, dim_size);
                }
                ptr_loads = ptr_loads_copy;
            } else if( array_t->m_physical_type == ASR::array_physical_typeType::UnboundedPointerArray ) {
                int ptr_loads_copy = ptr_loads;
                for( size_t idim = 0; idim < x.n_args; idim++ ) {
                    llvm::Value* dim_start = nullptr;
                    if (m_dims[idim].m_start) {
                        ptr_loads = 2 - !LLVM::is_llvm_pointer(*ASRUtils::expr_type(m_dims[idim].m_start));
                        this->visit_expr_wrapper(m_dims[idim].m_start, true);
                        dim_start = tmp;
                    } else {
                        llvm::Type* idx_type = arr_descr->get_index_type();
                        unsigned idx_bits = idx_type->getIntegerBitWidth();
                        dim_start = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1));
                    }
                    llvm::Value* dim_size = nullptr;
                    if (m_dims[idim].m_length) {
                        ptr_loads = 2 - !LLVM::is_llvm_pointer(*ASRUtils::expr_type(m_dims[idim].m_length));
                        if (is_intent_in) {
                            this->visit_expr_wrapper(m_dims[idim].m_length, true);
                        } else {
                            load_array_size_deep_copy(m_dims[idim].m_length);
                        }
                        dim_size = tmp;
                    } else {
                        // Last dimension of assumed-size array has no length
                        llvm::Type* idx_type = arr_descr->get_index_type();
                        unsigned idx_bits = idx_type->getIntegerBitWidth();
                        dim_size = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 0));
                    }
                    llvm_diminfo.push_back(al, dim_start);
                    llvm_diminfo.push_back(al, dim_size);
                }
                ptr_loads = ptr_loads_copy;
            }
            LCOMPILERS_ASSERT(ASRUtils::extract_n_dims_from_ttype(x_mv_type) > 0);
            bool is_polymorphic = false;
            ASR::symbol_t* selector_type_decl = ASRUtils::get_struct_sym_from_struct_expr(x.m_v);
            if (array_t->m_physical_type == ASR::array_physical_typeType::UnboundedPointerArray) {
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                llvm::Type* type = llvm_utils->get_el_type(x.m_v, ASRUtils::extract_type(x_mv_type), module.get());
                tmp = arr_descr->get_single_element(type, array, indices, x.n_args, ASRUtils::expr_type(x.m_v), x.m_v, location_manager,
                                                    selector_type_decl,
                                                    true,
                                                    false,
                                                    llvm_diminfo.p, is_polymorphic, nullptr,
                                                    false, false, array_name, infile);
            } else {
                llvm::Type* type;
                bool is_fixed_size = (array_t->m_physical_type == ASR::array_physical_typeType::FixedSizeArray ||
                    array_t->m_physical_type == ASR::array_physical_typeType::SIMDArray ||
                    (
                        array_t->m_physical_type == ASR::array_physical_typeType::StringArraySinglePointer &&
                        ASRUtils::is_fixed_size_array(x_mv_type)
                    )
                );
                if (is_fixed_size) {
                    type = llvm_utils->get_type_from_ttype_t_util(x.m_v, x_mv_type, module.get());
                } else {
                    // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                    type = llvm_utils->get_el_type(x.m_v, ASRUtils::extract_type(x_mv_type), module.get());
                }
                tmp = arr_descr->get_single_element(type, array, indices, x.n_args, ASRUtils::expr_type(x.m_v), x.m_v, location_manager,
                                                    selector_type_decl,
                                                    array_t->m_physical_type == ASR::array_physical_typeType::PointerArray,
                                                    is_fixed_size, llvm_diminfo.p, is_polymorphic,
                                                    nullptr, false,
                                                    check_for_bounds, array_name, infile);
            }
        }
        if( ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(x.m_type)) && !ASRUtils::is_class_type(x.m_type) ) {
            current_der_type_name = ASRUtils::symbol_name(
                ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_v))));
        }
    }

    void visit_ArraySection(const ASR::ArraySection_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_v);
        ptr_loads = ptr_loads_copy;
        llvm::Value* array = tmp;
        ASR::dimension_t* m_dims;
        [[maybe_unused]] int n_dims = ASRUtils::extract_dimensions_from_ttype(
                        ASRUtils::expr_type(x.m_v), m_dims);

        bool is_string_section = ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(x.m_v)) && n_dims == 0;
        if (is_string_section) {
            // String indexing:
            if (x.n_args == 1) {
                throw CodeGenError("Only string(a:b) supported for now.", x.base.base.loc);
            }

            LCOMPILERS_ASSERT(x.m_args[0].m_left)
            LCOMPILERS_ASSERT(x.m_args[0].m_right)
            //throw CodeGenError("Only string(a:b) for a,b variables for now.", x.base.base.loc);
            // Use the "right" index for now
            this->visit_expr_wrapper(x.m_args[0].m_right, true);
            llvm::Value *idx2 = tmp;
            this->visit_expr_wrapper(x.m_args[0].m_left, true);
            llvm::Value *idx1 = tmp;
            // idx = builder->CreateSub(idx, llvm::ConstantInt::get(context, llvm::APInt(32, 1)));
            //std::vector<llvm::Value*> idx_vec = {llvm::ConstantInt::get(context, llvm::APInt(32, 0)), idx};
            // std::vector<llvm::Value*> idx_vec = {idx};
            llvm::Value *str_data, *str_len;
            std::tie(str_data, str_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(x.m_v), array);
            // llvm::Value *p = CreateGEP(str, idx_vec);
            // TODO: Currently the string starts at the right location, but goes to the end of the original string.
            // We have to allocate a new string, copy it and add null termination.
            llvm::Value *step = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
            llvm::Value *present = llvm::ConstantInt::get(context, llvm::APInt(1, 1));
            llvm::Value *p = lfortran_str_slice(str_data, str_len, idx1, idx2, step, present, present);
            tmp = llvm_utils->CreateAlloca(*builder, character_type);
            builder->CreateStore(p, tmp);
        } else {
            tmp = array;
        }
    }

    void visit_ArrayReshape(const ASR::ArrayReshape_t& x) {
        if (x.m_value) {
            this->visit_expr(*x.m_value);
            return;
        }
        this->visit_expr(*x.m_array);
        llvm::Value* array = tmp;
        this->visit_expr(*x.m_shape);
        llvm::Value* shape = tmp;
        ASR::ttype_t* x_m_array_type = ASRUtils::expr_type(x.m_array);
        ASR::array_physical_typeType array_physical_type = ASRUtils::extract_physical_type(x_m_array_type);
        switch( array_physical_type ) {
            case ASR::array_physical_typeType::DescriptorArray: {
                ASR::ttype_t* asr_data_type = ASRUtils::duplicate_type_without_dims(al,
                    ASRUtils::get_contained_type(x_m_array_type), x_m_array_type->base.loc);
                ASR::ttype_t* asr_shape_type = ASRUtils::get_contained_type(ASRUtils::expr_type(x.m_shape));
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                llvm::Type* llvm_data_type = llvm_utils->get_el_type(x.m_array, asr_data_type, module.get());
                llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(x.m_array,
                    ASRUtils::type_get_past_allocatable_pointer(x_m_array_type), module.get());
                llvm::Type* shape_type = llvm_utils->get_type_from_ttype_t_util(x.m_shape,
                    ASRUtils::type_get_past_allocatable_pointer(asr_shape_type), module.get());
                tmp = arr_descr->reshape(array_type, array, llvm_data_type, shape_type, shape, asr_shape_type, module.get());
                break;
            }
            case ASR::array_physical_typeType::FixedSizeArray: {
                llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(x.m_array, x_m_array_type, module.get());
                llvm::Value *target = llvm_utils->CreateAlloca(
                    target_type, nullptr, "fixed_size_reshaped_array");
                llvm::Value* target_ = llvm_utils->create_gep2(target_type, target, 0);
                ASR::dimension_t* asr_dims = nullptr;
                size_t asr_n_dims = ASRUtils::extract_dimensions_from_ttype(x_m_array_type, asr_dims);
                int64_t size = ASRUtils::get_fixed_size_of_array(asr_dims, asr_n_dims);
                ASR::ttype_t* element_type = ASRUtils::type_get_past_array(
                    ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(x_m_array_type)));
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                llvm::Type* llvm_data_type = llvm_utils->get_el_type(x.m_array, element_type, module.get());
                llvm::DataLayout data_layout(module->getDataLayout());
                uint64_t data_size = data_layout.getTypeAllocSize(llvm_data_type);
                llvm::Value* llvm_size = llvm::ConstantInt::get(context, llvm::APInt(32, size));
                llvm_size = builder->CreateMul(llvm_size,
                    llvm::ConstantInt::get(context, llvm::APInt(32, data_size)));
                builder->CreateMemCpy(target_, llvm::MaybeAlign(), array, llvm::MaybeAlign(), llvm_size);
                tmp = target;
                break;
            }
            case ASR::PointerArray: {
                llvm::Type* type_of_array = llvm_utils->get_type_from_ttype_t_util(
                                            x.m_array,
                                            ASRUtils::extract_type(x_m_array_type), module.get());
                int64_t arr_size;
                if(ASRUtils::is_fixed_size_array(x_m_array_type)){
                    arr_size = ASRUtils::get_fixed_size_of_array(x_m_array_type);
                } else {
                    throw LCompilersException("Not Implemented (PointerArray + Not-compile-time size)");
                }

                if(ASRUtils::is_character(*x_m_array_type)){
                    tmp = create_and_setup_string_for_array(x_m_array_type,
                        llvm::ConstantInt::get(context, llvm::APInt(64, arr_size)),
                        false, "StringArrayReshape");
                    builder->CreateMemCpy(
                        llvm_utils->get_stringArray_data(x_m_array_type, tmp), llvm::MaybeAlign(),
                        llvm_utils->get_stringArray_data(ASRUtils::expr_type(x.m_array), array), llvm::MaybeAlign(),
                        llvm_utils->get_stringArray_whole_size(ASRUtils::expr_type(x.m_array))
                    );
                } else {
                    llvm::Value* type_alloca = builder->CreateAlloca(type_of_array,
                                                llvm::ConstantInt::get(context, llvm::APInt(32, arr_size)));
                    llvm::DataLayout data_layout(module->getDataLayout());
                    uint64_t data_size = data_layout.getTypeAllocSize(type_of_array);
                    builder->CreateMemCpy(
                        type_alloca, llvm::MaybeAlign(),
                        array, llvm::MaybeAlign(),
                        llvm::ConstantInt::get(context, llvm::APInt(32, arr_size*data_size)));
                }
                break;
            }
            default: {
                LCOMPILERS_ASSERT(false);
            }
        }
    }

    void visit_ArrayIsContiguous(const ASR::ArrayIsContiguous_t& x) {
        ASR::ttype_t* x_m_array_type = ASRUtils::expr_type(x.m_array);
        llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(x.m_array,
                ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(x_m_array_type)), module.get());
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 2 - // Sync: instead of 2 - , should this be ptr_loads_copy -
                    (LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_array)));
        visit_expr_wrapper(x.m_array);
        ptr_loads = ptr_loads_copy;
        if (is_a<ASR::StructInstanceMember_t>(*x.m_array)) {
            tmp = llvm_utils->CreateLoad2(array_type->getPointerTo(), tmp);
        }
        llvm::Value* llvm_arg1 = tmp;
        ASR::array_physical_typeType physical_type = ASRUtils::extract_physical_type(x_m_array_type);
        switch( physical_type ) {
            case ASR::array_physical_typeType::DescriptorArray: {
                llvm::Value* dim_des_val = arr_descr->get_pointer_to_dimension_descriptor_array(array_type, llvm_arg1);
                llvm::Value* is_contiguous = llvm::ConstantInt::get(context, llvm::APInt(1, 1));
                ASR::dimension_t* m_dims = nullptr;
                int n_dims = ASRUtils::extract_dimensions_from_ttype(x_m_array_type, m_dims);
                unsigned index_bit_width = arr_descr->get_index_type()->getIntegerBitWidth();
                llvm::Value* expected_stride = llvm::ConstantInt::get(context, llvm::APInt(index_bit_width, 1));
                for (int i = 0; i < n_dims; i++) {
                    llvm::Value* dim_index = llvm::ConstantInt::get(context, llvm::APInt(32, i));
                    llvm::Value* dim_desc = arr_descr->get_pointer_to_dimension_descriptor(dim_des_val, dim_index);
                    llvm::Value* dim_start = arr_descr->get_lower_bound(dim_desc);
                    llvm::Value* stride = arr_descr->get_stride(dim_desc);
                    llvm::Value* is_dim_contiguous = builder->CreateICmpEQ(stride, expected_stride);
                    is_contiguous = builder->CreateAnd(is_contiguous, is_dim_contiguous);
                    llvm::Value* dim_size = arr_descr->get_upper_bound(dim_desc);
                    expected_stride = builder->CreateMul(expected_stride, builder->CreateAdd(builder->CreateSub(dim_size, dim_start), llvm::ConstantInt::get(context, llvm::APInt(index_bit_width, 1))));
                }
                // Unallocated array is contiguous
                llvm::Value* is_allocated = arr_descr->get_is_allocated_flag(llvm_arg1, x.m_array);
                tmp = builder->CreateOr(is_contiguous, builder->CreateNot(is_allocated));
                break;
            }
            case ASR::array_physical_typeType::FixedSizeArray:
            case ASR::array_physical_typeType::SIMDArray:
                tmp = llvm::ConstantInt::get(context, llvm::APInt(1, 1));
                break;
            case ASR::array_physical_typeType::PointerArray:
            case ASR::array_physical_typeType::StringArraySinglePointer:
                tmp = llvm::ConstantInt::get(context, llvm::APInt(1, 0));
                break;
            default:
                LCOMPILERS_ASSERT(false);
        }
    }

    void lookup_EnumValue(const ASR::EnumValue_t& x) {
        ASR::EnumType_t* enum_type = ASR::down_cast<ASR::EnumType_t>(x.m_enum_type);
        ASR::Enum_t* enum_symbol = ASR::down_cast<ASR::Enum_t>(enum_type->m_enum_type);
        uint32_t h = get_hash((ASR::asr_t*) enum_symbol);
        llvm::Value* array = llvm_symtab[h];
        llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(x.m_enum_type, enum_type->m_enum_type, module.get());
        tmp = llvm_utils->create_gep2(type, array, tmp);
        // After the first GEP, tmp points to an enum value struct
        // Get the element type of the array (which is the enum value struct type)
        llvm::ArrayType* array_type = llvm::dyn_cast<llvm::ArrayType>(type);
        llvm::Type* enum_value_struct_type = array_type->getElementType();
        llvm::Type* value_field_type = enum_value_struct_type->getStructElementType(1);
        tmp = llvm_utils->CreateLoad2(value_field_type, llvm_utils->create_gep2(enum_value_struct_type, tmp, 1));
    }

    void visit_EnumValue(const ASR::EnumValue_t& x) {
        if( x.m_value ) {
            if( ASR::is_a<ASR::Integer_t>(*x.m_type) ) {
                this->visit_expr(*x.m_value);
            } else if( ASR::is_a<ASR::EnumStaticMember_t>(*x.m_v) ) {
                ASR::EnumStaticMember_t* x_enum_member = ASR::down_cast<ASR::EnumStaticMember_t>(x.m_v);
                ASR::Variable_t* x_mv = ASR::down_cast<ASR::Variable_t>(x_enum_member->m_m);
                ASR::EnumType_t* enum_t = ASR::down_cast<ASR::EnumType_t>(x.m_enum_type);
                ASR::Enum_t* enum_type = ASR::down_cast<ASR::Enum_t>(enum_t->m_enum_type);
                for( size_t i = 0; i < enum_type->n_members; i++ ) {
                    if( std::string(enum_type->m_members[i]) == std::string(x_mv->m_name) ) {
                        tmp = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, i));
                        break ;
                    }
                }
                if( lookup_enum_value_for_nonints ) {
                    lookup_EnumValue(x);
                }
            }
            return ;
        }

        visit_expr(*x.m_v);
        if( ASR::is_a<ASR::StructInstanceMember_t>(*x.m_v) ) {
            llvm::Type* member_type = llvm_utils->get_type_from_ttype_t_util(x.m_v, x.m_type, module.get());
            tmp = llvm_utils->CreateLoad2(member_type, tmp);
        }
        if( !ASR::is_a<ASR::Integer_t>(*x.m_type) && lookup_enum_value_for_nonints ) {
            lookup_EnumValue(x);
        }
    }

    void visit_EnumName(const ASR::EnumName_t& x) {
        if( x.m_value ) {
            this->visit_expr(*x.m_value);
            return ;
        }

        visit_expr(*x.m_v);
        if( ASR::is_a<ASR::StructInstanceMember_t>(*x.m_v) ) {
            llvm::Type* member_type = llvm_utils->get_type_from_ttype_t_util(x.m_v, x.m_enum_type, module.get());
            tmp = llvm_utils->CreateLoad2(member_type, tmp);
        }
        ASR::EnumType_t* enum_t = ASR::down_cast<ASR::EnumType_t>(x.m_enum_type);
        ASR::Enum_t* enum_type = ASR::down_cast<ASR::Enum_t>(enum_t->m_enum_type);
        uint32_t h = get_hash((ASR::asr_t*) enum_type);
        llvm::Value* array = llvm_symtab[h];
        if( ASR::is_a<ASR::Integer_t>(*enum_type->m_type) ) {
            int64_t min_value = INT64_MAX;

            for( auto itr: enum_type->m_symtab->get_scope() ) {
                ASR::Variable_t* itr_var = ASR::down_cast<ASR::Variable_t>(itr.second);
                ASR::expr_t* value = ASRUtils::expr_value(itr_var->m_symbolic_value);
                int64_t value_int64 = -1;
                ASRUtils::extract_value(value, value_int64);
                min_value = std::min(value_int64, min_value);
            }
            tmp = builder->CreateSub(tmp, llvm::ConstantInt::get(tmp->getType(),
                        llvm::APInt(32, min_value, true)));
            llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(nullptr, enum_t->m_enum_type, module.get());
            tmp = llvm_utils->create_gep2(array_type, array, tmp);
            // After the first GEP, tmp points to an enum value struct
            // Get the element type of the array (which is the enum value struct type)
            llvm::ArrayType* array_array_type = llvm::dyn_cast<llvm::ArrayType>(array_type);
            llvm::Type* enum_value_struct_type = array_array_type->getElementType();
            tmp = llvm_utils->create_gep2(enum_value_struct_type, tmp, 0);
        }
    }

    void visit_EnumConstructor(const ASR::EnumConstructor_t& x) {
        LCOMPILERS_ASSERT(x.n_args == 1);
        ASR::expr_t* m_arg = x.m_args[0];
        this->visit_expr(*m_arg);
    }

    void visit_UnionConstructor([[maybe_unused]] const ASR::UnionConstructor_t& x) {
        LCOMPILERS_ASSERT(x.n_args == 0);
    }

    llvm::Value* SizeOfTypeUtil(ASR::expr_t* expr, ASR::ttype_t* m_type, llvm::Type* output_type,
        ASR::ttype_t* output_type_asr) {
        llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(expr, m_type, module.get());
        llvm::DataLayout data_layout(module->getDataLayout());
        int64_t type_size = data_layout.getTypeAllocSize(llvm_type);
        return llvm::ConstantInt::get(output_type, llvm::APInt(
            ASRUtils::extract_kind_from_ttype_t(output_type_asr) * 8, type_size));
    }

    void visit_StructInstanceMember(const ASR::StructInstanceMember_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        current_der_type_name = "";
        ASR::ttype_t* x_m_v_type = ASRUtils::expr_type(x.m_v);

        // Early null check for Cast_t with allocatable class type argument
        // This must happen BEFORE visit_expr(*x.m_v) because the cast operation
        // will try to dereference the pointer, causing a crash if it's null
        if (compiler_options.po.bounds_checking && ASR::is_a<ASR::Cast_t>(*x.m_v)) {
            ASR::Cast_t* cast_expr = ASR::down_cast<ASR::Cast_t>(x.m_v);
            ASR::ttype_t* cast_arg_type = ASRUtils::expr_type(cast_expr->m_arg);
            if (ASRUtils::is_allocatable(cast_arg_type) &&
                ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable(cast_arg_type))) {
                // Visit the underlying class variable to get its pointer
                int64_t ptr_loads_save = ptr_loads;
                ptr_loads = 0;
                this->visit_expr(*cast_expr->m_arg);
                ptr_loads = ptr_loads_save;
                llvm::Value* class_ptr = tmp;

                // Get the variable name for the error message
                ASR::Variable_t* var = ASRUtils::expr_to_variable_or_null(cast_expr->m_arg);
                std::string var_name = var ? var->m_name : "unknown";

                // Get the LLVM type for the allocatable class
                llvm::Type* class_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    cast_expr->m_arg, cast_arg_type, module.get());

                // Load the pointer to get the actual class instance pointer
                llvm::Value* class_instance_ptr = llvm_utils->CreateLoad2(
                    class_llvm_type->getPointerTo(), class_ptr);

                // Check if the class instance pointer is null
                llvm::Value* cond = builder->CreateICmpEQ(
                    builder->CreatePtrToInt(class_instance_ptr,
                        llvm::Type::getInt64Ty(context)),
                    builder->CreatePtrToInt(llvm::ConstantPointerNull::get(
                        llvm::cast<llvm::PointerType>(class_instance_ptr->getType())),
                        llvm::Type::getInt64Ty(context)));
                llvm::Value* var_name_llvm = LCompilers::create_global_string_ptr(context, *module, *builder, var_name);
                llvm_utils->generate_runtime_error(cond,
                        "Tried to access member of unallocated variable '%s'",
                        {LLVMUtils::RuntimeLabel("'%s' unallocated here", {cast_expr->m_arg->base.loc}, {var_name_llvm})},
                        infile,
                        location_manager,
                        var_name_llvm);
            }
        }

        int64_t ptr_loads_copy = ptr_loads;
        if( ASR::is_a<ASR::UnionInstanceMember_t>(*x.m_v) ||
            (ASRUtils::is_class_type(ASRUtils::extract_type(x_m_v_type)) &&
            !compiler_options.new_classes) ) {
            ptr_loads = 0;
        } else {
            ptr_loads = 2 - LLVM::is_llvm_pointer(*x_m_v_type);
        }
        this->visit_expr(*x.m_v);
        ptr_loads = ptr_loads_copy;
        if (ASR::is_a<ASR::Cast_t>(*x.m_v) && LLVM::is_llvm_pointer(*x_m_v_type)) {
            llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(
                x.m_v, ASRUtils::type_get_past_allocatable_pointer(x_m_v_type), module.get());
            tmp = llvm_utils->CreateLoad2(type->getPointerTo(), tmp);
        }
        if (ASRUtils::is_class_type(ASRUtils::type_get_past_pointer(
                ASRUtils::type_get_past_allocatable(x_m_v_type))) ) {
            if (ASRUtils::is_allocatable(x_m_v_type)) {
                ASR::ttype_t* wrapped_struct_type = ASRUtils::make_StructType_t_util(al, x_m_v_type->base.loc,
                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_v)), true);
                llvm::Type* wrapper_struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_v, wrapped_struct_type, module.get())->getPointerTo();
                llvm::Type* x_mv_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_v, ASRUtils::extract_type(x_m_v_type), module.get());

                if (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_v)) {
                    tmp = llvm_utils->CreateLoad2(x_mv_llvm_type->getPointerTo(), tmp);
                }
                if (compiler_options.po.bounds_checking) {
                    ASR::Variable_t* var = ASRUtils::expr_to_variable_or_null(x.m_v);
                    if (var) {
                        llvm::Value* var_name_llvm = LCompilers::create_global_string_ptr(context, *module, *builder, var->m_name);
                        llvm::Value* cond = builder->CreateICmpEQ(
                            builder->CreatePtrToInt(tmp,
                                llvm::Type::getInt64Ty(context)),
                            builder->CreatePtrToInt(llvm::ConstantPointerNull::get(x_mv_llvm_type->getPointerTo()),
                                llvm::Type::getInt64Ty(context)));
                        llvm_utils->generate_runtime_error(cond,
                                "Tried to access member of unallocated variable '%s'",
                                {LLVMUtils::RuntimeLabel("'%s' unallocated here", {x.m_v->base.loc}, {var_name_llvm})},
                                infile,
                                location_manager,
                                var_name_llvm);
                    }
                }
                tmp = llvm_utils->create_gep2(x_mv_llvm_type, tmp, 1);
                tmp = llvm_utils->CreateLoad2(wrapper_struct_llvm_type, tmp);
            } else {
                ASR::ttype_t* x_m_v_type_ = ASRUtils::type_get_past_allocatable(
                    ASRUtils::type_get_past_pointer(x_m_v_type));
                llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(x.m_v, x_m_v_type_, module.get());
                tmp = llvm_utils->CreateLoad2(
                    name2dertype[current_der_type_name]->getPointerTo(), llvm_utils->create_gep2(type, tmp, 1));
            }
        } else if (compiler_options.po.bounds_checking &&
                ASRUtils::is_allocatable(x_m_v_type) && ASRUtils::is_struct(*x_m_v_type)) {
            ASR::Variable_t* var = ASRUtils::expr_to_variable_or_null(x.m_v);
            if (var) {
                llvm::Type* x_mv_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_v, x_m_v_type, module.get());
                llvm::Value* var_name_llvm = LCompilers::create_global_string_ptr(context, *module, *builder, var->m_name);
                llvm::Value* cond = builder->CreateICmpEQ(
                    builder->CreatePtrToInt(tmp,
                        llvm::Type::getInt64Ty(context)),
                    builder->CreatePtrToInt(llvm::ConstantPointerNull::get(x_mv_llvm_type->getPointerTo()),
                        llvm::Type::getInt64Ty(context)));
                llvm_utils->generate_runtime_error(cond,
                        "Tried to access member of unallocated variable '%s'",
                        {LLVMUtils::RuntimeLabel("'%s' unallocated here", {x.m_v->base.loc}, {var_name_llvm})},
                        infile,
                        location_manager,
                        var_name_llvm);
            }
        }
        if (ASR::is_a<ASR::Struct_t>(*symbol_get_past_external(x.m_m))) {
            ASR::Struct_t* member_struct = down_cast<ASR::Struct_t>(symbol_get_past_external(x.m_m));
            std::string member_name = member_struct->m_name;
            while( dertype2parent.find(current_der_type_name) != dertype2parent.end() &&
                        (current_der_type_name != member_name)) {
                if (tmp->getType()->isPointerTy()) {
                    tmp = llvm_utils->create_gep2(name2dertype[current_der_type_name], tmp, 0);
                } else {
                    if (llvm::isa<llvm::Constant>(tmp)) {
                        tmp = llvm::cast<llvm::Constant>(tmp)->getAggregateElement(0u);
                    } else {
                        tmp = builder->CreateExtractValue(tmp, 0);
                    }
                }
                current_der_type_name = dertype2parent[current_der_type_name];
            }
            return;
        }
        ASR::Variable_t* member = down_cast<ASR::Variable_t>(symbol_get_past_external(x.m_m));
        std::string member_name = std::string(member->m_name);
        LCOMPILERS_ASSERT(current_der_type_name.size() != 0);

        llvm::Type *xtype = name2dertype[current_der_type_name];
        if (LLVM::is_llvm_pointer(*x_m_v_type) && 
            ASR::is_a<ASR::StructInstanceMember_t>(*x.m_v) &&
            !ASRUtils::is_class_type(ASRUtils::extract_type(x_m_v_type))) {
            tmp = llvm_utils->CreateLoad2(xtype->getPointerTo(), tmp);
        }

        while( name2memidx[current_der_type_name].find(member_name) == name2memidx[current_der_type_name].end() ) {
            if( dertype2parent.find(current_der_type_name) == dertype2parent.end() ) {
                throw CodeGenError(current_der_type_name + " doesn't have any member named " + member_name,
                                    x.base.base.loc);
            }
            if (tmp->getType()->isPointerTy()) {
                tmp = llvm_utils->create_gep2(name2dertype[current_der_type_name], tmp, 0);
            } else {
                if (llvm::isa<llvm::Constant>(tmp)) {
                    tmp = llvm::cast<llvm::Constant>(tmp)->getAggregateElement(0u);
                } else {
                    tmp = builder->CreateExtractValue(tmp, 0);
                }
            }
            current_der_type_name = dertype2parent[current_der_type_name];
        }
        int member_idx = 0;
        member_idx = name2memidx[current_der_type_name][member_name];

        xtype = name2dertype[current_der_type_name];
        if (tmp->getType()->isPointerTy()) {
            ASR::ttype_t* base_t = ASRUtils::expr_type(x.m_v);
            base_t = ASRUtils::type_get_past_allocatable(base_t);
            base_t = ASRUtils::type_get_past_pointer(base_t);
            if (ASRUtils::is_array(base_t)) {// If nested derived type
                ASR::ttype_t *elem_t = ASRUtils::type_get_past_array(base_t);\
                if (ASRUtils::is_struct(*elem_t)){
                    llvm::Type *array_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_v, base_t, module.get());
                    tmp = llvm_utils->create_gep2(array_type, tmp, 0);
                    base_t = elem_t;
                }
            }
            tmp = llvm_utils->create_gep2(xtype, tmp, member_idx);
        } else {
            if (llvm::isa<llvm::Constant>(tmp)) {
                tmp = llvm::cast<llvm::Constant>(tmp)->getAggregateElement(member_idx);
            } else {
                tmp = builder->CreateExtractValue(tmp, member_idx);
            }
        }
        ASR::ttype_t* member_type = ASRUtils::type_get_past_pointer(
            ASRUtils::type_get_past_allocatable(member->m_type));
        member_type = ASRUtils::type_get_past_array(member_type);
        if( ASR::is_a<ASR::StructType_t>(*member_type) ) {
            ASR::symbol_t *s_sym = member->m_type_declaration;
            current_der_type_name = ASRUtils::symbol_name(
                ASRUtils::symbol_get_past_external(s_sym));
            if (!ASRUtils::is_class_type(member_type)) {
                uint32_t h = get_hash((ASR::asr_t*)member);
                if( llvm_symtab.find(h) != llvm_symtab.end() ) {
                    tmp = llvm_symtab[h];
                }
            }
        }

        // COMMON block type aliasing: Fortran allows different program units to
        // view the same COMMON block storage with different types (storage
        // association). When the local variable type (x.m_type) differs from
        // the struct member type (member->m_type), we must bitcast the pointer
        // to match the local view. Details handled by the helper function.
        tmp = llvm_utils->apply_common_block_alias_cast(
            tmp,
            const_cast<ASR::expr_t*>(reinterpret_cast<const ASR::expr_t*>(&x)),
            x.m_type,
            member->m_type
        );
    }

    void visit_StructConstant(const ASR::StructConstant_t& x) {
        std::vector<llvm::Constant *> elements;
        llvm::StructType* t = llvm::cast<llvm::StructType>(
            llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(x.m_dt_sym)), module.get()));
        ASR::Struct_t* struct_
            = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(x.m_dt_sym));

        [[maybe_unused]] size_t n_members = struct_->n_members;
        if (struct_->m_parent) {
            ASR::Struct_t* parent_struct = ASR::down_cast<ASR::Struct_t>(
                ASRUtils::symbol_get_past_external(struct_->m_parent));
            while (parent_struct) {
                n_members += parent_struct->n_members;
                if (parent_struct->m_parent) {
                    parent_struct = ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(parent_struct->m_parent));
                } else {
                    parent_struct = nullptr;
                }
            }
        }

        LCOMPILERS_ASSERT(x.n_args == n_members);
        for (size_t i = 0; i < x.n_args; ++i) {
            ASR::expr_t *value = x.m_args[i].m_value;
            llvm::Constant* initializer = nullptr;
            llvm::Type* type = nullptr;
            if (value == nullptr) {
                auto member2sym = struct_->m_symtab->get_scope();
                LCOMPILERS_ASSERT(member2sym[struct_->m_members[i]]->type == ASR::symbolType::Variable);
                ASR::Variable_t *s = ASR::down_cast<ASR::Variable_t>(member2sym[struct_->m_members[i]]);
                type = llvm_utils->get_type_from_ttype_t_util(
                    ASRUtils::EXPR(ASR::make_Var_t(al, s->base.base.loc, &s->base)),
                    s->m_type,
                    module.get());
                if (type->isArrayTy()) {
                    initializer = llvm::ConstantArray::getNullValue(type);
                } else {
                    initializer = llvm::Constant::getNullValue(type);
                }
            } else if (ASR::is_a<ASR::ArrayConstant_t>(*value)) {
                ASR::ArrayConstant_t *arr_expr = ASR::down_cast<ASR::ArrayConstant_t>(value);
                type = llvm_utils->get_type_from_ttype_t_util(value, arr_expr->m_type, module.get());
                initializer = get_const_array(value, type->getArrayElementType());
            } else {
                visit_expr_wrapper(value);
                initializer = llvm::dyn_cast<llvm::Constant>(tmp);
                if (!initializer) {
                    throw CodeGenError("Non-constant value found in struct initialization");
                }
            }
            elements.push_back(initializer);
        }
        tmp = llvm::ConstantStruct::get(t, elements);
        current_der_type_name = ASRUtils::symbol_name(x.m_dt_sym);
    }

    llvm::Constant* get_const_array(ASR::expr_t *value, llvm::Type* type) {
        LCOMPILERS_ASSERT(ASR::is_a<ASR::ArrayConstant_t>(*value));
        ASR::ArrayConstant_t* arr_const = ASR::down_cast<ASR::ArrayConstant_t>(value);
        std::vector<llvm::Constant*> arr_elements;
        size_t arr_const_size = (size_t) ASRUtils::get_fixed_size_of_array(arr_const->m_type);
        arr_elements.reserve(arr_const_size);
        int a_kind;
        for (size_t i = 0; i < arr_const_size; i++) {
            ASR::expr_t* elem = ASRUtils::fetch_ArrayConstant_value(al, arr_const, i);
            a_kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(elem));
            if (ASR::is_a<ASR::IntegerConstant_t>(*elem)) {
                ASR::IntegerConstant_t* int_const = ASR::down_cast<ASR::IntegerConstant_t>(elem);
                arr_elements.push_back(llvm::ConstantInt::get(
                    context, llvm::APInt(8 * a_kind, int_const->m_n, true)));
            } else if (ASR::is_a<ASR::RealConstant_t>(*elem)) {
                ASR::RealConstant_t* real_const = ASR::down_cast<ASR::RealConstant_t>(elem);
                if (a_kind == 4) {
                    arr_elements.push_back(llvm::ConstantFP::get(
                        context, llvm::APFloat((float) real_const->m_r)));
                } else if (a_kind == 8) {
                    arr_elements.push_back(llvm::ConstantFP::get(
                        context, llvm::APFloat((double) real_const->m_r)));
                }
            } else if (ASR::is_a<ASR::LogicalConstant_t>(*elem)) {
                ASR::LogicalConstant_t* logical_const = ASR::down_cast<ASR::LogicalConstant_t>(elem);
                arr_elements.push_back(llvm::ConstantInt::get(
                    context, llvm::APInt(1, logical_const->m_value)));
            }
        }
        llvm::ArrayType* arr_type = llvm::ArrayType::get(type, arr_const_size);
        llvm::Constant* initializer = nullptr;
        if (isNullValueArray(arr_elements)) {
            initializer = llvm::ConstantArray::getNullValue(arr_type);
        } else {
            initializer = llvm::ConstantArray::get(arr_type, arr_elements);
        }
        return initializer;
    }

    bool isNullValueArray(const std::vector<llvm::Constant*>& elements) {
        return std::all_of(elements.begin(), elements.end(),
            [](llvm::Constant* elem) { return elem->isNullValue(); });
    }

    bool needs_common_linkage_for_global(const ASR::Variable_t &x) {
        if (!compiler_options.separate_compilation
                || x.m_abi == ASR::abiType::ExternalUndefined) {
            return false;
        }
        ASR::symbol_t *owner = ASRUtils::get_asr_owner(
            const_cast<ASR::symbol_t*>(&x.base));
        if (owner && ASR::is_a<ASR::Module_t>(*owner)) {
            return startswith(ASRUtils::symbol_name(owner), "file_common_block_");
        }
        return false;
    }

    void set_global_variable_linkage_as_common(llvm::Value* ptr,
            const ASR::Variable_t &x) {
        if (needs_common_linkage_for_global(x)) {
            /*
                In case of global variables without initialization, clang
                generates a common symbol. For the following C code:

                ```
                int global_var;
                int global_variable_initalised = 42;
                ```

                on using `clang -S -emit-llvm` we get:

                ```
                ; ModuleID = 'a.c'
                source_filename = "a.c"
                target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
                target triple = "arm64-apple-macosx14.0.0"

                @global_var_initialized = global i32 42, align 4
                @global_var = common global i32 0, align 4

                !llvm.module.flags = !{!0, !1, !2, !3, !4}
                !llvm.ident = !{!5}

                !0 = !{i32 2, !"SDK Version", [2 x i32] [i32 14, i32 4]}
                !1 = !{i32 1, !"wchar_size", i32 4}
                !2 = !{i32 8, !"PIC Level", i32 2}
                !3 = !{i32 7, !"uwtable", i32 1}
                !4 = !{i32 7, !"frame-pointer", i32 1}
                !5 = !{!"Apple clang version 15.0.0 (clang-1500.3.9.4)"}
                ```

                Hence, we set the linkage to CommonLinkage for
                global variables without initialization in case
                `compiler_options.separate_compilation` is set to true.
            */
            llvm::GlobalVariable *gv = llvm::cast<llvm::GlobalVariable>(
                ptr
            );
            gv->setLinkage(llvm::GlobalValue::CommonLinkage);
        }
    }

    void visit_Variable(const ASR::Variable_t &x) {
        if (x.m_value && x.m_storage == ASR::storage_typeType::Parameter) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        uint32_t h = get_hash((ASR::asr_t*)&x);
        // This happens at global scope, so the intent can only be either local
        // (global variable declared/initialized in this translation unit), or
        // external (global variable not declared/initialized in this
        // translation unit, just referenced).
        LCOMPILERS_ASSERT(x.m_intent == intent_local || x.m_intent == ASRUtils::intent_unspecified
            || x.m_abi == ASR::abiType::ExternalUndefined);
        bool external = (x.m_abi != ASR::abiType::Source);
        llvm::Constant* init_value = nullptr;
        if (x.m_symbolic_value != nullptr &&
            !ASRUtils::is_string_only(x.m_type)){
            this->visit_expr_wrapper(x.m_symbolic_value, true);
            init_value = llvm::dyn_cast<llvm::Constant>(tmp);
        }

        // variable name to use in declaration
        std::string llvm_var_name = "";
        if (x.m_abi == ASR::abiType::BindC && x.m_bindc_name) {
            // for external global variable with bindc, use the C name
            llvm_var_name = x.m_bindc_name;
        } else {
            llvm_var_name = mangle_prefix + x.m_name;
        }
        if (x.m_type->type == ASR::ttypeType::Integer
            || x.m_type->type == ASR::ttypeType::UnsignedInteger) {
            int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
            llvm::Type *type;
            int init_value_bits = 8*a_kind;
            type = llvm_utils->getIntType(a_kind);
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                type);
            if (!external) {
                if (ASRUtils::is_array(x.m_type)) {
                    throw CodeGenError("Arrays are not supported by visit_Variable");
                }
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            init_value);
                } else {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            llvm::ConstantInt::get(context,
                                llvm::APInt(init_value_bits, 0)));
                    set_global_variable_linkage_as_common(ptr, x);
                }
            }
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::Real) {
            int a_kind = down_cast<ASR::Real_t>(x.m_type)->m_kind;
            llvm::Type *type;
            int init_value_bits = 8*a_kind;
            type = llvm_utils->getFPType(a_kind);
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name, type);
            if (!external) {
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            init_value);
                } else {
                    if( init_value_bits == 32 ) {
                        module->getNamedGlobal(llvm_var_name)->setInitializer(
                                llvm::ConstantFP::get(context,
                                    llvm::APFloat((float)0)));
                    } else if( init_value_bits == 64 ) {
                        module->getNamedGlobal(llvm_var_name)->setInitializer(
                                llvm::ConstantFP::get(context,
                                    llvm::APFloat((double)0)));
                    }
                    set_global_variable_linkage_as_common(ptr, x);
                }
            }
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::Array) {
            llvm::Constant *ptr{};
            if(ASRUtils::is_character(*x.m_type)){
                ASR::expr_t* value = nullptr;
                if( x.m_value ) {
                    value = x.m_value;
                } else if( x.m_symbolic_value &&
                        ASRUtils::is_value_constant(x.m_symbolic_value) ) {
                    value = x.m_symbolic_value;
                }
                if(value){LCOMPILERS_ASSERT(ASR::is_a<ASR::ArrayConstant_t>(*value));}
                ptr = llvm::cast<llvm::Constant>(llvm_utils->handle_global_nonallocatable_stringArray(al,
                    ASR::down_cast<ASR::Array_t>(x.m_type), value?ASR::down_cast<ASR::ArrayConstant_t>(value):nullptr, llvm_var_name));

            } else {
                llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                    ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))),
                    x.m_type, module.get());
                ptr = module->getOrInsertGlobal(llvm_var_name, type);
                if (!external) {
                    ASR::expr_t* value = nullptr;
                    if( x.m_value ) {
                        value = x.m_value;
                    } else if( x.m_symbolic_value &&
                            ASRUtils::is_value_constant(x.m_symbolic_value) ) {
                        value = x.m_symbolic_value;
                    }
                    if (value) {
                        llvm::Constant* initializer = get_const_array(value, type->getArrayElementType());
                        module->getNamedGlobal(llvm_var_name)->setInitializer(initializer);
                    } else {
                        module->getNamedGlobal(llvm_var_name)->setInitializer(llvm::ConstantArray::getNullValue(type));
                        set_global_variable_linkage_as_common(ptr, x);
                    }
                }
            }
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::Logical) {
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                llvm::Type::getInt1Ty(context));
            if (!external) {
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            init_value);
                } else {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            llvm::ConstantInt::get(context,
                                llvm::APInt(1, 0)));
                    set_global_variable_linkage_as_common(ptr, x);
                }
            }
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::String) {
            ASR::String_t* str = ASRUtils::get_string_type(x.m_type);
            llvm::Value *ptr{};
                bool is_const = (x.m_storage == ASR::storage_typeType::Parameter);
                if (!external) {
                    std::string initial_string_value;
                    if (x.m_symbolic_value) {
                        ASR::StringConstant_t* str_const = ASR::down_cast<ASR::StringConstant_t>(ASRUtils::expr_value(x.m_symbolic_value));
                        int64_t len; ASRUtils::extract_value(ASRUtils::get_string_type(str_const->m_type)->m_len, len);
                        initial_string_value = std::string(str_const->m_s, len);
                    } else {
                        initial_string_value = "";
                    }
                    ptr = llvm_utils->declare_global_string(str, initial_string_value,
                        is_const, llvm_var_name,
                        compiler_options.separate_compilation ? llvm::GlobalValue::ExternalLinkage : llvm::GlobalValue::PrivateLinkage);
                } else {
                    ptr = module->getOrInsertGlobal(llvm_var_name, llvm_utils->get_StringType(x.m_type));
                }
            llvm_symtab[h] = ptr;
        } else if( x.m_type->type == ASR::ttypeType::CPtr ) {
            llvm::Type* void_ptr = llvm::Type::getVoidTy(context)->getPointerTo();
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                void_ptr);
            if (!external) {
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            init_value);
                } else {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            llvm::ConstantPointerNull::get(
                                static_cast<llvm::PointerType*>(void_ptr))
                            );
                    set_global_variable_linkage_as_common(ptr, x);
                }
            }
            llvm_symtab[h] = ptr;
        } else if( x.m_type->type == ASR::ttypeType::StructType ) {
            ASR::StructType_t* struct_t = ASR::down_cast<ASR::StructType_t>(x.m_type);
            bool is_class = !struct_t->m_is_cstruct;
            llvm::Constant* inner_ptr;
            if (init_value == nullptr) {
                std::vector<llvm::Constant*> field_values;
                if (is_class && compiler_options.new_classes) {
                    // for class types, first field is vtable ptr
                    llvm::Constant* vtable_ptr = struct_api->get_pointer_to_method(
                        ASRUtils::symbol_get_past_external(x.m_type_declaration), module.get());
                    field_values.push_back(vtable_ptr);
                }
                get_type_default_field_values(x.m_type_declaration, field_values,
                    ASRUtils::symbol_get_past_external(x.m_type_declaration));
                llvm::StructType* llvm_struct_type = llvm::cast<llvm::StructType>(llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                    ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get()));
                if (is_class && !compiler_options.new_classes) {
                    // llvm_struct_type = %toml_lexer_polymorphic {i64, %toml_lexer*}
                    ASR::ttype_t* inner_struct_type = ASRUtils::make_StructType_t_util(al, x.base.base.loc,
                            ASRUtils::symbol_get_past_external(x.m_type_declaration), true);
                    // innerType = %toml_lexer*
                    llvm::StructType* innerType = llvm::cast<llvm::StructType>(
                        llvm_utils->get_type_from_ttype_t_util(inner_struct_type, x.m_type_declaration, module.get()));
                    init_value = llvm::ConstantStruct::get(innerType, field_values);
                    std::string inner_type_name = "_inner" + llvm_var_name;
                    inner_ptr = module->getOrInsertGlobal(inner_type_name, innerType);
                    module->getNamedGlobal(inner_type_name)->setInitializer(init_value);
                    int class_hash = get_class_hash(ASRUtils::symbol_get_past_external(x.m_type_declaration));
                    field_values.clear();
                    llvm::Constant* struct_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                                            llvm::APInt(64, class_hash));
                    // push type_hash and type pointer to %toml_lexer_polymorphic
                    field_values.push_back(struct_hash);
                    field_values.push_back(inner_ptr);
                }
                init_value = llvm::ConstantStruct::get(llvm_struct_type, field_values);
            }
            if (!is_class) {
                if( x.m_type_declaration && ASRUtils::is_c_ptr(x.m_type_declaration) ) {
                    llvm::Type* void_ptr = llvm::Type::getVoidTy(context)->getPointerTo();
                    llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                        void_ptr);
                    if (!external) {
                        if (init_value) {
                            module->getNamedGlobal(llvm_var_name)->setInitializer(
                                    init_value);
                        } else {
                            module->getNamedGlobal(llvm_var_name)->setInitializer(
                                    llvm::ConstantPointerNull::get(
                                        static_cast<llvm::PointerType*>(void_ptr))
                                    );
                            set_global_variable_linkage_as_common(ptr, x);
                        }
                    }
                    llvm_symtab[h] = ptr;
                } else {
                    llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                    ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get());
                    llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                        type);
                    if (!external) {
                        if (init_value) {
                            module->getNamedGlobal(llvm_var_name)->setInitializer(
                                    init_value);
                            // For common blocks (structs with zeroinitializer), use CommonLinkage
                            // to allow multiple definitions across compilation units to be merged.
                            if (init_value->isNullValue()) {
                                set_global_variable_linkage_as_common(ptr, x);
                            }
                        } else {
                            module->getNamedGlobal(llvm_var_name)->setInitializer(
                                    llvm::Constant::getNullValue(type)
                                );
                            set_global_variable_linkage_as_common(ptr, x);
                        }
                    }
                    llvm_symtab[h] = ptr;
                }
            } else {
                llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(
                    ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, x.m_type_declaration)),
                    x.m_type, module.get());
                llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                    type);
                if (!external) {
                    if (init_value) {
                        module->getNamedGlobal(llvm_var_name)->setInitializer(
                                init_value);
                        // For common blocks (structs with zeroinitializer), use CommonLinkage
                        // to allow multiple definitions across compilation units to be merged.
                        if (init_value->isNullValue()) {
                            set_global_variable_linkage_as_common(ptr, x);
                        }
                    } else {
                        module->getNamedGlobal(llvm_var_name)
                            ->setInitializer(llvm::Constant::getNullValue(type));
                        set_global_variable_linkage_as_common(ptr, x);
                    }
                }
                llvm_symtab[h] = ptr;
            }
            if (is_class && !compiler_options.new_classes) {
                allocatable_struct_array_members_details.push_back(std::make_pair(
                    ASRUtils::symbol_get_past_external(x.m_type_declaration), inner_ptr));
            } else {
                allocatable_struct_array_members_details.push_back(std::make_pair(
                    ASRUtils::symbol_get_past_external(x.m_type_declaration), llvm_symtab[h]));
            }
        } else if(x.m_type->type == ASR::ttypeType::Pointer ||
                    x.m_type->type == ASR::ttypeType::Allocatable) {
            ASR::dimension_t* m_dims = nullptr;
            int n_dims = 0, a_kind = -1;
            bool is_array_type = false, is_malloc_array_type = false, is_list = false;
            llvm::Type* x_ptr = llvm_utils->get_type_from_ttype_t(
                ASRUtils::EXPR(ASR::make_Var_t(
                    al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type,
                    x.m_type_declaration, x.m_storage, is_array_type,
                    is_malloc_array_type, is_list, m_dims, n_dims, a_kind, module.get());
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name,
                x_ptr);
            llvm::Type* type_ = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))),
                ASRUtils::type_get_past_pointer(
                ASRUtils::type_get_past_allocatable(x.m_type)),
                module.get(), x.m_abi);
            if (ASRUtils::is_array(x.m_type)) {  // memorize arrays only.
                allocatable_array_details.push_back(
                    { ASRUtils::EXPR(ASR::make_Var_t(
                          al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))),
                      ptr,
                      type_,
                      x.m_type,
                      ASRUtils::extract_dimensions_from_ttype(x.m_type, m_dims) });
            } else if (ASRUtils::is_character(*x.m_type) && !init_value) {
                // set all members of string_descriptor to null and zeroes.
                init_value = llvm::ConstantAggregateZero::get(string_descriptor);
            }
            if (!external) {
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            init_value);
                } else {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            llvm::ConstantPointerNull::get(
                                static_cast<llvm::PointerType*>(x_ptr))
                            );
                    set_global_variable_linkage_as_common(ptr, x);
                }
            }
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::List) {
            llvm::StructType* list_type = static_cast<llvm::StructType*>(
                llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get()));
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name, list_type);
            module->getNamedGlobal(llvm_var_name)->setInitializer(
                llvm::ConstantStruct::get(list_type,
                llvm::Constant::getNullValue(list_type)));
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::Tuple) {
            llvm::StructType* tuple_type = static_cast<llvm::StructType*>(
                llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get()));
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name, tuple_type);
            module->getNamedGlobal(llvm_var_name)->setInitializer(
                llvm::ConstantStruct::get(tuple_type,
                llvm::Constant::getNullValue(tuple_type)));
            llvm_symtab[h] = ptr;
        } else if(x.m_type->type == ASR::ttypeType::Dict) {
            llvm::StructType* dict_type = static_cast<llvm::StructType*>(
                llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get()));
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name, dict_type);
            module->getNamedGlobal(llvm_var_name)->setInitializer(
                llvm::ConstantStruct::get(dict_type,
                llvm::Constant::getNullValue(dict_type)));
            llvm_symtab[h] = ptr;
        } else if(x.m_type->type == ASR::ttypeType::Set) {
            llvm::StructType* set_type = static_cast<llvm::StructType*>(
                llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get()));
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name, set_type);
            module->getNamedGlobal(llvm_var_name)->setInitializer(
                llvm::ConstantStruct::get(set_type,
                llvm::Constant::getNullValue(set_type)));
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::Complex) {
            int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);

            llvm::Constant* re;
            llvm::Constant* im;
            llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get());;
            llvm::Constant* ptr = module->getOrInsertGlobal(llvm_var_name, type);

            if (!external) {
                double x_re = 0.0, x_im = 0.0;
                if (x.m_value) {
                    LCOMPILERS_ASSERT(ASR::is_a<ASR::ComplexConstant_t>(*x.m_value));
                    ASR::ComplexConstant_t* x_cc = ASR::down_cast<ASR::ComplexConstant_t>(x.m_value);
                    x_re = x_cc->m_re; x_im = x_cc->m_im;
                }
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(init_value);
                } else {
                    switch (a_kind) {
                        case 4: {
                            re = llvm::ConstantFP::get(context, llvm::APFloat((float) x_re));
                            im = llvm::ConstantFP::get(context, llvm::APFloat((float) x_im));
                            type = complex_type_4;
                            break;
                        }
                        case 8: {
                            re = llvm::ConstantFP::get(context, llvm::APFloat((double) x_re));
                            im = llvm::ConstantFP::get(context, llvm::APFloat((double) x_im));
                            type = complex_type_8;
                            break;
                        }
                        default: {
                            throw CodeGenError("kind type is not supported");
                        }
                    }
                    // Create a constant structure to represent the complex number
                    std::vector<llvm::Constant*> elements = { re, im };
                    llvm::Constant* complex_init = llvm::ConstantStruct::get(static_cast<llvm::StructType*>(type), elements);
                    module->getNamedGlobal(llvm_var_name)->setInitializer(complex_init);
                }
            }
            llvm_symtab[h] = ptr;
        } else if (x.m_type->type == ASR::ttypeType::TypeParameter) {
            // Ignore type variables
        } else if (x.m_type->type == ASR::ttypeType::FunctionType) {
            llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                ASR::make_Var_t(al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))), x.m_type, module.get());
            llvm::Constant *ptr = module->getOrInsertGlobal(llvm_var_name, type);
            if (!external) {
                if (init_value) {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            init_value);
                } else {
                    module->getNamedGlobal(llvm_var_name)->setInitializer(
                            llvm::Constant::getNullValue(type)
                        );
                    set_global_variable_linkage_as_common(ptr, x);
                }
            }
            llvm_symtab[h] = ptr;
        } else {
            throw CodeGenError("Variable type not supported " + ASRUtils::type_to_str_python_symbol(x.m_type, x.m_type_declaration), x.base.base.loc);
        }
    }

    void visit_PointerNullConstant(const ASR::PointerNullConstant_t& x){
        llvm::Type* value_type;

        value_type = ASRUtils::is_array(x.m_type)?
            llvm_utils->get_type_from_ttype_t_util(x.m_var_expr,
                ASRUtils::extract_type(x.m_type), module.get())->getPointerTo():
            llvm_utils->get_type_from_ttype_t_util(x.m_var_expr, x.m_type, module.get());
        tmp = llvm::ConstantPointerNull::get(static_cast<llvm::PointerType*>(value_type));
    }

    void visit_Enum(const ASR::Enum_t& x) {
        if ( x.m_abi == ASR::abiType::ExternalUndefined ) {
            return;
        }
        if( x.m_enum_value_type == ASR::enumtypeType::IntegerUnique &&
            x.m_abi == ASR::abiType::BindC ) {
            throw CodeGenError("C-interoperation support for non-consecutive but uniquely "
                               "valued integer enums isn't available yet.");
        }
        bool is_integer = ASR::is_a<ASR::Integer_t>(*x.m_type);
        ASR::storage_typeType m_storage = ASR::storage_typeType::Default;
        bool is_array_type = false, is_malloc_array_type = false, is_list = false;
        ASR::dimension_t* m_dims = nullptr;
        int n_dims = -1, a_kind = -1;
        llvm::Type* value_type = llvm_utils->get_type_from_ttype_t(ASRUtils::EXPR(ASR::make_Var_t(
                    al, x.base.base.loc, const_cast<ASR::symbol_t*>(&x.base))),
            x.m_type, nullptr, m_storage, is_array_type,
            is_malloc_array_type, is_list, m_dims, n_dims, a_kind, module.get());
        if( is_integer ) {
            int64_t min_value = INT64_MAX;
            int64_t max_value = INT64_MIN;
            size_t max_name_len = 0;
            llvm::Value* itr_value = nullptr;
            for( auto itr: x.m_symtab->get_scope() ) {
                ASR::Variable_t* itr_var = ASR::down_cast<ASR::Variable_t>(itr.second);
                ASR::expr_t* value = ASRUtils::expr_value(itr_var->m_symbolic_value);
                int64_t value_int64 = -1;
                this->visit_expr(*value);
                itr_value = tmp;
                ASRUtils::extract_value(value, value_int64);
                min_value = std::min(value_int64, min_value);
                max_value = std::max(value_int64, max_value);
                max_name_len = std::max(max_name_len, itr.first.size());
            }

            llvm::ArrayType* name_array_type = llvm::ArrayType::get(llvm::Type::getInt8Ty(context),
                                                                    max_name_len + 1);
            llvm::StructType* enum_value_type = llvm::StructType::create({name_array_type, value_type});
            llvm::Constant* empty_vt = llvm::ConstantStruct::get(enum_value_type, {llvm::ConstantArray::get(name_array_type,
                {llvm::ConstantInt::get(llvm::Type::getInt8Ty(context), llvm::APInt(8, '\0'))}),
                (llvm::Constant*) itr_value});
            std::vector<llvm::Constant*> enum_value_pairs(max_value - min_value + 1, empty_vt);

            for( auto itr: x.m_symtab->get_scope() ) {
                ASR::Variable_t* itr_var = ASR::down_cast<ASR::Variable_t>(itr.second);
                ASR::expr_t* value = ASRUtils::expr_value(itr_var->m_symbolic_value);
                int64_t value_int64 = -1;
                ASRUtils::extract_value(value, value_int64);
                this->visit_expr(*value);
                std::vector<llvm::Constant*> itr_var_name_v;
                itr_var_name_v.reserve(itr.first.size());
                for( size_t i = 0; i < itr.first.size(); i++ ) {
                    itr_var_name_v.push_back(llvm::ConstantInt::get(
                        llvm::Type::getInt8Ty(context), llvm::APInt(8, itr_var->m_name[i])));
                }
                itr_var_name_v.push_back(llvm::ConstantInt::get(
                    llvm::Type::getInt8Ty(context), llvm::APInt(8, '\0')));
                llvm::Constant* name = llvm::ConstantArray::get(name_array_type, itr_var_name_v);
                enum_value_pairs[value_int64 - min_value] = llvm::ConstantStruct::get(
                    enum_value_type, {name, (llvm::Constant*) tmp});
            }

            llvm::ArrayType* global_enum_array = llvm::ArrayType::get(enum_value_type,
                                                    max_value - min_value + 1);
            llvm::Constant *array = module->getOrInsertGlobal(x.m_name,
                                        global_enum_array);
            module->getNamedGlobal(x.m_name)->setInitializer(
                llvm::ConstantArray::get(global_enum_array, enum_value_pairs));
            uint32_t h = get_hash((ASR::asr_t*)&x);
            llvm_symtab[h] = array;
        } else {
            size_t max_name_len = 0;

            for( auto itr: x.m_symtab->get_scope() ) {
                max_name_len = std::max(max_name_len, itr.first.size());
            }

            llvm::ArrayType* name_array_type = llvm::ArrayType::get(llvm::Type::getInt8Ty(context),
                                                                    max_name_len + 1);
            llvm::StructType* enum_value_type = llvm::StructType::create({name_array_type, value_type});
            std::vector<llvm::Constant*> enum_value_pairs(x.n_members, nullptr);

            for( auto itr: x.m_symtab->get_scope() ) {
                ASR::Variable_t* itr_var = ASR::down_cast<ASR::Variable_t>(itr.second);
                ASR::expr_t* value = itr_var->m_symbolic_value;
                int64_t value_int64 = -1;
                ASRUtils::extract_value(value, value_int64);
                this->visit_expr(*value);
                std::vector<llvm::Constant*> itr_var_name_v;
                itr_var_name_v.reserve(itr.first.size());
                for( size_t i = 0; i < itr.first.size(); i++ ) {
                    itr_var_name_v.push_back(llvm::ConstantInt::get(
                        llvm::Type::getInt8Ty(context), llvm::APInt(8, itr_var->m_name[i])));
                }
                itr_var_name_v.push_back(llvm::ConstantInt::get(
                    llvm::Type::getInt8Ty(context), llvm::APInt(8, '\0')));
                llvm::Constant* name = llvm::ConstantArray::get(name_array_type, itr_var_name_v);
                size_t dest_idx = 0;
                for( size_t j = 0; j < x.n_members; j++ ) {
                    if( std::string(x.m_members[j]) == itr.first ) {
                        dest_idx = j;
                        break ;
                    }
                }
                enum_value_pairs[dest_idx] = llvm::ConstantStruct::get(
                    enum_value_type, {name, (llvm::Constant*) tmp});
            }

            llvm::ArrayType* global_enum_array = llvm::ArrayType::get(enum_value_type,
                                                    x.n_members);
            llvm::Constant *array = module->getOrInsertGlobal(x.m_name,
                                        global_enum_array);
            module->getNamedGlobal(x.m_name)->setInitializer(
                llvm::ConstantArray::get(global_enum_array, enum_value_pairs));
            uint32_t h = get_hash((ASR::asr_t*)&x);
            llvm_symtab[h] = array;
        }
    }

    void start_module_init_function_prototype(const ASR::Module_t &x) {
        uint32_t h = get_hash((ASR::asr_t*)&x);
        llvm::FunctionType *function_type = llvm::FunctionType::get(
                llvm::Type::getVoidTy(context), {}, false);
        LCOMPILERS_ASSERT(llvm_symtab_fn.find(h) == llvm_symtab_fn.end());
        std::string module_fn_name = "__lfortran_module_init_" + std::string(x.m_name);
        llvm::Function *F = llvm::Function::Create(function_type,
                llvm::Function::ExternalLinkage, module_fn_name, module.get());
        llvm::BasicBlock *BB = llvm::BasicBlock::Create(context, ".entry", F);
        builder->SetInsertPoint(BB);

        llvm_symtab_fn[h] = F;
    }

    void finish_module_init_function_prototype(const ASR::Module_t &x) {
        uint32_t h = get_hash((ASR::asr_t*)&x);
        builder->CreateRetVoid();
        llvm_symtab_fn[h]->removeFromParent();
    }

    void visit_Module(const ASR::Module_t &x) {
        SymbolTable* current_scope_copy = current_scope;
        current_scope = x.m_symtab;
        mangle_prefix = "__module_" + std::string(x.m_name) + "_";

        start_module_init_function_prototype(x);
        std::vector<ASR::symbol_t*> variables;
        std::vector<ASR::symbol_t*> functions;
        std::vector<ASR::symbol_t*> structs;

        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Variable_t>(*item.second)) {
                variables.push_back(item.second);
            } else if (is_a<ASR::Function_t>(*item.second)) {
                functions.push_back(item.second);
            } else if (ASR::is_a<ASR::Struct_t>(*item.second)) {
                structs.push_back(item.second);
            }
        }
        // Visit in order: Function --> Struct --> Variables
        for (auto &sym: functions) {
            ASR::Function_t *v = down_cast<ASR::Function_t>(
                        sym);
            ASR::FunctionType_t* func_type = ASR::down_cast<ASR::FunctionType_t>(v->m_function_signature);
            if (x.m_parent_module && func_type->m_module) {
                mangle_prefix = "__module_" + std::string(x.m_parent_module) + "_";
            }
            instantiate_function(*v);
            mangle_prefix = "__module_" + std::string(x.m_name) + "_";
        }
        for (auto &sym: variables) {
            ASR::Variable_t *v = down_cast<ASR::Variable_t>(
                    sym);
            if( v->m_storage != ASR::storage_typeType::Parameter ) {
                visit_Variable(*v);
            }
        }
        finish_module_init_function_prototype(x);

        visit_procedures(x);
        mangle_prefix = "";
        current_scope = current_scope_copy;
    }

#ifdef HAVE_TARGET_WASM
    void add_wasm_start_function() {
        llvm::FunctionType *function_type = llvm::FunctionType::get(
            llvm::Type::getVoidTy(context), {}, false);
        llvm::Function *F = llvm::Function::Create(function_type,
                llvm::Function::ExternalLinkage, "_start", module.get());
        llvm::BasicBlock *BB = llvm::BasicBlock::Create(context, ".entry", F);
        builder->SetInsertPoint(BB);
        std::vector<llvm::Value *> args;
        args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, 0)));
        args.push_back(llvm_utils->CreateAlloca(*builder, character_type));
        builder->CreateCall(module->getFunction("main"), args);
        builder->CreateRet(nullptr);
    }
#endif

    void visit_Program(const ASR::Program_t &x) {
        llvm::DIScope* debug_current_scope_copy = debug_current_scope;
        llvm::DISubprogram *SP = nullptr;
        loop_head.clear();
        loop_head_names.clear();
        loop_or_block_end.clear();
        loop_or_block_end_names.clear();
        call_arg_alloca_pool.clear();
        call_arg_alloca_idx.clear();
        convert_call_args_depth = 0;
        strings_to_be_deallocated.reserve(al, 1);
        heap_fixed_size_arrays.reserve(al, 1);
        SymbolTable* current_scope_copy = current_scope;
        current_scope = x.m_symtab;
        bool is_dict_present_copy_lp = dict_api_lp->is_dict_present();
        bool is_dict_present_copy_sc = dict_api_sc->is_dict_present();
        dict_api_lp->set_is_dict_present(false);
        dict_api_sc->set_is_dict_present(false);
        bool is_set_present_copy_lp = set_api_lp->is_set_present();
        bool is_set_present_copy_sc = set_api_sc->is_set_present();
        set_api_lp->set_is_set_present(false);
        set_api_sc->set_is_set_present(false);
        llvm_goto_targets.clear();
        // Generate code for the main program
        std::vector<llvm::Type*> command_line_args = {
            llvm::Type::getInt32Ty(context),
            character_type->getPointerTo()
        };
        llvm::FunctionType *function_type = llvm::FunctionType::get(
                llvm::Type::getInt32Ty(context), command_line_args, false);
        llvm::Function *F = llvm::Function::Create(function_type,
                llvm::Function::ExternalLinkage, "main", module.get());
        llvm::BasicBlock *BB = llvm::BasicBlock::Create(context,
                ".entry", F);
        if (compiler_options.emit_debug_info) {
            debug_emit_function(x, SP);
            F->setSubprogram(SP);
            debug_current_scope = SP;
        }
        builder->SetInsertPoint(BB);
        if (compiler_options.emit_debug_info) {
            builder->SetCurrentDebugLocation(nullptr);
            debug_emit_loc(x);
        }

        // Generate code for nested subroutines and functions first:
        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Function_t>(*item.second)) {
                ASR::Function_t *v = down_cast<ASR::Function_t>(
                        item.second);
                instantiate_function(*v);
            }
        }
        visit_procedures(x);
        llvm_goto_targets.clear();

        builder->SetInsertPoint(BB);
        // Clear alloca pool after nested functions are processed, before main body
        call_arg_alloca_pool.clear();
        call_arg_alloca_idx.clear();
        convert_call_args_depth = 0;
        if (compiler_options.emit_debug_info) {
            debug_current_scope = SP;
            builder->SetCurrentDebugLocation(nullptr);
            debug_emit_loc(x);
        }
        // Call the `_lpython_call_initial_functions` function to assign command line argument
        // values to `argc` and `argv`, and set the random seed to the system clock.
        {
            if (compiler_options.emit_debug_info) debug_emit_loc(x);
            llvm::Function *fn = module->getFunction("_lpython_call_initial_functions");
            if(!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context),
                        character_type->getPointerTo()
                    }, false);
                fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, "_lpython_call_initial_functions", module.get());
            }
            std::vector<llvm::Value *> args;
            for (llvm::Argument &llvm_arg : F->args()) {
                args.push_back(&llvm_arg);
            }
            builder->CreateCall(fn, args);
        }
        // Enable floating point exception trapping if requested
        if (compiler_options.fpe_traps != 0) {
            if (compiler_options.emit_debug_info) debug_emit_loc(x);
            llvm::Function *fpe_fn = module->getFunction("_lfortran_enable_fpe_traps");
            if(!fpe_fn) {
                llvm::FunctionType *fpe_function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context)
                    }, false);
                fpe_fn = llvm::Function::Create(fpe_function_type,
                    llvm::Function::ExternalLinkage, "_lfortran_enable_fpe_traps", module.get());
            }
            llvm::Value *mask_val = llvm::ConstantInt::get(context,
                llvm::APInt(32, compiler_options.fpe_traps));
            builder->CreateCall(fpe_fn, {mask_val});
        }
        // Set runtime color preference based on compiler option (only when enabled)
        if (compiler_options.use_runtime_colors) {
            if (compiler_options.emit_debug_info) debug_emit_loc(x);
            llvm::Function *fn = module->getFunction("_lfortran_set_use_runtime_colors");
            if(!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context)
                    }, false);
                fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, "_lfortran_set_use_runtime_colors", module.get());
            }
            llvm::Value *use_colors = llvm::ConstantInt::get(context,
                llvm::APInt(32, 1));
            builder->CreateCall(fn, {use_colors});
        }
        for(to_be_allocated_array array : allocatable_array_details){
            fill_array_details_(array.expr, array.pointer_to_array_type, array.array_type, nullptr, array.n_dims,
                true, true, false, array.var_type);
        }
        for(auto& st : allocatable_struct_array_members_details) {
            allocate_array_members_of_struct(ASR::down_cast<ASR::Struct_t>(st.first),
                st.second, ASRUtils::symbol_type(st.first), false, false);
        }
        declare_vars(x);
        for(variable_inital_value var_to_initalize : variable_inital_value_vec){
            set_VariableInital_value(var_to_initalize.v, var_to_initalize.target_var);
        }
        proc_return = llvm::BasicBlock::Create(context, "return");
        predeclare_goto_targets(F, x.m_body, x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            this->visit_stmt(*x.m_body[i]);
        }
        {
            llvm::Function *fn = module->getFunction("_lpython_free_argv");
            if(!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {}, false);
                fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, "_lpython_free_argv", module.get());
            }
            builder->CreateCall(fn, {});
        }
        start_new_block(proc_return);
        llvm_symtab_finalizer.finalize_symtab(x.m_symtab);
        free_heap_fixed_size_arrays();
        llvm::Value *ret_val2 = llvm::ConstantInt::get(context,
            llvm::APInt(32, 0));
        builder->CreateRet(ret_val2);
        dict_api_lp->set_is_dict_present(is_dict_present_copy_lp);
        dict_api_sc->set_is_dict_present(is_dict_present_copy_sc);
        set_api_lp->set_is_set_present(is_set_present_copy_lp);
        set_api_sc->set_is_set_present(is_set_present_copy_sc);

        // Finalize the debug info.
        if (compiler_options.emit_debug_info) DBuilder->finalize();
        if (compiler_options.emit_debug_info) debug_current_scope = debug_current_scope_copy;
        current_scope = current_scope_copy;
        loop_head.clear();
        loop_head_names.clear();
        loop_or_block_end.clear();
        loop_or_block_end_names.clear();
        strings_to_be_deallocated.reserve(al, 1);

#ifdef HAVE_TARGET_WASM
        if (startswith(compiler_options.target, "wasm")) {
            add_wasm_start_function();
        }
#endif
    }

    /*
    * This function detects if the current variable is an argument.
    * of a function or argument. Some manipulations are to be done
    * only on arguments and not on local variables.
    */
    bool is_argument(ASR::Variable_t* v, ASR::expr_t** m_args,
                        int n_args) {
        for( int i = 0; i < n_args; i++ ) {
            ASR::expr_t* m_arg = m_args[i];
            uint32_t h_m_arg = get_hash((ASR::asr_t*)m_arg);
            uint32_t h_v = get_hash((ASR::asr_t*)v);
            if( h_m_arg == h_v ) {
                return true;
            }
        }
        return false;
    }

    void fill_array_details_(ASR::expr_t* expr, llvm::Value* ptr, llvm::Type* type_, ASR::dimension_t* m_dims,
        size_t n_dims, bool is_malloc_array_type, bool is_array_type,
        bool is_list, [[maybe_unused]]ASR::ttype_t* m_type, bool is_data_only=false) {
        // Skip function call for AssumedLength strings
        // Their descriptors come from the original parameter inside subroutines
        if (ASRUtils::is_character(*m_type)) {
            ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(
                ASRUtils::extract_type(m_type));
            if (str_type->m_len_kind == ASR::string_length_kindType::AssumedLength) {
                return;
            }
        }
        ASR::ttype_t* asr_data_type = ASRUtils::type_get_past_array(
            ASRUtils::type_get_past_pointer(
                ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(expr))));
        // Use the array element *storage* type (e.g. logical arrays are i8-backed).
        llvm::Type* llvm_data_type = llvm_utils->get_el_type(expr, asr_data_type, module.get());
        llvm::Value* ptr_ = nullptr;
        if( is_malloc_array_type && !is_list && !is_data_only ) {
            ptr_ = llvm_utils->CreateAlloca(*builder, type_, nullptr, "arr_desc");
            if(ASRUtils::is_character(*m_type)){
                llvm::Value* str_desc = create_and_setup_string_for_array(m_type, nullptr, false, "arr_desc_str_desc");
                builder->CreateStore(str_desc, arr_descr->get_pointer_to_data(type_, ptr_));
            } else if (ASRUtils::non_unlimited_polymorphic_class(m_type)){ 
                // For polymorphic allocatable arrays, set data pointer to NULL initially.
                // The wrapper will be allocated when `allocate` is called.
                auto const struct_sym = ASR::down_cast<ASR::Struct_t>(ASRUtils::get_struct_sym_from_struct_expr(expr));
                llvm::Type* const llvm_class_type = llvm_utils->getClassType(struct_sym);
                llvm::Value* const array_data = arr_descr->get_pointer_to_data(type_, ptr_);  
                builder->CreateStore(llvm::ConstantPointerNull::get(llvm_class_type->getPointerTo()), array_data);
            }
            arr_descr->fill_dimension_descriptor(type_, ptr_, n_dims);
        }
        if( is_array_type && !is_malloc_array_type &&
            !is_list ) {
            llvm::Type* ptr_typ = llvm_utils->get_type_from_ttype_t_util(expr, ASRUtils::expr_type(expr), module.get());
            fill_array_details(ptr_typ, ptr, llvm_data_type, m_dims, n_dims, is_data_only);
            // For non-allocatable DescriptorArray character arrays,
            // fill_array_details allocated an array of string_descriptors
            // but their data pointers are uninitialized. Set the string
            // length on descriptors[0], then allocate a contiguous
            // character data buffer via set_array_of_strings_memory_on_heap.
            if (!is_data_only && ASRUtils::is_character(*m_type)) {
                ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(
                    ASRUtils::extract_type(m_type));
                if (str_type->m_len != nullptr &&
                    str_type->m_len_kind == ASR::string_length_kindType::ExpressionLength) {
                    // Load descriptors[0] from the array's data pointer
                    llvm::Value* data_ptr_ptr = arr_descr->get_pointer_to_data(
                        ptr_typ, ptr);
                    llvm::Value* first_desc = builder->CreateLoad(
                        llvm_data_type->getPointerTo(), data_ptr_ptr);
                    // Set descriptors[0].length from the ASR string length
                    setup_string_length(first_desc, str_type, str_type->m_len);
                    // Compute array size (product of dimension lengths)
                    int64_t ptr_loads_copy = ptr_loads;
                    ptr_loads = 2;
                    llvm::Value* prod = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
                    for (size_t r = 0; r < n_dims; r++) {
                        load_array_size_deep_copy(m_dims[r].m_length);
                        prod = builder->CreateMul(prod, tmp);
                    }
                    ptr_loads = ptr_loads_copy;
                    // Allocate the flat character buffer
                    llvm_utils->set_array_of_strings_memory_on_heap(
                        str_type, first_desc,
                        llvm_utils->get_string_length(str_type, first_desc),
                        prod, false);
                }
            }
        }
        const bool special_array_type = ASRUtils::is_character(*m_type) || ASRUtils::non_unlimited_polymorphic_class(m_type); // already Nullified
        if( is_array_type && is_malloc_array_type &&
            !is_list && !is_data_only && !special_array_type) {
            // Set allocatable arrays as unallocated
            LCOMPILERS_ASSERT(ptr_ != nullptr);
            arr_descr->reset_is_allocated_flag(type_, ptr_, llvm_data_type);
        }
        if( ptr_ ) {
            LLVM::CreateStore(*builder, ptr_, ptr);
        }
    }
    
    void set_pointer_variable_to_null(ASR::Variable_t* v, llvm::Value* null_value, llvm::Value* ptr,
        bool ignore_intent = false) {
        // Initialize pointer/allocatable variables to NULL when:
        // - Type is Allocatable or Pointer
        // - Intent is local or return_var
        // - It's NOT a simple character type (but character arrays ARE included)
        if( (ASR::is_a<ASR::Allocatable_t>(*v->m_type) ||
                ASR::is_a<ASR::Pointer_t>(*v->m_type)) &&
            (ignore_intent ||
             v->m_intent == ASRUtils::intent_local ||
             v->m_intent == ASRUtils::intent_return_var ) &&
             (!ASRUtils::is_character(*v->m_type) ||
              ASRUtils::is_array(v->m_type))) {
            if (ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable_pointer(v->m_type))) {
                ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(v->m_type_declaration);
                llvm::Type* wrapper_struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(v->m_type, struct_sym, module.get());
                llvm::Value* struct_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                                        llvm::APInt(64, get_class_hash(struct_sym)));
                if ( compiler_options.new_classes ) {
                    builder->CreateStore(llvm::ConstantPointerNull::getNullValue(wrapper_struct_llvm_type), ptr);
                } else {
                    llvm::Type* v_llvm_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)), v->m_type, module.get());
                    llvm::Value* hash_ptr = llvm_utils->create_gep2(v_llvm_type, ptr, 0);
                    builder->CreateStore(struct_hash, hash_ptr);
                    llvm::Value* struct_ptr = llvm_utils->create_gep2(v_llvm_type, ptr, 1);
                    builder->CreateStore(llvm::ConstantPointerNull::getNullValue(wrapper_struct_llvm_type->getPointerTo()), struct_ptr);
                }
            } else {
                builder->CreateStore(null_value, ptr);
            }
        }
    }

    void allocate_array_members_of_struct(ASR::Struct_t* struct_sym, llvm::Value* ptr,
            ASR::ttype_t* asr_type, bool is_intent_out = false, bool initialize_val = true,
            bool skip_allocatable_array_descriptor_init = false) {
        LCOMPILERS_ASSERT(ASR::is_a<ASR::StructType_t>(*asr_type));
        ASR::Struct_t* struct_type_t = nullptr;
        if (ASR::is_a<ASR::StructType_t>(*asr_type)) {
            struct_type_t = struct_sym;
        } else {
            return;
        }

        if (ASRUtils::is_class_type(ASRUtils::extract_type(asr_type))) {
            llvm::Type* const class_type = llvm_utils->getClassType(struct_sym, false);
            llvm::Type* const struct_type = llvm_utils->getStructType(struct_sym, module.get(), true);
            ptr = llvm_utils->create_gep2(class_type, ptr, 1);
            ptr = llvm_utils->CreateLoad2(struct_type, ptr);
        }
        while (struct_type_t) {
            std::string struct_type_name = struct_type_t->m_name;
            for( auto item: struct_type_t->m_symtab->get_scope() ) {
                ASR::symbol_t *sym = ASRUtils::symbol_get_past_external(item.second);
                if (name2memidx[struct_type_name].find(item.first) == name2memidx[struct_type_name].end()) {
                    continue;
                }
                if( ASR::is_a<ASR::StructMethodDeclaration_t>(*sym) ||
                    ASR::is_a<ASR::GenericProcedure_t>(*sym) ||
                    ASR::is_a<ASR::Union_t>(*sym) ||
                    ASR::is_a<ASR::Struct_t>(*sym) ||
                    ASR::is_a<ASR::CustomOperator_t>(*sym) ) {
                    continue ;
                }
                ASR::ttype_t* symbol_type = ASRUtils::symbol_type(sym);
                int idx = 0;
                idx = name2memidx[struct_type_name][item.first];
                llvm::Type* type = name2dertype[struct_type_name];
                llvm::Value* ptr_member = llvm_utils->create_gep2(type, ptr, idx);
                ASR::Variable_t* v = nullptr;
                // Don't reinitialize arrays where the type's intent is out because array descriptor is allocated on the stack
                // and might be returned.
                if( ASR::is_a<ASR::Variable_t>(*sym) && !(is_intent_out ) ) {
                    v = ASR::down_cast<ASR::Variable_t>(sym);
                    if (compiler_options.new_classes &&
                            !LLVM::is_llvm_pointer(*v->m_type) &&
                            ASRUtils::is_class_type(ASRUtils::extract_type(v->m_type))) {
                        struct_api->store_class_vptr(ASRUtils::symbol_get_past_external(v->m_type_declaration), 
                            ptr_member, module.get());
                    } else {
                        set_pointer_variable_to_null(v, llvm::Constant::getNullValue(
                            llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                        al, v->base.base.loc, &v->base)), v->m_type, module.get())),
                            ptr_member, true);
                    }
                }
                if( ASRUtils::is_array(symbol_type) && v && !is_intent_out) {
                    if (skip_allocatable_array_descriptor_init && ASRUtils::is_allocatable(v->m_type)) {
                        continue;
                    }
                    ASR::dimension_t* m_dims = nullptr;
                    size_t n_dims = ASRUtils::extract_dimensions_from_ttype(symbol_type, m_dims);
                    ASR::array_physical_typeType phy_type = ASRUtils::extract_physical_type(symbol_type);
                    bool is_data_only = (phy_type == ASR::array_physical_typeType::PointerArray ||
                                        phy_type == ASR::array_physical_typeType::UnboundedPointerArray ||
                                        phy_type == ASR::array_physical_typeType::FixedSizeArray ||
                                        (phy_type == ASR::array_physical_typeType::StringArraySinglePointer &&
                                        ASRUtils::is_fixed_size_array(symbol_type)));
                    if (phy_type == ASR::array_physical_typeType::DescriptorArray ||
                        (phy_type == ASR::array_physical_typeType::StringArraySinglePointer &&
                        ASRUtils::is_dimension_empty(m_dims, n_dims))) {
                        int n_dims = 0, a_kind=4;
                        ASR::dimension_t* m_dims = nullptr;
                        bool is_array_type = false;
                        bool is_malloc_array_type = false;
                        bool is_list = false;
                        llvm_utils->get_type_from_ttype_t(ASRUtils::EXPR(ASR::make_Var_t(
                            al, v->base.base.loc, &v->base)), v->m_type,
                                    v->m_type_declaration, v->m_storage, is_array_type,
                                    is_malloc_array_type, is_list, m_dims, n_dims, a_kind,
                                    module.get());
                        llvm::Type* type_ = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(
                            ASR::make_Var_t(al, v->base.base.loc, &v->base)),
                            ASRUtils::type_get_past_pointer(
                                ASRUtils::type_get_past_allocatable(v->m_type)), module.get(), v->m_abi);
                        
                        if (compiler_options.new_classes) {
                            llvm::Value* arr = arr_descr->allocate_descriptor_on_heap(type_, n_dims);
                            builder->CreateStore(arr, ptr_member);

                            llvm::Value* ptr_to_dim_desc = llvm_utils->CreateLoad2(
                                arr_descr->get_dimension_descriptor_type(true),
                                llvm_utils->create_gep2(type_, arr, 2));

                            // Initialize dimension_descriptor
                            builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(32, 1)),
                                llvm_utils->create_gep2(arr_descr->get_dimension_descriptor_type(), ptr_to_dim_desc, 1));
                            builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(32, 1)),
                                llvm_utils->create_gep2(arr_descr->get_dimension_descriptor_type(), ptr_to_dim_desc, 2));

                            ASR::ttype_t* element_type = ASRUtils::type_get_past_array(
                                ASRUtils::type_get_past_allocatable_pointer(v->m_type));
                            // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                            llvm::Type* data_type = llvm_utils->get_el_type(
                                ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, &v->base)),
                                element_type, module.get());
                            if(ASRUtils::is_character(*v->m_type)){
                                llvm::Value* str_desc = create_and_setup_string_for_array(v->m_type, nullptr, false, "arr_desc_str_desc");
                                builder->CreateStore(str_desc, arr_descr->get_pointer_to_data(type_, arr));
                            } else {
                                arr_descr->reset_is_allocated_flag(type_, arr, data_type);
                            }

                        } else {
                            fill_array_details_(ASRUtils::EXPR(ASR::make_Var_t(
                                al, v->base.base.loc, &v->base)), ptr_member, type_, m_dims, n_dims,
                                is_malloc_array_type, is_array_type, is_list, v->m_type);
                        }
                    } else {
                        fill_array_details_(ASRUtils::EXPR(ASR::make_Var_t(
                            al, v->base.base.loc, &v->base)), ptr_member, nullptr, m_dims, n_dims, false, true, false, symbol_type, is_data_only);
                    }
                    if (ASR::is_a<ASR::StructType_t>(*ASRUtils::type_get_past_array(symbol_type))
                        && !ASRUtils::is_class_type(ASRUtils::type_get_past_array(symbol_type))) {
                        allocate_array_members_of_struct_arrays(ASRUtils::get_expr_from_sym(al, sym), ptr_member, symbol_type);
                    }
                } else if (ASR::is_a<ASR::StructType_t>(*symbol_type) && !ASRUtils::is_class_type(symbol_type)) {
                    ASR::Struct_t* struct_sym = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
                        ASR::down_cast<ASR::Variable_t>(sym)->m_type_declaration));
                    allocate_array_members_of_struct(struct_sym, ptr_member, symbol_type);
                }  else if(ASRUtils::is_string_only(symbol_type) && !is_intent_out) {
                    setup_string(ptr_member, symbol_type);
                }
                if( ASR::is_a<ASR::Variable_t>(*sym) && initialize_val) {
                    v = ASR::down_cast<ASR::Variable_t>(sym);
                    if( v->m_symbolic_value ) {
                        visit_expr(*v->m_symbolic_value);
                        if( ASR::is_a<ASR::PointerNullConstant_t>(*v->m_symbolic_value) &&
                            ASRUtils::is_array(v->m_type)){ // Store into array's data pointer.
                            LCOMPILERS_ASSERT(ASR::is_a<ASR::Pointer_t>(*v->m_type));
                            llvm::Value* pointer_array = builder->CreateLoad(
                                llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                                al, v->base.base.loc, &v->base)), v->m_type, module.get()),
                                ptr_member);
                            llvm::Type* const array_desc_type = llvm_utils->arr_api->get_array_type(
                                ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, (ASR::symbol_t*)v)),
                                ASRUtils::type_get_past_allocatable_pointer(v->m_type),
                                llvm_utils->get_el_type(
                                    ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, &v->base)),
                                    ASRUtils::extract_type(v->m_type),
                                    module.get()),
                                false);
                            builder->CreateStore(
                                tmp, llvm_utils->create_gep2(array_desc_type, pointer_array, 0));
                        } else if(ASRUtils::is_string_only(expr_type(v->m_symbolic_value))) {
                            llvm_utils->lfortran_str_copy(
                            ptr_member, tmp,
                            ASRUtils::get_string_type(symbol_type),
                            ASRUtils::get_string_type(expr_type(v->m_symbolic_value)),
                            ASRUtils::is_allocatable(symbol_type));
                        } else if (ASRUtils::is_array(v->m_type)) {
                            ASR::ArrayConstant_t* arr_const = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(v->m_symbolic_value));
                            llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::expr_value(v->m_symbolic_value), arr_const->m_type, module.get());
                            llvm::Value* arg_size = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context),
                            llvm::APInt(32, ASRUtils::get_fixed_size_of_array(arr_const->m_type)));
                            llvm::Type* llvm_data_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::expr_value(v->m_symbolic_value),
                                ASRUtils::type_get_past_array(ASRUtils::expr_type(v->m_symbolic_value)), module.get());
                            llvm::DataLayout data_layout(module->getDataLayout());
                            size_t dt_size = data_layout.getTypeAllocSize(llvm_data_type);
                            arg_size = builder->CreateMul(llvm::ConstantInt::get(
                                llvm::Type::getInt32Ty(context), llvm::APInt(32, dt_size)), arg_size);
                            builder->CreateMemCpy(llvm_utils->create_gep2(array_type,ptr_member, 0),
                                llvm::MaybeAlign(), tmp, llvm::MaybeAlign(), arg_size, v->m_is_volatile);
                        } else if ((ASRUtils::is_pointer(v->m_type) &&
                                !ASR::is_a<ASR::PointerNullConstant_t>(
                                    *v->m_symbolic_value))        ||
                            ASRUtils::is_allocatable(v->m_type)) { // Any non primitve
                            throw LCompilersException("Not implemented");
                        } else {
                            LLVM::CreateStore(*builder, tmp, ptr_member);
                        }
                    }
                }
            }
            if (struct_type_t->m_parent) {
                ptr = llvm_utils->create_gep2(name2dertype[struct_type_t->m_name], ptr, 0);
                struct_type_t = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(struct_type_t->m_parent));
            } else {
                struct_type_t = nullptr;
            }
        }
    }

    void allocate_array_members_of_struct_arrays(ASR::expr_t* expr, llvm::Value* ptr, ASR::ttype_t* v_m_type) {
        ASR::array_physical_typeType phy_type = ASRUtils::extract_physical_type(v_m_type);
        llvm::Type* el_type = llvm_utils->get_type_from_ttype_t_util(expr,
            ASRUtils::extract_type(v_m_type), module.get());
        llvm::Value* array_size = llvm_utils->CreateAlloca(
                llvm::Type::getInt32Ty(context), nullptr, "array_size");
        switch( phy_type ) {
            case ASR::array_physical_typeType::FixedSizeArray: {
                ASR::dimension_t* m_dims = nullptr;
                size_t n_dims = ASRUtils::extract_dimensions_from_ttype(v_m_type, m_dims);
                LLVM::CreateStore(*builder, llvm::ConstantInt::get(llvm::Type::getInt32Ty(context),
                    llvm::APInt(32, ASRUtils::get_fixed_size_of_array(m_dims, n_dims))), array_size);
                break;
            }
            case ASR::array_physical_typeType::DescriptorArray: {
                llvm::Type* ptr_type = llvm_utils->get_type_from_ttype_t_util(expr, ASRUtils::type_get_past_allocatable_pointer(v_m_type), module.get());
                llvm::Value* array_size_value = arr_descr->get_array_size(ptr_type, ptr, nullptr, 4);
                LLVM::CreateStore(*builder, array_size_value, array_size);
                break;
            }
            case ASR::array_physical_typeType::PointerArray: {
                ASR::dimension_t* m_dims = nullptr;
                size_t n_dims = ASRUtils::extract_dimensions_from_ttype(v_m_type, m_dims);
                llvm::Value* llvm_size = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 1));
                int ptr_loads_copy = ptr_loads;
                ptr_loads = 2;
                for( size_t i = 0; i < n_dims; i++ ) {
                    visit_expr_wrapper(m_dims[i].m_length, true);
                    llvm_size = builder->CreateMul(tmp, llvm_size);
                }
                ptr_loads = ptr_loads_copy;
                LLVM::CreateStore(*builder, llvm_size, array_size);
                break;
            }
            default: {
                LCOMPILERS_ASSERT_MSG(false, std::to_string(phy_type));
            }
        }
        llvm::Value* llvmi = llvm_utils->CreateAlloca(llvm::Type::getInt32Ty(context), nullptr, "i");
        llvm::Type* t = llvm::Type::getInt32Ty(context);
        LLVM::CreateStore(*builder,
            llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 0)), llvmi);
        create_loop(nullptr, [=]() {
                llvm::Value* llvmi_loaded = llvm_utils->CreateLoad2(t, llvmi);
                llvm::Value* array_size_loaded = llvm_utils->CreateLoad2(t, array_size);
                return builder->CreateICmpSLT(
                    llvmi_loaded, array_size_loaded);
            },
            [=]() {
                llvm::Value* ptr_i = nullptr;
                switch (phy_type) {
                    case ASR::array_physical_typeType::FixedSizeArray: {
                        llvm::Type* ptr_i_type = llvm_utils->get_type_from_ttype_t_util(expr, v_m_type, module.get());
                        ptr_i = llvm_utils->create_gep2(ptr_i_type, ptr, llvm_utils->CreateLoad2(t, llvmi));
                        break;
                    }
                    case ASR::array_physical_typeType::DescriptorArray: {
                        llvm::Type* ptr_i_type = llvm_utils->get_type_from_ttype_t_util(expr, ASRUtils::type_get_past_allocatable_pointer(v_m_type), module.get());
                        if (ASRUtils::is_class_type(ASRUtils::extract_type(v_m_type))) {
                            // For class arrays: data pointer points to a single class wrapper
                            // which contains [vptr, struct_array_ptr]
                            ASR::Struct_t* struct_sym = ASR::down_cast<ASR::Struct_t>(
                                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(expr)));
                            ASR::StructType_t* struct_type = ASR::down_cast<ASR::StructType_t>(
                                ASRUtils::extract_type(v_m_type));
                            llvm::Value* class_wrapper = llvm_utils->CreateLoad2(el_type->getPointerTo(),
                                arr_descr->get_pointer_to_data(ptr_i_type, ptr));
                            ptr_i = llvm_utils->get_class_element_from_array(struct_sym, struct_type,
                                class_wrapper, llvm_utils->CreateLoad2(t, llvmi));
                        } else {
                            ptr_i = llvm_utils->create_ptr_gep2(el_type,
                                llvm_utils->CreateLoad2(el_type->getPointerTo(), arr_descr->get_pointer_to_data(ptr_i_type, ptr)),
                                llvm_utils->CreateLoad2(t, llvmi));
                        }
                        break;
                    }
                    case ASR::array_physical_typeType::PointerArray: {
                        ptr_i = llvm_utils->create_ptr_gep2(el_type, ptr, llvm_utils->CreateLoad2(t, llvmi));
                        break;
                    }
                    default: {
                        LCOMPILERS_ASSERT(false);
                    }
                }
                allocate_array_members_of_struct(
                    ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(expr))),
                        ptr_i, ASRUtils::extract_type(v_m_type), false, true, true);
                LLVM::CreateStore(*builder,
                    builder->CreateAdd(llvm_utils->CreateLoad2(t, llvmi),
                        llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 1))),
                    llvmi);
            });
    }

    void create_vtab_for_struct_type(ASR::symbol_t* struct_type_sym, SymbolTable* symtab) {
        LCOMPILERS_ASSERT(ASR::is_a<ASR::Struct_t>(*struct_type_sym));
        ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(struct_type_sym);
        if( type2vtab.find(struct_type_sym) != type2vtab.end() &&
            type2vtab[struct_type_sym].find(symtab) != type2vtab[struct_type_sym].end() ) {
            return ;
        }
        if( type2vtabtype.find(struct_type_sym) == type2vtabtype.end() ) {
            std::vector<llvm::Type*> type_vec = {llvm_utils->getIntType(8)};
            type2vtabtype[struct_type_sym] = llvm::StructType::create(
                                                context, type_vec,
                                                std::string("__vtab_") +
                                                std::string(struct_type_t->m_name));
        }
        llvm::Type* vtab_type = type2vtabtype[struct_type_sym];
        llvm::Value* vtab_obj = llvm_utils->CreateAlloca(*builder, vtab_type);
        llvm::Value* struct_type_hash_ptr = llvm_utils->create_gep2(vtab_type, vtab_obj, 0);
        llvm::Value* struct_type_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
            llvm::APInt(64, get_class_hash(struct_type_sym)));
        builder->CreateStore(struct_type_hash, struct_type_hash_ptr);
        type2vtab[struct_type_sym][symtab] = vtab_obj;
        ASR::symbol_t* struct_type_ = struct_type_sym;
        bool base_found = false;
        while( !base_found ) {
            if( ASR::is_a<ASR::Struct_t>(*struct_type_) ) {
                ASR::Struct_t* struct_type = ASR::down_cast<ASR::Struct_t>(struct_type_);
                if( struct_type->m_parent == nullptr ) {
                    base_found = true;
                } else {
                    struct_type_ = ASRUtils::symbol_get_past_external(struct_type->m_parent);
                }
            } else {
                LCOMPILERS_ASSERT(false);
            }
        }
        class2vtab[struct_type_][symtab].push_back(vtab_obj);
    }

    void get_type_default_field_values(ASR::symbol_t* struct_sym,
            std::vector<llvm::Constant*>& field_values, ASR::symbol_t* orig_struct_sym) {
        struct_sym = ASRUtils::symbol_get_past_external(struct_sym);
        ASR::Struct_t* struct_t = ASR::down_cast<ASR::Struct_t>(struct_sym);

        if (compiler_options.new_classes) {
            if (struct_t->m_parent != nullptr) {
                std::vector<llvm::Constant*> tmp_field_values;
                get_type_default_field_values(struct_t->m_parent, tmp_field_values, orig_struct_sym);
                llvm::StructType* llvm_struct_type = llvm::cast<llvm::StructType>(
                    llvm_utils->get_type_from_ttype_t_util(ASRUtils::symbol_type(
                        struct_t->m_parent), struct_t->m_parent, module.get()));
                field_values.push_back(llvm::ConstantStruct::get(llvm_struct_type, tmp_field_values));
            }
        }
        for (size_t i = 0; i < struct_t->n_members; i++) {
            std::string member_name = struct_t->m_members[i];
            ASR::symbol_t* sym = struct_t->m_symtab->get_symbol(member_name);
            if (!sym || !ASR::is_a<ASR::Variable_t>(*sym))
                continue;
            ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(sym);
            if (var->m_value != nullptr) {
                llvm::Constant* c = create_llvm_constant_from_asr_expr(var->m_value, orig_struct_sym);
                field_values.push_back(c);
            } else {
                llvm::Type* member_type = llvm_utils->get_type_from_ttype_t_util(
                    ASRUtils::EXPR(ASR::make_Var_t(al, var->base.base.loc, &var->base)),var->m_type, module.get());
                field_values.push_back(llvm::Constant::getNullValue(member_type));
            }
        }
    }

    llvm::Constant* create_llvm_constant_from_asr_expr(ASR::expr_t* expr,
            ASR::symbol_t* orig_struct_sym = nullptr) {
        ASR::expr_t* expr_value = ASRUtils::expr_value(expr);
        if (expr_value != nullptr && expr_value != expr) {
            return create_llvm_constant_from_asr_expr(expr_value, orig_struct_sym);
        }
        switch (expr->type) {
            case ASR::exprType::IntegerConstant: {
                ASR::IntegerConstant_t* ic = ASR::down_cast<ASR::IntegerConstant_t>(expr);
                llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(nullptr, ic->m_type, module.get());
                return llvm::ConstantInt::get(llvm_type, ic->m_n, true);
            }
            case ASR::exprType::UnsignedIntegerConstant: {
                ASR::UnsignedIntegerConstant_t* uic = ASR::down_cast<ASR::UnsignedIntegerConstant_t>(expr);
                llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(nullptr, uic->m_type, module.get());
                return llvm::ConstantInt::get(llvm_type, uic->m_n, false);
            }
            case ASR::exprType::LogicalConstant: {
                ASR::LogicalConstant_t* lc = ASR::down_cast<ASR::LogicalConstant_t>(expr);
                llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(nullptr, lc->m_type, module.get());
                return llvm::ConstantInt::get(llvm_type, lc->m_value ? 1 : 0, false);
            }
            case ASR::exprType::RealConstant: {
                ASR::RealConstant_t* rc = ASR::down_cast<ASR::RealConstant_t>(expr);
                llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(nullptr, rc->m_type, module.get());
                if (llvm_type->isFloatTy()) {
                    return llvm::ConstantFP::get(llvm_type, static_cast<float>(rc->m_r));
                } else if (llvm_type->isDoubleTy()) {
                    return llvm::ConstantFP::get(llvm_type, rc->m_r);
                }
                break;
            }
            case ASR::exprType::StructConstant: {
                std::vector<llvm::Constant*> field_values;
                ASR::symbol_t* struct_sym = ASRUtils::get_struct_sym_from_struct_expr(expr);
                if (orig_struct_sym == nullptr) {
                    orig_struct_sym = struct_sym;
                }
                get_type_default_field_values(struct_sym, field_values, orig_struct_sym);
                llvm::StructType* llvm_struct_type = llvm::cast<llvm::StructType>(
                    llvm_utils->get_type_from_ttype_t_util(expr, ASRUtils::expr_type(expr), module.get()));
                return llvm::ConstantStruct::get(llvm_struct_type, field_values);
            }
            case ASR::exprType::PointerNullConstant: {
                ASR::PointerNullConstant_t* pnc = ASR::down_cast<ASR::PointerNullConstant_t>(expr);
                llvm::Type* value_type = ASRUtils::is_array(pnc->m_type)
                    ? llvm_utils->get_type_from_ttype_t_util(pnc->m_var_expr,
                        ASRUtils::extract_type(pnc->m_type), module.get())->getPointerTo()
                    : llvm_utils->get_type_from_ttype_t_util(pnc->m_var_expr, pnc->m_type, module.get());
                return llvm::ConstantPointerNull::get(llvm::cast<llvm::PointerType>(value_type));
            }
            default:
                throw LCompilersException( "Unsupported constant expression in struct default initializer.");
        }
        return nullptr;
    }

    void collect_variable_types_and_struct_types(
        std::set<std::string>& variable_type_names,
        std::vector<ASR::symbol_t*>& struct_types,
        SymbolTable* x_symtab) {
        if (x_symtab == nullptr) {
            return ;
        }
        for (auto &item : x_symtab->get_scope()) {
            ASR::symbol_t* var_sym = item.second;
            if (ASR::is_a<ASR::Variable_t>(*var_sym)) {
                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(var_sym);
                ASR::ttype_t* v_type = ASRUtils::extract_type(v->m_type);
                if (ASR::is_a<ASR::StructType_t>(*v_type)) {
                    variable_type_names.insert(ASRUtils::symbol_name(var_sym));
                }
            } else if (ASR::is_a<ASR::Struct_t>(
                        *ASRUtils::symbol_get_past_external(var_sym))) {
                struct_types.push_back(ASRUtils::symbol_get_past_external(var_sym));
            }
        }
        collect_variable_types_and_struct_types(variable_type_names, struct_types, x_symtab->parent);
    }
    void set_VariableInital_value(ASR::Variable_t* v, llvm::Value* target_var){
        if (v->m_value != nullptr) {
            this->visit_expr_wrapper(v->m_value, true, v->m_is_volatile);
        } else {
            this->visit_expr_wrapper(v->m_symbolic_value, true, v->m_is_volatile);
        }
        llvm::Value *init_value = tmp;
        if( ASRUtils::is_array(v->m_type) &&
            ASRUtils::is_array(ASRUtils::expr_type(v->m_symbolic_value)) &&
            (ASR::is_a<ASR::ArrayConstant_t>(*v->m_symbolic_value) ||
            (v->m_value && ASR::is_a<ASR::ArrayConstant_t>(*v->m_value)))) {
            ASR::array_physical_typeType target_ptype = ASRUtils::extract_physical_type(v->m_type);
            if( target_ptype == ASR::array_physical_typeType::DescriptorArray ) {
                llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)), v->m_type, module.get());
                target_var = arr_descr->get_pointer_to_data(target_type, target_var);
                builder->CreateStore(init_value, target_var, v->m_is_volatile);
            } else if( target_ptype == ASR::array_physical_typeType::FixedSizeArray ) {
                llvm::Value* arg_size = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context),
                llvm::APInt(32, ASRUtils::get_fixed_size_of_array(ASR::down_cast<ASR::ArrayConstant_t>(v->m_value)->m_type)));
                llvm::Type* llvm_data_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)),
                    ASRUtils::type_get_past_array(ASRUtils::expr_type(v->m_value)), module.get());
                llvm::DataLayout data_layout(module->getDataLayout());
                size_t dt_size = data_layout.getTypeAllocSize(llvm_data_type);
                arg_size = builder->CreateMul(llvm::ConstantInt::get(
                    llvm::Type::getInt32Ty(context), llvm::APInt(32, dt_size)), arg_size);
                llvm::Type* llvm_type
                    = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)), v->m_type, module.get());
                builder->CreateMemCpy(llvm_utils->create_gep2(llvm_type,target_var, 0),
                    llvm::MaybeAlign(), init_value, llvm::MaybeAlign(), arg_size, v->m_is_volatile);
            } else if(target_ptype == ASR::PointerArray){
                if(ASRUtils::is_array_of_strings(v->m_type)){
                    builder->CreateMemCpy(
                        llvm_utils->get_stringArray_data(v->m_type, target_var), llvm::MaybeAlign(),
                        llvm_utils->get_stringArray_data(v->m_type, init_value), llvm::MaybeAlign(),
                        llvm_utils->get_stringArray_whole_size(v->m_type));
                } else {
                    throw LCompilersException("Unhandled Array Type");
                }
            } else {
                throw LCompilersException("Unhandled ArrayPhysicalType");
            }
        } else if (ASR::is_a<ASR::ArrayReshape_t>(*v->m_symbolic_value)) {
            llvm::Type* arr_type = llvm_utils->get_type_from_ttype_t_util(
                v->m_symbolic_value, ASRUtils::expr_type(v->m_symbolic_value), module.get());
            builder->CreateStore(builder->CreateLoad(arr_type, init_value), target_var, v->m_is_volatile);
        } else if (is_a<ASR::String_t>(*v->m_type)) {
            ASR::String_t *t = down_cast<ASR::String_t>(v->m_type);
            visit_expr(*t->m_len);
            if( t->m_len_kind == ASR::string_length_kindType::DeferredLength ){LCOMPILERS_ASSERT(false);}
            // target decides if the str_copy is performed on string descriptor or pointer.
            tmp = llvm_utils->lfortran_str_copy(
                target_var, init_value,
                ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(v->m_type)),
                ASR::down_cast<ASR::String_t>((ASRUtils::extract_type(expr_type(v->m_symbolic_value? v->m_symbolic_value : v->m_value)))),
                ASRUtils::is_allocatable(v->m_type));
            if (v->m_intent == intent_local) {
                llvm::Type* v_llvm_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)), v->m_type, module.get());
                strings_to_be_deallocated.push_back(al, llvm_utils->CreateLoad2(v_llvm_type, target_var, v->m_is_volatile));
            }
        } else if(ASRUtils::is_array(v->m_type) &&
                (ASR::is_a<ASR::PointerNullConstant_t>(*v->m_symbolic_value) ||
                (v->m_value && ASR::is_a<ASR::PointerNullConstant_t>(*v->m_value)))){
                LCOMPILERS_ASSERT(ASR::is_a<ASR::Pointer_t>(*v->m_type));
                LCOMPILERS_ASSERT(ASRUtils::extract_physical_type(v->m_type) ==
                                     ASR::array_physical_typeType::DescriptorArray);
                llvm::Type* const array_desc_type = llvm_utils->arr_api->get_array_type(
                    ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, (ASR::symbol_t*)v)),
                    ASRUtils::type_get_past_allocatable_pointer(v->m_type),
                    llvm_utils->get_el_type(
                        ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, &v->base)),
                        ASRUtils::extract_type(v->m_type),
                        module.get()),
                    false);
                llvm::Value* data_ptr = llvm_utils->create_gep2(
                    array_desc_type, llvm_utils->CreateLoad2(array_desc_type->getPointerTo(), target_var), 0);
                builder->CreateStore(init_value, data_ptr, v->m_is_volatile);
        } else {
            if (v->m_storage == ASR::storage_typeType::Save
                && v->m_value
                && ((ASR::is_a<ASR::Integer_t>(*v->m_type)
                || ASR::is_a<ASR::Real_t>(*v->m_type)
                || ASR::is_a<ASR::Logical_t>(*v->m_type))
                || (ASR::is_a<ASR::ArrayConstant_t>(*v->m_value)
                && ASRUtils::is_array(v->m_type)
                && ASRUtils::extract_physical_type(v->m_type)
                    == ASR::array_physical_typeType::FixedSizeArray
                && (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_array(v->m_type))
                    || ASR::is_a<ASR::Real_t>(*ASRUtils::type_get_past_array(v->m_type))
                    || ASR::is_a<ASR::Logical_t>(*ASRUtils::type_get_past_array(v->m_type)))))
                && !v->m_is_volatile) {
                // Do nothing, the value is already initialized
                // in the global variable
            } else {
                builder->CreateStore(init_value, target_var, v->m_is_volatile);
            }
        }
    }

    template<typename T>
    void process_Variable(ASR::symbol_t* var_sym, T& x, uint32_t &debug_arg_count) {
        llvm::Value *target_var = nullptr;
        ASR::Variable_t *v = down_cast<ASR::Variable_t>(var_sym);
        uint32_t h = get_hash((ASR::asr_t*)v);
        llvm::Type *type;
        int n_dims = 0, a_kind = 4;
        ASR::dimension_t* m_dims = nullptr;
        bool is_array_type = false;
        bool is_malloc_array_type = false;
        bool is_list = false;
        bool is_dict = ASR::is_a<ASR::Dict_t>(*v->m_type);
        bool is_tuple = ASR::is_a<ASR::Tuple_t>(*v->m_type);
        if (v->m_intent == intent_local ||
            v->m_intent == intent_return_var ||
            !v->m_intent) {
            type = llvm_utils->get_type_from_ttype_t(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)),
                v->m_type, v->m_type_declaration, v->m_storage, is_array_type,
                is_malloc_array_type, is_list, m_dims, n_dims, a_kind, module.get());
            llvm::Type* type_ = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)),
                ASRUtils::type_get_past_pointer(
                    ASRUtils::type_get_past_allocatable(v->m_type)), module.get(), v->m_abi);

            /*
            * The following if block is used for converting any
            * general array descriptor to a pointer type which
            * can be passed as an argument in a function call in LLVM IR.
            */
            if( x.class_type == ASR::symbolType::Function) {
                std::string m_name = std::string(x.m_name);
                ASR::Function_t* _func = (ASR::Function_t*)(&(x.base));
                std::uint32_t m_h = get_hash((ASR::asr_t*)_func);
                ASR::abiType abi_type = ASRUtils::get_FunctionType(_func)->m_abi;
                bool is_v_arg = is_argument(v, _func->m_args, _func->n_args);
                if( is_array_type && !is_list && !is_dict) {
                    /* The first element in an array descriptor can be either of
                    * llvm::ArrayType or llvm::PointerType. However, a
                    * function only accepts llvm::PointerType for arrays. Hence,
                    * the following if block extracts the pointer to first element
                    * of an array from its descriptor. Note that this happens only
                    * for arguments and not for local function variables.
                    */
                    if( abi_type == ASR::abiType::Source && is_v_arg ) {
                        type = arr_descr->get_argument_type(type, m_h, v->m_name, arr_arg_type_cache);
                        is_array_type = false;
                    } else if( abi_type == ASR::abiType::Intrinsic &&
                        fname2arg_type.find(m_name) != fname2arg_type.end() ) {
                        type = fname2arg_type[m_name].second;
                        is_array_type = false;
                    }
                }
            }

            llvm::Value* array_size = nullptr;
            bool is_array_of_strings = ASRUtils::is_array(v->m_type) && ASRUtils::is_character(*v->m_type);
            if( ASRUtils::is_array(v->m_type) &&
                ASRUtils::extract_physical_type(v->m_type) ==
                ASR::array_physical_typeType::PointerArray &&
                !LLVM::is_llvm_pointer(*v->m_type) ) {
                ASR::ttype_t* element_type = ASRUtils::type_get_past_array(v->m_type);
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                type = llvm_utils->get_el_type(
                    ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, &v->base)),
                    element_type, module.get());
                ASR::dimension_t* m_dims = nullptr;
                size_t n_dims = ASRUtils::extract_dimensions_from_ttype(v->m_type, m_dims);
                array_size = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 1));
                int ptr_loads_copy = ptr_loads;
                ptr_loads = 2;
                for( size_t i = 0; i < n_dims; i++ ) {
                    this->visit_expr_wrapper(m_dims[i].m_length, true);

                    if (m_dims[i].m_length != nullptr &&  ASR::is_a<ASR::Var_t>(*m_dims[i].m_length)) {
                        ASR::Var_t* m_length_var = ASR::down_cast<ASR::Var_t>(m_dims[i].m_length);
                        ASR::symbol_t* m_length_sym = ASRUtils::symbol_get_past_external(m_length_var->m_v);
                        if (m_length_sym != nullptr && ASR::is_a<ASR::Variable_t>(*m_length_sym)) {
                            ASR::Variable_t* m_length_variable = ASR::down_cast<ASR::Variable_t>(m_length_sym);
                            uint32_t m_length_variable_h = get_hash((ASR::asr_t*)m_length_variable);
                            llvm::Type* deep_type = llvm_utils->get_type_from_ttype_t_util(m_dims[i].m_length, ASRUtils::expr_type(m_dims[i].m_length), module.get());
                            llvm::Value* deep = new llvm::GlobalVariable(
                                    *module,
                                    deep_type,
                                    false,
                                    llvm::GlobalValue::InternalLinkage,
                                    llvm::Constant::getNullValue(deep_type),
                                    "deep_" + std::to_string(global_deep_count++));
                            builder->CreateStore(tmp, deep, v->m_is_volatile);
                            llvm::Type* m_dims_length_llvm_type = llvm_utils->get_type_from_ttype_t_util(m_dims[i].m_length, ASRUtils::expr_type(m_dims[i].m_length), module.get());
                            tmp = llvm_utils->CreateLoad2(m_dims_length_llvm_type,deep, v->m_is_volatile);
                            llvm_symtab_deep_copy[{m_length_variable_h, current_scope}] = deep;
                        }
                    }

                    // Make dimension length and return size compatible.(TODO : array_size should be of type int64)
                    if(ASRUtils::extract_kind_from_ttype_t(
                        ASRUtils::expr_type(m_dims[i].m_length)) > 4){
                        tmp = builder->CreateTrunc(tmp, llvm::IntegerType::get(context, 32));
                    } else if (ASRUtils::extract_kind_from_ttype_t(
                        ASRUtils::expr_type(m_dims[i].m_length)) < 4){
                        tmp = builder->CreateSExt(tmp, llvm::IntegerType::get(context, 32));
                    }

                    array_size = builder->CreateMul(array_size, tmp);
                }
                ptr_loads = ptr_loads_copy;
            }
            llvm::Value *ptr = nullptr;
            // Allocate the variable
            if( !compiler_options.stack_arrays && array_size ) { // malloc for PointerArray
                if(is_array_of_strings){
                    ptr = create_and_setup_string_for_array(v->m_type, array_size, compiler_options.stack_arrays, v->m_name);
                } else {
                    llvm::DataLayout data_layout(module->getDataLayout());
                    uint64_t size = data_layout.getTypeAllocSize(type);
                    array_size = builder->CreateMul(array_size,
                        llvm::ConstantInt::get(context, llvm::APInt(32, size)));
                    llvm::Value* ptr_i8 = LLVMArrUtils::lfortran_malloc(
                        context, *module, *builder, array_size);
                    ptr = builder->CreateBitCast(ptr_i8, type->getPointerTo());
                }
            } else if(ASRUtils::is_string_only(v->m_type)){
                if(v->m_storage == ASR::Save || v->m_storage == ASR::Parameter){
                    if(v->m_storage == ASR::Parameter) {LCOMPILERS_ASSERT(v->m_symbolic_value)}
                    std::string str_initial_value_string {};
                    if(v->m_symbolic_value){ // Get initial value if exist.
                        char* str_inital_value{};
                        ASRUtils::extract_value(ASRUtils::expr_value(v->m_symbolic_value), str_inital_value);
                        int str_initial_value_len{};
                        ASRUtils::extract_value(ASRUtils::expr_value(
                            ASRUtils::get_string_type(ASRUtils::expr_type(v->m_symbolic_value))->m_len),
                            str_initial_value_len);
                        str_initial_value_string = std::string(str_inital_value, str_initial_value_len);
                    }
                    ptr = llvm_utils->declare_global_string(ASRUtils::get_string_type(v->m_type),
                            str_initial_value_string, false,
                            v->m_name);
                } else {
                    // Create String + Set it up
                    ptr = llvm_utils->create_string(ASRUtils::get_string_type(v->m_type), v->m_name);
                    setup_string(ptr, v->m_type);
                }
            } else { // Alloca for rest of types (not its internals if exist).
                if (v->m_storage == ASR::storage_typeType::Save) {
                    std::string parent_function_name = std::string(x.m_name);
                    std::string global_name = parent_function_name+ "." + v->m_name;
                    ptr = module->getOrInsertGlobal(global_name, type);
                    llvm::GlobalVariable *gptr = module->getNamedGlobal(global_name);
                    gptr->setLinkage(llvm::GlobalValue::InternalLinkage);
                    llvm::Constant *init_value;
                    if (v->m_value
                            && (ASR::is_a<ASR::Integer_t>(*v->m_type)
                            || ASR::is_a<ASR::Real_t>(*v->m_type)
                            || ASR::is_a<ASR::Logical_t>(*v->m_type))) {
                        this->visit_expr(*v->m_value);
                        init_value = llvm::dyn_cast<llvm::Constant>(tmp);
                    } else if (v->m_value
                            && ASR::is_a<ASR::ArrayConstant_t>(*v->m_value)
                            && ASRUtils::is_array(v->m_type)
                            && ASRUtils::extract_physical_type(v->m_type)
                                == ASR::array_physical_typeType::FixedSizeArray
                            && (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_array(v->m_type))
                                || ASR::is_a<ASR::Real_t>(*ASRUtils::type_get_past_array(v->m_type))
                                || ASR::is_a<ASR::Logical_t>(*ASRUtils::type_get_past_array(v->m_type)))) {
                        llvm::Type* el_type = type->getArrayElementType();
                        init_value = get_const_array(v->m_value, el_type);
                    } else {
                        init_value = llvm::Constant::getNullValue(type);
                    }
                    gptr->setInitializer(init_value);
                } else {
                    // Large fixed-size arrays (> 4KB-1) use heap allocation to prevent stack overflow.
                    // This is recursion-safe unlike static storage, as each call gets its own copy.
                    // Memory is freed at function exit.
                    // BLOCK constructs always use heap regardless of size (can be in loops).
                    constexpr uint64_t MAX_STACK_ARRAY_SIZE = 4 * 1024 - 1;  // 4KB arrays and above use heap
                    bool use_heap_allocation = false;
                    uint64_t type_size = 0;
                    if (!compiler_options.stack_arrays &&
                        ASRUtils::is_array(v->m_type) &&
                        ASRUtils::extract_physical_type(v->m_type) ==
                            ASR::array_physical_typeType::FixedSizeArray) {
                        const llvm::DataLayout& data_layout = module->getDataLayout();
                        type_size = data_layout.getTypeAllocSize(type);
                        // BLOCKs always use heap (can be in loops), others use threshold
                        if (in_block_context || type_size > MAX_STACK_ARRAY_SIZE) {
                            use_heap_allocation = true;
                        }
                    }

                    if (use_heap_allocation) {
                        // Allocate on heap to avoid stack overflow (recursion-safe)
                        llvm::Value* malloc_size = llvm::ConstantInt::get(
                            llvm_utils->getIntType(8), llvm::APInt(64, type_size));
                        llvm::Value* ptr_i8 = LLVMArrUtils::lfortran_malloc(
                            context, *module, *builder, malloc_size);
                        ptr = builder->CreateBitCast(ptr_i8, type->getPointerTo());
                        // Track for cleanup at function exit
                        heap_fixed_size_arrays.push_back(al, ptr_i8);
                    } else {
#if LLVM_VERSION_MAJOR >= 15
                        bool is_llvm_ptr = false;
                        if ( LLVM::is_llvm_pointer(*v->m_type) &&
                                !ASRUtils::is_class_type(ASRUtils::type_get_past_pointer(
                                ASRUtils::type_get_past_allocatable(v->m_type))) &&
                                !ASRUtils::is_descriptorString(v->m_type) ) {
                            is_llvm_ptr = true;
                        }
                        ptr = llvm_utils->CreateAlloca(*builder, type_, array_size,
                            v->m_name, is_llvm_ptr);
#else
                        ptr = llvm_utils->CreateAlloca(*builder, type, array_size, v->m_name);
#endif
                    }
                }
            }
            if (compiler_options.new_classes && !LLVM::is_llvm_pointer(*v->m_type) &&
                    ASRUtils::is_class_type(ASRUtils::extract_type(v->m_type))) {
                struct_api->store_class_vptr(ASRUtils::symbol_get_past_external(v->m_type_declaration),
                    ptr, module.get());
            } else {
                set_pointer_variable_to_null(v, llvm::ConstantPointerNull::get(
                    static_cast<llvm::PointerType*>(type)), ptr);
            }
            // std::cout<< "Allocated variable " << v->m_name << " of type ";
            // type->print(llvm::outs()); llvm::outs() << "\n";
            // type_->print(llvm::outs()); llvm::outs() << "\n";
            ASR::expr_t* var_expr = ASRUtils::EXPR(ASR::make_Var_t(al, v->base.base.loc, &v->base));
            // Initialize non-primitve types
            if( ASR::is_a<ASR::StructType_t>(
                *ASRUtils::type_get_past_array(v->m_type))
                && !ASRUtils::is_class_type(
                    ASRUtils::type_get_past_array(v->m_type))) {
                if( ASRUtils::is_array(v->m_type) ) {
                    // For DescriptorArray, the array descriptor (ndim, dim_desc, data
                    // ptr) is not initialized yet at this point. Defer the member
                    // initialization until after fill_array_details_ sets it up.
                    if (ASRUtils::extract_physical_type(v->m_type) !=
                            ASR::array_physical_typeType::DescriptorArray) {
                        allocate_array_members_of_struct_arrays(var_expr, ptr, v->m_type);
                    }
                } else {
                    allocate_array_members_of_struct(ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(var_expr))), ptr, v->m_type);
                }
            }
            if (compiler_options.emit_debug_info) {
                // Reset the debug location
                builder->SetCurrentDebugLocation(nullptr);
                uint32_t line, column;
                debug_get_line_column(v->base.base.loc.first, line, column);
                std::string type_name;
                uint32_t type_size, type_encoding;
                get_type_debug_info(v->m_type, type_name, type_size,
                    type_encoding);
                llvm::DIType* di_type = DBuilder->createBasicType(
                    type_name, type_size, type_encoding);
                llvm::DILocalVariable* debug_var = nullptr;
                if (v->m_intent == ASR::intentType::In ||
                    v->m_intent == ASR::intentType::Out ||
                    v->m_intent == ASR::intentType::InOut ||
                    v->m_intent == ASR::intentType::Unspecified) {
                    debug_var = DBuilder->createParameterVariable(
                        debug_current_scope, v->m_name, ++debug_arg_count, debug_Unit, line,
                        di_type, true);
                } else {
                    debug_var = DBuilder->createAutoVariable(
                        debug_current_scope, v->m_name, debug_Unit, line,
                        di_type, true);
                }
                DBuilder->insertDeclare(ptr, debug_var, DBuilder->createExpression(),
                    llvm::DILocation::get(debug_current_scope->getContext(),
                    line, 0, debug_current_scope), builder->GetInsertBlock());
            }

            if( ASR::is_a<ASR::StructType_t>(*v->m_type) && !ASRUtils::is_class_type(v->m_type) ) {
                ASR::Struct_t* struct_type = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(v->m_type_declaration));
                int64_t alignment_value = -1;
                if( ASRUtils::extract_value(struct_type->m_alignment, alignment_value) ) {
                    llvm::Align align(alignment_value);
                    reinterpret_cast<llvm::AllocaInst*>(ptr)->setAlignment(align);
                }
            }
            llvm_symtab[h] = ptr;
            if( (ASRUtils::is_array(v->m_type) &&
                ((ASRUtils::extract_physical_type(v->m_type) == ASR::array_physical_typeType::DescriptorArray) ||
                (ASRUtils::extract_physical_type(v->m_type) == ASR::array_physical_typeType::StringArraySinglePointer &&
                ASRUtils::is_dimension_empty(m_dims,n_dims))))
            ) {
                fill_array_details_(ASRUtils::EXPR(ASR::make_Var_t(
                    al, v->base.base.loc, &v->base)), ptr, type_, m_dims, n_dims,
                    is_malloc_array_type, is_array_type, is_list, v->m_type);
                // Now that the descriptor is initialized, initialize allocatable
                // members of each element for DescriptorArray struct arrays.
                if( ASR::is_a<ASR::StructType_t>(
                        *ASRUtils::type_get_past_array(v->m_type))
                    && !ASRUtils::is_class_type(
                        ASRUtils::type_get_past_array(v->m_type))
                    && ASRUtils::extract_physical_type(v->m_type) ==
                        ASR::array_physical_typeType::DescriptorArray
                    && !is_malloc_array_type ) {
                    allocate_array_members_of_struct_arrays(var_expr, ptr, v->m_type);
                }
            }
            ASR::expr_t* init_expr = v->m_symbolic_value;
            if( v->m_storage != ASR::storage_typeType::Parameter ) {
                for( size_t i = 0; i < v->n_dependencies; i++ ) {
                    std::string variable_name = v->m_dependencies[i];
                    ASR::symbol_t* dep_sym = x.m_symtab->resolve_symbol(variable_name);
                    if (dep_sym) {
                        if (ASR::is_a<ASR::Variable_t>(*dep_sym)) {
                            ASR::Variable_t* dep_v = ASR::down_cast<ASR::Variable_t>(dep_sym);
                            if ( dep_v->m_symbolic_value == nullptr &&
                                !(ASRUtils::is_array(dep_v->m_type) && ASRUtils::extract_physical_type(dep_v->m_type) ==
                                    ASR::array_physical_typeType::FixedSizeArray)) {
                                init_expr = nullptr;
                                break;
                            }
                        }
                    }
                }
            }
            if( init_expr != nullptr && !is_list && !is_dict && !is_tuple) {
                target_var = ptr;
                if ((v->m_storage == ASR::Save   ||
                    v->m_storage == ASR::Parameter)
                    && 
                    ASRUtils::is_string_only(v->m_type)) {
                    // DO Nothing
                    // (String + Save) variable is declared as global llvm variable with the intended inital value
                } else if(v->m_storage == ASR::storage_typeType::Save &&
                    ASR::is_a<ASR::Function_t>(
                        *ASR::down_cast<ASR::symbol_t>(v->m_parent_symtab->asr_owner))){
                    variable_inital_value_vec.push_back({v, target_var});
                } else {
                    set_VariableInital_value(v, target_var);
                }
            } else {
                if (is_list) {
                    ASR::List_t* asr_list = ASR::down_cast<ASR::List_t>(v->m_type);
                    std::string type_code = ASRUtils::get_type_code(asr_list->m_type);
                    list_api->list_init(type_code, ptr, module.get());
                } else if (is_dict) {
                    ASR::Dict_t* asr_dict = ASR::down_cast<ASR::Dict_t>(v->m_type);
                    std::string key_type_code = ASRUtils::get_type_code(asr_dict->m_key_type);
                    std::string value_type_code = ASRUtils::get_type_code(asr_dict->m_value_type);

                    llvm_utils->get_type_from_ttype_t_util(nullptr, ASRUtils::TYPE(ASR::make_List_t(al, asr_dict->base.base.loc, asr_dict->m_key_type)), module.get());
                    llvm_utils->get_type_from_ttype_t_util(nullptr, ASRUtils::TYPE(ASR::make_List_t(al, asr_dict->base.base.loc, asr_dict->m_value_type)), module.get());
                    llvm_utils->get_type_from_ttype_t_util(nullptr, v->m_type, module.get());

                    if (ASRUtils::is_character(*asr_dict->m_key_type))
                        dict_api_sc->dict_init(asr_dict, ptr, module.get(), 0);
                    else
                        dict_api_lp->dict_init(asr_dict, ptr, module.get(), 0);
                } else if (is_tuple) {
                    auto tuple_type_ = ASR::down_cast<ASR::Tuple_t>(v->m_type);
                    for (size_t i=0; i<tuple_type_->n_type; i++) {
                        if (ASRUtils::is_descriptorString(tuple_type_->m_type[i]) && ASRUtils::is_deferredLength_string(tuple_type_->m_type[i])) {
                            auto item_ptr = llvm_utils->create_gep2(type, ptr, i);

                            builder->CreateStore(llvm::Constant::getNullValue(llvm_utils->string_descriptor), item_ptr);
                            ASR::String_t *t = ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(tuple_type_->m_type[i]));
                            llvm_utils->set_string_memory_on_heap(t->m_physical_type, item_ptr, llvm_utils->get_string_length(t, item_ptr));
                        }
                    }
                }
            }
        }
    }

    template<typename T>
    void declare_vars(const T &x, bool create_vtabs=true) {
        uint32_t debug_arg_count = 0;
        std::vector<std::string> var_order = ASRUtils::determine_variable_declaration_order(x.m_symtab);
        if( create_vtabs && !compiler_options.new_classes ) {
            std::set<std::string> variable_type_names;
            std::vector<ASR::symbol_t*> struct_types;
            // Collects all Struct symbols and StructType variables type names in x.m_symtab and its parent symtabs
            collect_variable_types_and_struct_types(variable_type_names, struct_types, x.m_symtab);
            for( size_t i = 0; i < struct_types.size(); i++ ) {
                ASR::symbol_t* struct_type = struct_types[i];
                bool create_vtab = false;
                for( const std::string& variable_type_name: variable_type_names ) {
                    ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(
                        ASRUtils::symbol_get_past_external(x.m_symtab->resolve_symbol(variable_type_name)));
                    ASR::symbol_t* class_sym = ASRUtils::symbol_get_past_external(var->m_type_declaration);
                    if (ASRUtils::is_allocatable_or_pointer(var->m_type) &&
                          ASRUtils::is_class_type(ASRUtils::extract_type(var->m_type))) {
                        create_vtab = true;
                        break;
                    }
                    bool is_vtab_needed = false;
                    ASR::symbol_t* temp_struct_type = struct_type;
                    while( !is_vtab_needed && temp_struct_type ) {
                        if( temp_struct_type == class_sym ) {
                            is_vtab_needed = true;
                        } else {
                            temp_struct_type = ASR::down_cast<ASR::Struct_t>(
                                ASRUtils::symbol_get_past_external(temp_struct_type))->m_parent;
                        }
                    }
                    if( is_vtab_needed ) {
                        create_vtab = true;
                        break;
                    }
                }
                if( create_vtab ) {
                    if (compiler_options.new_classes) {
                        struct_api->create_new_vtable_for_struct_type(
                            ASRUtils::symbol_get_past_external(struct_types[i]), module.get());
                    } else {
                        create_vtab_for_struct_type(
                            ASRUtils::symbol_get_past_external(struct_types[i]),
                            x.m_symtab);
                    }
                }
            }
        }
        for (auto &item : var_order) {
            ASR::symbol_t* var_sym = x.m_symtab->get_symbol(item);
            if (is_a<ASR::Variable_t>(*var_sym)) {
                process_Variable(var_sym, x, debug_arg_count);
            }
        }
    }

    bool is_function_variable(const ASR::Variable_t &v) {
        if (v.m_type_declaration) {
            return ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(v.m_type_declaration));
        } else {
            return false;
        }
    }

    bool is_function_variable(const ASR::symbol_t *v) {
        if( !ASR::is_a<ASR::Variable_t>(*v) ) {
            return false;
        }
        return is_function_variable(*ASR::down_cast<ASR::Variable_t>(v));
    }

    // F is the function that we are generating and we go over all arguments
    // (F.args()) and handle three cases:
    //     * Variable (`integer :: x`)
    //     * Function (callback) Variable (`procedure(fn) :: x`)
    //     * Function (`fn`)
    void declare_args(const ASR::Function_t &x, llvm::Function &F) {
        size_t asr_arg_idx = 0;
        auto arg_it = F.arg_begin();

        // Windows complex(kind=8) uses "pass-as-subroutine" (sret-style) ABI:
        // the LLVM function has an extra hidden first argument to store the
        // return value, while ASR still models it as a function with a return var.
        if (compiler_options.platform == Platform::Windows &&
            x.m_return_var != nullptr &&
            ASR::is_a<ASR::Complex_t>(*ASRUtils::expr_type(x.m_return_var)) &&
            ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(x.m_return_var)) == 8 &&
            F.getReturnType()->isVoidTy() &&
            F.arg_size() == x.n_args + 1) {
            llvm::Argument* sret = &*arg_it;
            sret->setName("_sret");
            current_sret_arg = sret;
            ++arg_it;
        }

        for (; arg_it != F.arg_end(); ++arg_it) {
            LCOMPILERS_ASSERT(asr_arg_idx < x.n_args);
            llvm::Argument &llvm_arg = *arg_it;
            ASR::symbol_t *s = symbol_get_past_external(
                    ASR::down_cast<ASR::Var_t>(x.m_args[asr_arg_idx])->m_v);
            ASR::symbol_t* arg_sym = s;
            if (is_a<ASR::Variable_t>(*s)) {
                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(s);
                if (is_function_variable(*v)) {
                    // * Function (callback) Variable (`procedure(fn) :: x`)
                    s = ASRUtils::symbol_get_past_external(v->m_type_declaration);
                } else {
                    // * Variable (`integer :: x`)
                    ASR::Variable_t *arg = EXPR2VAR(x.m_args[asr_arg_idx]);
                    LCOMPILERS_ASSERT(is_arg_dummy(arg->m_intent));

                    llvm::Value* llvm_sym = &llvm_arg;
                    uint32_t h = get_hash((ASR::asr_t*)arg);
                    std::string arg_s = arg->m_name;
                    llvm_arg.setName(arg_s);
                    llvm_symtab[h] = llvm_sym;
                }
            }
            if (is_a<ASR::Function_t>(*s)) {
                // * Function (`fn`)
                // Deal with case where procedure passed in as argument
                ASR::Function_t *arg = ASR::down_cast<ASR::Function_t>(s);
                uint32_t h = get_hash((ASR::asr_t*)arg_sym);
                std::string arg_s = ASRUtils::symbol_name(arg_sym);
                llvm_arg.setName(arg_s);
                llvm_symtab_fn_arg[h] = &llvm_arg;
                if( is_function_variable(arg_sym) ) {
                    llvm_symtab[h] = &llvm_arg;
                }
                if (llvm_symtab_fn.find(h) == llvm_symtab_fn.end()) {
                    llvm::FunctionType* fntype = llvm_utils->get_function_type(*arg, module.get());
                    llvm::Function* fn = llvm::Function::Create(fntype, llvm::Function::ExternalLinkage, arg->m_name, module.get());
                    llvm_symtab_fn[h] = fn;
                }
            }
            asr_arg_idx++;
        }
    }

    template <typename T>
    void declare_local_vars(const T &x) {
        declare_vars(x);
    }

    void visit_Function(const ASR::Function_t &x) {
        llvm::DIScope* debug_current_scope_copy = debug_current_scope;
        loop_head.clear();
        loop_head_names.clear();
        loop_or_block_end.clear();
        loop_or_block_end_names.clear();
        call_arg_alloca_pool.clear();
        call_arg_alloca_idx.clear();
        convert_call_args_depth = 0;
        strings_to_be_deallocated.reserve(al, 1);
        heap_fixed_size_arrays.reserve(al, 1);
        SymbolTable* current_scope_copy = current_scope;
        current_scope = x.m_symtab;
        bool is_dict_present_copy_lp = dict_api_lp->is_dict_present();
        bool is_dict_present_copy_sc = dict_api_sc->is_dict_present();
        dict_api_lp->set_is_dict_present(false);
        dict_api_sc->set_is_dict_present(false);
        bool is_set_present_copy_lp = set_api_lp->is_set_present();
        bool is_set_present_copy_sc = set_api_sc->is_set_present();
        set_api_lp->set_is_set_present(false);
        set_api_sc->set_is_set_present(false);
        llvm_goto_targets.clear();
        instantiate_function(x);
        if (ASRUtils::get_FunctionType(x)->m_deftype == ASR::deftypeType::Interface) {
            // Interface does not have an implementation and it is already
            // declared, so there is nothing to do here
            if (compiler_options.emit_debug_info) debug_current_scope = debug_current_scope_copy;
            dict_api_lp->set_is_dict_present(is_dict_present_copy_lp);
            dict_api_sc->set_is_dict_present(is_dict_present_copy_sc);
            set_api_lp->set_is_set_present(is_set_present_copy_lp);
            set_api_sc->set_is_set_present(is_set_present_copy_sc);
            current_scope = current_scope_copy;
            return;
        }
        visit_procedures(x);
        generate_function(x);
        parent_function = nullptr;
        dict_api_lp->set_is_dict_present(is_dict_present_copy_lp);
        dict_api_sc->set_is_dict_present(is_dict_present_copy_sc);
        set_api_lp->set_is_set_present(is_set_present_copy_lp);
        set_api_sc->set_is_set_present(is_set_present_copy_sc);

        // Finalize the debug info.
        if (compiler_options.emit_debug_info) DBuilder->finalize();
        if (compiler_options.emit_debug_info) debug_current_scope = debug_current_scope_copy;
        current_scope = current_scope_copy;
        loop_head.clear();
        loop_head_names.clear();
        loop_or_block_end.clear();
        loop_or_block_end_names.clear();
        strings_to_be_deallocated.reserve(al, 1);
        heap_fixed_size_arrays.reserve(al, 1);
    }

    void instantiate_function(const ASR::Function_t &x){
        llvm::DIScope* debug_current_scope_copy = debug_current_scope;
        uint32_t h = get_hash((ASR::asr_t*)&x);
        llvm::Function *F = nullptr;
        std::string sym_name = x.m_name;
        if (sym_name == "main") {
            sym_name = "_xx_lcompilers_changed_main_xx";
        }
        if (llvm_symtab_fn.find(h) != llvm_symtab_fn.end()) {
            /*
            throw CodeGenError("Function code already generated for '"
                + std::string(x.m_name) + "'");
            */
            F = llvm_symtab_fn[h];
        } else {
            llvm::FunctionType* function_type = llvm_utils->get_function_type(x, module.get());
            if( ASRUtils::get_FunctionType(x)->m_deftype == ASR::deftypeType::Interface && !ASRUtils::get_FunctionType(x)->m_module ) {
                ASR::FunctionType_t* asr_function_type = ASRUtils::get_FunctionType(x);
                for( size_t i = 0; i < asr_function_type->n_arg_types; i++ ) {
                    if( ASRUtils::is_class_type(asr_function_type->m_arg_types[i]) ) {
                        if (compiler_options.emit_debug_info) {
                            debug_current_scope = debug_current_scope_copy;
                        }
                        return ;
                    }
                }
            }
            // Compute the mangled function name using centralized logic
            ASR::FunctionType_t *ftype = ASRUtils::get_FunctionType(x);
            std::string fn_name = compute_llvm_function_name(
                sym_name, ftype, compiler_options, mangle_prefix, parent_function
            );
            if (llvm_symtab_fn_names.find(fn_name) == llvm_symtab_fn_names.end()) {
                llvm_symtab_fn_names[fn_name] = h;
                F = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, fn_name, module.get());
            } else {
                uint32_t old_h = llvm_symtab_fn_names[fn_name];
                F = llvm_symtab_fn[old_h];
            }
            llvm_symtab_fn[h] = F;

            // Instantiate (pre-declare) all nested interfaces
            for (auto &item : x.m_symtab->get_scope()) {
                if (is_a<ASR::Function_t>(*item.second)) {
                    const ASR::Function_t* parent_function_copy = parent_function;
                    parent_function = &x;
                    ASR::Function_t *v = down_cast<ASR::Function_t>(
                            item.second);
                    // check if item.second is present in x.m_args
                    bool interface_as_arg = false;
                    for (size_t i=0; i<x.n_args; i++) {
                        if (is_a<ASR::Var_t>(*x.m_args[i])) {
                            ASR::Var_t *arg = down_cast<ASR::Var_t>(x.m_args[i]);
                            if ( arg->m_v == item.second ) {
                                interface_as_arg = true;
                                llvm::FunctionType* fntype = llvm_utils->get_function_type(*v, module.get());
                                llvm::Function* fn = llvm::Function::Create(fntype, llvm::Function::ExternalLinkage, v->m_name, module.get());
                                uint32_t hash = get_hash((ASR::asr_t*)v);
                                llvm_symtab_fn[hash] = fn;
                            }
                        }
                    }
                    if (!interface_as_arg) {
                        instantiate_function(*v);
                    }
                    parent_function = parent_function_copy;
                } else if ( ASR::is_a<ASR::Variable_t>(*ASRUtils::symbol_get_past_external(item.second)) && is_function_variable(ASRUtils::symbol_get_past_external(item.second)) ) {
                    ASR::Variable_t *v = down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(item.second));
                    bool interface_as_arg = false;
                    for (size_t i=0; i<x.n_args; i++) {
                        if (is_a<ASR::Var_t>(*x.m_args[i])) {
                            ASR::Var_t *arg = down_cast<ASR::Var_t>(x.m_args[i]);
                            if ( arg->m_v == item.second ) {
                                interface_as_arg = true;
                            }
                        }
                    }
                    if ( interface_as_arg ) {
                        continue;
                    }
                    ASR::Function_t *var = ASR::down_cast<ASR::Function_t>(
                            ASRUtils::symbol_get_past_external(v->m_type_declaration));
                    uint32_t h = get_hash((ASR::asr_t*)v);
                    if (llvm_symtab_fn.find(h) != llvm_symtab_fn.end()) {
                        continue;
                    }
                    llvm::FunctionType* function_type = llvm_utils->get_function_type(*var, module.get());
                    std::string fn_name;
                    std::string sym_name = v->m_name;
                    if (ASRUtils::get_FunctionType(*var)->m_abi == ASR::abiType::BindC) {
                        if (ASRUtils::get_FunctionType(*var)->m_bindc_name) {
                            fn_name = ASRUtils::get_FunctionType(*var)->m_bindc_name;
                        } else {
                            fn_name = sym_name;
                        }
                    } else if (ASRUtils::get_FunctionType(*var)->m_deftype == ASR::deftypeType::Interface &&
                        ASRUtils::get_FunctionType(*var)->m_abi != ASR::abiType::Intrinsic) {
                        fn_name = sym_name;
                    } else {
                        fn_name = mangle_prefix + sym_name;
                    }
                    if (llvm_symtab_fn_names.find(fn_name) == llvm_symtab_fn_names.end()) {
                        llvm_symtab_fn_names[fn_name] = h;
                        llvm::Function* F = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, fn_name, module.get());
                        llvm_symtab_fn[h] = F;
                    } else {
                        uint32_t old_h = llvm_symtab_fn_names[fn_name];
                        llvm_symtab_fn[h] = llvm_symtab_fn[old_h];
                    }
                }
            }
        }
        if (compiler_options.emit_debug_info) {
            debug_current_scope = debug_current_scope_copy;
        }
    }

    inline void define_function_entry(const ASR::Function_t& x) {
        uint32_t h = get_hash((ASR::asr_t*)&x);
        parent_function = &x;
        llvm::Function* F = llvm_symtab_fn[h];
        llvm_goto_targets.clear();
        current_sret_arg = nullptr;
        // Clear alloca pool for each new function to avoid cross-function references
        call_arg_alloca_pool.clear();
        call_arg_alloca_idx.clear();
        convert_call_args_depth = 0;
        if (compiler_options.emit_debug_info) {
            llvm::DISubprogram *SP = nullptr;
            debug_emit_function(x, SP);
            F->setSubprogram(SP);
            debug_current_scope = SP;
        }
        proc_return = llvm::BasicBlock::Create(context, "return");
        llvm::BasicBlock *BB = llvm::BasicBlock::Create(context,
                ".entry", F);
        builder->SetInsertPoint(BB);
        if (compiler_options.emit_debug_info) debug_emit_loc(x);
        declare_args(x, *F);
        for( auto& sym: x.m_symtab->get_scope() ) {
            if( !ASR::is_a<ASR::Variable_t>(*sym.second) ) {
                continue ;
            }
            ASR::intentType symbol_intent = ASRUtils::symbol_intent(
                ASRUtils::symbol_get_past_external(sym.second));
            if( !(symbol_intent == ASRUtils::intent_in ||
                 symbol_intent == ASRUtils::intent_inout ||
                 symbol_intent == ASRUtils::intent_out) ) {
                continue;
            }
            ASR::ttype_t* symbol_type = ASRUtils::symbol_type(sym.second);
            // Reinitialize StructType members if intent is intent_out
            if (ASR::is_a<ASR::StructType_t>(*symbol_type) && symbol_intent == ASRUtils::intent_out) {
                uint32_t h = get_hash((ASR::asr_t*)sym.second);
                LCOMPILERS_ASSERT(llvm_symtab.find(h) != llvm_symtab.end());
                llvm::Value* st_desc = llvm_symtab[h];

                ASR::Struct_t* struct_sym = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
                        ASR::down_cast<ASR::Variable_t>(sym.second)->m_type_declaration));

                if (ASRUtils::is_class_type(symbol_type)) {
                    // TODO: Make this work for extended types too
                    if (!compiler_options.new_classes) {
                        llvm::Type* src_class_type = llvm_utils->get_type_from_ttype_t_util(
                            ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, sym.second)),
                            symbol_type, module.get());
                        st_desc = llvm_utils->create_gep2(src_class_type, st_desc, 1);

                        ASR::Struct_t* src_struct_sym = ASR::down_cast<ASR::Struct_t>(
                                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, sym.second)))));
                        llvm::Type* src_struct_type = get_llvm_struct_data_type(src_struct_sym, true);
                        st_desc = llvm_utils->CreateLoad2(src_struct_type, st_desc);
                    }

                    allocate_array_members_of_struct(struct_sym, st_desc, ASR::down_cast<ASR::Variable_t>(sym.second)->m_type, true);
                } else {
                    allocate_array_members_of_struct(struct_sym, st_desc, ASR::down_cast<ASR::Variable_t>(sym.second)->m_type, true);
                }
            }
            if (ASRUtils::is_string_only(symbol_type) && ASRUtils::is_allocatable(symbol_type)) {                                                                  
                ASR::String_t* str_t = ASRUtils::get_string_type(symbol_type);                                             
                if (str_t->m_len_kind == ASR::ExpressionLength && str_t->m_len) {                                      
                    uint32_t h = get_hash((ASR::asr_t*)sym.second);                                                   
                    LCOMPILERS_ASSERT(llvm_symtab.find(h) != llvm_symtab.end());                                           
                    llvm::Value* str_desc = llvm_symtab[h];                                                         
                    setup_string_length(str_desc, str_t, str_t->m_len);                                     
                }                                                                                            
            }                                                                                                              
            if( !(ASRUtils::is_pointer(symbol_type) || ASRUtils::is_allocatable(symbol_type)) &&
                ASRUtils::is_array(symbol_type) &&
                ASRUtils::extract_physical_type(symbol_type)
                    == ASR::array_physical_typeType::DescriptorArray ) {
                llvm::Type* desc_array_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::get_expr_from_sym(al, sym.second),
                        ASRUtils::type_get_past_allocatable_pointer(symbol_type),
                        module.get());
                llvm::Value* array_desc = llvm_utils->CreateAlloca(
                    desc_array_type, nullptr, "array_descriptor_local");
                uint32_t h = get_hash((ASR::asr_t*)sym.second);
                LCOMPILERS_ASSERT(llvm_symtab.find(h) != llvm_symtab.end());
                llvm::Value* arg_array_desc = llvm_symtab[h];
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                llvm::Type *data_type = llvm_utils->get_el_type(ASRUtils::get_expr_from_sym(al, sym.second),
                    ASRUtils::extract_type(symbol_type), module.get());
                builder->CreateStore(llvm_utils->create_ptr_gep2(data_type,
                llvm_utils->CreateLoad2(data_type->getPointerTo(), arr_descr->get_pointer_to_data(desc_array_type, arg_array_desc)),
                    arr_descr->get_offset(desc_array_type, arg_array_desc)), arr_descr->get_pointer_to_data(desc_array_type, array_desc));
                ASR::dimension_t* m_dims = nullptr;
                int n_dims = ASRUtils::extract_dimensions_from_ttype(symbol_type, m_dims);
                Vec<llvm::Value*> lbs, lengths;
                lbs.reserve(al, n_dims);
                lengths.reserve(al, n_dims);
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 2;
                for( int i = 0; i < n_dims; i++ ) {
                    if( m_dims[i].m_start ) {
                        visit_expr_wrapper(m_dims[i].m_start);
                        lbs.push_back(al, tmp);
                    } else {
                        lbs.push_back(al, nullptr);
                    }
                    if( m_dims[i].m_length ) {
                        visit_expr_wrapper(m_dims[i].m_length);
                        lengths.push_back(al, tmp);
                    } else {
                        lengths.push_back(al, nullptr);
                    }
                }
                arr_descr->reset_array_details(
                    desc_array_type, array_desc, arg_array_desc, lbs.p, lengths.p, n_dims);
                ptr_loads = ptr_loads_copy;
                llvm_symtab[h] = array_desc;
            }
        }
        declare_local_vars(x);
    }

    inline void free_heap_fixed_size_arrays() {
        // Free all heap-allocated large fixed-size arrays
        for (size_t i = 0; i < heap_fixed_size_arrays.n; i++) {
            llvm_utils->lfortran_free(heap_fixed_size_arrays[i]);
        }
        heap_fixed_size_arrays.n = 0;
    }

    inline void define_function_exit(const ASR::Function_t& x) {
        if (x.m_return_var) {
            start_new_block(proc_return);
            llvm_symtab_finalizer.finalize_symtab(x.m_symtab);
            free_heap_fixed_size_arrays();
            llvm::Function* fn = builder->GetInsertBlock()->getParent();
            if (fn->getReturnType()->isVoidTy()) {
                // On Windows, complex(kind=8) returns use the "pass-as-subroutine" ABI:
                // write the return value into the hidden first argument.
                ASR::ttype_t* ret_type = ASRUtils::expr_type(x.m_return_var);
                if (compiler_options.platform == Platform::Windows &&
                    ASR::is_a<ASR::Complex_t>(*ret_type) &&
                    ASRUtils::extract_kind_from_ttype_t(ret_type) == 8) {
                    LCOMPILERS_ASSERT(current_sret_arg != nullptr);
                    ASR::Variable_t *asr_retval = EXPR2VAR(x.m_return_var);
                    uint32_t h = get_hash((ASR::asr_t*)asr_retval);
                    llvm::Value *ret_val_ptr = llvm_symtab[h];
                    llvm::Value *ret_val = llvm_utils->CreateLoad2(complex_type_8, ret_val_ptr);
                    builder->CreateStore(ret_val, current_sret_arg);
                }
                builder->CreateRetVoid();
                return;
            }
            ASR::Variable_t *asr_retval = EXPR2VAR(x.m_return_var);
            uint32_t h = get_hash((ASR::asr_t*)asr_retval);
            llvm::Value *ret_val = llvm_symtab[h];
            llvm::Value *ret_val2 = ret_val;
            if (!ASRUtils::is_class_type(ASRUtils::extract_type(asr_retval->m_type)) &&
                !(ASR::is_a<ASR::Pointer_t>(*asr_retval->m_type) && ASR::is_a<ASR::String_t>(*ASRUtils::extract_type(asr_retval->m_type))) ) {
                llvm::Type* asr_retval_llvm_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, asr_retval->base.base.loc, &asr_retval->base)), asr_retval->m_type, module.get());
                ret_val2 = llvm_utils->CreateLoad2(asr_retval_llvm_type, ret_val);
            }
            // Handle Complex type return value - convert to platform ABI:
            {
                ASR::ttype_t* arg_type = asr_retval->m_type;
                llvm::Value *tmp = ret_val;
                if (is_a<ASR::Complex_t>(*arg_type)) {
                    int c_kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                    llvm::Type* complex_val_type = llvm_utils->get_type_from_ttype_t_util(x.m_return_var,
                        arg_type,
                        module.get());
                    if (c_kind == 4) {
                        if (compiler_options.platform == Platform::Windows) {
                            // tmp is {float, float}*
                            // type_fx2p is i64*
                            llvm::Type* type_fx2p = llvm::Type::getInt64Ty(context)->getPointerTo();
                            // Convert {float,float}* to i64* using bitcast
                            tmp = builder->CreateBitCast(tmp, type_fx2p);
                            // Then convert i64* -> i64
                            tmp = llvm_utils->CreateLoad2(llvm::Type::getInt64Ty(context), tmp);
                        } else if (compiler_options.platform == Platform::macOS_ARM) {
                            // Pass by value

                            tmp = llvm_utils->CreateLoad2(complex_val_type, tmp);
                        } else {
                            // tmp is {float, float}*
                            // type_fx2 is <2 x float>
                            llvm::Type* type_fx2 = FIXED_VECTOR_TYPE::get(llvm::Type::getFloatTy(context), 2);
                            // Convert {float,float}* to <2 x float>* using bitcast
                            tmp = builder->CreateBitCast(tmp, type_fx2->getPointerTo());
                            // Then convert <2 x float>* -> <2 x float>
                            tmp = llvm_utils->CreateLoad2(type_fx2, tmp);
                        }
                    } else {
                        LCOMPILERS_ASSERT(c_kind == 8)
                        if (compiler_options.platform == Platform::Windows) {
                            // 128 bit aggregate type is passed by reference
                        } else {
                            // Pass by value
                            tmp = llvm_utils->CreateLoad2(complex_val_type, tmp);
                        }
                    }
                ret_val2 = tmp;
                }
            }
            builder->CreateRet(ret_val2);
        } else {
            start_new_block(proc_return);
            llvm_symtab_finalizer.finalize_symtab(x.m_symtab);
            free_heap_fixed_size_arrays();
            builder->CreateRetVoid();
        }
    }

    /* Case: We don't know type of obj at compile time. 
    We use this runtime function from runtime vptr to deep copy properly
    subroutine describe(obj)
        class(base_t), intent(in) :: obj
        class(base_t), allocatable :: obj_tmp
        obj_tmp = obj
    end subroutine
    Example: `class_65.f90`
    */

    void generate_function(const ASR::Function_t &x) {
        bool interactive = (ASRUtils::get_FunctionType(x)->m_abi == ASR::abiType::ExternalUndefined);
        if (ASRUtils::get_FunctionType(x)->m_deftype == ASR::deftypeType::Implementation ) {

            if (interactive) return;

            if (!prototype_only) {
                define_function_entry(x);
                predeclare_goto_targets(builder->GetInsertBlock()->getParent(), x.m_body, x.n_body);

                for (size_t i=0; i<x.n_body; i++) {
                    this->visit_stmt(*x.m_body[i]);
                }
                
                define_function_exit(x);
            }
        } else if( ASRUtils::get_FunctionType(x)->m_abi == ASR::abiType::Intrinsic &&
                   ASRUtils::get_FunctionType(x)->m_deftype == ASR::deftypeType::Interface ) {
            std::string m_name = x.m_name;
            if( m_name == "lbound" || m_name == "ubound" ) {
                define_function_entry(x);

                // Defines the size intrinsic's body at LLVM level.
                ASR::Variable_t *arg = EXPR2VAR(x.m_args[0]);
                uint32_t h = get_hash((ASR::asr_t*)arg);
                llvm::Value* llvm_arg1 = llvm_symtab[h];
                llvm::Type* llvm_arg1_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[0], arg->m_type, module.get());

                arg = EXPR2VAR(x.m_args[1]);
                h = get_hash((ASR::asr_t*)arg);
                llvm::Value* llvm_arg2 = llvm_symtab[h];
                llvm::Type* llvm_arg2_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[1], arg->m_type, module.get());

                ASR::Variable_t *ret = EXPR2VAR(x.m_return_var);
                h = get_hash((ASR::asr_t*)ret);
                llvm::Value* llvm_ret_ptr = llvm_symtab[h];

                llvm::Value* dim_des_val = llvm_utils->CreateLoad2(llvm_arg1_type, llvm_arg1);
                llvm::Value* dim_val = llvm_utils->CreateLoad2(llvm_arg2_type, llvm_arg2);
                llvm::Value* const_1 = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
                dim_val = builder->CreateSub(dim_val, const_1);
                llvm::Value* dim_struct = arr_descr->get_pointer_to_dimension_descriptor(dim_des_val, dim_val);
                llvm::Value* res = nullptr;
                if( m_name == "lbound" ) {
                    res = arr_descr->get_lower_bound(dim_struct);
                } else if( m_name == "ubound" ) {
                    res = arr_descr->get_upper_bound(dim_struct);
                }
                builder->CreateStore(res, llvm_ret_ptr);

                define_function_exit(x);
            }
        }
    }


    template<typename T>
    void visit_procedures(const T &x) {
        for (auto &item : x.m_symtab->get_scope()) {
            if (is_a<ASR::Function_t>(*item.second)) {
                ASR::Function_t *s = ASR::down_cast<ASR::Function_t>(item.second);
                visit_Function(*s);
            }
        }
    }

    bool is_nested_pointer(llvm::Value* val) {
        // TODO: Remove this in future
        // Related issue, https://github.com/lcompilers/lpython/pull/707#issuecomment-1169773106.
        return val->getType()->isPointerTy() &&
               val->getType()->getContainedType(0)->isPointerTy();
    }

    void visit_CLoc(const ASR::CLoc_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_arg);
        ptr_loads = ptr_loads_copy;
        if( is_nested_pointer(tmp) ) {
            llvm::Type* nested_type = llvm_utils->get_type_from_ttype_t_util(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
            tmp = llvm_utils->CreateLoad2(nested_type, tmp);
        }
        ASR::ttype_t* arg_type = ASRUtils::get_contained_type(ASRUtils::expr_type(x.m_arg));
        if( ASRUtils::is_array(arg_type) ) {
            llvm::Type* elem_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::get_contained_type(arg_type), nullptr, module.get());
            tmp = llvm_utils->CreateLoad2(elem_type->getPointerTo(), arr_descr->get_pointer_to_data(elem_type, tmp));
        }
        tmp = builder->CreateBitCast(tmp,
                    llvm::Type::getVoidTy(context)->getPointerTo());
    }


    llvm::Value* GetPointerCPtrUtil(llvm::Value* llvm_tmp, ASR::expr_t* asr_expr) {
        // If the input is a simple variable and not a pointer
        // then this check will fail and load will not happen
        // (which is what we want for simple variables).
        // For pointers, the actual LLVM variable will be a
        // double pointer, so we need to load one time and then
        // use it later on.
        ASR::ttype_t* asr_type = ASRUtils::expr_type(asr_expr);
        if(ASR::is_a<ASR::Pointer_t>(*asr_type) &&
            (LLVM::is_llvm_pointer(*ASRUtils::type_get_past_pointer(asr_type))
             || ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_pointer(asr_type))
             || llvm::isa<llvm::AllocaInst>(llvm_tmp))) {
            ASR::ttype_t* contained_type = ASRUtils::type_get_past_pointer(asr_type);
            llvm::Type* llvm_ty = llvm_utils->get_type_from_ttype_t_util(nullptr, contained_type, module.get());
            llvm_tmp = llvm_utils->CreateLoad2(llvm_ty->getPointerTo(), llvm_tmp);
        }
        asr_type = ASRUtils::get_contained_type(asr_type);

        if( ASRUtils::is_array(asr_type) &&
            !ASR::is_a<ASR::CPtr_t>(*asr_type) ) {
            ASR::array_physical_typeType physical_type = ASRUtils::extract_physical_type(asr_type);
            llvm::Type *el_type = llvm_utils->get_el_type(
                asr_expr, ASRUtils::extract_type(asr_type), module.get());
            switch( physical_type ) {
                case ASR::array_physical_typeType::DescriptorArray: {
                    llvm_tmp = llvm_utils->CreateLoad2(el_type->getPointerTo(), arr_descr->get_pointer_to_data(llvm_utils->get_type_from_ttype_t_util(asr_expr, asr_type, module.get()), llvm_tmp));
                    break;
                }
                case ASR::array_physical_typeType::FixedSizeArray: {
                    llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(asr_expr, asr_type, module.get());
                    llvm_tmp = llvm_utils->create_gep2(type, llvm_tmp, 0);
                    break;
                }
                case ASR::array_physical_typeType::PointerArray: {
                    break;
                }
                default: {
                    LCOMPILERS_ASSERT(false);
                }
            }
        }

        // // TODO: refactor this into a function, it is being used a few times
        // llvm::Type *target_type = llvm_tmp->getType();
        // // Create alloca to get a pointer, but do it
        // // at the beginning of the function to avoid
        // // using alloca inside a loop, which would
        // // run out of stack
        // llvm::BasicBlock &entry_block = builder->GetInsertBlock()->getParent()->getEntryBlock();
        // llvm::IRBuilder<> builder0(context);
        // builder0.SetInsertPoint(&entry_block, entry_block.getFirstInsertionPt());
        // llvm::AllocaInst *target = builder0.CreateAlloca(
        //     target_type, nullptr, "call_arg_value_ptr");
        // builder->CreateStore(llvm_tmp, target);
        // llvm_tmp = target;
        return llvm_tmp;
    }

    void visit_GetPointer(const ASR::GetPointer_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_arg);
        ptr_loads = ptr_loads_copy;
        tmp = GetPointerCPtrUtil(tmp, x.m_arg);
    }

    void visit_PointerToCPtr(const ASR::PointerToCPtr_t& x) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr(*x.m_arg);
        ptr_loads = ptr_loads_copy;
        if( !ASR::is_a<ASR::GetPointer_t>(*x.m_arg) ) {
            tmp = GetPointerCPtrUtil(tmp, x.m_arg);
        } else if(ASRUtils::is_character(*expr_type(x.m_arg))){ // Targetted physicalType is `char*`
            tmp = llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_arg), tmp);
        }
        tmp = builder->CreateBitCast(tmp,
                    llvm::Type::getVoidTy(context)->getPointerTo());
    }


    void visit_CPtrToPointer(const ASR::CPtrToPointer_t& x) {
        ASR::expr_t *cptr = x.m_cptr, *fptr = x.m_ptr, *shape = x.m_shape;
        int reduce_loads = 0;
        if( ASR::is_a<ASR::Var_t>(*cptr) ) {
            ASR::Variable_t* cptr_var = ASRUtils::EXPR2VAR(cptr);
            reduce_loads = cptr_var->m_intent == ASRUtils::intent_in;
        }
        if( ASRUtils::is_array(ASRUtils::expr_type(fptr)) ) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 1 - reduce_loads;
            this->visit_expr(*cptr);
            llvm::Value* llvm_cptr = tmp;
            if (ASR::is_a<ASR::StructInstanceMember_t>(*cptr)) {
                // `type(c_ptr)` requires an extra load here
                // TODO: be more explicit about ptr_loads: https://github.com/lfortran/lfortran/issues/4245
                llvm::Type* llvm_cptr_type = llvm_utils->get_type_from_ttype_t_util(cptr, ASRUtils::expr_type(cptr), module.get());
                llvm_cptr = llvm_utils->CreateLoad2(llvm_cptr_type, llvm_cptr);
            }
            ptr_loads = 0;
            this->visit_expr(*fptr);
            llvm::Value* llvm_fptr = tmp;
            ptr_loads = ptr_loads_copy;
            llvm::Value* llvm_shape = nullptr;
            ASR::ttype_t* asr_shape_type = nullptr;
            if( shape ) {
                asr_shape_type = ASRUtils::get_contained_type(ASRUtils::expr_type(shape));
                this->visit_expr(*shape);
                llvm_shape = tmp;
            }
            ASR::ttype_t* fptr_type = ASRUtils::expr_type(fptr);
            llvm::Type* llvm_fptr_type = llvm_utils->get_type_from_ttype_t_util(fptr,
                ASRUtils::get_contained_type(fptr_type), module.get());
            llvm_fptr = llvm_utils->CreateLoad2(llvm_fptr_type->getPointerTo(), llvm_fptr);
            llvm::Type* idx_type = arr_descr->get_index_type();
            unsigned idx_bit_width = idx_type->getIntegerBitWidth();
            builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(idx_bit_width, 0)),
                arr_descr->get_offset(llvm_fptr_type, llvm_fptr, false));
            ASR::dimension_t* fptr_dims;
            int fptr_rank = ASRUtils::extract_dimensions_from_ttype(
                                ASRUtils::expr_type(fptr),
                                fptr_dims);
            ASR::ttype_t* fptr_data_type = ASRUtils::duplicate_type_without_dims(al, ASRUtils::get_contained_type(fptr_type), fptr_type->base.loc);
            llvm::Type* llvm_fptr_data_type = nullptr;
            if (ASRUtils::is_descriptorString(fptr_data_type)) {
                llvm_fptr_data_type = llvm_utils->get_type_from_ttype_t_util(fptr, fptr_data_type, module.get());
            } else {
                // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                llvm_fptr_data_type = llvm_utils->get_el_type(
                    fptr, ASRUtils::extract_type(fptr_type), module.get());
            }
            llvm::Value* fptr_data = arr_descr->get_pointer_to_data(llvm_fptr_type, llvm_fptr);
            llvm::Value* fptr_des = arr_descr->get_pointer_to_dimension_descriptor_array(llvm_fptr_type, llvm_fptr);
            llvm::Value* shape_data = llvm_shape;
            if( llvm_shape && (ASRUtils::extract_physical_type(asr_shape_type) ==
                ASR::array_physical_typeType::DescriptorArray) ) {
                ASR::ttype_t* shape_elem_asr_type = ASRUtils::type_get_past_pointer(ASRUtils::expr_type(shape));
                llvm::Type* shape_elem_llvm_type = llvm_utils->get_type_from_ttype_t_util( nullptr, shape_elem_asr_type, module.get());
                llvm::Type* shape_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    nullptr, ASRUtils::expr_type(shape), module.get());
                shape_data = llvm_utils->CreateLoad2(shape_elem_llvm_type, arr_descr->get_pointer_to_data(shape_llvm_type, llvm_shape));
            }

            if (ASRUtils::is_descriptorString(fptr_data_type)) {
                fptr_data = llvm_utils->CreateLoad2(llvm_fptr_data_type->getPointerTo(), fptr_data);
                fptr_data = llvm_utils->create_gep2(llvm_fptr_data_type, fptr_data, 0);
                llvm_cptr = builder->CreateBitCast(llvm_cptr, llvm_utils->i8_ptr);
            } else {
                llvm_cptr = builder->CreateBitCast(llvm_cptr, llvm_fptr_data_type->getPointerTo());
            }
            builder->CreateStore(llvm_cptr, fptr_data);

            llvm::Value* prod = llvm::ConstantInt::get(context, llvm::APInt(idx_bit_width, 1));
            for( int i = 0; i < fptr_rank; i++ ) {
                llvm::Value* curr_dim = llvm::ConstantInt::get(context, llvm::APInt(32, i));
                llvm::Value* desi = arr_descr->get_pointer_to_dimension_descriptor(fptr_des, curr_dim);
                llvm::Value* desi_stride = arr_descr->get_stride(desi, false);
                llvm::Value* desi_lb = arr_descr->get_lower_bound(desi, false);
                llvm::Value* desi_size = arr_descr->get_dimension_size(fptr_des, curr_dim, false);
                builder->CreateStore(prod, desi_stride);
                llvm::Value* idx_one = llvm::ConstantInt::get(context, llvm::APInt(idx_bit_width, 1));
                llvm::Value* new_lb = idx_one;
                if( x.m_lower_bounds ) {
                    int ptr_loads_copy = ptr_loads;
                    ptr_loads = 2;
                    this->visit_expr_wrapper(x.m_lower_bounds, true);
                    ptr_loads = ptr_loads_copy;
                    tmp = llvm_utils->create_ptr_gep2(idx_type, tmp,  i);
                    new_lb = llvm_utils->CreateLoad2(idx_type, tmp);
                }
                llvm::Value* new_size = nullptr;
                if( ASRUtils::extract_physical_type(asr_shape_type) == ASR::array_physical_typeType::DescriptorArray ||
                    ASRUtils::extract_physical_type(asr_shape_type) == ASR::array_physical_typeType::PointerArray ) {
                    new_size = shape_data ? builder->CreateSExtOrTrunc(llvm_utils->CreateLoad2(
                        idx_type, llvm_utils->create_ptr_gep2(idx_type, shape_data, i)), idx_type) : idx_one;
                } else if( ASRUtils::extract_physical_type(asr_shape_type) == ASR::array_physical_typeType::FixedSizeArray ) {
                    llvm::Type* shape_llvm_type = llvm_utils->get_type_from_ttype_t_util(shape, asr_shape_type, module.get());
                    new_size = shape_data ? builder->CreateSExtOrTrunc(llvm_utils->CreateLoad2(
                        idx_type, llvm_utils->create_gep2(shape_llvm_type, shape_data, i)), idx_type) : idx_one;
                }
                builder->CreateStore(new_lb, desi_lb);
                builder->CreateStore(new_size, desi_size);
                prod = builder->CreateMul(prod, new_size);
            }
        } else {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 1 - reduce_loads;
            this->visit_expr(*cptr);
            llvm::Value* llvm_cptr = tmp;
            if (ASR::is_a<ASR::StructInstanceMember_t>(*cptr)) {
                // Load the actual pointer value for type(c_ptr) members
                llvm::Type* cptr_llvm_type = llvm::Type::getInt8Ty(context)->getPointerTo(); // void*
                llvm_cptr = llvm_utils->CreateLoad2(cptr_llvm_type, llvm_cptr);
            } else if (ASR::is_a<ASR::ArrayItem_t>(*cptr)) {
                llvm::Type* cptr_llvm_type = llvm_utils->get_type_from_ttype_t_util(cptr, ASRUtils::expr_type(cptr), module.get());
                llvm_cptr = llvm_utils->CreateLoad2(cptr_llvm_type, llvm_cptr);
            }
            this->visit_expr_load_wrapper(fptr, 0);
            llvm::Value*  const llvm_fptr = tmp;
            ASR::ttype_t* const fptr_type = ASRUtils::expr_type(fptr);
            if (ASRUtils::is_string_only(fptr_type)) {
                llvm::Value* const cptr_to_charPTR = builder->CreateBitCast(llvm_cptr, llvm_utils->character_type);
                llvm::Value* const charPTR_ref = llvm_utils->get_string_data(ASRUtils::get_string_type(fptr_type), llvm_fptr, true);
                builder->CreateStore(cptr_to_charPTR, charPTR_ref);
            } else {
                ASR::ttype_t* fptr_asr_type = ASRUtils::expr_type(fptr);
                ASR::ttype_t* fptr_contained = ASRUtils::type_get_past_pointer(fptr_asr_type);
                bool is_proc_ptr = ASR::is_a<ASR::FunctionType_t>(*fptr_contained);
                llvm::Type* llvm_fptr_elem_type =llvm_utils->get_type_from_ttype_t_util(fptr, fptr_contained, module.get());
                if (is_proc_ptr) {
                    // procedure pointer cast to function pointer
                    llvm_cptr = builder->CreateBitCast(llvm_cptr,llvm_fptr_elem_type);
                    builder->CreateStore(llvm_cptr, llvm_fptr);
                } else {
                    llvm_cptr = builder->CreateBitCast(llvm_cptr,llvm_fptr_elem_type->getPointerTo());
                    builder->CreateStore(llvm_cptr, llvm_fptr);
                }
            }
            ptr_loads = ptr_loads_copy;
            tmp = nullptr;
        }
    }

    void visit_PointerAssociated(const ASR::PointerAssociated_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        llvm::AllocaInst *res = llvm_utils->CreateAlloca(
            llvm::Type::getInt1Ty(context), nullptr, "is_associated");
        ASR::ttype_t* p_type = ASRUtils::expr_type(x.m_ptr);
        llvm::Value *ptr, *nptr;
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        visit_expr_wrapper(x.m_ptr, false);
        ptr = tmp;
        if (ASRUtils::is_class_type(ASRUtils::extract_type(p_type)) && !compiler_options.new_classes) {
            // If the pointer is class, get its type pointer
            ptr = llvm_utils->create_gep2(llvm_utils->get_type_from_ttype_t_util(x.m_ptr, p_type, module.get()), ptr, 1);
            ptr = llvm_utils->CreateLoad2(llvm_utils->get_type_from_ttype_t_util(x.m_ptr, p_type, module.get())->getPointerTo(), ptr);
        } else if(ASRUtils::is_character(*p_type)){ // String OR array of strings
            ptr = ASRUtils::is_array_of_strings(p_type) ?
                llvm_utils->get_stringArray_data(p_type, ptr) :
                llvm_utils->get_string_data(ASRUtils::get_string_type(p_type), ptr);
        } else if (!ASR::is_a<ASR::PointerNullConstant_t>(*x.m_ptr)) {
            llvm::Type* p_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_ptr, p_type, module.get());
            bool load_cptr = true;
            if (ASR::is_a<ASR::CPtr_t>(*p_type) && ASR::is_a<ASR::Var_t>(*x.m_ptr)) {
                ASR::Variable_t* p_var = ASRUtils::EXPR2VAR(x.m_ptr);
                load_cptr = !is_cptr_dummy_passed_by_value(p_var);
            }
            if (load_cptr) {
                ptr = llvm_utils->CreateLoad2(p_llvm_type, ptr);
            }
        }
        if( ASRUtils::is_array(p_type) &&
            !ASRUtils::is_array_of_strings(p_type) &&
            ASRUtils::extract_physical_type(p_type) ==
            ASR::array_physical_typeType::DescriptorArray) {
            LCOMPILERS_ASSERT(ASR::is_a<ASR::Pointer_t>(*p_type));
            ptr = arr_descr->get_pointer_to_data(x.m_ptr,
                ASRUtils::type_get_past_allocatable_pointer(p_type), ptr, module.get());
            llvm::Type* array_inner_type = llvm_utils->get_type_from_ttype_t_util(x.m_ptr,
                ASRUtils::extract_type(p_type), module.get());
            ptr = llvm_utils->CreateLoad2(array_inner_type->getPointerTo(), ptr);
        }
        ptr_loads = ptr_loads_copy;
        if( ASR::is_a<ASR::CPtr_t>(*ASRUtils::expr_type(x.m_ptr)) &&
            x.m_tgt && ASR::is_a<ASR::CPtr_t>(*ASRUtils::expr_type(x.m_tgt)) ) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_tgt, true);
            ptr_loads = ptr_loads_copy;
            tmp = builder->CreateICmpEQ(
                builder->CreatePtrToInt(ptr, llvm_utils->getIntType(8, false)),
                builder->CreatePtrToInt(tmp, llvm_utils->getIntType(8, false)));
            return ;
        }
        llvm_utils->create_if_else(builder->CreateICmpEQ(
            builder->CreatePtrToInt(ptr, llvm_utils->getIntType(8, false)),
            llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), llvm::APInt(64, 0))),
        [&]() {
            builder->CreateStore(
                llvm::ConstantInt::get(llvm::Type::getInt1Ty(context), llvm::APInt(1, 0)),
                res);
        },
        [&]() {
            if (x.m_tgt) {
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr_wrapper(x.m_tgt, true);
                ptr_loads = ptr_loads_copy;
                // ASR::Variable_t *t = EXPR2VAR(x.m_tgt);
                // uint32_t t_h = get_hash((ASR::asr_t*)t);
                // nptr = llvm_symtab[t_h];
                nptr = tmp;
                if( ASRUtils::is_array(ASRUtils::expr_type(x.m_tgt)) ) {
                    ASR::array_physical_typeType tgt_ptype = ASRUtils::extract_physical_type(
                        ASRUtils::expr_type(x.m_tgt));
                    llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(x.m_tgt,
                        ASRUtils::expr_type(x.m_tgt), module.get());
                    if( tgt_ptype == ASR::array_physical_typeType::FixedSizeArray ) {
                        nptr = llvm_utils->create_gep2(array_type, nptr, 0);
                    } else if( tgt_ptype == ASR::array_physical_typeType::DescriptorArray ) {
                        llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(x.m_tgt,
                            ASRUtils::expr_type(x.m_tgt), module.get());
                        llvm::Type *array_inner_type = llvm_utils->get_type_from_ttype_t_util(x.m_ptr,
                            ASRUtils::extract_type(p_type), module.get());
                        nptr = builder->CreateLoad(array_type, nptr);
                        nptr = llvm_utils->CreateLoad2(array_inner_type->getPointerTo(), arr_descr->get_pointer_to_data(x.m_tgt, ASRUtils::expr_type(x.m_tgt), nptr, module.get()));
                    }
                }
                nptr = builder->CreatePtrToInt(nptr, llvm_utils->getIntType(8, false));
                ptr = builder->CreatePtrToInt(ptr, llvm_utils->getIntType(8, false));
                builder->CreateStore(builder->CreateICmpEQ(ptr, nptr), res);
            } else {
                llvm::Type* value_type = llvm_utils->get_type_from_ttype_t_util(x.m_ptr, p_type, module.get());
                nptr = llvm::ConstantPointerNull::get(static_cast<llvm::PointerType*>(value_type));
                nptr = builder->CreatePtrToInt(nptr, llvm_utils->getIntType(8, false));
                ptr = builder->CreatePtrToInt(ptr, llvm_utils->getIntType(8, false));
                builder->CreateStore(builder->CreateICmpNE(ptr, nptr), res);
            }
        });
        tmp = llvm_utils->CreateLoad2(llvm::Type::getInt1Ty(context), res);
    }

    // Check if the expression is a component array: an array formed by
    // accessing a scalar struct member across an array of structs
    // e.g., token%first where token is array of structs and first is scalar member
    bool is_component_array_expr(ASR::expr_t* expr) {
        if (!expr) {
            return false;
        }
        // Look past ArrayPhysicalCast
        if (ASR::is_a<ASR::ArrayPhysicalCast_t>(*expr)) {
            expr = ASR::down_cast<ASR::ArrayPhysicalCast_t>(expr)->m_arg;
        }
        if (!ASR::is_a<ASR::StructInstanceMember_t>(*expr)) {
            return false;
        }
        ASR::StructInstanceMember_t* sim = ASR::down_cast<ASR::StructInstanceMember_t>(expr);
        if (!ASRUtils::is_array(sim->m_type)) {
            return false;
        }
        ASR::ttype_t* base_type = ASRUtils::type_get_past_pointer(
            ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(sim->m_v)));
        ASR::ttype_t* member_type = ASRUtils::symbol_type(sim->m_m);
        member_type = ASRUtils::type_get_past_pointer(
            ASRUtils::type_get_past_allocatable(member_type));
        return ASRUtils::is_array(base_type) && !ASRUtils::is_array(member_type);
    }

    // Handle associate statement where the value is a component array
    // e.g., associate(first => token%first)
    // This creates a descriptor with proper stride to access struct members
    void handle_component_array_association(const ASR::Associate_t& x) {
        ASR::expr_t* value_expr = x.m_value;
        // Look past ArrayPhysicalCast
        if (ASR::is_a<ASR::ArrayPhysicalCast_t>(*value_expr)) {
            value_expr = ASR::down_cast<ASR::ArrayPhysicalCast_t>(value_expr)->m_arg;
        }
        ASR::StructInstanceMember_t* sim = ASR::down_cast<ASR::StructInstanceMember_t>(value_expr);
        ASR::Variable_t* member = ASR::down_cast<ASR::Variable_t>(
            ASRUtils::symbol_get_past_external(sim->m_m));

        // Get the base struct array
        ASR::ttype_t* base_type = ASRUtils::expr_type(sim->m_v);
        ASR::ttype_t* base_struct_array_type = ASRUtils::type_get_past_pointer(
            ASRUtils::type_get_past_allocatable(base_type));
        ASR::ttype_t* struct_elem_type = ASRUtils::type_get_past_array(base_struct_array_type);

        // Get the target and value types
        ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
        ASR::ttype_t* component_elem_type = ASRUtils::type_get_past_array(
            ASRUtils::type_get_past_pointer(target_type));

        // Visit target (the pointer variable)
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        visit_expr(*x.m_target);
        llvm::Value* target_ptr = tmp;
        ptr_loads = ptr_loads_copy;

        // Visit the base struct array
        ptr_loads_copy = ptr_loads;
        ptr_loads = 1 - !LLVM::is_llvm_pointer(*base_type);
        visit_expr(*sim->m_v);
        llvm::Value* base_array_desc = tmp;
        ptr_loads = ptr_loads_copy;

        // Get LLVM types
        llvm::Type* target_desc_type = llvm_utils->get_type_from_ttype_t_util(
            x.m_target, ASRUtils::type_get_past_pointer(target_type), module.get());
        llvm::Type* base_array_llvm_type = llvm_utils->get_type_from_ttype_t_util(
            sim->m_v, base_struct_array_type, module.get());
        llvm::Type* struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(
            sim->m_v, struct_elem_type, module.get());
        llvm::Type* component_llvm_type = llvm_utils->get_type_from_ttype_t_util(
            x.m_target, component_elem_type, module.get());

        // Create a new descriptor for the component array
        llvm::AllocaInst* new_desc = llvm_utils->CreateAlloca(
            target_desc_type, nullptr, "component_array_desc");

        // Get the struct symbol name for member index lookup
        ASR::symbol_t* struct_sym = ASRUtils::get_struct_sym_from_struct_expr(sim->m_v);
        std::string struct_name = ASRUtils::symbol_name(
            ASRUtils::symbol_get_past_external(struct_sym));
        std::string member_name = std::string(member->m_name);

        // Find the member index in the struct
        int member_idx = 0;
        std::string current_type_name = struct_name;
        while (name2memidx[current_type_name].find(member_name) == name2memidx[current_type_name].end()) {
            if (dertype2parent.find(current_type_name) == dertype2parent.end()) {
                throw CodeGenError(current_type_name + " doesn't have member " + member_name,
                                  x.base.base.loc);
            }
            current_type_name = dertype2parent[current_type_name];
        }
        member_idx = name2memidx[current_type_name][member_name];

        // Get the base array data pointer (pointer to first struct)
        ASR::array_physical_typeType base_ptype = ASRUtils::extract_physical_type(base_struct_array_type);
        llvm::Value* base_data_ptr = nullptr;

        if (base_ptype == ASR::array_physical_typeType::DescriptorArray) {
            base_data_ptr = arr_descr->get_pointer_to_data(
                sim->m_v, base_struct_array_type, base_array_desc, module.get());
            base_data_ptr = llvm_utils->CreateLoad2(struct_llvm_type->getPointerTo(), base_data_ptr);
        } else if (base_ptype == ASR::array_physical_typeType::FixedSizeArray) {
            base_data_ptr = llvm_utils->create_gep2(base_array_llvm_type, base_array_desc, 0);
        } else {
            base_data_ptr = base_array_desc;
        }

        // Get pointer to the first struct's member
        llvm::Value* first_member_ptr = llvm_utils->create_gep2(
            struct_llvm_type, base_data_ptr, member_idx);

        // Store data pointer (pointing to first element's member)
        builder->CreateStore(first_member_ptr,
            arr_descr->get_pointer_to_data(target_desc_type, new_desc));

        // Get rank from base array
        int n_dims = ASRUtils::extract_n_dims_from_ttype(base_struct_array_type);

        // Compute the stride multiplier: sizeof(struct) / sizeof(component)
        // This is the number of component-sized elements between consecutive struct elements
        llvm::DataLayout data_layout(module->getDataLayout());
        uint64_t struct_size = data_layout.getTypeAllocSize(struct_llvm_type);
        uint64_t component_size = data_layout.getTypeAllocSize(component_llvm_type);
        uint64_t stride_multiplier = struct_size / component_size;

        if (base_ptype == ASR::array_physical_typeType::DescriptorArray) {
            // Initialize descriptor using the base descriptor, then adjust strides
            arr_descr->reset_array_details(target_desc_type, new_desc, base_array_llvm_type,
                base_array_desc, n_dims);
            llvm::Value* dim_des_array = arr_descr->get_pointer_to_dimension_descriptor_array(
                target_desc_type, new_desc);
            for (int i = 0; i < n_dims; i++) {
                llvm::Value* dim_idx = llvm::ConstantInt::get(context, llvm::APInt(32, i));
                llvm::Value* target_dim_des = arr_descr->get_pointer_to_dimension_descriptor(
                    dim_des_array, dim_idx);
                llvm::Value* base_stride = arr_descr->get_stride(target_dim_des, true);
                llvm::Value* new_stride = builder->CreateMul(
                    base_stride,
                    llvm::ConstantInt::get(arr_descr->get_index_type(), stride_multiplier));
                builder->CreateStore(new_stride, arr_descr->get_stride(target_dim_des, false));
            }
        } else {
            // Set offset to 0
            unsigned index_bit_width = arr_descr->get_index_type()->getIntegerBitWidth();
            builder->CreateStore(
                llvm::ConstantInt::get(context, llvm::APInt(index_bit_width, 0)),
                arr_descr->get_offset(target_desc_type, new_desc, false));

            // Set rank
            builder->CreateStore(
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, n_dims)),
                arr_descr->get_rank(target_desc_type, new_desc, true));

            // Allocate dimension descriptors
            llvm::Type* dim_des_type = arr_descr->get_dimension_descriptor_type(false);
            llvm::Value* dim_des_array = llvm_utils->CreateAlloca(
                dim_des_type,
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), n_dims),
                "component_dim_des");
            builder->CreateStore(dim_des_array,
                arr_descr->get_pointer_to_dimension_descriptor_array(target_desc_type, new_desc, false));

            // Copy dimension info from base array with adjusted stride
            for (int i = 0; i < n_dims; i++) {
                llvm::Value* dim_idx = llvm::ConstantInt::get(context, llvm::APInt(32, i));
                llvm::Value* target_dim_des = arr_descr->get_pointer_to_dimension_descriptor(
                    dim_des_array, dim_idx);

                // For fixed-size arrays, extract dims from the type
                ASR::dimension_t* dims = nullptr;
                [[maybe_unused]] int rank = ASRUtils::extract_dimensions_from_ttype(base_struct_array_type, dims);
                LCOMPILERS_ASSERT(rank > 0 && i < rank);

                // Lower bound (default 1)
                llvm::Value* lb = llvm::ConstantInt::get(arr_descr->get_index_type(), 1);
                if (dims[i].m_start) {
                    visit_expr_wrapper(dims[i].m_start, true);
                    lb = builder->CreateSExtOrTrunc(tmp, arr_descr->get_index_type());
                }
                builder->CreateStore(lb, arr_descr->get_lower_bound(target_dim_des, false));

                // Dimension size
                llvm::Value* dim_size = llvm::ConstantInt::get(arr_descr->get_index_type(), 1);
                if (dims[i].m_length) {
                    visit_expr_wrapper(dims[i].m_length, true);
                    dim_size = builder->CreateSExtOrTrunc(tmp, arr_descr->get_index_type());
                }
                builder->CreateStore(dim_size, arr_descr->get_dimension_size(target_dim_des, false));

                // Stride for first dimension is stride_multiplier, for subsequent it's cumulative
                llvm::Value* stride = llvm::ConstantInt::get(
                    arr_descr->get_index_type(), stride_multiplier);
                if (i > 0) {
                    // Get previous dimension's stride and size
                    llvm::Value* prev_dim_idx = llvm::ConstantInt::get(context, llvm::APInt(32, i - 1));
                    llvm::Value* prev_dim_des = arr_descr->get_pointer_to_dimension_descriptor(
                        dim_des_array, prev_dim_idx);
                    llvm::Value* prev_stride = arr_descr->get_stride(prev_dim_des, true);
                    llvm::Value* prev_size = arr_descr->get_dimension_size(prev_dim_des, true);
                    stride = builder->CreateMul(prev_stride, prev_size);
                }
                builder->CreateStore(stride, arr_descr->get_stride(target_dim_des, false));
            }
        }

        // Store the new descriptor to the target pointer
        builder->CreateStore(new_desc, target_ptr);
    }

    void handle_pointer_section_target(const ASR::Associate_t& x) {
        ASR::ArraySection_t* target_section = ASR::down_cast<ASR::ArraySection_t>(x.m_target);
        
        // Get the base pointer variable from the target section
        [[maybe_unused]] ASR::Variable_t* ptr_var = ASRUtils::EXPR2VAR(target_section->m_v);
        ASR::ttype_t* value_type = ASRUtils::expr_type(x.m_value);
        
        // Get the llvm values
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        visit_expr(*target_section->m_v);
        llvm::Value* target_desc = tmp;
        
        ptr_loads = 1 - !LLVM::is_llvm_pointer(*value_type);
        visit_expr(*x.m_value);
        llvm::Value* value_desc = tmp;
        ptr_loads = ptr_loads_copy;
        
        
        llvm::Type* value_el_type = llvm_utils->get_el_type(x.m_value,
            ASRUtils::extract_type(value_type), module.get());
        
        // Create a new descriptor for the pointer with the specified bounds
        ASR::ttype_t* desc_type = ASRUtils::duplicate_type_with_empty_dims(al,
            ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(value_type)),
             ASR::array_physical_typeType::DescriptorArray, true);
        llvm::Type* target_type_llvm = llvm_utils->get_type_from_ttype_t_util(
            target_section->m_v, desc_type, module.get());
        llvm::AllocaInst *new_desc = llvm_utils->CreateAlloca(
            target_type_llvm, nullptr, "pointer_section_descriptor");
        
        // Extract bounds from the target section
        int target_rank = 0;
        Vec<llvm::Value*> lbs; lbs.reserve(al, target_section->n_args);
        Vec<llvm::Value*> ubs; ubs.reserve(al, target_section->n_args);
        
        for (size_t i = 0; i < target_section->n_args; i++) {
            ASR::array_index_t& idx = target_section->m_args[i];
            // For pointer section, we have left:right bounds
            if (idx.m_left != nullptr) {
                visit_expr_wrapper(idx.m_left, true);
                lbs.push_back(al, tmp);
                
                if (idx.m_right != nullptr) {
                    visit_expr_wrapper(idx.m_right, true);
                    ubs.push_back(al, tmp);
                } else {
                    // Use left as both bounds for single element
                    ubs.push_back(al, lbs.p[i]);
                }
                target_rank++;
            } else if (idx.m_right != nullptr) {
                // Single index - treat as 1:right
                llvm::Type* idx_type = arr_descr->get_index_type();
                unsigned idx_bits = idx_type->getIntegerBitWidth();
                lbs.push_back(al, llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1)));
                visit_expr_wrapper(idx.m_right, true);
                ubs.push_back(al, tmp);
                target_rank++;
            }
        }
        
        // Fill the descriptor with the value's data and the target's bounds
        llvm::Value* dim_des_ptr = arr_descr->get_pointer_to_dimension_descriptor_array(
            target_type_llvm, new_desc, false);
        llvm::Value* dim_des_val = llvm_utils->CreateAlloca(
            arr_descr->get_dimension_descriptor_type(false),
            llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, target_rank)));
        builder->CreateStore(dim_des_val, dim_des_ptr);
        
        // Get value data pointer
        llvm::Value* value_data = nullptr;
        ASR::array_physical_typeType value_physical_type = ASRUtils::extract_physical_type(value_type);
        if (value_physical_type == ASR::array_physical_typeType::DescriptorArray) {
            ASR::ttype_t* value_type_past_alloc = ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(value_type));
            llvm::Type* value_desc_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                value_type_past_alloc, module.get());
            if (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_value)) {
                value_desc = llvm_utils->CreateLoad2(value_desc_type->getPointerTo(), value_desc);
            } else if (ASR::is_a<ASR::ArraySection_t>(*x.m_value)) {
                ASR::ArraySection_t* as = ASR::down_cast<ASR::ArraySection_t>(x.m_value);
                ASR::ttype_t* v_type = ASRUtils::expr_type(as->m_v);
                if (ASRUtils::is_allocatable(v_type) || ASRUtils::is_pointer(v_type)) {
                    value_desc = llvm_utils->CreateLoad2(value_desc_type->getPointerTo(), value_desc);
                }
            } else if (ASR::is_a<ASR::Var_t>(*x.m_value)) {
                if (ASRUtils::is_allocatable(ASRUtils::expr_type(x.m_value)) ||
                    ASRUtils::is_pointer(ASRUtils::expr_type(x.m_value))) {
                    value_desc = llvm_utils->CreateLoad2(value_desc_type->getPointerTo(), value_desc);
                }
            }
            value_data = arr_descr->get_pointer_to_data(value_desc_type, value_desc);
            value_data = llvm_utils->CreateLoad2(value_el_type->getPointerTo(), value_data);
        } else if (value_physical_type == ASR::array_physical_typeType::FixedSizeArray ||
                   value_physical_type == ASR::array_physical_typeType::PointerArray) {
            llvm::Type* val_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(value_type)),
                module.get());
            value_data = llvm_utils->create_gep2(val_type, value_desc, 0);
        } else {
            value_data = value_desc;
        }
        
        // Store data pointer in descriptor
        builder->CreateStore(value_data, arr_descr->get_pointer_to_data(
            target_type_llvm, new_desc));
        
        // Set offset to 0
        llvm::Value* offset_ptr = arr_descr->get_offset(target_type_llvm, new_desc, false);
        llvm::Type* idx_type = arr_descr->get_index_type();
        unsigned idx_bits = idx_type->getIntegerBitWidth();
        builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 0)), offset_ptr);
        
        // Set rank
        builder->CreateStore(
            llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, target_rank)),
            arr_descr->get_rank(target_type_llvm, new_desc, true));
        
        llvm::Value* current_stride = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1));
        // Set dimension descriptors with the target bounds
        for (int i = 0; i < target_rank; i++) {
            llvm::Value* dim_idx = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, i));
            llvm::Value* dim_des = arr_descr->get_pointer_to_dimension_descriptor(dim_des_val, dim_idx);

            // Get pointers to dimension descriptor fields
            // Structure: index 0 = stride, index 1 = lower_bound, index 2 = size
            llvm::Value* stride_ptr = arr_descr->get_stride(dim_des, false);
            llvm::Value* lb_ptr = arr_descr->get_lower_bound(dim_des, false);
            llvm::Value* size_ptr = arr_descr->get_dimension_size(dim_des, false);

            // Set stride to current_stride
            builder->CreateStore(current_stride, stride_ptr);

            // Set lower bound from target section
            llvm::Value* lb_idx = builder->CreateSExtOrTrunc(lbs.p[i], idx_type);
            builder->CreateStore(lb_idx, lb_ptr);

            // Calculate and set size: ub - lb + 1
            llvm::Value* ub_idx = builder->CreateSExtOrTrunc(ubs.p[i], idx_type);
            llvm::Value* size = builder->CreateAdd(
                builder->CreateSub(ub_idx, lb_idx),
                llvm::ConstantInt::get(idx_type, 1));
            builder->CreateStore(size, size_ptr);

            // Update current_stride
            current_stride = builder->CreateMul(current_stride, size);
        }
        
        // Store the new descriptor to the target pointer
        builder->CreateStore(new_desc, target_desc);
    }

    void handle_array_section_association_to_pointer(const ASR::Associate_t& x) {
        ASR::ArraySection_t* array_section = ASR::down_cast<ASR::ArraySection_t>(x.m_value);
        ASR::ttype_t* value_array_type = ASRUtils::expr_type(array_section->m_v);
        bool is_parameter = ASRUtils::is_value_constant(array_section->m_v);

        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 1 - !LLVM::is_llvm_pointer(*value_array_type);
        visit_expr_wrapper(array_section->m_v);
        llvm::Value* value_desc = tmp;
        llvm::Type* value_desc_type = llvm_utils->get_type_from_ttype_t_util(array_section->m_v,
            ASRUtils::expr_type(array_section->m_v), module.get());
        if( ASR::is_a<ASR::StructInstanceMember_t>(*array_section->m_v) &&
            ASRUtils::extract_physical_type(value_array_type) !=
                ASR::array_physical_typeType::FixedSizeArray ) {
            value_desc = llvm_utils->CreateLoad2(value_desc_type, value_desc);
        }
        llvm::Type *value_el_type = llvm_utils->get_el_type(array_section->m_v,
              ASRUtils::extract_type(value_array_type), module.get());
        ptr_loads = 0;
        visit_expr(*x.m_target);
        llvm::Value* target_desc = tmp;
        ptr_loads = ptr_loads_copy;

        ASR::ttype_t* target_desc_type = ASRUtils::duplicate_type_with_empty_dims(al,
            ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(value_array_type)),
             ASR::array_physical_typeType::DescriptorArray, true);
        llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(array_section->m_v, target_desc_type, module.get());
        llvm::AllocaInst *target = llvm_utils->CreateAlloca(
            target_type, nullptr, "array_section_descriptor");
        if( ASRUtils::is_character(*expr_type(x.m_target))){
            llvm::Value* str_desc = llvm_utils->create_string_descriptor("array_section_string_desc");
            builder->CreateStore(str_desc, arr_descr->get_pointer_to_data(target_type, target));
        }
        int value_rank = array_section->n_args, target_rank = 0;
        Vec<llvm::Value*> lbs; lbs.reserve(al, value_rank);
        Vec<llvm::Value*> ubs; ubs.reserve(al, value_rank);
        Vec<llvm::Value*> ds; ds.reserve(al, value_rank);
        Vec<llvm::Value*> non_sliced_indices; non_sliced_indices.reserve(al, value_rank);
        ASR::ttype_t* array_type = ASRUtils::expr_type(array_section->m_v);
        ASR::array_physical_typeType arr_physical_type = ASRUtils::extract_physical_type(array_type);
        ASR::dimension_t* m_dims = nullptr;
        [[maybe_unused]] int array_value_rank = ASRUtils::extract_dimensions_from_ttype(array_type, m_dims);
        LCOMPILERS_ASSERT(array_value_rank == value_rank);
        for( int i = 0; i < value_rank; i++ ) {
            lbs.p[i] = nullptr; ubs.p[i] = nullptr; ds.p[i] = nullptr;
            non_sliced_indices.p[i] = nullptr;
            if( array_section->m_args[i].m_step != nullptr ) {
                if (array_section->m_args[i].m_left) {
                    visit_expr_wrapper(array_section->m_args[i].m_left, true);
                    lbs.p[i] = tmp;
                } else if (m_dims[i].m_start) {
                    visit_expr_wrapper(m_dims[i].m_start, true);
                    lbs.p[i] = tmp;
                } else {
                    llvm::Type* idx_type = arr_descr->get_index_type();
                    unsigned idx_bits = idx_type->getIntegerBitWidth();
                    lbs.p[i] = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1));
                }

                if (array_section->m_args[i].m_right) {
                    if (arr_physical_type == ASR::array_physical_typeType::UnboundedPointerArray &&
                        ASR::is_a<ASR::ArrayBound_t>(*array_section->m_args[i].m_right)) {
                        llvm::Value *lbound = builder->CreateSExtOrTrunc(
                            lbs.p[i], arr_descr->get_index_type());
                        ubs.p[i] = lbound;
                    } else {
                        visit_expr_wrapper(array_section->m_args[i].m_right, true);
                        ubs.p[i] = tmp;
                    }
                } else {
                    llvm::Type* idx_type = arr_descr->get_index_type();
                    unsigned idx_bits = idx_type->getIntegerBitWidth();
                    llvm::Value *lbound = builder->CreateSExtOrTrunc(lbs.p[i], idx_type);
                    if (m_dims[i].m_length) {
                        visit_expr_wrapper(m_dims[i].m_length, true);
                        llvm::Value *length = builder->CreateSExtOrTrunc(tmp, idx_type);
                        ubs.p[i] = builder->CreateSub(builder->CreateAdd(lbound, length),
                            llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1)));
                    } else {
                        // Assumed-size array: last dimension has no length
                        ubs.p[i] = lbound;
                    }
                }

                if (array_section->m_args[i].m_step) {
                    visit_expr_wrapper(array_section->m_args[i].m_step, true);
                    ds.p[i] = tmp;
                } else {
                    llvm::Type* idx_type = arr_descr->get_index_type();
                    unsigned idx_bits = idx_type->getIntegerBitWidth();
                    ds.p[i] = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1));
                }
                target_rank++;
            } else {
                visit_expr_wrapper(array_section->m_args[i].m_right, true);
                non_sliced_indices.p[i] = tmp;
            }
        }
        LCOMPILERS_ASSERT(target_rank > 0);
        llvm::Value* target_dim_des_ptr = arr_descr->get_pointer_to_dimension_descriptor_array(target_type, target, false);
        llvm::Value* target_dim_des_val = llvm_utils->CreateAlloca(arr_descr->get_dimension_descriptor_type(false),
            llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, target_rank)));
        builder->CreateStore(target_dim_des_val, target_dim_des_ptr);
        if( arr_physical_type == ASR::array_physical_typeType::PointerArray ||
            arr_physical_type == ASR::array_physical_typeType::UnboundedPointerArray ||
            arr_physical_type == ASR::array_physical_typeType::FixedSizeArray ||
            arr_physical_type == ASR::array_physical_typeType::StringArraySinglePointer) {
            if( (arr_physical_type == ASR::array_physical_typeType::FixedSizeArray ||
                arr_physical_type == ASR::array_physical_typeType::StringArraySinglePointer) &&
                !is_parameter) {
                llvm::Type *val_type = llvm_utils->get_type_from_ttype_t_util(array_section->m_v,
                    ASRUtils::type_get_past_allocatable(
                    ASRUtils::type_get_past_pointer(value_array_type)),
                    module.get());
                value_desc = llvm_utils->create_gep2(val_type, value_desc, 0);
            }
            Vec<llvm::Value*> llvm_diminfo;
            llvm_diminfo.reserve(al, value_rank * 2);
            for( int i = 0; i < value_rank; i++ ) {
                llvm::Type* idx_type = arr_descr->get_index_type();
                unsigned idx_bits = idx_type->getIntegerBitWidth();
                llvm::Value *dim_start = nullptr;
                if (m_dims[i].m_start) {
                    visit_expr_wrapper(m_dims[i].m_start, true);
                    dim_start = tmp;
                } else {
                    dim_start = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1));
                }
                llvm_diminfo.push_back(al, dim_start);

                llvm::Value *dim_length = nullptr;
                if (m_dims[i].m_length) {
                    visit_expr_wrapper(m_dims[i].m_length, true);
                    dim_length = tmp;
                } else {
                    dim_length = llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 0));
                }
                llvm_diminfo.push_back(al, dim_length);
            }
            arr_descr->fill_descriptor_for_array_section_data_only(value_desc, value_el_type, expr_type(x.m_value),
                target, expr_type(x.m_target), x.m_target,
                lbs.p, ubs.p, ds.p, non_sliced_indices.p,
                llvm_diminfo.p, value_rank, target_rank, location_manager);
        } else {
            arr_descr->fill_descriptor_for_array_section(value_desc, value_el_type, expr_type(x.m_value),
                target, expr_type(x.m_target), x.m_target,
                lbs.p, ubs.p, ds.p, non_sliced_indices.p,
                array_section->n_args, target_rank, location_manager);
        }
        builder->CreateStore(target, target_desc);
    }

    void visit_Associate(const ASR::Associate_t& x) {
        bool is_target_pointer_section = false;
        if (ASR::is_a<ASR::ArraySection_t>(*x.m_target)) {
            ASR::ArraySection_t* target_section = ASR::down_cast<ASR::ArraySection_t>(x.m_target);
            ASR::ttype_t* target_section_type = ASRUtils::expr_type(target_section->m_v);
            if (ASRUtils::is_pointer(target_section_type)) {
                is_target_pointer_section = true;
            }
        }
        if (is_target_pointer_section) {
            handle_pointer_section_target(x);
        } else if( ASR::is_a<ASR::ArraySection_t>(*x.m_value) ) {
            handle_array_section_association_to_pointer(x);
        } else if (is_component_array_expr(x.m_value)) {
            handle_component_array_association(x);
        } else {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            visit_expr(*x.m_target);
            llvm::Value* llvm_target = tmp;
            visit_expr(*x.m_value);
            llvm::Value* llvm_value = tmp;
            ptr_loads = ptr_loads_copy;
            ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
            ASR::ttype_t* value_type = ASRUtils::expr_type(x.m_value);
            ASR::dimension_t* m_dims = nullptr;
            int n_dims = ASRUtils::extract_dimensions_from_ttype(target_type, m_dims);
            ASR::ttype_t *type = ASRUtils::get_contained_type(target_type);
            type = ASRUtils::type_get_past_allocatable(type);
            [[maybe_unused]] bool is_target_class = ASRUtils::is_class_type(
                ASRUtils::type_get_past_allocatable_pointer(target_type));
            [[maybe_unused]] bool is_value_class = ASRUtils::is_class_type(
                ASRUtils::type_get_past_pointer(
                    ASRUtils::type_get_past_allocatable(value_type)));
            llvm::Type *i64 = llvm::Type::getInt64Ty(context);
            if (ASR::is_a<ASR::PointerNullConstant_t>(*x.m_value)) {
                if(ASRUtils::is_array(target_type) ){ // Fetch data ptr
                    LCOMPILERS_ASSERT(ASRUtils::extract_physical_type(target_type) ==
                        ASR::array_physical_typeType::DescriptorArray);
                    llvm::Type* target_type_llvm = llvm_utils->get_type_from_ttype_t_util(
                        x.m_target, target_type, module.get());
                    llvm_target = llvm_utils->CreateLoad2(target_type_llvm, llvm_target);
                    llvm_target = arr_descr->get_pointer_to_data(x.m_target, target_type, llvm_target, module.get());
                }
                builder->CreateStore(llvm_value, llvm_target);
            } else if ((ASRUtils::is_string_only(value_type)) && (ASRUtils::is_unlimited_polymorphic_type(target_type))){
                // String to unlimited polymorphic association
                ASR::ttype_t* target_base_type = ASRUtils::type_get_past_pointer(target_type);
                llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    x.m_target, target_base_type, module.get());
                llvm::Value* target_ptr = llvm_target;
                if (LLVM::is_llvm_pointer(*target_type)) {
                    // Allocate unlimited polymorphic wrapper if it's NULL
                    llvm::Value* null_cond = builder->CreateICmpEQ(
                        llvm_utils->CreateLoad2(target_llvm_type->getPointerTo(), llvm_target),
                        llvm::ConstantPointerNull::get(target_llvm_type->getPointerTo()));
                    llvm_utils->create_if_else(
                        null_cond,
                        [&]() {
                            llvm::Value* wrapper_size = SizeOfTypeUtil(x.m_target, target_base_type,
                                llvm_utils->getIntType(4), ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                            llvm::Value* wrapper_ptr = LLVMArrUtils::lfortran_malloc(
                                context, *module, *builder, wrapper_size);
                            builder->CreateMemSet(wrapper_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)),
                                wrapper_size, llvm::MaybeAlign());
                            wrapper_ptr = builder->CreateBitCast(wrapper_ptr, target_llvm_type->getPointerTo());
                            builder->CreateStore(wrapper_ptr, llvm_target);
                        }, []() {});
                    target_ptr = llvm_utils->CreateLoad2(target_llvm_type->getPointerTo(), llvm_target);
                }
                struct_api->store_intrinsic_type_vptr(value_type,
                    ASRUtils::extract_kind_from_ttype_t(value_type), target_ptr, module.get());
                llvm::Value* value_ptr = llvm_value;
                if (!llvm_value->getType()->isPointerTy()) {
                    // String descriptor is a value, need to allocate and get its address
                    llvm::Value* temp_alloca = llvm_utils->CreateAlloca(*builder, llvm_value->getType());
                    builder->CreateStore(llvm_value, temp_alloca);
                    value_ptr = temp_alloca;
                }
                llvm::Value* void_data_ptr = builder->CreateBitCast(value_ptr, llvm_utils->i8_ptr); //i8*
                builder->CreateStore(void_data_ptr, llvm_utils->create_gep2(target_llvm_type, target_ptr, 1));
            
            } else if(ASRUtils::is_string_only(value_type) || // Maybe we can handle this case in a string api function
                      (ASRUtils::is_unlimited_polymorphic_type(value_type) && ASRUtils::is_string_only(target_type))) {
                // Handle for unlimited_polymorphic to string pointers as well
                LCOMPILERS_ASSERT(ASRUtils::is_string_only(target_type));
                // If extracting from unlimited polymorphic, get the string descriptor pointer first
                if (ASRUtils::is_unlimited_polymorphic_type(value_type)) {    
                    ASR::ttype_t* value_base_type = ASRUtils::type_get_past_pointer(value_type);
                    llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_value, value_base_type, module.get());
                    llvm::Value* value_ptr = llvm_value;
                    if (LLVM::is_llvm_pointer(*value_type)) { 
                        value_ptr = llvm_utils->CreateLoad2(value_llvm_type->getPointerTo(), llvm_value);
                    } 
                    // Extract data pointer and cast to string_descriptor*  
                    llvm::Value* data_field_ptr = llvm_utils->create_gep2(value_llvm_type, value_ptr, 1);
                    llvm::Value* data_ptr = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, data_field_ptr);
                    llvm::Type* string_desc_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_target, target_type, module.get());
                    llvm_value = builder->CreateBitCast(data_ptr, string_desc_type->getPointerTo());
                }

                llvm::Value* target_ptr = llvm_utils->get_string_data(
                    ASRUtils::get_string_type(target_type), llvm_target, true); //i8**
                llvm::Value* value_ptr = llvm_utils->get_string_data(
                    ASRUtils::get_string_type(target_type), llvm_value); // i8*
                builder->CreateStore(value_ptr, target_ptr);
                switch (ASRUtils::get_string_type(target_type)->m_physical_type)
                {
                    case ASR::DescriptorString:{
                        llvm::Value* target_length = llvm_utils->get_string_length(
                            ASRUtils::get_string_type(target_type), llvm_target, true); // i64*
                        llvm::Value* value_length = llvm_utils->get_string_length(
                            ASRUtils::get_string_type(target_type), llvm_value); // i64
                        builder->CreateStore(value_length, target_length);
                        break;
                    }
                    default:
                        throw LCompilersException("Unhandled String Physical Type");
                }
            } else if (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_value) &&
                        ASR::is_a<ASR::FunctionType_t>(*value_type)) {
                llvm::Type* llvm_value_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, value_type, module.get());
                llvm_value = llvm_utils->CreateLoad2(llvm_value_type, llvm_value);
                builder->CreateStore(llvm_value, llvm_target);
            } else if (compiler_options.new_classes &&
                       is_target_class &&
                       !ASRUtils::is_array(target_type) &&
                       ASRUtils::is_array(value_type) &&
                       ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::AssumedRankArray) {
                // select rank (assoc => arg) rank(0) case:
                // `arg` is represented as an assumed-rank array descriptor even when rank==0,
                // but `assoc` is a scalar class pointer. Associate the scalar wrapper pointer
                // (descriptor.data) rather than bitcasting the whole descriptor.
                llvm::Type* const array_desc_type = llvm_utils->arr_api->
                    get_array_type(x.m_value, ASRUtils::type_get_past_allocatable_pointer(value_type),
                        llvm_utils->get_el_type(x.m_value, ASRUtils::extract_type(value_type), module.get()), false);
                llvm::Value* value_data_ptr = llvm_utils->create_gep2(array_desc_type, llvm_value, 0);
                llvm::Type* value_el_type = llvm_utils->get_el_type(
                    x.m_value, ASRUtils::extract_type(value_type), module.get());
                llvm::Value* wrapper_ptr = llvm_utils->CreateLoad2(
                    value_el_type->getPointerTo(), value_data_ptr);
                builder->CreateStore(wrapper_ptr, llvm_target);
            } else if (compiler_options.new_classes &&
                    (is_target_class || is_value_class) &&
                    !ASRUtils::is_array(ASRUtils::type_get_past_pointer(value_type)) &&
                    !ASRUtils::is_array(ASRUtils::type_get_past_pointer(target_type))) {
                if (LLVM::is_llvm_pointer(*value_type)) {
                    llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_value, value_type, module.get());
                    llvm_value = llvm_utils->CreateLoad2(value_llvm_type, llvm_value);
                }
                if (is_target_class && is_value_class) {
                    llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_target, target_type, module.get());
                    llvm_value = builder->CreateBitCast(llvm_value, target_llvm_type);
                    builder->CreateStore(llvm_value, llvm_target);
                } else if (is_target_class) {
                    // check_and_allocate_scalar(x.m_target, x.m_value, value_type, true);
                    llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_target, ASRUtils::extract_type(target_type), module.get());
                    
                    // Allocate class wrapper first
                    llvm::Value* null_cond = builder->CreateICmpEQ(
                        llvm_utils->CreateLoad2(target_llvm_type->getPointerTo(), llvm_target),
                        llvm::ConstantPointerNull::get(target_llvm_type->getPointerTo()));
                    llvm_utils->create_if_else(
                        null_cond,
                        [&]() {
                            llvm::Value* wrapper_size = SizeOfTypeUtil(x.m_target, target_type,
                                llvm_utils->getIntType(4), ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                            llvm::Value* wrapper_ptr = LLVMArrUtils::lfortran_malloc(
                                context, *module, *builder, wrapper_size);
                            builder->CreateMemSet(wrapper_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)),
                                wrapper_size, llvm::MaybeAlign());
                            wrapper_ptr = builder->CreateBitCast(wrapper_ptr, target_llvm_type->getPointerTo());
                            builder->CreateStore(wrapper_ptr, llvm_target);
                        }, []() {});
                    llvm_target = llvm_utils->CreateLoad2(target_llvm_type->getPointerTo(), llvm_target);

                    // Store vptr
                    if (ASRUtils::is_array(value_type)) {
                        llvm::Type* value_el_type = llvm_utils->get_el_type(x.m_value, ASRUtils::type_get_past_array(ASRUtils::type_get_past_allocatable_pointer(value_type)), module.get());
                        llvm::Value* src_data_ptr = llvm_utils->CreateLoad2(value_el_type->getPointerTo(), 
                            arr_descr->get_pointer_to_data(x.m_value, ASRUtils::type_get_past_allocatable_pointer(value_type), llvm_value, module.get()));
                        
                        if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(value_type))) {
                           llvm::Value* src_vptr = llvm_utils->CreateLoad2(llvm_utils->vptr_type, 
                               llvm_utils->create_gep2(value_el_type, src_data_ptr, 0));
                           
                           llvm::Value* dest_vptr_ptr = llvm_utils->create_gep2(target_llvm_type, llvm_target, 0);
                           builder->CreateStore(src_vptr, dest_vptr_ptr);
                           
                           llvm_value = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, 
                               llvm_utils->create_gep2(value_el_type, src_data_ptr, 1));
                        }
                    } else if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(value_type))) {
                        struct_api->store_class_vptr(
                            ASRUtils::get_struct_sym_from_struct_expr(x.m_value), llvm_target, module.get());
                    } else {
                        struct_api->store_intrinsic_type_vptr(value_type,
                            ASRUtils::extract_kind_from_ttype_t(value_type), llvm_target, module.get());
                    }

                    llvm_target = llvm_utils->create_gep2(target_llvm_type, llvm_target, 1);
                    if (ASRUtils::is_unlimited_polymorphic_type(x.m_target)) {
                        llvm_value = builder->CreateBitCast(llvm_value, llvm_utils->i8_ptr);
                    } else {
                        llvm::Type* actual_struct_type = llvm_utils->getStructType(
                            ASR::down_cast<ASR::Struct_t>(
                                ASRUtils::symbol_get_past_external(
                                    ASRUtils::get_struct_sym_from_struct_expr(x.m_target))),
                            module.get(), true);
                        llvm_value = builder->CreateBitCast(llvm_value, actual_struct_type);
                    }
                    builder->CreateStore(llvm_value, llvm_target);
                } else {
                    llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_value, ASRUtils::extract_type(value_type), module.get());
                    llvm::Value* val_data_ptr = llvm_utils->create_gep2(value_llvm_type, llvm_value, 1);
                    if (ASRUtils::is_unlimited_polymorphic_type(x.m_value)) {
                        val_data_ptr = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, val_data_ptr);
                    } else {
                        ASR::Struct_t* value_struct_type_t = ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value)));
                        llvm::Type* value_struct_type = llvm_utils->getStructType(value_struct_type_t, module.get(), true);
                        val_data_ptr = llvm_utils->CreateLoad2(value_struct_type, val_data_ptr);
                    }

                    // Handle target type: unlimited polymorphic or struct types
                    ASR::ttype_t* target_base_type = ASRUtils::type_get_past_pointer(target_type);
                    if (ASRUtils::is_unlimited_polymorphic_type(target_base_type) ||
                        ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(target_base_type))) {
                        // Target is unlimited polymorphic or a struct type 
                        ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>( 
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target)));
                        llvm::Type* struct_type = llvm_utils->getStructType(struct_type_t, module.get(), true);
                        val_data_ptr = builder->CreateBitCast(val_data_ptr, struct_type);
                        builder->CreateStore(val_data_ptr, llvm_target);
                    } else {
                        // Handle cases where unlimited polymorphic pointers are associated to 
                        // specific-typed pointers (Int, Real), used in select type blocks
                        llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                            x.m_target, target_type, module.get());
                        val_data_ptr = builder->CreateBitCast(val_data_ptr, target_llvm_type);
                        builder->CreateStore(val_data_ptr, llvm_target);
                    }
                }
            } else if (is_target_class && !is_value_class) {
                llvm::Type* llvm_target_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, target_type, module.get());
                if ( compiler_options.new_classes ) {
                    ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target)));
                    llvm_value = builder->CreateBitCast(
                        llvm_value, llvm_utils->getStructType(struct_type_t, module.get(), true));
                    builder->CreateStore(llvm_value, llvm_target);
                } else {
                    llvm::Value* vtab_address_ptr = llvm_utils->create_gep2(llvm_target_type, llvm_target, 0);
                    llvm_target = llvm_utils->create_gep2(llvm_target_type, llvm_target, 1);
                    ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value));
                    if (type2vtab.find(struct_sym) == type2vtab.end() ||
                        type2vtab[struct_sym].find(current_scope) == type2vtab[struct_sym].end()) {
                        create_vtab_for_struct_type(struct_sym, current_scope);
                    }
                    llvm::Value* vtab_obj = type2vtab[struct_sym][current_scope];
                    llvm::Type* vtab_struct_type = llvm_utils->getStructType(
                        ASR::down_cast<ASR::Struct_t>(struct_sym), module.get(), false);
                    llvm::Value* vtab_obj_casted = builder->CreateBitCast(vtab_obj, vtab_struct_type->getPointerTo());
                    llvm::Value* gep = llvm_utils->create_gep2(vtab_struct_type, vtab_obj_casted, 0);
                    llvm::Value* struct_type_hash = llvm_utils->CreateLoad2(i64, gep);
                    builder->CreateStore(struct_type_hash, vtab_address_ptr);

                    ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target)));
                    llvm_value = builder->CreateBitCast(
                        llvm_value, llvm_utils->getStructType(struct_type_t, module.get(), true));
                    builder->CreateStore(llvm_value, llvm_target);
                }
            } else if (!is_target_class && is_value_class) {
                llvm::Type* llvm_value_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, value_type, module.get());
                llvm::Value* val_data_ptr = llvm_utils->create_gep2(llvm_value_type, llvm_value, 1);
                ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target))));
                [[maybe_unused]] ASR::Struct_t* class_type_t = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value))));
                LCOMPILERS_ASSERT(ASRUtils::is_derived_type_similar(struct_type_t, class_type_t));
                llvm::Type* struct_type = llvm_utils->getStructType(struct_type_t, module.get(), true);
                llvm::Value* casted_val_ptr = builder->CreateBitCast(val_data_ptr, struct_type->getPointerTo());
                llvm::Value* struct_value = builder->CreateLoad(struct_type, casted_val_ptr);
                builder->CreateStore(struct_value, llvm_target);
            } else if( is_target_class && is_value_class ) {
                ASR::Struct_t* value_struct_t = ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value))));
                LCOMPILERS_ASSERT(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target))
                                  == ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value)));
                llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                    ASRUtils::type_get_past_allocatable_pointer(value_type), module.get());
                llvm::Type* ptr_type = llvm_utils->getStructType(
                    ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value))), module.get(), true);
                llvm::Value* gep = llvm_utils->create_gep2(value_llvm_type, llvm_value, 0);
                llvm::Value* value_vtabid = llvm_utils->CreateLoad2(i64, gep);
                llvm::Value* value_class = llvm_utils->CreateLoad2(ptr_type, llvm_utils->create_gep2(value_llvm_type, llvm_value, 1));
                builder->CreateStore(value_vtabid, llvm_utils->create_gep2(value_llvm_type, llvm_target, 0));

                if ( ASRUtils::is_unlimited_polymorphic_type(value_struct_t) ) {
                    // we need to cast `value_class` to `void*`
                    llvm::Type* void_ptr_type = llvm::Type::getVoidTy(context)->getPointerTo();
                    value_class = builder->CreateBitCast(value_class, void_ptr_type);
                }
                builder->CreateStore(value_class, llvm_utils->create_gep2(value_llvm_type, llvm_target, 1));
            } else if (ASR::is_a<ASR::Pointer_t>(*value_type) &&
                       ASR::is_a<ASR::Pointer_t>(*target_type) &&
                       ASR::is_a<ASR::FunctionCall_t>(*x.m_value)) {
                builder->CreateStore(llvm_value, llvm_target);
            } else {
                bool is_value_data_only_array = (ASRUtils::is_array(value_type) && (
                      ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::PointerArray ||
                      ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::UnboundedPointerArray ||
                      ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::FixedSizeArray ||
                      ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::DescriptorArray));
                if( LLVM::is_llvm_pointer(*value_type) ) {
                    llvm::Type* llvm_value_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, value_type, module.get());
                    llvm_value = llvm_utils->CreateLoad2(llvm_value_type, llvm_value);
                }
                if( is_value_data_only_array ) { // This needs a refactor to handle
                    ASR::ttype_t* target_type_ = ASRUtils::type_get_past_pointer(target_type);
                    switch( ASRUtils::extract_physical_type(target_type_) ) {
                        case ASR::array_physical_typeType::DescriptorArray: {
                            // class(*) array pointer association (new classes):
                            //   class(*), pointer :: generic(:)
                            //   <concrete>, target :: x(:)
                            //   generic => x
                            //
                            // Here, the array descriptor data field points to the polymorphic wrapper
                            // (e.g. %"~unlimited_polymorphic_type"*) and NOT directly to the concrete data.
                            // The wrapper then stores (vptr, i8* data). We must set both correctly.
                            if (compiler_options.new_classes &&
                                ASRUtils::is_unlimited_polymorphic_type(target_type_) &&
                                !ASRUtils::is_unlimited_polymorphic_type(value_type)) {

                                llvm::Type* llvm_target_type = llvm_utils->get_type_from_ttype_t_util(
                                    x.m_target, target_type_, module.get());
                                llvm::Value* llvm_target_ = llvm_utils->CreateAlloca(*builder, llvm_target_type);

                                llvm::Type* const dim_desc_type = llvm_utils->arr_api->get_dimension_descriptor_type(false);
                                size_t n_dims = (size_t)ASRUtils::extract_n_dims_from_ttype(value_type);
                                LCOMPILERS_ASSERT(n_dims > 0);

                                // Allocate and fill the target array descriptor dimensions
                                if (ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::DescriptorArray) {
                                    arr_descr->fill_dimension_descriptor(llvm_target_type, llvm_target_, (int)n_dims);
                                } else {
                                    ASR::dimension_t* m_dims = nullptr;
                                    ASRUtils::extract_dimensions_from_ttype(value_type, m_dims);
                                    ASR::ttype_t* data_type = ASRUtils::duplicate_type_without_dims(
                                        al, target_type_, target_type_->base.loc);
                                    llvm::Type* wrapper_llvm_type = llvm_utils->get_el_type(x.m_target, data_type, module.get());
                                    fill_array_details(llvm_target_type, llvm_target_, wrapper_llvm_type, m_dims, (int)n_dims, false, false);
                                }

                                // Allocate the polymorphic wrapper for the associated target
                                ASR::ttype_t* wrapper_asr_type = ASRUtils::extract_type(target_type_);
                                llvm::Type* wrapper_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                                    x.m_target, wrapper_asr_type, module.get());
                                llvm::Value* wrapper_size = SizeOfTypeUtil(x.m_target, wrapper_asr_type,
                                    llvm_utils->getIntType(4),
                                    ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)));
                                llvm::Value* wrapper_ptr = LLVMArrUtils::lfortran_malloc(
                                    context, *module, *builder, wrapper_size);
                                builder->CreateMemSet(wrapper_ptr, llvm::ConstantInt::get(context, llvm::APInt(8, 0)),
                                    wrapper_size, llvm::MaybeAlign());
                                wrapper_ptr = builder->CreateBitCast(wrapper_ptr, wrapper_llvm_type->getPointerTo());

                                // Get pointer to the first element of the concrete RHS array
                                llvm::Value* value_data_ptr = nullptr;
                                ASR::ttype_t* value_elem_asr_type = ASRUtils::extract_type(value_type);
                                llvm::Type* value_el_type = llvm_utils->get_el_type(
                                    x.m_value, value_elem_asr_type, module.get());
                                switch (ASRUtils::extract_physical_type(value_type)) {
                                    case ASR::array_physical_typeType::DescriptorArray: {
                                        llvm::Type* const src_array_desc_type = llvm_utils->arr_api->
                                            get_array_type(x.m_value, ASRUtils::type_get_past_allocatable_pointer(value_type),
                                                value_el_type, false);
                                        llvm::Value* src_data_ptr_ptr = llvm_utils->create_gep2(src_array_desc_type, llvm_value, 0);
                                        value_data_ptr = llvm_utils->CreateLoad2(value_el_type->getPointerTo(), src_data_ptr_ptr);
                                        break;
                                    }
                                    case ASR::array_physical_typeType::FixedSizeArray: {
                                        llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(
                                            x.m_value, value_type, module.get());
                                        value_data_ptr = llvm_utils->create_gep2(llvm_type, llvm_value, 0);
                                        break;
                                    }
                                    default: {
                                        // Other data-only physical types should be handled via explicit cases
                                        LCOMPILERS_ASSERT(false);
                                    }
                                }

                                // Store vptr + data pointer into the wrapper
                                if (ASR::is_a<ASR::StructType_t>(*value_elem_asr_type)) {
                                    llvm::Value* src_vptr = llvm_utils->CreateLoad2(
                                        llvm_utils->vptr_type, llvm_utils->create_gep2(value_el_type, value_data_ptr, 0));
                                    builder->CreateStore(src_vptr, llvm_utils->create_gep2(wrapper_llvm_type, wrapper_ptr, 0));
                                    llvm::Value* src_data_ptr = llvm_utils->CreateLoad2(
                                        llvm_utils->i8_ptr, llvm_utils->create_gep2(value_el_type, value_data_ptr, 1));
                                    builder->CreateStore(src_data_ptr, llvm_utils->create_gep2(wrapper_llvm_type, wrapper_ptr, 1));
                                } else {
                                    struct_api->store_intrinsic_type_vptr(value_elem_asr_type,
                                        ASRUtils::extract_kind_from_ttype_t(value_elem_asr_type), wrapper_ptr, module.get());
                                    llvm::Value* void_data_ptr = builder->CreateBitCast(value_data_ptr, llvm_utils->i8_ptr);
                                    builder->CreateStore(void_data_ptr, llvm_utils->create_gep2(wrapper_llvm_type, wrapper_ptr, 1));
                                }

                                // Store wrapper pointer into the class(*) array descriptor data field
                                llvm::Value* target_data_ptr = arr_descr->get_pointer_to_data(llvm_target_type, llvm_target_);
                                builder->CreateStore(wrapper_ptr, target_data_ptr);

                                // If the RHS has a descriptor, copy its dims + offset over to our new descriptor
                                if (ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::DescriptorArray) {
                                    llvm::Type* const src_array_desc_type = llvm_utils->arr_api->
                                        get_array_type(x.m_value, ASRUtils::type_get_past_allocatable_pointer(value_type),
                                            value_el_type, false);
                                    llvm::Value* src_dim_ptr = builder->CreateLoad(dim_desc_type->getPointerTo(),
                                        llvm_utils->create_gep2(src_array_desc_type, llvm_value, 2));
                                    llvm::Value* target_dim_ptr = builder->CreateLoad(dim_desc_type->getPointerTo(),
                                        llvm_utils->create_gep2(llvm_target_type, llvm_target_, 2));
                                    llvm::DataLayout data_layout(module->getDataLayout());
                                    int dim_desc_size = (int)data_layout.getTypeAllocSize(dim_desc_type);
                                    builder->CreateMemCpy(target_dim_ptr, llvm::MaybeAlign(8), src_dim_ptr, llvm::MaybeAlign(8),
                                        dim_desc_size*(int)n_dims);

                                    llvm::Value* src_offset = llvm_utils->create_gep2(src_array_desc_type, llvm_value, 1);
                                    llvm::Value* target_offset = llvm_utils->create_gep2(llvm_target_type, llvm_target_, 1);
                                    builder->CreateStore(
                                        llvm_utils->CreateLoad2(arr_descr->get_index_type(), src_offset),
                                        target_offset);
                                }

                                llvm_value = llvm_target_;
                                break;
                            }
                            if(ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::DescriptorArray){
                                    // Declare llvm type for (Array descriptor, Dimension Descriptor)
                                    llvm::Type* const value_array_desc_type = llvm_utils->arr_api->
                                        get_array_type(x.m_value, ASRUtils::type_get_past_allocatable_pointer(value_type),
                                            llvm_utils->get_el_type(x.m_value, ASRUtils::extract_type(value_type), module.get()), false);
                                    llvm::Type* const target_array_desc_type = llvm_utils->arr_api->
                                        get_array_type(x.m_target, ASRUtils::type_get_past_allocatable_pointer(target_type),
                                            llvm_utils->get_el_type(x.m_target, ASRUtils::extract_type(target_type), module.get()), false);
                                    LCOMPILERS_ASSERT(value_array_desc_type->isStructTy());
                                    LCOMPILERS_ASSERT(target_array_desc_type->isStructTy());
                                    llvm::Type* const dim_desc_type = llvm_utils->arr_api->get_dimension_descriptor_type(false);
                                    // If the target descriptor pointer is NULL, allocate one, then re-load.
                                    llvm::Value* target_desc_check = llvm_utils->CreateLoad2(
                                        target_array_desc_type->getPointerTo(), llvm_target);
                                    llvm_utils->create_if_else(
                                        builder->CreateICmpEQ(
                                            target_desc_check,
                                            llvm::ConstantPointerNull::get(target_array_desc_type->getPointerTo())),
                                        [&]() {
                                            llvm::Value* new_desc = llvm_utils->CreateAlloca(*builder, target_array_desc_type);
                                            // Allocate dimension descriptors for n_dims
                                            llvm::Value* n_dims_val = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), n_dims);
                                            llvm::Value* dim_ptr = llvm_utils->CreateAlloca(*builder, dim_desc_type, n_dims_val);
                                            builder->CreateStore(dim_ptr, llvm_utils->create_gep2(target_array_desc_type, new_desc, 2));
                                            // Store rank
                                            builder->CreateStore(n_dims_val,
                                                llvm_utils->create_gep2(target_array_desc_type, new_desc, 4));
                                            builder->CreateStore(new_desc, llvm_target);
                                        },
                                        []() {});
                                    llvm::Value* llvm_target_ = builder->CreateLoad(target_array_desc_type->getPointerTo(), llvm_target);

                                    // Get element types and check if source is a class wrapper
                                    llvm::Type* value_el_type = llvm_utils->get_el_type(x.m_value,
                                            ASRUtils::extract_type(value_type), module.get());
                                    llvm::Type* target_el_type = llvm_utils->get_el_type(x.m_target,
                                            ASRUtils::extract_type(target_type), module.get());
                                    
                                    // Check if source is a class type (has wrapper with vptr + data pointer)
                                    // and target is a concrete/derived type (not a class wrapper)
                                    bool source_is_class = compiler_options.new_classes && 
                                        ASRUtils::is_class_type(ASRUtils::extract_type(value_type));
                                    bool target_is_class = compiler_options.new_classes &&
                                        ASRUtils::is_class_type(ASRUtils::extract_type(target_type));
                                    
                                    llvm::Value* value_data_ptr = llvm_utils->create_gep2(value_array_desc_type, llvm_value, 0);
                                    llvm::Value* target_data_ptr = llvm_utils->create_gep2(target_array_desc_type, llvm_target_, 0);
                                    llvm::Value* loaded_data_ptr = builder->CreateLoad(value_el_type->getPointerTo(), value_data_ptr);
                                    
                                    if (source_is_class && !target_is_class) {
                                        // Class wrapper is {vptr, base_type*}. Extract data pointer (field 1).
                                        llvm::Value* wrapper_data_field = llvm_utils->create_gep2(value_el_type, loaded_data_ptr, 1);
                                        llvm::Type* wrapper_data_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value))), module.get(), true);
                                        llvm::Value* base_data_ptr = llvm_utils->CreateLoad2(wrapper_data_type, wrapper_data_field);
                                        // Bitcast base_type* to target_type* (e.g., abstype* -> mytype*)
                                        loaded_data_ptr = builder->CreateBitCast(base_data_ptr, target_el_type->getPointerTo());
                                    } else {
                                        // Simple bitcast if element types differ
                                        loaded_data_ptr = builder->CreateBitCast(loaded_data_ptr, target_el_type->getPointerTo());
                                    }
                                    builder->CreateStore(loaded_data_ptr, target_data_ptr);
                                    
                                    // Deep Copy dimension descriptor
                                    llvm::Value* value_dim_ptr = builder->CreateLoad(dim_desc_type->getPointerTo(),
                                                                    llvm_utils->create_gep2(value_array_desc_type, llvm_value, 2)); // Pointer to dimension descriptor of the RHS array.
                                    llvm::Value* target_dim_ptr = builder->CreateLoad(dim_desc_type->getPointerTo(),
                                                                llvm_utils->create_gep2(target_array_desc_type, llvm_target_, 2)); // Pointer to dimension descriptor of the LHS array.
                                    llvm::DataLayout data_layout(module->getDataLayout());
                                    int dim_desc_size = (int)data_layout.getTypeAllocSize(dim_desc_type);
                                    builder->CreateMemCpy(target_dim_ptr, llvm::MaybeAlign(8), value_dim_ptr, llvm::MaybeAlign(8), dim_desc_size*n_dims);
                                    // Copy offset
                                    llvm::Value* value_offset = llvm_utils->create_gep2(value_array_desc_type, llvm_value, 1); // Pointer to offset of the RHS array.
                                    llvm::Value* target_offset = llvm_utils->create_gep2(target_array_desc_type, llvm_target_, 1); // Pointer to offset of the LHS array.
                                    builder->CreateStore(builder->CreateLoad(arr_descr->get_index_type(), value_offset), target_offset);
                                    // Other fields of the array descriptor should be already set.
                                    return;
                            } else if( ASRUtils::extract_physical_type(value_type) == ASR::array_physical_typeType::FixedSizeArray ) {
                                llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                                    value_type, module.get());
                                llvm_value = llvm_utils->create_gep2(llvm_type, llvm_value, 0);
                            }
                            llvm::Type* llvm_target_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, target_type_, module.get());
                            llvm::Value* llvm_target_ = llvm_utils->CreateAlloca(*builder, llvm_target_type);
                            ASR::dimension_t* m_dims = nullptr;
                            size_t n_dims = ASRUtils::extract_dimensions_from_ttype(value_type, m_dims);
                            ASR::ttype_t* data_type = ASRUtils::duplicate_type_without_dims(
                                                        al, target_type_, target_type_->base.loc);
                            // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                            llvm::Type* llvm_data_type = llvm_utils->get_el_type(x.m_target, data_type, module.get());
                            fill_array_details(llvm_target_type, llvm_target_, llvm_data_type, m_dims, n_dims, false, false);
                            llvm::Value* target_data_ptr = arr_descr->get_pointer_to_data(llvm_target_type, llvm_target_);
#if LLVM_VERSION_MAJOR < 15
                            // Typed-pointer LLVM (<15) requires the stored pointer type to match
                            // the destination field type exactly.
                            if (llvm_value->getType() != target_data_ptr->getType()->getPointerElementType()) {
                                LCOMPILERS_ASSERT(llvm_value->getType()->isPointerTy());
                                LCOMPILERS_ASSERT(target_data_ptr->getType()->getPointerElementType()->isPointerTy());
                                llvm_value = builder->CreateBitCast(
                                    llvm_value, target_data_ptr->getType()->getPointerElementType());
                            }
#endif
                            builder->CreateStore(llvm_value, target_data_ptr);
                            llvm_value = llvm_target_;
                            break;
                        }
                        case ASR::array_physical_typeType::FixedSizeArray: {
                            llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,value_type, module.get());
                            llvm_value = llvm_utils->CreateLoad2(llvm_type, llvm_value);
                            break;
                        }
                        case ASR::array_physical_typeType::PointerArray: {
                            break;
                        }
                        default: {
                            LCOMPILERS_ASSERT(false);
                        }
                    }
                }
                builder->CreateStore(llvm_value, llvm_target);
            }
        }
    }

    void handle_StringSection_Assignment(ASR::expr_t *target, ASR::expr_t *value) {
        // Handles the case when LHS of assignment is string.
        std::string runtime_func_name = "_lfortran_str_slice_assign";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    character_type, {
                        character_type, llvm::Type::getInt64Ty(context),
                        character_type, llvm::Type::getInt64Ty(context),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context), llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt1Ty(context), llvm::Type::getInt1Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        ASR::StringSection_t *ss = ASR::down_cast<ASR::StringSection_t>(target);
        llvm::Value *lp, *rp;
        llvm::Value *str, *idx1, *idx2, *step, *str_val;
        visit_expr_load_wrapper(ss->m_arg, 0,true);
        str = tmp;
        visit_expr_load_wrapper(value, 0,true);
        str_val = tmp;
        if (ss->m_start) {
            this->visit_expr_wrapper(ss->m_start, true);
            idx1 = tmp;
            lp = llvm::ConstantInt::get(context,
                llvm::APInt(1, 1));
        } else {
            lp = llvm::ConstantInt::get(context,
                llvm::APInt(1, 0));
            idx1 = llvm::Constant::getNullValue(llvm::Type::getInt32Ty(context));
        }
        if (ss->m_end) {
            this->visit_expr_wrapper(ss->m_end, true);
            idx2 = tmp;
            rp = llvm::ConstantInt::get(context,
                llvm::APInt(1, 1));
        } else {
            rp = llvm::ConstantInt::get(context,
                llvm::APInt(1, 0));
            idx2 = llvm::Constant::getNullValue(llvm::Type::getInt32Ty(context));
        }
        if (ss->m_step) {
            this->visit_expr_wrapper(ss->m_step, true);
            step = tmp;
        } else {
            step = llvm::ConstantInt::get(context,
                llvm::APInt(32, 0));
        }
        llvm::Value* str_data, *str_len;
        std::tie(str_data, str_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(ss->m_arg), str);

        llvm::Value* str_val_data, *str_val_len;
        std::tie(str_val_data, str_val_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(value), str_val);

        tmp = builder->CreateCall(fn, {str_data, str_len, str_val_data, str_val_len, idx1, idx2, step, lp, rp});

        llvm::Value* str_arg_data {};
        llvm::Value* str_arg_len  {};
        std::tie(str_arg_data, str_arg_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(ss->m_arg), str);
        tmp = builder->CreateMemCpy(
            str_arg_data,llvm::MaybeAlign(8),
            tmp, llvm::MaybeAlign(8),
            str_arg_len);
    }

    void visit_OverloadedStringConcat(const ASR::OverloadedStringConcat_t &x) {
        LCOMPILERS_ASSERT(x.m_overloaded != nullptr)
        this->visit_expr(*x.m_overloaded);
    }

    // Logical arrays use i8 storage; scalar logicals use i1.
    // These two helpers handle the boundary conversions in one place.
    llvm::Value* logical_store_val(llvm::Value* v) {
        if (v->getType()->isIntegerTy(1))
            return builder->CreateZExt(v, llvm::Type::getInt8Ty(context));
        return v;
    }

    llvm::Value* logical_load_val(llvm::Value* ptr, ASR::expr_t* x,
                                  bool is_volatile = false) {
        if (x->type == ASR::exprType::ArrayItem &&
            ASRUtils::is_logical(*ASRUtils::expr_type(x))) {
            llvm::Value* v = llvm_utils->CreateLoad2(
                llvm::Type::getInt8Ty(context), ptr, is_volatile);
            return builder->CreateICmpNE(v,
                llvm::ConstantInt::get(llvm::Type::getInt8Ty(context), 0));
        }
        llvm::Type* t = llvm_utils->get_type_from_ttype_t_util(
            x, ASRUtils::expr_type(x), module.get());
        return llvm_utils->CreateLoad2(t, ptr, is_volatile);
    }

    void visit_Assignment(const ASR::Assignment_t &x) {
        if (compiler_options.emit_debug_info) debug_emit_loc(x);

        // Special-case: transfer(character, int8_array, size) lowered as BitCast.
        // When scalarized into element-wise assignments, extract the corresponding
        // byte from the source string.
        if (ASR::is_a<ASR::BitCast_t>(*x.m_value)) {
            ASR::BitCast_t* bc = ASR::down_cast<ASR::BitCast_t>(x.m_value);
            if (ASR::is_a<ASR::ArrayItem_t>(*x.m_target) &&
                ASRUtils::is_integer(*ASRUtils::expr_type(x.m_target)) &&
                ASR::down_cast<ASR::Integer_t>(ASRUtils::expr_type(x.m_target))->m_kind == 1 &&
                ASRUtils::is_string_only(ASRUtils::expr_type(bc->m_source))) {
                ASR::ArrayItem_t* ai = ASR::down_cast<ASR::ArrayItem_t>(x.m_target);
                if (ai->n_args == 1 && ai->m_args[0].m_right) {
                    bool is_assignment_target_copy = is_assignment_target;
                    is_assignment_target = true;
                    visit_expr(*x.m_target);
                    is_assignment_target = is_assignment_target_copy;
                    llvm::Value* dest_ptr = builder->CreateBitCast(tmp, llvm_utils->i8_ptr);

                    int64_t ptr_loads_copy = ptr_loads;
                    ptr_loads = 0;
                    visit_expr_wrapper(bc->m_source, true);
                    ptr_loads = ptr_loads_copy;
                    llvm::Value* src_desc = tmp;
                    llvm::Value* src_data = llvm_utils->get_string_data(
                        ASRUtils::get_string_type(bc->m_source), src_desc);
                    src_data = builder->CreateBitCast(src_data, llvm_utils->i8_ptr);

                    visit_expr_wrapper(ai->m_args[0].m_right, true);
                    llvm::Value* idx = tmp;
                    idx = builder->CreateZExtOrTrunc(idx, llvm::Type::getInt64Ty(context));
                    llvm::Value* zero_based = builder->CreateSub(idx, llvm::ConstantInt::get(idx->getType(), 1));
                    llvm::Value* src_byte_ptr = builder->CreateGEP(
                        llvm::Type::getInt8Ty(context), src_data, zero_based);
                    llvm::Value* byte_val = llvm_utils->CreateLoad2(
                        llvm::Type::getInt8Ty(context), src_byte_ptr);
                    builder->CreateStore(byte_val, dest_ptr);
                    return;
                }
            }

            ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
            ASR::ttype_t* target_type_past_alloc =
                ASRUtils::type_get_past_allocatable_pointer(target_type);
            if (ASRUtils::is_array(target_type_past_alloc) &&
                ASRUtils::extract_physical_type(target_type_past_alloc) ==
                    ASR::array_physical_typeType::DescriptorArray) {
                ASR::ttype_t* elem_type = ASRUtils::extract_type(target_type_past_alloc);
                bool is_int8 = ASRUtils::is_integer(*elem_type) &&
                               ASR::down_cast<ASR::Integer_t>(elem_type)->m_kind == 1;
                bool src_is_string = ASRUtils::is_string_only(ASRUtils::expr_type(bc->m_source));
                bool is_whole_array_target = (x.m_target->type == ASR::exprType::Var ||
                                              x.m_target->type == ASR::exprType::StructInstanceMember);
                if (is_int8 && src_is_string && is_whole_array_target) {
                    bool is_assignment_target_copy = is_assignment_target;
                    is_assignment_target = true;
                    visit_expr(*x.m_target);
                    is_assignment_target = is_assignment_target_copy;
                    llvm::Value* target = tmp;

                    visit_ArrayPhysicalCastUtil(
                        target, x.m_target,
                        target_type_past_alloc, target_type_past_alloc,
                        ASR::array_physical_typeType::DescriptorArray,
                        ASR::array_physical_typeType::PointerArray);
                    llvm::Value* dest_data = builder->CreateBitCast(tmp, llvm_utils->i8_ptr);

                    int64_t ptr_loads_copy = ptr_loads;
                    ptr_loads = 0;
                    visit_expr_wrapper(bc->m_source, true);
                    ptr_loads = ptr_loads_copy;
                    llvm::Value* src_desc = tmp;
                    llvm::Value* src_data = llvm_utils->get_string_data(
                        ASRUtils::get_string_type(bc->m_source), src_desc);
                    src_data = builder->CreateBitCast(src_data, llvm_utils->i8_ptr);

                    llvm::Value* nbytes = nullptr;
                    if (bc->m_size) {
                        visit_expr_wrapper(bc->m_size, true);
                        nbytes = tmp;
                    } else {
                        nbytes = llvm_utils->get_string_length(
                            ASRUtils::get_string_type(bc->m_source), src_desc);
                    }
                    if (nbytes->getType()->isIntegerTy(32)) {
                        nbytes = builder->CreateZExt(nbytes, llvm::Type::getInt64Ty(context));
                    } else if (!nbytes->getType()->isIntegerTy(64)) {
                        nbytes = builder->CreateIntCast(nbytes, llvm::Type::getInt64Ty(context), false);
                    }

                    builder->CreateMemCpy(
                        dest_data, llvm::MaybeAlign(1),
                        src_data, llvm::MaybeAlign(1),
                        nbytes);
                    return;
                }
            }
        }

        if( x.m_overloaded ) {
            this->visit_stmt(*x.m_overloaded);
            return ;
        }

        // ClassToIntrinsic store-through: when the LHS is a Cast(Var, ClassToIntrinsic, ...),
        // we extract the data pointer from the polymorphic wrapper and store the RHS into it.
        if (ASR::is_a<ASR::Cast_t>(*x.m_target) &&
            ASR::down_cast<ASR::Cast_t>(x.m_target)->m_kind ==
                ASR::cast_kindType::ClassToIntrinsic) {
            ASR::Cast_t* target_cast = ASR::down_cast<ASR::Cast_t>(x.m_target);
            ASR::ttype_t* target_type = target_cast->m_type;   // e.g., integer(4)
            ASR::ttype_t* poly_type = ASRUtils::expr_type(target_cast->m_arg); // class(*)

            // 1. Evaluate RHS
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 2;  // load to value
            this->visit_expr_wrapper(x.m_value, true);
            llvm::Value* rhs_value = tmp;

            // 2. Evaluate LHS (the class(*) variable  NOT the Cast)
            ptr_loads = 0;  // get pointer to polymorphic wrapper
            this->visit_expr(*target_cast->m_arg);
            llvm::Value* poly_ptr = tmp;
            ptr_loads = ptr_loads_copy;

            // 3. Handle allocatable/pointer extra indirection
            llvm::Type* poly_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                target_cast->m_arg, ASRUtils::extract_type(poly_type), module.get());
            if (LLVM::is_llvm_pointer(*poly_type)) {
                poly_ptr = llvm_utils->CreateLoad2(poly_llvm_type->getPointerTo(), poly_ptr);
            }

            // 4. GEP to data field (index 1), load i8*, bitcast, store
            llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                const_cast<ASR::expr_t*>(&target_cast->base),
                ASRUtils::extract_type(target_type), module.get());
            llvm::Value* data_ptr = llvm_utils->create_gep2(poly_llvm_type, poly_ptr, 1);
            data_ptr = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, data_ptr);
            data_ptr = builder->CreateBitCast(data_ptr, target_llvm_type->getPointerTo());

            if (ASRUtils::is_character(*target_type)) {
                // String assignment needs lfortran_str_copy
                llvm_utils->deepcopy(x.m_value, rhs_value, data_ptr,
                    target_type, target_type, module.get());
            } else {
                builder->CreateStore(rhs_value, data_ptr);
            }
            return;
        }

        ASR::ttype_t* asr_target_type = ASRUtils::expr_type(x.m_target);
        ASR::ttype_t* asr_value_type = ASRUtils::expr_type(x.m_value);
        bool is_target_list = ASR::is_a<ASR::List_t>(*asr_target_type);
        bool is_value_list = ASR::is_a<ASR::List_t>(*asr_value_type);
        bool is_target_tuple = ASR::is_a<ASR::Tuple_t>(*asr_target_type);
        bool is_value_tuple = ASR::is_a<ASR::Tuple_t>(*asr_value_type);
        bool is_target_dict = ASR::is_a<ASR::Dict_t>(*asr_target_type);
        bool is_value_dict = ASR::is_a<ASR::Dict_t>(*asr_value_type);
        bool is_target_set = ASR::is_a<ASR::Set_t>(*asr_target_type);
        bool is_value_set = ASR::is_a<ASR::Set_t>(*asr_value_type);
        bool is_target_struct = ASR::is_a<ASR::StructType_t>(
            *ASRUtils::type_get_past_allocatable(asr_target_type)) &&
            !ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable(asr_target_type));
        bool is_value_struct = ASR::is_a<ASR::StructType_t>(
            *ASRUtils::type_get_past_allocatable_pointer(asr_value_type)) &&
             !ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable_pointer(asr_value_type));
        // a class variable is always either an allocatable, a pointer, or a dummy argument of a procedure
        bool is_target_class = ASRUtils::is_class_type(
                                   ASRUtils::type_get_past_allocatable_pointer(asr_target_type));
        bool is_value_class = ASRUtils::is_class_type(
                                  ASRUtils::type_get_past_allocatable_pointer(asr_value_type));
        bool is_target_unlimited_polymorphic = ASRUtils::is_unlimited_polymorphic_type(x.m_target);
        bool is_value_unlimited_polymorphic = ASRUtils::is_unlimited_polymorphic_type(x.m_value);
        bool is_value_list_to_array = (ASR::is_a<ASR::Cast_t>(*x.m_value) &&
            ASR::down_cast<ASR::Cast_t>(x.m_value)->m_kind == ASR::cast_kindType::ListToArray);

        llvm::Type* asr_target_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get());


        // When assigning to a StructInstanceMember, whose instance is allocatable
        // Check if the underlying struct instance is allocated, if not allocate
        if (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_target) &&
            !ASRUtils::is_character(*asr_value_type)) {
            ASR::StructInstanceMember_t *sim = ASR::down_cast<ASR::StructInstanceMember_t>(x.m_target);
            if (!compiler_options.new_classes && ASRUtils::is_allocatable(sim->m_v) && 
                    !ASRUtils::is_array(ASRUtils::expr_type(sim->m_v))) {
                check_and_allocate_scalar(sim->m_v, x.m_value, asr_value_type);
            }

            if (ASRUtils::is_allocatable(x.m_target) && !ASRUtils::is_array(asr_target_type)) {
                check_and_allocate_scalar(x.m_target, x.m_value, asr_value_type);
            }
        }

        if( is_target_list && is_value_list ) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_target);
            llvm::Value* target_list = tmp;
            this->visit_expr(*x.m_value);
            llvm::Value* value_list = tmp;
            ptr_loads = ptr_loads_copy;
            ASR::List_t* value_asr_list = ASR::down_cast<ASR::List_t>(
                                            ASRUtils::expr_type(x.m_value));
            std::string value_type_code = ASRUtils::get_type_code(value_asr_list->m_type);
            list_api->list_deepcopy(x.m_value, value_list, target_list,
                                    value_asr_list, module.get());
            return ;
        } else if( is_target_tuple && is_value_tuple ) {
            int64_t ptr_loads_copy = ptr_loads;
            if( ASR::is_a<ASR::TupleConstant_t>(*x.m_target) &&
                !ASR::is_a<ASR::TupleConstant_t>(*x.m_value) ) {
                ptr_loads = 0;
                this->visit_expr(*x.m_value);
                llvm::Value* value_tuple = tmp;
                ASR::TupleConstant_t* const_tuple = ASR::down_cast<ASR::TupleConstant_t>(x.m_target);
                ASR::Tuple_t* tuple_type = ASR::down_cast<ASR::Tuple_t>(const_tuple->m_type);
                for( size_t i = 0; i < const_tuple->n_elements; i++ ) {
                    ptr_loads = 0;
                    visit_expr(*const_tuple->m_elements[i]);
                    llvm::Value* target_ptr = tmp;
                    llvm::Value* item = tuple_api->read_item(value_tuple, tuple_type, i, false);
                    builder->CreateStore(item, target_ptr);
                }
                ptr_loads = ptr_loads_copy;
            } else if( ASR::is_a<ASR::TupleConstant_t>(*x.m_target) &&
                       ASR::is_a<ASR::TupleConstant_t>(*x.m_value) ) {
                ASR::TupleConstant_t* asr_value_tuple = ASR::down_cast<ASR::TupleConstant_t>(x.m_value);
                ASR::TupleConstant_t* asr_target_tuple = ASR::down_cast<ASR::TupleConstant_t>(x.m_target);
                Vec<llvm::Value*> src_deepcopies;
                src_deepcopies.reserve(al, asr_value_tuple->n_elements);
                for( size_t i = 0; i < asr_value_tuple->n_elements; i++ ) {
                    ASR::ttype_t* asr_tuple_i_type = ASRUtils::expr_type(asr_value_tuple->m_elements[i]);
                    llvm::Type* llvm_tuple_i_type = llvm_utils->get_type_from_ttype_t_util(asr_value_tuple->m_elements[i], asr_tuple_i_type, module.get());
                    llvm::Value* llvm_tuple_i = llvm_utils->CreateAlloca(*builder, llvm_tuple_i_type);
                    ptr_loads = !LLVM::is_llvm_struct(asr_tuple_i_type);
                    visit_expr(*asr_value_tuple->m_elements[i]);
                    llvm_utils->deepcopy(asr_value_tuple->m_elements[i], tmp, llvm_tuple_i, expr_type(asr_target_tuple->m_elements[i]), asr_tuple_i_type, module.get());
                    src_deepcopies.push_back(al, llvm_tuple_i);
                }
                for( size_t i = 0; i < asr_target_tuple->n_elements; i++ ) {
                    ptr_loads = 0;
                    visit_expr(*asr_target_tuple->m_elements[i]);
                    llvm::Type* tuple_elem_type = llvm_utils->get_type_from_ttype_t_util(asr_target_tuple->m_elements[i], ASRUtils::expr_type(asr_target_tuple->m_elements[i]), module.get());
                    LLVM::CreateStore(*builder,
                        llvm_utils->CreateLoad2(tuple_elem_type, src_deepcopies[i]),
                        tmp
                    );
                }
                ptr_loads = ptr_loads_copy;
            } else {
                ptr_loads = 0;
                this->visit_expr(*x.m_value);
                llvm::Value* value_tuple = tmp;
                this->visit_expr(*x.m_target);
                llvm::Value* target_tuple = tmp;
                ptr_loads = ptr_loads_copy;
                ASR::Tuple_t* value_tuple_type = ASR::down_cast<ASR::Tuple_t>(asr_value_type);
                std::string type_code = ASRUtils::get_type_code(value_tuple_type->m_type,
                                                                value_tuple_type->n_type);
                tuple_api->tuple_deepcopy(x.m_value, value_tuple, target_tuple,
                                          value_tuple_type, module.get());
            }
            return ;
        } else if( is_target_dict && is_value_dict ) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_value);
            llvm::Value* value_dict = tmp;
            this->visit_expr(*x.m_target);
            llvm::Value* target_dict = tmp;
            ptr_loads = ptr_loads_copy;
            ASR::Dict_t* value_dict_type = ASR::down_cast<ASR::Dict_t>(asr_value_type);
            llvm_utils->set_dict_api(value_dict_type);

            std::string key_type_code = ASRUtils::get_type_code(value_dict_type->m_key_type);
            std::string value_type_code = ASRUtils::get_type_code(value_dict_type->m_value_type);
            llvm_utils->dict_api->dict_deepcopy(nullptr, value_dict, target_dict,
                                    value_dict_type, module.get());
            return ;
        } else if( is_target_set && is_value_set ) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_value);
            llvm::Value* value_set = tmp;
            this->visit_expr(*x.m_target);
            llvm::Value* target_set = tmp;
            ptr_loads = ptr_loads_copy;
            ASR::Set_t* value_set_type = ASR::down_cast<ASR::Set_t>(asr_value_type);
            llvm_utils->set_set_api(value_set_type);
            llvm_utils->set_api->set_deepcopy(x.m_value, value_set, target_set,
                                    value_set_type, module.get());
            return ;
        } else if (compiler_options.new_classes &&
                    (is_target_class || is_target_struct) &&
                    (is_value_class || is_value_struct)) {
            if (ASRUtils::is_allocatable(asr_target_type) && 
                    !(is_target_class && is_value_class)) {
                check_and_allocate_scalar(x.m_target, x.m_value, asr_value_type, true);
            }
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_value);
            llvm::Value* value_struct_orig = tmp;
            bool is_assignment_target_copy = is_assignment_target;
            is_assignment_target = true;
            this->visit_expr(*x.m_target);
            is_assignment_target = is_assignment_target_copy;
            llvm::Value* target_struct_orig = tmp;
            llvm::Value* ptr_to_target_struct = target_struct_orig;
            ptr_loads = ptr_loads_copy;

            llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                x.m_value, ASRUtils::extract_type(asr_value_type), module.get());
            llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                x.m_target, ASRUtils::extract_type(asr_target_type), module.get());

            if (LLVM::is_llvm_pointer(*asr_target_type)) {
                target_struct_orig = llvm_utils->CreateLoad2(target_llvm_type->getPointerTo(), target_struct_orig);
            }
            if (LLVM::is_llvm_pointer(*asr_value_type)) {
                value_struct_orig = llvm_utils->CreateLoad2(value_llvm_type->getPointerTo(), value_struct_orig);
            }

            llvm::Value* target_struct = target_struct_orig;
            llvm::Value* value_struct = value_struct_orig;
            llvm::Value* llvm_dt = value_struct;
            if (ASR::is_a<ASR::ArrayItem_t>(*x.m_value)) {
                ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(x.m_value);
                ptr_loads = LLVM::is_llvm_pointer(*ASRUtils::expr_type(array_item->m_v));
                this->visit_expr_wrapper(array_item->m_v, true);
                ptr_loads = ptr_loads_copy;
                llvm::Type* struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    array_item->m_v, ASRUtils::extract_type(array_item->m_type), module.get());
                if (ASRUtils::extract_physical_type(
                        ASRUtils::expr_type(array_item->m_v)) == ASR::array_physical_typeType::DescriptorArray) {
                    llvm_dt = llvm_utils->CreateLoad2(
                        struct_llvm_type->getPointerTo(), arr_descr->get_pointer_to_data(
                        array_item->m_v, ASRUtils::expr_type(array_item->m_v), tmp, module.get()));
                } else {
                    llvm_dt = tmp;
                }
            }

            if (is_target_unlimited_polymorphic) {
                target_struct = llvm_utils->create_gep2(target_llvm_type, target_struct, 1);
                target_struct = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, target_struct);
            } else if (is_target_class) {
                target_struct = llvm_utils->create_gep2(target_llvm_type, target_struct, 1);
                llvm::Type* target_cstruct_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target))), module.get(), true);
                target_struct = llvm_utils->CreateLoad2(target_cstruct_type, target_struct);
            } 

            if (is_value_unlimited_polymorphic) {
                value_struct = llvm_utils->create_gep2(value_llvm_type, value_struct, 1);
                value_struct = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, value_struct);
            } else if (is_value_class) {
                value_struct = llvm_utils->create_gep2(value_llvm_type, value_struct, 1);
                llvm::Type* value_cstruct_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value))), module.get(), true);
                value_struct = llvm_utils->CreateLoad2(value_cstruct_type, value_struct);
            }

            if (is_target_class && is_value_class) {
                // Use runtime copy function for class to class assignments
                // As we don't know the type of value

                // Check if this is a derived-to-base assignment
                bool use_target_copy = false;
                if (!is_target_unlimited_polymorphic && !is_value_unlimited_polymorphic) {
                    ASR::symbol_t* target_sym = ASRUtils::get_struct_sym_from_struct_expr(x.m_target);
                    ASR::symbol_t* value_sym = ASRUtils::get_struct_sym_from_struct_expr(x.m_value);
                    if (target_sym && value_sym &&
                        ASR::is_a<ASR::Struct_t>(*target_sym) &&
                        ASR::is_a<ASR::Struct_t>(*value_sym)) {
                        ASR::Struct_t* target_struct_t = ASR::down_cast<ASR::Struct_t>(target_sym);
                        ASR::Struct_t* value_struct_t = ASR::down_cast<ASR::Struct_t>(value_sym);
                        // If target is parent of value, this is derived-to-base
                        use_target_copy = ASRUtils::is_parent(value_struct_t, target_struct_t);
                    }
                }

                // For derived-to-base assignments, use the target's copy function
                // to avoid writing past the target allocation.
                // For same-type or base-to-derived, use source's copy function.
                llvm::Value* copy_source = use_target_copy ? target_struct : llvm_dt;
                
                // Use runtime allocate function for class to class assignments
                if (ASRUtils::is_allocatable(asr_target_type)) {
                    // Deallocating target first
                    Vec<ASR::expr_t*> dealloc_stmts;
                    dealloc_stmts.reserve(al, 1);
                    dealloc_stmts.push_back(al, x.m_target);
                    ASR::stmt_t* del = ASRUtils::STMT(ASR::make_ImplicitDeallocate_t(al, 
                        x.m_target->base.loc, dealloc_stmts.p, dealloc_stmts.n));
                    this->visit_stmt(*del);
                    llvm::FunctionType* fnTy = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), {llvm_utils->i8_ptr->getPointerTo()}, false);
                    llvm::PointerType *fnPtrTy = llvm::PointerType::get(fnTy, 0);
                    llvm::PointerType *fnPtrPtrTy = llvm::PointerType::get(fnPtrTy, 0);
                    llvm::PointerType *fnPtrPtrPtrTy = llvm::PointerType::get(fnPtrPtrTy, 0);
                    llvm::Value* vtable_ptr = builder->CreateBitCast(copy_source, fnPtrPtrPtrTy);
                    vtable_ptr = llvm_utils->CreateLoad2(fnPtrPtrTy, vtable_ptr);
                    llvm::Value* fn = (llvm_utils->create_ptr_gep2(fnPtrTy, vtable_ptr, 1));
                    fn = llvm_utils->CreateLoad2(fnPtrTy, fn);
                    
                    builder->CreateCall(fnTy, fn, {builder->CreateBitCast(
                        ptr_to_target_struct, llvm_utils->i8_ptr->getPointerTo())});

                    // Reload target_struct after allocation
                    target_struct_orig = llvm_utils->CreateLoad2(target_llvm_type->getPointerTo(), ptr_to_target_struct);
                    ptr_to_target_struct = llvm_utils->create_gep2(target_llvm_type, target_struct_orig, 1);
                    if (!is_target_unlimited_polymorphic) {
                        target_struct = llvm_utils->CreateLoad2(llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target))), module.get(), true), ptr_to_target_struct);
                    } else {
                        target_struct = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, ptr_to_target_struct);
                    }
                }

                llvm::FunctionType* fnTy = llvm_utils->struct_copy_functype;
                llvm::PointerType *fnPtrTy = llvm::PointerType::get(fnTy, 0);
                llvm::PointerType *fnPtrPtrTy = llvm::PointerType::get(fnPtrTy, 0);
                llvm::PointerType *fnPtrPtrPtrTy = llvm::PointerType::get(fnPtrPtrTy, 0);
                llvm::Value* vtable_ptr = builder->CreateBitCast(copy_source, fnPtrPtrPtrTy);
                vtable_ptr = llvm_utils->CreateLoad2(fnPtrPtrTy, vtable_ptr);
                llvm::Value* fn = llvm_utils->create_ptr_gep2(fnPtrTy, vtable_ptr, 0);
                fn = llvm_utils->CreateLoad2(fnPtrTy, fn);
                value_struct = builder->CreateBitCast(value_struct, llvm_utils->i8_ptr);
                target_struct = builder->CreateBitCast(target_struct, llvm_utils->i8_ptr);
                builder->CreateCall(fnTy, fn, {value_struct, target_struct});
            } else {
                ASR::symbol_t* vptr_sym;
                ASR::expr_t* deepcopy_var;
                ASR::ttype_t* deepcopy_type;
                if (is_value_class) {
                    vptr_sym = ASRUtils::get_struct_sym_from_struct_expr(x.m_target);
                    value_struct = builder->CreateBitCast(value_struct, target_llvm_type->getPointerTo());
                    deepcopy_type = ASRUtils::make_StructType_t_util(al, x.m_target->base.loc, vptr_sym, true);
                    deepcopy_var = x.m_target;
                } else {
                    vptr_sym = ASRUtils::get_struct_sym_from_struct_expr(x.m_value);
                    if (is_value_class) {
                        llvm::Type* value_cstruct_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value))),
                            module.get(), false);
                        target_struct = builder->CreateBitCast(target_struct, value_cstruct_type->getPointerTo());
                    } else {
                        target_struct = builder->CreateBitCast(target_struct, value_llvm_type->getPointerTo());
                    }
                    deepcopy_type = ASRUtils::make_StructType_t_util(al, x.m_value->base.loc, vptr_sym, true);
                    deepcopy_var = x.m_value;
                }

                llvm_utils->deepcopy(deepcopy_var, value_struct, target_struct,
                    deepcopy_type, deepcopy_type, module.get());
            }
            if (is_target_unlimited_polymorphic || is_target_class) {
                // Store Vptr from original struct
                if (is_value_class || is_value_unlimited_polymorphic) {
                    llvm::Value* vptr = builder->CreateBitCast(llvm_dt, llvm_utils->vptr_type->getPointerTo());
                    vptr = llvm_utils->CreateLoad2(llvm_utils->vptr_type, vptr);
                    builder->CreateStore(vptr, builder->CreateBitCast(
                        target_struct_orig, llvm_utils->vptr_type->getPointerTo()));
                } else {
                    builder->CreateStore(struct_api->get_pointer_to_method(ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(x.m_value)), module.get()),
                        builder->CreateBitCast(target_struct_orig, llvm_utils->vptr_type->getPointerTo()));
                }
            }
            return;
        } else if( is_target_struct && is_value_struct ) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_value);
            llvm::Value* value_struct = tmp;
            bool is_assignment_target_copy = is_assignment_target;
            is_assignment_target = true;
            this->visit_expr(*x.m_target);
            is_assignment_target = is_assignment_target_copy;
            llvm::Value* target_struct = tmp;
            ptr_loads = ptr_loads_copy;
            if (ASRUtils::is_allocatable(asr_target_type)) {
                llvm::Type* tar_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get());
                target_struct = llvm_utils->CreateLoad2(tar_type, target_struct);
            }
            if (ASRUtils::is_allocatable(asr_value_type)) {
                llvm::Type* val_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, asr_value_type, module.get());
                value_struct = llvm_utils->CreateLoad2(val_type, value_struct);
            }
            llvm_utils->deepcopy(x.m_value, value_struct, target_struct,
                asr_value_type, ASRUtils::type_get_past_allocatable(asr_target_type), module.get());
            return ;
        } else if (compiler_options.new_classes &&
                    (is_value_unlimited_polymorphic || is_target_unlimited_polymorphic)) {
            if (ASRUtils::is_allocatable(asr_target_type)) {
                check_and_allocate_scalar(x.m_target, x.m_value, asr_value_type, true);
            }
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = LLVM::is_llvm_pointer(*asr_value_type);
            this->visit_expr(*x.m_value);
            llvm::Value* value = tmp;
            ptr_loads = LLVM::is_llvm_pointer(*asr_target_type);
            bool is_assignment_target_copy = is_assignment_target;
            is_assignment_target = true;
            this->visit_expr_wrapper(x.m_target, true);
            is_assignment_target = is_assignment_target_copy;
            llvm::Value* target = tmp;
            ptr_loads = ptr_loads_copy;

            if (is_value_unlimited_polymorphic) {
                llvm_utils->deepcopy(x.m_value, value, target,
                    asr_target_type, asr_value_type, module.get());
            } else {
                struct_api->store_intrinsic_type_vptr(asr_value_type,
                    ASRUtils::extract_kind_from_ttype_t(asr_value_type), target, module.get());
                llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    x.m_target, ASRUtils::extract_type(asr_target_type), module.get());
                llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    x.m_value, ASRUtils::extract_type(asr_value_type), module.get());
                target = llvm_utils->create_gep2(target_llvm_type, target, 1);
                target = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, target);
                target = builder->CreateBitCast(target, value_llvm_type->getPointerTo());
                // With ptr_loads=0, variables produce a pointer while
                // constants produce a value directly.  deepcopy for scalar
                // intrinsic types expects a loaded value, so load only when
                // the LLVM value is actually a pointer.
                if (!ASRUtils::is_array(asr_value_type) &&
                        !ASRUtils::is_character(*asr_value_type) &&
                        value->getType()->isPointerTy()) {
                    value = llvm_utils->CreateLoad2(value_llvm_type, value);
                }
                // The target pointer has been reinterpreted as value type,
                // so pass value type wrapped in Allocatable as dest type
                // (retains the allocatable flag needed for string data
                // allocation inside the unlimited polymorphic container).
                ASR::ttype_t* dest_type_for_copy = ASRUtils::TYPE(
                    ASR::make_Allocatable_t(al, asr_value_type->base.loc, asr_value_type));
                llvm_utils->deepcopy(x.m_value, value, target,
                    dest_type_for_copy, asr_value_type, module.get());
            }
            return;
        } else if (is_target_class && is_value_class) {
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*x.m_value);
            llvm::Value* value_struct = tmp;
            bool is_assignment_target_copy = is_assignment_target;
            is_assignment_target = true;
            this->visit_expr(*x.m_target);
            is_assignment_target = is_assignment_target_copy;
            llvm::Value* target_struct = tmp;
            ptr_loads = ptr_loads_copy;
            llvm::Type *i64 = llvm::Type::getInt64Ty(context);

            // deepcopy the class hash
            llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, asr_value_type, module.get());
            llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get());

            llvm::Value* value_class_hash = llvm_utils->create_gep2(value_llvm_type, value_struct, 0);
            value_class_hash = llvm_utils->CreateLoad2(i64, value_class_hash);

            llvm::Value* target_class_hash_ptr = llvm_utils->create_gep2(target_llvm_type, target_struct, 0);

            builder->CreateStore(value_class_hash, target_class_hash_ptr);

            // deepcopy the class ptr
            ASR::ttype_t* wrapped_value_struct_type = ASRUtils::make_StructType_t_util(al, asr_value_type->base.loc,
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value)), true);
            llvm::Type* wrapper_value_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, wrapped_value_struct_type, module.get());

            ASR::ttype_t* wrapped_target_struct_type = ASRUtils::make_StructType_t_util(al, asr_target_type->base.loc,
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target)), true);
            llvm::Type* wrapper_target_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, wrapped_target_struct_type, module.get());


            llvm::Value* value_class_ptr = llvm_utils->create_gep2(value_llvm_type, value_struct, 1);
            // Get value object of value_class_type pointer
            value_class_ptr = llvm_utils->CreateLoad2(wrapper_value_llvm_type->getPointerTo(), value_class_ptr);
            value_class_ptr = llvm_utils->CreateLoad2(wrapper_value_llvm_type, value_class_ptr);

            llvm::Value* target_class_ptr = llvm_utils->create_gep2(target_llvm_type, target_struct, 1);
            // Bitcast target_class_type to value_class_type and then store value object in it
            target_class_ptr = llvm_utils->CreateLoad2(wrapper_target_llvm_type->getPointerTo(), target_class_ptr);
            target_class_ptr = builder->CreateBitCast(target_class_ptr, wrapper_value_llvm_type->getPointerTo());

            builder->CreateStore(value_class_ptr, target_class_ptr);
            return;
        } else if (ASR::is_a<ASR::Allocatable_t>(*asr_target_type) &&
                   ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable(asr_target_type)) &&
                   is_value_struct) {
            check_and_allocate_scalar(x.m_target, x.m_value, asr_value_type);
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = ASRUtils::is_allocatable(asr_value_type);
            this->visit_expr(*x.m_value);
            llvm::Value* value_struct = tmp;

            bool is_assignment_target_copy = is_assignment_target;
            is_assignment_target = true;
            ptr_loads = 0;
            this->visit_expr(*x.m_target);
            is_assignment_target = is_assignment_target_copy;

            // Get and bitcast the wrapped struct in classtype
            ASR::ttype_t* wrapped_struct_type = ASRUtils::make_StructType_t_util(al, asr_target_type->base.loc,
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_target)), true);
            llvm::Type* wrapper_struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, wrapped_struct_type, module.get())->getPointerTo();
            llvm::Value* vptr_hash = llvm_utils->create_gep2(asr_target_llvm_type, tmp, 0);
            llvm::Value* struct_type_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                llvm::APInt(64, get_class_hash(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_value)))));
            builder->CreateStore(struct_type_hash, vptr_hash);
            tmp = llvm_utils->create_gep2(asr_target_llvm_type, tmp, 1);
            tmp = llvm_utils->CreateLoad2(wrapper_struct_llvm_type, tmp);
            tmp = builder->CreateBitCast(tmp, value_struct->getType());
            ptr_loads = ptr_loads_copy;
            llvm::Value* target_struct = tmp;

            llvm_utils->deepcopy(x.m_value, value_struct, target_struct,
                asr_target_type, ASRUtils::type_get_past_allocatable(asr_value_type), module.get());
            return;
        }

        if( ASR::is_a<ASR::Pointer_t>(*ASRUtils::expr_type(x.m_target)) &&
            ASR::is_a<ASR::GetPointer_t>(*x.m_value) ) {
            ASR::Variable_t *asr_target = EXPR2VAR(x.m_target);
            ASR::GetPointer_t* get_ptr = ASR::down_cast<ASR::GetPointer_t>(x.m_value);
            uint32_t target_h = get_hash((ASR::asr_t*)asr_target);
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 2 - LLVM::is_llvm_pointer(*ASRUtils::expr_type(get_ptr->m_arg));
            visit_expr_wrapper(get_ptr->m_arg, true);
            ptr_loads = ptr_loads_copy;
            if( ASRUtils::is_array(ASRUtils::expr_type(get_ptr->m_arg)) &&
                ASRUtils::extract_physical_type(ASRUtils::expr_type(get_ptr->m_arg)) !=
                ASR::array_physical_typeType::DescriptorArray) {
                visit_ArrayPhysicalCastUtil(
                    tmp, get_ptr->m_arg, ASRUtils::type_get_past_pointer(
                        ASRUtils::type_get_past_allocatable(get_ptr->m_type)),
                        ASRUtils::expr_type(get_ptr->m_arg),
                    ASRUtils::extract_physical_type(ASRUtils::expr_type(get_ptr->m_arg)),
                    ASR::array_physical_typeType::DescriptorArray);
            }
            builder->CreateStore(tmp, llvm_symtab[target_h]);
            return ;
        }

        // Handle BitCast (transfer intrinsic) to character arrays
        if (ASR::is_a<ASR::BitCast_t>(*x.m_value)) {
            ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
            // Only handle array-related targets
            bool is_array_target = (x.m_target->type == ASR::exprType::ArraySection) ||
                                   (x.m_target->type == ASR::exprType::ArrayItem) ||
                                   (x.m_target->type == ASR::exprType::Var && ASRUtils::is_array(target_type));
            if (is_array_target) {
                ASR::ttype_t* elem_type = target_type;
                if(ASRUtils::is_array(target_type)){
                    elem_type = ASRUtils::extract_type(target_type);
                }
                if (ASRUtils::is_character(*elem_type)){
                    handle_bitcast_assignment_char(x);
                    return;
                }
            }
        }

        llvm::Value *target, *value;
        uint32_t h;
        if( x.m_target->type == ASR::exprType::ArrayItem ||
            x.m_target->type == ASR::exprType::StringItem ||
            x.m_target->type == ASR::exprType::StringSection ||
            x.m_target->type == ASR::exprType::ArraySection ||
            x.m_target->type == ASR::exprType::StructInstanceMember ||
            x.m_target->type == ASR::exprType::ListItem ||
            x.m_target->type == ASR::exprType::DictItem ||
            x.m_target->type == ASR::exprType::UnionInstanceMember ||
            (x.m_target->type == ASR::exprType::FunctionCall &&
             ASRUtils::is_pointer(ASRUtils::expr_type(x.m_target))) ) {
            is_assignment_target = true;
            this->visit_expr(*x.m_target);
            is_assignment_target = false;
            target = tmp;
            if( ASR::is_a<ASR::ListItem_t>(*x.m_target) ) {
                ASR::ListItem_t* asr_target0 = ASR::down_cast<ASR::ListItem_t>(x.m_target);
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr(*asr_target0->m_a);
                ptr_loads = ptr_loads_copy;
                llvm::Value* list = tmp;
                this->visit_expr_wrapper(asr_target0->m_pos, true);
                llvm::Value* pos = tmp;

                target = list_api->read_item_using_ttype(asr_target0->m_type, list, pos, compiler_options.po.bounds_checking,
                                             module.get(), true);
            }
        } else {
            if (!ASR::is_a<ASR::Var_t>(*x.m_target)) {
                std::string target_type = "unknown";
                if (x.m_target->type == ASR::exprType::StringConstant) {
                    target_type = "StringConstant (this is likely a bug in an ASR pass that incorrectly "
                                  "constant-folded an assignment target like ch(5:5) = 'X')";
                } else {
                    target_type = "type " + std::to_string(x.m_target->type);
                }
                throw CodeGenError("Assignment target must be a variable or subscripted expression, got: " + target_type);
            }
            ASR::Variable_t *asr_target = EXPR2VAR(x.m_target);
            h = get_hash((ASR::asr_t*)asr_target);
            target = llvm_symtab[h];
            if (ASR::is_a<ASR::Pointer_t>(*asr_target->m_type) &&
                !ASR::is_a<ASR::CPtr_t>(
                    *ASRUtils::get_contained_type(asr_target->m_type)) &&
                !ASR::is_a<ASR::StructType_t>(
                    *ASRUtils::get_contained_type(asr_target->m_type)) &&
                !ASRUtils::is_character(*asr_target->m_type)) {
                llvm::Type* target_load_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target->m_type, module.get());
                target = llvm_utils->CreateLoad2(target_load_type, target);
            }
            ASR::ttype_t *cont_type = ASRUtils::get_contained_type(asr_target_type);
            if ( ASRUtils::is_array(cont_type) ) {
                if( is_value_list_to_array ) {
                    this->visit_expr_wrapper(x.m_value, true);
                    llvm::Value* list_data = tmp;
                    int64_t ptr_loads_copy = ptr_loads;
                    ptr_loads = 0;
                    this->visit_expr(*ASR::down_cast<ASR::Cast_t>(x.m_value)->m_arg);
                    llvm::Value* plist = tmp;
                    ptr_loads = ptr_loads_copy;
                    llvm::Value* array_data = nullptr;
                    if( ASRUtils::extract_physical_type(asr_target_type) ==
                        ASR::array_physical_typeType::DescriptorArray ) {
                        llvm::Type* elem_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::get_contained_type(asr_target_type), module.get());
                        llvm::Type* desc_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get());
                        array_data = llvm_utils->CreateLoad2(elem_type->getPointerTo(),
                            arr_descr->get_pointer_to_data(desc_type->getPointerTo(), llvm_utils->CreateLoad2(desc_type->getPointerTo(), target)));
                    } else if( ASRUtils::extract_physical_type(asr_target_type) ==
                               ASR::array_physical_typeType::FixedSizeArray ) {
                        llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get());
                        array_data = llvm_utils->create_gep2(target_llvm_type, target, 0);
                    } else {
                        LCOMPILERS_ASSERT(false);
                    }
                    llvm::Type* list_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get());
                    llvm::Value* size = list_api->len_using_type(list_llvm_type, plist);
                    llvm::Type* el_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                        ASRUtils::extract_type(ASRUtils::expr_type(x.m_value)), module.get());
                    llvm::DataLayout data_layout(module->getDataLayout());
                    uint64_t size_ = data_layout.getTypeAllocSize(el_type);
                    size = builder->CreateMul(size, llvm::ConstantInt::get(
                        llvm::Type::getInt32Ty(context), llvm::APInt(32, size_)));
                    builder->CreateMemCpy(array_data, llvm::MaybeAlign(),
                                          list_data, llvm::MaybeAlign(), size);
                    return ;
                }
                if( asr_target->m_type->type == ASR::ttypeType::String ) {
                    llvm::Type* char_ptr_type = character_type->getPointerTo();
                    llvm::Type* desc_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, asr_target_type, module.get())->getPointerTo();
                    target = llvm_utils->CreateLoad2(char_ptr_type, arr_descr->get_pointer_to_data(desc_type, target));
                }
            }
        }
        if( ASR::is_a<ASR::UnionConstructor_t>(*x.m_value) ) {
            return ;
        }
        ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
        ASR::ttype_t* value_type = ASRUtils::expr_type(x.m_value);
        ASR::expr_t *m_value = x.m_value;
        if (ASRUtils::is_simd_array(x.m_target) && ASR::is_a<ASR::ArraySection_t>(*m_value)) {
            m_value = ASR::down_cast<ASR::ArraySection_t>(m_value)->m_v;
        }
        int ptr_loads_copy = ptr_loads;
        if(ASRUtils::is_string_only(value_type)){
            ptr_loads = 0;
        } else if(ASRUtils::is_array(value_type)){
            ptr_loads = 1;
        } else {
            ptr_loads = 2;
        }
        this->visit_expr_wrapper(m_value, true);
        ptr_loads = ptr_loads_copy;
        if( ASR::is_a<ASR::Var_t>(*x.m_value) &&
            ASR::is_a<ASR::UnionType_t>(*value_type) ) {
            llvm::Type* union_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, value_type, module.get());
            tmp = llvm_utils->CreateLoad2(union_type, tmp);
        }
        value = tmp;
        if (x.m_target->type == ASR::exprType::ArrayItem)
            value = logical_store_val(value);

        if (ASR::is_a<ASR::StructType_t>(*target_type) && !ASRUtils::is_class_type(target_type)) {
            if (value->getType()->isPointerTy()) {
                llvm::Type* st_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, target_type, module.get());
                value = llvm_utils->CreateLoad2(st_type, value);
            }
        }
        if ( ASRUtils::is_string_only(ASRUtils::expr_type(x.m_value))) {
            // For struct members (especially common blocks), treat as allocatable
            // so _lfortran_strcpy allocates memory if the pointer is NULL.
            // Common block structs are initialized with zeroinitializer, so
            // their string descriptor pointers start as NULL.
            bool is_dest_allocatable = ASRUtils::is_allocatable(asr_target_type) ||
                                       ASR::is_a<ASR::StructInstanceMember_t>(*x.m_target);
            llvm_utils->lfortran_str_copy(target, value,
                ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(asr_target_type)),
                ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(asr_value_type)),
                is_dest_allocatable);
            tmp = nullptr;
            return;
        }
        if( ASRUtils::is_array(target_type) &&
            ASRUtils::is_array(value_type) &&
            ASRUtils::check_equal_type(target_type, value_type, x.m_target, x.m_value) ) {
            bool data_only_copy = false;
            ASR::array_physical_typeType target_ptype = ASRUtils::extract_physical_type(target_type);
            ASR::array_physical_typeType value_ptype = ASRUtils::extract_physical_type(value_type);
            bool is_target_data_only_array = (target_ptype == ASR::array_physical_typeType::PointerArray ||
                                             target_ptype == ASR::array_physical_typeType::UnboundedPointerArray);
            bool is_value_data_only_array = (value_ptype == ASR::array_physical_typeType::PointerArray ||
                                            value_ptype == ASR::array_physical_typeType::UnboundedPointerArray);
            bool is_target_fixed_sized_array = (target_ptype == ASR::array_physical_typeType::FixedSizeArray);
            bool is_value_fixed_sized_array = (value_ptype == ASR::array_physical_typeType::FixedSizeArray);
            bool is_target_simd_array = (target_ptype == ASR::array_physical_typeType::SIMDArray);
            bool is_target_descriptor_based_array = (target_ptype == ASR::array_physical_typeType::DescriptorArray);
            bool is_value_descriptor_based_array = (value_ptype == ASR::array_physical_typeType::DescriptorArray);
            llvm::Type* target_el_type = llvm_utils->get_el_type(
                x.m_target, ASRUtils::extract_type(target_type), module.get());
            llvm::Type* value_el_type = llvm_utils->get_el_type(
                x.m_value, ASRUtils::extract_type(value_type), module.get());
            if( is_value_fixed_sized_array && is_target_fixed_sized_array ) {
                ASR::dimension_t* asr_dims = nullptr;
                size_t asr_n_dims = ASRUtils::extract_dimensions_from_ttype(target_type, asr_dims);
                int64_t size = ASRUtils::get_fixed_size_of_array(asr_dims, asr_n_dims);
                llvm::DataLayout data_layout(module->getDataLayout());
                uint64_t data_size = data_layout.getTypeAllocSize(target_el_type);
                llvm::Value* llvm_size = llvm::ConstantInt::get(context, llvm::APInt(32, size));
                llvm_size = builder->CreateMul(llvm_size,
                    llvm::ConstantInt::get(context, llvm::APInt(32, data_size)));
                builder->CreateMemCpy(target, llvm::MaybeAlign(), value, llvm::MaybeAlign(), llvm_size);
            } else if( is_value_descriptor_based_array && is_target_fixed_sized_array ) {
                value = llvm_utils->CreateLoad2(value_el_type->getPointerTo(), arr_descr->get_pointer_to_data(x.m_value, value_type, value, module.get()));
                llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, target_type, module.get());
                target = llvm_utils->create_gep2(target_llvm_type, target, 0);
                ASR::dimension_t* asr_dims = nullptr;
                size_t asr_n_dims = ASRUtils::extract_dimensions_from_ttype(target_type, asr_dims);
                int64_t size = ASRUtils::get_fixed_size_of_array(asr_dims, asr_n_dims);
                llvm::DataLayout data_layout(module->getDataLayout());
                uint64_t data_size = data_layout.getTypeAllocSize(target_el_type);
                llvm::Value* llvm_size = llvm::ConstantInt::get(context, llvm::APInt(32, size));
                llvm_size = builder->CreateMul(llvm_size,
                    llvm::ConstantInt::get(context, llvm::APInt(32, data_size)));
                builder->CreateMemCpy(target, llvm::MaybeAlign(), value, llvm::MaybeAlign(), llvm_size);
            } else if( is_target_descriptor_based_array && is_value_fixed_sized_array ) {
                if( ASRUtils::is_allocatable(target_type) ) {
                    llvm::Type* alloc_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::type_get_past_allocatable_pointer(target_type), module.get());
                    target = llvm_utils->CreateLoad2(alloc_type->getPointerTo(), target);
                }
                llvm::Type* llvm_array_type = llvm_utils->get_type_from_ttype_t_util(x.m_target,
                        ASRUtils::type_get_past_allocatable_pointer(target_type), module.get());
                llvm::Value* llvm_size = arr_descr->get_array_size(llvm_array_type, target, nullptr, 4);
                target = llvm_utils->CreateLoad2(target_el_type->getPointerTo(), arr_descr->get_pointer_to_data(llvm_utils->get_type_from_ttype_t_util(x.m_target,
                    ASRUtils::type_get_past_allocatable_pointer(target_type),
                    module.get()), target));
                llvm::DataLayout data_layout(module->getDataLayout());
                uint64_t data_size = data_layout.getTypeAllocSize(value_el_type);
                llvm_size = builder->CreateMul(llvm_size,
                    llvm::ConstantInt::get(context, llvm::APInt(32, data_size)));
                builder->CreateMemCpy(target, llvm::MaybeAlign(), value, llvm::MaybeAlign(), llvm_size);
            } else if( is_target_data_only_array || is_value_data_only_array ) {
                if( is_value_fixed_sized_array ) {
                    is_value_data_only_array = true;
                }
                if( is_target_fixed_sized_array ) {
                    is_target_data_only_array = true;
                }
                llvm::Value *target_data = nullptr, *value_data = nullptr, *llvm_size = nullptr;
                llvm_size = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 1));
                if( is_target_data_only_array ) {
                    target_data =
                        ASRUtils::is_array_of_strings(target_type) ?
                        llvm_utils->get_stringArray_data(target_type, target):
                        target;
                    ASR::dimension_t* target_dims = nullptr;
                    int target_ndims = ASRUtils::extract_dimensions_from_ttype(target_type, target_dims);
                    data_only_copy = true;
                    for( int i = 0; i < target_ndims; i++ ) {
                        if( target_dims[i].m_length == nullptr ) {
                            data_only_copy = false;
                            break;
                        }
                        this->visit_expr_wrapper(target_dims[i].m_length, true);
                        llvm_size = builder->CreateMul(llvm_size, builder->CreateSExtOrTrunc(tmp,
                                llvm::Type::getInt32Ty(context)));
                    }
                    if(ASRUtils::is_array_of_strings(target_type)){ // Neglect previous llvm_size
                        llvm_size = llvm_utils->get_stringArray_whole_size(target_type);
                    }
                } else {
                    llvm::Type* load_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::type_get_past_allocatable_pointer(target_type), module.get());
                    target = llvm_utils->CreateLoad2(load_type->getPointerTo(), target);
                    target_data =
                            ASRUtils::is_array_of_strings(target_type) ?
                            llvm_utils->get_stringArray_data(target_type, target) :
                            llvm_utils->CreateLoad2(llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::get_contained_type(target_type), module.get())->getPointerTo(), arr_descr->get_pointer_to_data(llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::type_get_past_allocatable_pointer(target_type), module.get()), target));
                }
                if( is_value_data_only_array ) {
                    value_data =
                            ASRUtils::is_array_of_strings(value_type) ?
                            llvm_utils->get_stringArray_data(value_type, value):
                            value;
                    ASR::dimension_t* value_dims = nullptr;
                    int value_ndims = ASRUtils::extract_dimensions_from_ttype(value_type, value_dims);
                    if( !data_only_copy ) {
                        llvm_size = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 1));
                        data_only_copy = true;
                        for( int i = 0; i < value_ndims; i++ ) {
                            if( value_dims[i].m_length == nullptr ) {
                                data_only_copy = false;
                                break;
                            }
                            this->visit_expr_wrapper(value_dims[i].m_length, true);
                            tmp = builder->CreateSExtOrTrunc(tmp, llvm::Type::getInt32Ty(context));
                            llvm_size = builder->CreateMul(llvm_size, tmp);
                        }
                        if(ASRUtils::is_array_of_strings(value_type)){ // Neglect previous llvm_size
                            llvm_size = llvm_utils->get_stringArray_whole_size(value_type);
                        }
                    }
                } else {
                    llvm::Type* llvm_array_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                        ASRUtils::type_get_past_array(
                            ASRUtils::type_get_past_allocatable_pointer(
                                ASRUtils::expr_type(x.m_value))), module.get());
                    llvm::Type* llvm_array_type_ = llvm_utils->get_type_from_ttype_t_util(x.m_value, ASRUtils::expr_type(x.m_value), module.get());
                    value_data =
                            ASRUtils::is_array_of_strings(value_type) ?
                            llvm_utils->get_stringArray_data(value_type, value) :
                            llvm_utils->CreateLoad2(
                                llvm_array_type->getPointerTo(),
                                arr_descr->get_pointer_to_data(llvm_array_type_, value));
                }
                LCOMPILERS_ASSERT(data_only_copy);
                arr_descr->copy_array_data_only(target_data, value_data, module.get(),
                                                target_el_type,
                                                target_type,
                                                llvm_size);
            } else if ( is_target_simd_array ) {
                if (ASR::is_a<ASR::ArraySection_t>(*x.m_value)) {
                    int idx = 1;
                    ASR::ArraySection_t *arr = down_cast<ASR::ArraySection_t>(x.m_value);
                    (void) ASRUtils::extract_value(arr->m_args->m_left, idx);
                    llvm::Type* value_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_value, value_type, module.get());
                    value = llvm_utils->create_gep2(value_llvm_type, value, idx-1);
                    llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, target_type, module.get());
                    target = llvm_utils->create_gep2(target_llvm_type, target, 0);
                    ASR::dimension_t* asr_dims = nullptr;
                    size_t asr_n_dims = ASRUtils::extract_dimensions_from_ttype(target_type, asr_dims);
                    int64_t size = ASRUtils::get_fixed_size_of_array(asr_dims, asr_n_dims);
                    llvm::DataLayout data_layout(module->getDataLayout());
                    uint64_t data_size = data_layout.getTypeAllocSize(target_el_type);
                    llvm::Value* llvm_size = llvm::ConstantInt::get(context, llvm::APInt(32, size));
                    llvm_size = builder->CreateMul(llvm_size,
                        llvm::ConstantInt::get(context, llvm::APInt(32, data_size)));
                    builder->CreateMemCpy(target, llvm::MaybeAlign(), value, llvm::MaybeAlign(), llvm_size);
                } else {
                    builder->CreateStore(value, target);
                }
            } else {
                if( LLVM::is_llvm_pointer(*target_type) ) {
                    llvm::Type* ptr_load_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::type_get_past_allocatable_pointer(target_type), module.get());
                    target = llvm_utils->CreateLoad2(ptr_load_type->getPointerTo(), target);
                }
                llvm::Type* target_array_type = llvm_utils->get_type_from_ttype_t_util(x.m_target,
                        ASRUtils::type_get_past_allocatable_pointer(target_type), module.get());
                llvm::Type* source_array_type = llvm_utils->get_type_from_ttype_t_util(x.m_value,
                        ASRUtils::type_get_past_allocatable_pointer(value_type), module.get());
                if (x.m_move_allocation) {
                    arr_descr->copy_array_move_allocation(source_array_type, value, target_array_type, target, module.get(), x.m_target, target_type);
                } else {
                    arr_descr->copy_array(source_array_type, value, target_array_type, target, module.get(), x.m_target, target_type, false);
                }
            }
        } else if( ASR::is_a<ASR::DictItem_t>(*x.m_target) ) {
            ASR::DictItem_t* dict_item_t = ASR::down_cast<ASR::DictItem_t>(x.m_target);
            ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(
                                    ASRUtils::expr_type(dict_item_t->m_a));
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*dict_item_t->m_a);
            llvm::Value* pdict = tmp;

            ptr_loads = !LLVM::is_llvm_struct(dict_type->m_key_type);
            this->visit_expr_wrapper(dict_item_t->m_key, true);
            llvm::Value *key = tmp;
            ptr_loads = ptr_loads_copy;

            llvm_utils->set_dict_api(dict_type);
            // Note - The value is fully loaded to an LLVM value (not at all a pointer)
            // as opposed to DictInsert where LLVM values are loaded depending upon
            // the ASR type of value. Might give issues here.
            llvm_utils->dict_api->write_item(dict_item_t->m_a, pdict, key, value, module.get(),
                                dict_type->m_key_type,
                                dict_type->m_value_type);
        } else if (ASRUtils::is_allocatable(target_type)) {
            ASR::ttype_t* asr_type = ASRUtils::type_get_past_pointer(
                ASRUtils::type_get_past_allocatable(
                ASRUtils::expr_type(x.m_target)));
            if (ASR::is_a<ASR::Integer_t>(*asr_type) ||
                ASR::is_a<ASR::Real_t>(*asr_type) ||
                ASR::is_a<ASR::Complex_t>(*asr_type) ||
                ASR::is_a<ASR::Logical_t>(*asr_type)) {
                check_and_allocate_scalar(x.m_target);
            }

            if (!LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_value))) {
                llvm::Type* target_ptr_type = llvm_utils->get_type_from_ttype_t_util(x.m_target, ASRUtils::expr_type(x.m_target), module.get());
                target = llvm_utils->CreateLoad2(target_ptr_type, target);
            }
            builder->CreateStore(value, target);
        } else {
            builder->CreateStore(value, target);
        }
    }

    void generate_binop_check(ASR::expr_t* left, ASR::expr_t* right) {
        ASR::ttype_t *type32 = ASRUtils::TYPE(ASR::make_Integer_t(al, left->base.loc, 4));

        ASR::ttype_t* left_type = ASRUtils::expr_type(left);
        ASR::ttype_t* right_type = ASRUtils::expr_type(right);
        ASR::dimension_t* m_dims = nullptr;
        size_t lrank = ASRUtils::extract_dimensions_from_ttype(left_type, m_dims);
        ASR::dimension_t* n_dims = nullptr;
        size_t rrank = ASRUtils::extract_dimensions_from_ttype(right_type, n_dims);

        if (lrank == 0 || rrank == 0 || lrank != rrank) {
            return;
        }

        for (size_t dim = 0; dim < lrank; dim++) {
            ASR::expr_t* dim_asr = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, m_dims[dim].loc, dim + 1,
                        ASRUtils::TYPE(ASR::make_Integer_t(al, m_dims[dim].loc, 4))));

            ASR::expr_t* left_size = ASRUtils::EXPR(ASR::make_ArraySize_t(al, left->base.loc,
                left, dim_asr, type32, nullptr));
            visit_expr(*left_size);
            llvm::Value* left_llvm_size = tmp;

            ASR::expr_t* right_size = ASRUtils::EXPR(ASR::make_ArraySize_t(al, right->base.loc,
                right, dim_asr, type32, nullptr));
            visit_expr(*right_size);
            llvm::Value* right_llvm_size = tmp;

            ASR::Variable_t* left_var = ASRUtils::expr_to_variable_or_null(left);
            ASR::Variable_t* right_var = ASRUtils::expr_to_variable_or_null(right);

            llvm::Value* dim_llvm = llvm::ConstantInt::get(context, llvm::APInt(32, dim + 1));
            if (left_var && right_var) {
                llvm::Value *left_name = LCompilers::create_global_string_ptr(context, *module, *builder, left_var->m_name);
                llvm::Value *right_name = LCompilers::create_global_string_ptr(context, *module, *builder, right_var->m_name);
                llvm_utils->generate_runtime_error(builder->CreateICmpNE(right_llvm_size, left_llvm_size),
                                                    "Array shape mismatch in binary operation with operands '%s' and '%s'. Tried to match size %d of dimension %d of '%s' with size %d of dimension %d of '%s'.",
                                                    {LLVMUtils::RuntimeLabel("LHS size is %d", {left->base.loc}, {left_llvm_size}),
                                                    LLVMUtils::RuntimeLabel("RHS size is %d", {right->base.loc}, {right_llvm_size})},
                                                    infile,
                                                    location_manager,
                                                    left_name,
                                                    right_name,
                                                    left_llvm_size,
                                                    dim_llvm,
                                                    left_name,
                                                    right_llvm_size,
                                                    dim_llvm,
                                                    right_name);
            } else {
                llvm_utils->generate_runtime_error(builder->CreateICmpNE(right_llvm_size, left_llvm_size),
                                                    "Array shape mismatch in binary operation. Tried to match size %d of dimension %d of one argument with size %d of dimension %d of the other.",
                                                    {LLVMUtils::RuntimeLabel("LHS size is %d", {left->base.loc}, {left_llvm_size}),
                                                    LLVMUtils::RuntimeLabel("RHS size is %d", {right->base.loc}, {right_llvm_size})},
                                                    infile,
                                                    location_manager,
                                                    left_llvm_size,
                                                    dim_llvm,
                                                    right_llvm_size,
                                                    dim_llvm);
            }
        }
    }

    void generate_binop_checks(ASR::expr_t** components, size_t n) {
        for (size_t i = 0; i < n - 1; i++) {
            generate_binop_check(components[i], components[i + 1]);
        }
    }

    void visit_DebugCheckArrayBounds(const ASR::DebugCheckArrayBounds_t &x) {
        if (compiler_options.po.bounds_checking) {
            // Check for errors in array operations in the RHS of the assignment
            generate_binop_checks(x.m_components, x.n_components);

            ASR::ttype_t *type32 = ASRUtils::TYPE(ASR::make_Integer_t(al, x.m_components[0]->base.loc, 4));

            ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
            ASR::dimension_t* m_dims = nullptr;
            size_t rank = ASRUtils::extract_dimensions_from_ttype(target_type, m_dims);
            for (size_t dim = 0; dim < rank; dim++) {
                ASR::expr_t* dim_asr = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, m_dims[dim].loc, dim + 1,
                            ASRUtils::TYPE(ASR::make_Integer_t(al, m_dims[dim].loc, 4))));
                llvm::Value* dim_llvm = llvm::ConstantInt::get(context, llvm::APInt(32, dim + 1));

                ASR::expr_t* target_size_asr = ASRUtils::EXPR(ASR::make_ArraySize_t(al, x.m_target->base.loc,
                    x.m_target, dim_asr, type32, nullptr));
                visit_expr(*target_size_asr);
                llvm::Value* target_size = tmp;

                ASR::expr_t* x_m_components_0_size = ASRUtils::EXPR(ASR::make_ArraySize_t(al, x.m_components[0]->base.loc,
                    x.m_components[0], dim_asr, type32, nullptr));
                visit_expr(*x_m_components_0_size);
                llvm::Value* value_size = tmp;

                ASR::Variable_t* target_variable = ASRUtils::expr_to_variable_or_null(x.m_target);
                if (target_variable) {
                    ASR::expr_t* v = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, (ASR::symbol_t *)target_variable));
                    if (ASRUtils::is_array(target_variable->m_type) &&
                        ASRUtils::is_allocatable(target_variable->m_type) &&
                        ASRUtils::extract_physical_type(target_variable->m_type) == ASR::array_physical_typeType::DescriptorArray) {
                        visit_expr_load_wrapper(v, 1);
                        llvm::Value* target_desc = tmp;
                        llvm::Value* is_allocated = arr_descr->get_is_allocated_flag(target_desc, v);
                        // With move don't throw error when target is unallocated
                        if (!x.m_move_allocation) {
                            llvm::Value* is_not_allocated = builder->CreateNot(is_allocated);
                            llvm::Value* target_var_name_llvm = LCompilers::create_global_string_ptr(context, *module, *builder, target_variable->m_name);
                            llvm_utils->generate_runtime_error(is_not_allocated,
                                "Array '%s' is not allocated. Use '--realloc-lhs-arrays' option to reallocate LHS automatically.",
                                    {LLVMUtils::RuntimeLabel("'%s' not allocated here", {x.m_target->base.loc}, {target_var_name_llvm})},
                                    infile,
                                    location_manager,
                                    target_var_name_llvm);
                        }

                        llvm::Function *fn = builder->GetInsertBlock()->getParent();
                        llvm::BasicBlock *thenBB = nullptr;
                        llvm::BasicBlock *mergeBB = nullptr;
                        thenBB = llvm::BasicBlock::Create(context, "then", fn);
                        mergeBB = llvm::BasicBlock::Create(context, "ifcont");

                        builder->CreateCondBr(is_allocated, thenBB, mergeBB);
                        builder->SetInsertPoint(thenBB); {
                            llvm_utils->generate_runtime_error(builder->CreateICmpNE(value_size, target_size),
                                                                "Array shape mismatch in assignment to '%s'. Tried to match size %d of dimension %d of LHS with size %d of dimension %d of RHS. Use '--realloc-lhs-arrays' option to reallocate LHS automatically.",
                                                                {LLVMUtils::RuntimeLabel("LHS size is %d", {x.m_target->base.loc}, {target_size}),
                                                                LLVMUtils::RuntimeLabel("RHS size is %d", {x.m_components[0]->base.loc}, {value_size})},
                                                                infile,
                                                                location_manager,
                                                                LCompilers::create_global_string_ptr(context, *module, *builder, target_variable->m_name),
                                                                target_size,
                                                                dim_llvm,
                                                                value_size,
                                                                dim_llvm);
                        }
                        builder->CreateBr(mergeBB);

                        start_new_block(mergeBB);
                    } else {
                        llvm_utils->generate_runtime_error(builder->CreateICmpNE(value_size, target_size),
                                                            "Array shape mismatch in assignment to '%s'. Tried to match size %d of dimension %d of LHS with size %d of dimension %d of RHS.",
                                                     {LLVMUtils::RuntimeLabel("LHS size is %d", {x.m_target->base.loc}, {target_size}),
                                                         LLVMUtils::RuntimeLabel("RHS size is %d", {x.m_components[0]->base.loc}, {value_size})},
                                                          infile,
                                                        location_manager,
                                                            LCompilers::create_global_string_ptr(context, *module, *builder, target_variable->m_name),
                                                            target_size,
                                                            dim_llvm,
                                                            value_size,
                                                            dim_llvm);
                    }
                } else {
                    llvm_utils->generate_runtime_error(builder->CreateICmpNE(value_size, target_size),
                                                        "Array shape mismatch in assignment. Tried to match size %d of dimension %d of LHS with size %d of dimension %d of RHS.",
                                                   {LLVMUtils::RuntimeLabel("LHS size is %d", {x.m_target->base.loc}, {target_size}),
                                                       LLVMUtils::RuntimeLabel("RHS size is %d", {x.m_components[0]->base.loc}, {value_size})},
                                                        infile,
                                                        location_manager,
                                                        target_size,
                                                        dim_llvm,
                                                        value_size,
                                                        dim_llvm);
                }
            }
        }
    }

    // Checks if target_expr is allocated and if not then allocate
    void check_and_allocate_scalar(ASR::expr_t *target_expr, ASR::expr_t *value_expr = nullptr,
            ASR::ttype_t *value_struct_type = nullptr, bool is_assignment = false) {
        ASR::ttype_t *asr_ttype =ASRUtils::expr_type(target_expr);
        ASR::ttype_t *asr_type = ASRUtils::type_get_past_pointer(
            ASRUtils::type_get_past_allocatable(asr_ttype));
        if (ASRUtils::is_array(asr_ttype)) {
            throw CodeGenError("Target is an array, it should be scalar");
        }
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr_wrapper(target_expr, false);
        ptr_loads = ptr_loads_copy;
        llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(target_expr, asr_type, module.get());
        llvm::Value* llvm_cond = nullptr;

        if (ASR::is_a<ASR::Allocatable_t>(*asr_ttype) &&
            ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable(asr_ttype))) {
            llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(target_expr, asr_ttype, module.get());
            ASR::ttype_t* wrapped_struct_type = ASRUtils::make_StructType_t_util(al, asr_ttype->base.loc,
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(target_expr)), true);
            if (value_struct_type == nullptr) {
                value_struct_type = wrapped_struct_type;
            }
            // llvm::Type* wrapper_struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(target_expr, wrapped_struct_type, module.get());
            llvm::Value* target_struct_ptr = tmp;
            if (!compiler_options.new_classes) {
                target_struct_ptr = llvm_utils->create_gep2(target_llvm_type, tmp, 1);
            }
            target_struct_ptr = llvm_utils->CreateLoad2(target_llvm_type, target_struct_ptr);
            llvm::Value* null_cond = builder->CreateICmpEQ(
                        target_struct_ptr,
                        llvm::ConstantPointerNull::get(llvm::cast<llvm::PointerType>(target_llvm_type)));
            
            if (compiler_options.new_classes && is_assignment && 
                    !ASRUtils::is_class_type(ASRUtils::extract_type(value_struct_type))) {
                // If lhs is class(), rhs is type() then we must reallocate always
                Vec<ASR::expr_t*> del_args; del_args.reserve(al, 1);
                del_args.push_back(al, target_expr);
                ASR::stmt_t* delete_stmt = ASRUtils::STMT(ASR::make_ImplicitDeallocate_t(
                    al, target_expr->base.loc, del_args.p, del_args.n));
                this->visit_stmt(*delete_stmt);
                null_cond = llvm::ConstantInt::get(context, llvm::APInt(1, 1));
            }

            // consider the class hash only if the assignment value is a struct type
            if (ASR::is_a<ASR::StructType_t>(*value_struct_type) && !compiler_options.new_classes) {
                ASR::symbol_t* value_struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(value_expr));
                llvm::Value* value_hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                                llvm::APInt(64, get_class_hash(value_struct_sym)));
                llvm::Value* hash_ptr = llvm_utils->create_gep2(target_llvm_type, tmp, 0);
                llvm::Value* present_hash = llvm_utils->CreateLoad2(llvm_utils->getIntType(8), hash_ptr);
                llvm::Value* hash_cond = builder->CreateICmpNE(
                            present_hash,
                            value_hash);
                // Reallocate when target struct ptr is null or
                // hashes of target and value are not equal
                llvm_cond = builder->CreateOr(null_cond, hash_cond);
            } else {
                // Reallocate when target struct ptr is null
                llvm_cond = null_cond;
            }
        } else {
            if (ASR::is_a<ASR::StructType_t>(*
                    ASRUtils::type_get_past_allocatable_pointer(asr_ttype)) && (value_struct_type == nullptr)) {
                value_struct_type = ASRUtils::make_StructType_t_util(al, asr_type->base.loc,
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(target_expr)), true);
            }
            llvm_cond = builder->CreateICmpEQ(
                        builder->CreateLoad(llvm_type->getPointerTo(), tmp),
                        llvm::ConstantPointerNull::get(llvm_type->getPointerTo()));
        }
        llvm_utils->create_if_else(
            llvm_cond,
            [&]() {
                    Vec<ASR::alloc_arg_t> alloc_args; alloc_args.reserve(al, 1);
                    ASR::alloc_arg_t alloc_arg;
                    alloc_arg.loc = target_expr->base.loc;
                    alloc_arg.m_a = target_expr;
                    alloc_arg.m_dims = nullptr;
                    alloc_arg.n_dims = 0;
                    alloc_arg.m_sym_subclass = nullptr;
                    // if the assignment target is a class type variable and the value is not a struct type,
                    // then set the ttype of the alloc_arg to the class type
                    if (ASRUtils::is_class_type(asr_type) &&
                        !ASR::is_a<ASR::StructType_t>(*
                            ASRUtils::type_get_past_allocatable_pointer(value_struct_type))) {
                        alloc_arg.m_type = ASRUtils::make_StructType_t_util(al, asr_type->base.loc,
                                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(target_expr)), true);
                        alloc_arg.m_sym_subclass = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(target_expr));
                    } else {
                        if (value_struct_type) {
                            value_struct_type = ASRUtils::type_get_past_allocatable_pointer(value_struct_type);
                        }
                        alloc_arg.m_type = value_struct_type;
                        if (value_expr == nullptr) {
                            value_expr = target_expr;
                        }
                        alloc_arg.m_sym_subclass = ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(value_expr));
                    }
                    alloc_arg.m_len_expr = nullptr;
                    alloc_args.push_back(al, alloc_arg);
                    ASR::stmt_t *alloc_stmt =
                        ASRUtils::STMT(
                            ASR::make_Allocate_t(al, target_expr->base.loc, alloc_args.p, 1, nullptr, nullptr, nullptr));

                    this->visit_stmt(*alloc_stmt);
            },
            []() {});
    }

    static constexpr int POLYMORPHIC_BOX_DATA_FIELD = 1;

    bool is_polymorphic_to_concrete_cast(ASR::ttype_t* src, ASR::ttype_t* dst) {
        return ASRUtils::is_unlimited_polymorphic_type(src) &&
               !ASRUtils::is_unlimited_polymorphic_type(dst);
    }

    llvm::Value* unwrap_polymorphic_box_data(llvm::Type* box_type, llvm::Value* box_ptr) {
        llvm::Value* data_field = llvm_utils->create_gep2(box_type, box_ptr, POLYMORPHIC_BOX_DATA_FIELD);
        return llvm_utils->CreateLoad2(llvm_utils->i8_ptr, data_field);
    }

    llvm::Value* get_typed_array_data_ptr(
            ASR::ttype_t* src_type, ASR::ttype_t* dst_type,
            llvm::Type* src_el_type, llvm::Type* dst_el_type,
            llvm::Value* first_el_ptr) {
        if (is_polymorphic_to_concrete_cast(src_type, dst_type) &&
            llvm::isa<llvm::StructType>(src_el_type)) {
            llvm::Value* unwrapped = unwrap_polymorphic_box_data(src_el_type, first_el_ptr);
            return builder->CreateBitCast(unwrapped, dst_el_type->getPointerTo());
        }
        return builder->CreateBitCast(first_el_ptr, dst_el_type->getPointerTo());
    }

    void PointerToData_to_Descriptor(ASR::expr_t* expr, ASR::ttype_t* m_type, ASR::ttype_t* m_type_for_dimensions) {
        llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(expr,
            ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(m_type)), module.get());
        llvm::AllocaInst *target = llvm_utils->CreateAlloca(
            target_type, nullptr, "array_descriptor");
        ASR::ttype_t* array_ttype = ASRUtils::type_get_past_allocatable(
            ASRUtils::type_get_past_pointer(m_type));
        llvm::Type* llvm_data_type = llvm_utils->get_el_type(
            expr, ASRUtils::extract_type(array_ttype), module.get());
        llvm::Type* expected_data_ptr_type = llvm_data_type->getPointerTo();
        if (llvm::StructType* desc_struct = llvm::dyn_cast<llvm::StructType>(target_type)) {
            if (desc_struct->getNumElements() > 0 &&
                desc_struct->getElementType(0)->isPointerTy()) {
                expected_data_ptr_type = desc_struct->getElementType(0);
            }
        }
        llvm::Value* data_ptr = arr_descr->get_pointer_to_data(target_type, target);
        llvm::Value* tmp_cast = tmp;
        if (tmp_cast->getType() != expected_data_ptr_type) {
            tmp_cast = builder->CreateBitCast(tmp_cast, expected_data_ptr_type);
        }
        builder->CreateStore(tmp_cast, data_ptr);
        ASR::dimension_t* m_dims = nullptr;
        int n_dims = ASRUtils::extract_dimensions_from_ttype(m_type_for_dimensions, m_dims);
        llvm::Type* llvm_typ = llvm_utils->get_type_from_ttype_t_util(expr,
            ASRUtils::type_get_past_allocatable(m_type), module.get());
        fill_array_details(llvm_typ, target, llvm_data_type, m_dims, n_dims, false, false);
        if( LLVM::is_llvm_pointer(*m_type) ) {
            llvm::AllocaInst* target_ptr = llvm_utils->CreateAlloca(
                target_type->getPointerTo(), nullptr, "array_descriptor_ptr");
            builder->CreateStore(target, target_ptr);
            target = target_ptr;
        }
        tmp = target;
    }

    void visit_ArrayPhysicalCastUtil(llvm::Value* arg, ASR::expr_t* m_arg,
        ASR::ttype_t* m_type, ASR::ttype_t* m_type_for_dimensions,
        ASR::array_physical_typeType m_old, ASR::array_physical_typeType m_new) {

        if( m_old == m_new &&
            m_old != ASR::array_physical_typeType::DescriptorArray ) {
            return ;
        }

        llvm::Type *data_type = llvm_utils->get_el_type(
            m_arg, ASRUtils::extract_type(ASRUtils::expr_type(m_arg)), module.get());
        llvm::Type *arr_type = llvm_utils->get_type_from_ttype_t_util(m_arg,
            ASRUtils::type_get_past_allocatable(
            ASRUtils::type_get_past_pointer(ASRUtils::expr_type(m_arg))),
            module.get());
        llvm::Type* m_arg_llvm_type = llvm_utils->get_type_from_ttype_t_util(m_arg, ASRUtils::expr_type(m_arg), module.get());
        if( m_new == ASR::array_physical_typeType::PointerArray &&
            m_old == ASR::array_physical_typeType::DescriptorArray ) {
            if( ASR::is_a<ASR::StructInstanceMember_t>(*m_arg) ) {
                arg = llvm_utils->CreateLoad2(m_arg_llvm_type, arg);
            }
            ASR::ttype_t* src_asr_type = ASRUtils::expr_type(m_arg);
            ASR::ttype_t* dst_asr_type = m_type;
            llvm::Type* dst_el_type = llvm_utils->get_el_type(
                m_arg, ASRUtils::extract_type(ASRUtils::type_get_past_allocatable_pointer(dst_asr_type)), module.get());
            llvm::Value* src_data_ptr = llvm_utils->CreateLoad2(data_type->getPointerTo(),
                arr_descr->get_pointer_to_data(m_arg, src_asr_type, arg, module.get()));
            llvm::Value* src_first_el_ptr = llvm_utils->create_ptr_gep2(data_type, src_data_ptr,
                arr_descr->get_offset(arr_type, arg));
            tmp = get_typed_array_data_ptr(src_asr_type, dst_asr_type, data_type, dst_el_type, src_first_el_ptr);
        } else if( m_new == ASR::array_physical_typeType::UnboundedPointerArray &&
            m_old == ASR::array_physical_typeType::DescriptorArray ) {
            if( ASR::is_a<ASR::StructInstanceMember_t>(*m_arg) ) {
                arg = llvm_utils->CreateLoad2(m_arg_llvm_type, arg);
            }
            ASR::ttype_t* src_asr_type = ASRUtils::expr_type(m_arg);
            ASR::ttype_t* dst_asr_type = m_type;
            llvm::Type* dst_el_type = llvm_utils->get_el_type(
                m_arg, ASRUtils::extract_type(ASRUtils::type_get_past_allocatable_pointer(dst_asr_type)), module.get());
            llvm::Value* src_data_ptr = llvm_utils->CreateLoad2(data_type->getPointerTo(),
                arr_descr->get_pointer_to_data(m_arg, src_asr_type, arg, module.get()));
            llvm::Value* src_first_el_ptr = llvm_utils->create_ptr_gep2(data_type, src_data_ptr,
                arr_descr->get_offset(arr_type, arg));
            tmp = get_typed_array_data_ptr(src_asr_type, dst_asr_type, data_type, dst_el_type, src_first_el_ptr);
        } else if(
            m_new == ASR::array_physical_typeType::PointerArray &&
            m_old == ASR::array_physical_typeType::UnboundedPointerArray) {
            // Both are pointer-to-data representations, just pass through
        } else if(
            m_new == ASR::array_physical_typeType::UnboundedPointerArray &&
            m_old == ASR::array_physical_typeType::PointerArray) {
            // Both are pointer-to-data representations, just pass through
        } else if(
            m_new == ASR::array_physical_typeType::PointerArray &&
            m_old == ASR::array_physical_typeType::FixedSizeArray) {
            if( ((ASRUtils::expr_value(m_arg) &&
                !ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(m_arg))) ||
                ASRUtils::expr_value(m_arg) == nullptr ) &&
                !ASR::is_a<ASR::ArrayConstructor_t>(*m_arg) ) {
                tmp = llvm_utils->CreateGEP2(m_arg_llvm_type, tmp, 0);
            }
        } else if(
            m_new == ASR::array_physical_typeType::UnboundedPointerArray &&
            m_old == ASR::array_physical_typeType::FixedSizeArray) {
            if( ((ASRUtils::expr_value(m_arg) &&
                !ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(m_arg))) ||
                ASRUtils::expr_value(m_arg) == nullptr) &&
                !ASR::is_a<ASR::ArrayConstructor_t>(*m_arg) ) {
                tmp = llvm_utils->create_gep2(arr_type, tmp, 0);
            }
        } else if (
            m_new == ASR::array_physical_typeType::SIMDArray &&
            m_old == ASR::array_physical_typeType::FixedSizeArray) {
            // pass
        } else if (
            m_new == ASR::array_physical_typeType::DescriptorArray &&
            m_old == ASR::array_physical_typeType::SIMDArray) {
            tmp = llvm_utils->CreateLoad2(m_arg_llvm_type, arg);
        } else if(
            m_new == ASR::array_physical_typeType::DescriptorArray &&
            m_old == ASR::array_physical_typeType::FixedSizeArray) {
            if( ((ASRUtils::expr_value(m_arg) &&
                !ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(m_arg))) ||
                ASRUtils::expr_value(m_arg) == nullptr) &&
                !ASR::is_a<ASR::ArrayConstructor_t>(*m_arg) ) {
                tmp = llvm_utils->create_gep2(arr_type, tmp, 0);
            }
            PointerToData_to_Descriptor(m_arg, m_type, m_type_for_dimensions);
        } else if(
            m_new == ASR::array_physical_typeType::DescriptorArray &&
            m_old == ASR::array_physical_typeType::PointerArray) {
            PointerToData_to_Descriptor(m_arg, m_type, m_type_for_dimensions);
        } else if(
            m_new == ASR::array_physical_typeType::DescriptorArray &&
            m_old == ASR::array_physical_typeType::UnboundedPointerArray) {
            PointerToData_to_Descriptor(m_arg, m_type, m_type_for_dimensions);
        } else if(
            m_new == ASR::array_physical_typeType::FixedSizeArray &&
            m_old == ASR::array_physical_typeType::DescriptorArray) {
            if( ASR::is_a<ASR::StructInstanceMember_t>(*m_arg) ) {
                tmp = llvm_utils->CreateLoad2(m_arg_llvm_type, tmp);
            }
            tmp = llvm_utils->CreateLoad2(data_type->getPointerTo(), arr_descr->get_pointer_to_data(m_arg, m_type, tmp, module.get()));
            llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(m_arg, m_type, module.get())->getPointerTo();
            tmp = builder->CreateBitCast(tmp, target_type);
        } else if(
            m_new == ASR::array_physical_typeType::DescriptorArray &&
            m_old == ASR::array_physical_typeType::DescriptorArray) {
            llvm::Type* target_desc_type = llvm_utils->get_type_from_ttype_t_util(
                m_arg,
                ASRUtils::type_get_past_allocatable(
                    ASRUtils::type_get_past_pointer(m_type)),
                module.get());
            llvm::AllocaInst *target_desc = llvm_utils->CreateAlloca(
                target_desc_type, nullptr, "array_descriptor");

            llvm::Value* source_desc = arg;
            // `reset_array_details()` expects `source_arr` to be indexed using the same
            // descriptor type as the target. The only difference between the source and
            // destination descriptor types here is the element pointer type, so a bitcast
            // is safe for copying descriptor metadata (dims/offset/rank).
            llvm::Value* source_desc_as_target = builder->CreateBitCast(
                source_desc, target_desc_type->getPointerTo());

            ASR::ttype_t* src_asr_type = ASRUtils::expr_type(m_arg);
            ASR::ttype_t* dst_asr_type = m_type;
            ASR::ttype_t* src_arr_asr_type = ASRUtils::type_get_past_allocatable_pointer(src_asr_type);
            ASR::ttype_t* dst_arr_asr_type = ASRUtils::type_get_past_allocatable_pointer(dst_asr_type);

            llvm::Type* src_el_type = llvm_utils->get_el_type(
                m_arg, ASRUtils::extract_type(src_arr_asr_type), module.get());
            llvm::Type* dst_el_type = llvm_utils->get_el_type(
                m_arg, ASRUtils::extract_type(dst_arr_asr_type), module.get());

            llvm::Value* src_data_ptr = llvm_utils->CreateLoad2(
                src_el_type->getPointerTo(),
                arr_descr->get_pointer_to_data(m_arg, src_asr_type, source_desc, module.get()));
            llvm::Value* src_offset = arr_descr->get_offset(target_desc_type, source_desc_as_target);
            llvm::Value* src_first_el_ptr = llvm_utils->create_ptr_gep2(src_el_type, src_data_ptr, src_offset);

            llvm::Value* dst_first_el_ptr = get_typed_array_data_ptr(
                src_asr_type, dst_asr_type, src_el_type, dst_el_type, src_first_el_ptr);
            builder->CreateStore(dst_first_el_ptr,
                arr_descr->get_pointer_to_data(target_desc_type, target_desc));

            int n_dims = ASRUtils::extract_n_dims_from_ttype(m_type_for_dimensions);
            arr_descr->reset_array_details(target_desc_type, target_desc, target_desc_type, source_desc_as_target, n_dims);
            tmp = target_desc;
        } else if (
            m_new == ASR::array_physical_typeType::PointerArray &&
            m_old == ASR::array_physical_typeType::StringArraySinglePointer) {
        //
            if (ASRUtils::is_fixed_size_array(m_type)) {
                if( ((ASRUtils::expr_value(m_arg) &&
                    !ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(m_arg))) ||
                    ASRUtils::expr_value(m_arg) == nullptr) &&
                    !ASR::is_a<ASR::ArrayConstructor_t>(*m_arg) ) {
                    tmp = llvm_utils->create_gep2(arr_type, tmp, 0);
                }
            } else {
                tmp = llvm_utils->CreateLoad2(data_type->getPointerTo(),arr_descr->get_pointer_to_data(arr_type, tmp));
            }
        } else if (
            m_new == ASR::array_physical_typeType::StringArraySinglePointer &&
            m_old == ASR::array_physical_typeType::DescriptorArray) {
            auto const arr_data_loaded = llvm_utils->CreateLoad2(data_type->getPointerTo(), arr_descr->get_pointer_to_data(arr_type, tmp));
            tmp = llvm_utils->get_string_data(ASRUtils::get_string_type(m_type), arr_data_loaded); //StringArraySinglePointer = `char*`
        } else if (
            m_new == ASR::array_physical_typeType::StringArraySinglePointer &&
            m_old == ASR::array_physical_typeType::PointerArray) {
            if (ASRUtils::is_character(*ASRUtils::extract_type(ASRUtils::expr_type(m_arg)))) {
                // For character arrays in bind(c) context
                ASR::ttype_t* old_ttype = ASRUtils::extract_type(ASRUtils::expr_type(m_arg));
                llvm::Type* str_desc = llvm_utils->get_type_from_ttype_t_util(m_arg, old_ttype, module.get());
                tmp = llvm_utils->create_gep2(str_desc, tmp, 0);
                tmp = llvm_utils->CreateLoad2(llvm::Type::getInt8Ty(context)->getPointerTo(),tmp);
            }
        } else if (
            m_new == ASR::array_physical_typeType::DescriptorArray &&
            m_old == ASR::array_physical_typeType::AssumedRankArray) {

            if (!ASRUtils::is_array(m_type)) {
                // rank(0): extract scalar value from the assumed-rank descriptor.
                llvm::Value* data_ptr = llvm_utils->CreateLoad2(
                    data_type->getPointerTo(),
                    arr_descr->get_pointer_to_data(arr_type, arg));
                if (ASRUtils::is_struct(*m_type)) {
                    // For struct types, return the pointer (deepcopy needs a pointer)
                    tmp = data_ptr;
                } else {
                    tmp = llvm_utils->CreateLoad2(data_type, data_ptr);
                }
            } else {

            llvm::Type* target_desc_type = llvm_utils->get_type_from_ttype_t_util(
                m_arg,
                ASRUtils::type_get_past_allocatable(
                    ASRUtils::type_get_past_pointer(m_type)),
                module.get());
            llvm::AllocaInst *target_desc = llvm_utils->CreateAlloca(
                target_desc_type, nullptr, "array_descriptor");

            llvm::Value* source_desc = arg;
            // `reset_array_details()` expects `source_arr` to be indexed using the same
            // descriptor type as the target. The only difference between the source and
            // destination descriptor types here is the element pointer type, so a bitcast
            // is safe for copying descriptor metadata (dims/offset/rank).
            llvm::Value* source_desc_as_target = builder->CreateBitCast(
                source_desc, target_desc_type->getPointerTo());

            ASR::ttype_t* src_asr_type = ASRUtils::expr_type(m_arg);
            ASR::ttype_t* dst_asr_type = m_type;
            ASR::ttype_t* src_arr_asr_type = ASRUtils::type_get_past_allocatable_pointer(src_asr_type);
            ASR::ttype_t* dst_arr_asr_type = ASRUtils::type_get_past_allocatable_pointer(dst_asr_type);

            llvm::Type* src_el_type = llvm_utils->get_el_type(
                m_arg, ASRUtils::extract_type(src_arr_asr_type), module.get());
            llvm::Type* dst_el_type = llvm_utils->get_el_type(
                m_arg, ASRUtils::extract_type(dst_arr_asr_type), module.get());

            llvm::Value* src_data_ptr = llvm_utils->CreateLoad2(
                src_el_type->getPointerTo(),
                arr_descr->get_pointer_to_data(m_arg, src_asr_type, source_desc, module.get()));
            llvm::Value* src_offset = arr_descr->get_offset(target_desc_type, source_desc_as_target);
            llvm::Value* src_first_el_ptr = llvm_utils->create_ptr_gep2(src_el_type, src_data_ptr, src_offset);

            llvm::Value* dst_first_el_ptr = get_typed_array_data_ptr(
                src_asr_type, dst_asr_type, src_el_type, dst_el_type, src_first_el_ptr);

            builder->CreateStore(dst_first_el_ptr,
                arr_descr->get_pointer_to_data(target_desc_type, target_desc));

            int n_dims = ASRUtils::extract_n_dims_from_ttype(m_type_for_dimensions);
            arr_descr->reset_array_details(target_desc_type, target_desc, target_desc_type, source_desc_as_target, n_dims);
            if( LLVM::is_llvm_pointer(*m_type) ) {
                llvm::AllocaInst* target_ptr = llvm_utils->CreateAlloca(
                    target_desc_type->getPointerTo(), nullptr, "array_descriptor_ptr");
                builder->CreateStore(target_desc, target_ptr);
                tmp = target_ptr;
            } else {
                tmp = target_desc;
            }
            } // end else (rank >= 1)
        } else if (
            m_new == ASR::array_physical_typeType::PointerArray &&
            m_old == ASR::array_physical_typeType::AssumedRankArray) {
            
            tmp = llvm_utils->CreateLoad2(data_type->getPointerTo(), arr_descr->get_pointer_to_data(m_arg, m_type, arg, module.get()));
            tmp = llvm_utils->create_ptr_gep2(data_type, tmp, arr_descr->get_offset(arr_type, arg));
        } else {
            LCOMPILERS_ASSERT(false);
        }
    }

    void visit_ArrayPhysicalCast(const ASR::ArrayPhysicalCast_t& x) {
        if( x.m_old != ASR::array_physical_typeType::DescriptorArray ) {
            LCOMPILERS_ASSERT(x.m_new != x.m_old);
        }
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 2 - LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_arg));
        this->visit_expr_wrapper(x.m_arg, false);
        ptr_loads = ptr_loads_copy;
        visit_ArrayPhysicalCastUtil(tmp, x.m_arg, x.m_type, x.m_type, x.m_old, x.m_new);
    }

    void visit_AssociateBlockCall(const ASR::AssociateBlockCall_t& x) {
        LCOMPILERS_ASSERT(ASR::is_a<ASR::AssociateBlock_t>(*x.m_m));
        ASR::AssociateBlock_t* associate_block = ASR::down_cast<ASR::AssociateBlock_t>(x.m_m);
        
        llvm::BasicBlock* start_BB = llvm::BasicBlock::Create(context, std::string(associate_block->m_name) + "_start");
        start_new_block(start_BB);

        declare_vars(*associate_block);
        for (size_t i = 0; i < associate_block->n_body; i++) {
            this->visit_stmt(*(associate_block->m_body[i]));
        }

        llvm::BasicBlock* end_BB = llvm::BasicBlock::Create(context, std::string(associate_block->m_name) + "_end");
        start_new_block(end_BB);
        llvm_symtab_finalizer.finalize_symtab(associate_block->m_symtab);
    }

    void visit_BlockCall(const ASR::BlockCall_t& x) {
        if( x.m_label != -1 ) {
            if( llvm_goto_targets.find(x.m_label) == llvm_goto_targets.end() ) {
                llvm::BasicBlock *new_target = llvm::BasicBlock::Create(context, "goto_target");
                llvm_goto_targets[x.m_label] = new_target;
            }
            start_new_block(llvm_goto_targets[x.m_label]);
        }
        LCOMPILERS_ASSERT(ASR::is_a<ASR::Block_t>(*x.m_m));
        ASR::Block_t* block = ASR::down_cast<ASR::Block_t>(x.m_m);
        std::string block_name;
        if (block->m_name) {
            block_name = std::string(block->m_name);
        } else {
            block_name = "block";
        }
        std::string blockstart_name = block_name + ".start";
        std::string blockend_name = block_name + ".end";
        llvm::BasicBlock* const blockstart = llvm::BasicBlock::Create(context, blockstart_name);
        llvm::BasicBlock* const blockend   = llvm::BasicBlock::Create(context, blockend_name);
        start_new_block(blockstart);
        SymbolTable* current_scope_copy = current_scope;
        current_scope = block->m_symtab;

        // BLOCK arrays always use heap allocation (can be in loops)
        // Track allocations separately for cleanup at BLOCK exit
        size_t heap_arrays_before = heap_fixed_size_arrays.n;
        in_block_context = true;
        declare_vars(*block);
        in_block_context = false;
        loop_or_block_end.push_back(blockend);
        loop_or_block_end_names.push_back(blockend_name);
        for (size_t i = 0; i < block->n_body; i++) {
            this->visit_stmt(*(block->m_body[i]));
        }

        // Free BLOCK-local heap arrays before exiting BLOCK (important for loops)
        for (size_t i = heap_arrays_before; i < heap_fixed_size_arrays.n; i++) {
            llvm_utils->lfortran_free(heap_fixed_size_arrays[i]);
        }
        heap_fixed_size_arrays.n = heap_arrays_before;

        start_new_block(blockend);
        llvm_symtab_finalizer.finalize_symtab(block->m_symtab);

        loop_or_block_end.pop_back();
        loop_or_block_end_names.pop_back();
        current_scope = current_scope_copy;
    }

    inline void visit_expr_wrapper(ASR::expr_t* x, bool load_ref=false, bool is_volatile = false) {
        // Check if *x is nullptr.
        if( x == nullptr ) {
            throw CodeGenError("Internal error: x is nullptr");
        }

        this->visit_expr(*x);

        if (compiler_options.new_classes && load_ref &&
               ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(ASRUtils::expr_type(x))) &&
                ASR::is_a<ASR::StructInstanceMember_t>(*x)) {
            llvm::Type* x_llvm_type = llvm_utils->get_type_from_ttype_t_util(x, ASRUtils::expr_type(x), module.get());
            tmp = llvm_utils->CreateLoad2(x_llvm_type, tmp, is_volatile);
            return;
        }

        if (compiler_options.new_classes && load_ref && 
                LLVM::is_llvm_pointer(*ASRUtils::expr_type(x)) &&
                (ASRUtils::is_unlimited_polymorphic_type(x) || ASR::is_a<ASR::Cast_t>(*x))) {
            llvm::Type* x_llvm_type = llvm_utils->get_type_from_ttype_t_util(x, ASRUtils::expr_type(x), module.get());
            tmp = llvm_utils->CreateLoad2(x_llvm_type, tmp, is_volatile);
            return;
        }

        if( x->type == ASR::exprType::ArrayItem ||
            x->type == ASR::exprType::ArraySection ||
            x->type == ASR::exprType::StructInstanceMember ) {
            if( load_ref &&
                !ASRUtils::is_value_constant(ASRUtils::expr_value(x)) &&
                (ASRUtils::is_array(expr_type(x)) || !ASRUtils::is_character(*expr_type(x)))) {
                tmp = logical_load_val(tmp, x, is_volatile);
            }
        }
    }
    /*
        Visits the expression with the desired pointer loads
        and reverting back the original load.
    */
    void visit_expr_load_wrapper(ASR::expr_t* x, int desired_ptr_load, bool load_ref=false){
        int ptr_loads_copy = ptr_loads;
        ptr_loads = desired_ptr_load;
        if(load_ref){
            this->visit_expr_wrapper(x, true);
        } else {
            this->visit_expr(*x);
        }
        ptr_loads = ptr_loads_copy;
    }

    void fill_type_stmt(const ASR::SelectType_t& x,
        std::vector<ASR::type_stmt_t*>& type_stmt_order,
        ASR::type_stmtType type_stmt_type) {
        for( size_t i = 0; i < x.n_body; i++ ) {
            if( x.m_body[i]->type == type_stmt_type ) {
                type_stmt_order.push_back(x.m_body[i]);
            }
        }
    }

    void fill_rank_stmt(const ASR::SelectRank_t& x, std::vector<ASR::rank_stmt_t*>& rank_stmt_order,
        ASR::rank_stmtType rank_stmt_type) {
        for( size_t i = 0; i < x.n_body; i++ ) {
            if( x.m_body[i]->type == rank_stmt_type ) {
                rank_stmt_order.push_back(x.m_body[i]);
            }
        }
    }

    void visit_SelectRank(const ASR::SelectRank_t& x) {
        LCOMPILERS_ASSERT(ASR::is_a<ASR::Var_t>(*x.m_selector));
        std::vector<ASR::rank_stmt_t*> rank_stmts;
        fill_rank_stmt(x, rank_stmts, ASR::rank_stmtType::RankExpr);
        LCOMPILERS_ASSERT(x.n_body == rank_stmts.size());
        ASR::Var_t* selector_var = ASR::down_cast<ASR::Var_t>(x.m_selector);
        std::string selector_var_name = ASRUtils::symbol_name(selector_var->m_v);
        uint64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        visit_Var(*selector_var);
        ptr_loads = ptr_loads_copy;
        llvm::Value* llvm_selector = tmp;
        llvm::Type* llvm_selector_type_ = llvm_utils->get_type_from_ttype_t_util(x.m_selector, ASRUtils::expr_type(x.m_selector), module.get());
        llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");

        llvm::Value* rank = arr_descr->get_rank(llvm_selector_type_, llvm_selector);
        for( size_t i = 0; i < rank_stmts.size(); i++ ) {
            llvm::Function* fn = builder->GetInsertBlock()->getParent();
            llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
            llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

            llvm::Value* cond = nullptr;
            ASR::stmt_t** rank_block = nullptr;
            size_t n_rank_block = 0;
            switch( rank_stmts[i]->type ) {
                case ASR::rank_stmtType::RankExpr: {
                    ASR::RankExpr_t* rank_expr = ASR::down_cast<ASR::RankExpr_t>(rank_stmts[i]);
                    llvm::Value* rank_value = nullptr;
                    this->visit_expr_wrapper(rank_expr->m_rank, false);
                    rank_value = tmp;
                    cond = builder->CreateICmpEQ(rank, rank_value);

                    rank_block = rank_expr->m_body;
                    n_rank_block = rank_expr->n_body;
                    break;
                }
                default: {
                    throw CodeGenError("ASR::rank_stmtType, " +
                                       std::to_string(x.m_body[i]->type) +
                                       " is not yet supported.");
                }
            }
            builder->CreateCondBr(cond, thenBB, elseBB);
            builder->SetInsertPoint(thenBB);
            {
                if ( n_rank_block == 1 && ASR::is_a<ASR::BlockCall_t>(*rank_block[0])) {
                    visit_BlockCall(*ASR::down_cast<ASR::BlockCall_t>(rank_block[0]));
                }
            }
            builder->CreateBr(mergeBB);
            start_new_block(elseBB);

        }
        if (x.n_default > 0) {
            for( size_t i = 0; i < x.n_default; i++ ) {
                this->visit_stmt(*x.m_default[i]);
            }
        }
        start_new_block(mergeBB);
    }

    void visit_SelectType(const ASR::SelectType_t& x) {
        LCOMPILERS_ASSERT(ASR::is_a<ASR::Var_t>(*x.m_selector) || ASR::is_a<ASR::StructInstanceMember_t>(*x.m_selector));
        // Process TypeStmtName first, then ClassStmt
        std::vector<ASR::type_stmt_t*> select_type_stmts;
        fill_type_stmt(x, select_type_stmts, ASR::type_stmtType::TypeStmtName);
        fill_type_stmt(x, select_type_stmts, ASR::type_stmtType::TypeStmtType);
        fill_type_stmt(x, select_type_stmts, ASR::type_stmtType::ClassStmt);
        LCOMPILERS_ASSERT(x.n_body == select_type_stmts.size());
        ASR::Var_t* selector_var = nullptr;
        ASR::StructInstanceMember_t* selector_struct = nullptr;
        if (ASR::is_a<ASR::Var_t>(*x.m_selector)) {
            selector_var = ASR::down_cast<ASR::Var_t>(x.m_selector);
        } else if (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_selector)) {
            selector_struct = ASR::down_cast<ASR::StructInstanceMember_t>(x.m_selector);
        }
        uint64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        if (selector_var) {
            visit_Var(*selector_var);
        } else if (selector_struct) {
            visit_StructInstanceMember(*selector_struct);
        }
        ptr_loads = ptr_loads_copy;
        llvm::Value* llvm_selector = tmp;
        llvm::Type* llvm_selector_type_ = llvm_utils->get_type_from_ttype_t_util(x.m_selector, ASRUtils::expr_type(x.m_selector), module.get());
        llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");
        for( size_t i = 0; i < select_type_stmts.size(); i++ ) {
            llvm::Function *fn = builder->GetInsertBlock()->getParent();

            llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
            llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

            llvm::Value* cond = nullptr;
            if (compiler_options.new_classes) {
                cond = llvm_utils->CreateAlloca(*builder, llvm::Type::getInt1Ty(context));
            }
            ASR::stmt_t** type_block = nullptr;
            size_t n_type_block = 0;
            llvm::Type *i64 = llvm::Type::getInt64Ty(context);
            switch( select_type_stmts[i]->type ) {
                case ASR::type_stmtType::TypeStmtName: {
                    ASR::TypeStmtName_t* type_stmt_name = ASR::down_cast<ASR::TypeStmtName_t>(select_type_stmts[i]);
                    ASR::symbol_t* type_sym = ASRUtils::symbol_get_past_external(type_stmt_name->m_sym);
                    LCOMPILERS_ASSERT(ASR::is_a<ASR::Struct_t>(*type_sym));
                    if (compiler_options.new_classes) {
                        llvm::Value* static_ptr = llvm_selector;
                        llvm::Type* static_ptr_type = llvm_selector_type_;
                        ASR::ttype_t* selector_var_type = ASRUtils::expr_type(x.m_selector);
                        // If selector is a pointer type, load it first
                        if (LLVM::is_llvm_pointer(*selector_var_type)) {
                            static_ptr = llvm_utils->CreateLoad2(llvm_selector_type_, static_ptr);
                            selector_var_type = ASRUtils::type_get_past_pointer(selector_var_type);
                            static_ptr_type = llvm_utils->get_type_from_ttype_t_util(x.m_selector, selector_var_type, module.get());
                        }
                        if (ASRUtils::is_array(selector_var_type) && 
                                ASRUtils::extract_physical_type(selector_var_type) == ASR::array_physical_typeType::DescriptorArray) {
                            static_ptr_type = llvm_utils->get_type_from_ttype_t_util(
                                x.m_selector, ASRUtils::type_get_past_allocatable_pointer(selector_var_type), module.get());
                            static_ptr = arr_descr->get_pointer_to_data(static_ptr_type, static_ptr);
                            llvm::Type* el_type = llvm_utils->get_type_from_ttype_t_util(
                                x.m_selector, ASRUtils::extract_type(selector_var_type), module.get());
                            static_ptr = llvm_utils->CreateLoad2(
                                el_type->getPointerTo(),
                                static_ptr);
                        }

                        if (struct_api->newclass2vtab.find(type_sym) == struct_api->newclass2vtab.end()) {
                            struct_api->create_new_vtable_for_struct_type(type_sym, module.get());
                        }

                        // Use `lfortran_dynamic_cast()` to compare runtime type-info of a class
                        // variable passed as selector variable. We need to compare the exact type
                        // instead of inheritance here.
                        if (ASRUtils::is_unlimited_polymorphic_type(x.m_selector)) {
                            llvm::Value* val = lfortran_dynamic_cast(
                                    static_ptr, struct_api->newclass2typeinfo.at(type_sym), true);
                            builder->CreateStore(builder->CreateICmpNE(
                                val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                        } else {
                            ASR::symbol_t* selector_sym = ASRUtils::symbol_get_past_external(
                                ASRUtils::get_struct_sym_from_struct_expr(x.m_selector));
                            llvm::Value* is_selector_null = builder->CreateICmpEQ(
                                builder->CreatePtrToInt(static_ptr, llvm::Type::getInt64Ty(context)),
                                llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), llvm::APInt(64, 0)));
                            llvm_utils->create_if_else(is_selector_null, [=]() {
                                llvm::Value* ptr_to_method = struct_api->get_pointer_to_method(selector_sym, module.get());
                                llvm::Value* vptr = llvm_utils->CreateAlloca(*builder, llvm_utils->vptr_type);
                                builder->CreateStore(ptr_to_method, vptr);
                                llvm::Value* val = lfortran_dynamic_cast(
                                    vptr, struct_api->newclass2typeinfo.at(type_sym), true);
                                builder->CreateStore(builder->CreateICmpNE(
                                    val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                            }, [=](){
                                llvm::Value* val = lfortran_dynamic_cast(
                                    static_ptr, struct_api->newclass2typeinfo.at(type_sym), true);
                                builder->CreateStore(builder->CreateICmpNE(
                                    val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                            });
                        }
                    } else {
                        ASR::ttype_t* selector_var_type = ASRUtils::expr_type(x.m_selector);
                        llvm::Value* vptr_int_hash = llvm_utils->CreateLoad2(i64, llvm_utils->create_gep2(llvm_selector_type_, llvm_selector, 0));
                        if( ASRUtils::is_array(selector_var_type) ) {
                            vptr_int_hash = llvm_utils->CreateLoad2(i64, llvm_utils->create_gep2(i64, vptr_int_hash, 0));
                        }
                        if ((type2vtab.find(type_sym) == type2vtab.end()) ||
                            (type2vtab[type_sym].find(current_scope) == type2vtab[type_sym].end())) {
                            if (!compiler_options.new_classes) {
                                create_vtab_for_struct_type(type_sym, current_scope);
                            }
                        }
                        llvm::Value* type_sym_vtab = type2vtab[type_sym][current_scope];
                        llvm::Type* vtab_struct_type = llvm_utils->getStructType(
                            ASR::down_cast<ASR::Struct_t>(type_sym), module.get(), false);
                        llvm::Value* vtab_obj_casted = builder->CreateBitCast(type_sym_vtab, vtab_struct_type->getPointerTo());
                        cond = builder->CreateICmpEQ(
                                vptr_int_hash,
                                llvm_utils->CreateLoad2( i64, llvm_utils->create_gep2(vtab_struct_type, vtab_obj_casted, 0) ) );
                    }
                    type_block = type_stmt_name->m_body;
                    n_type_block = type_stmt_name->n_body;
                    break ;
                }
                case ASR::type_stmtType::ClassStmt: {
                    ASR::ClassStmt_t* class_stmt = ASR::down_cast<ASR::ClassStmt_t>(select_type_stmts[i]);
                    ASR::symbol_t* class_sym = ASRUtils::symbol_get_past_external(class_stmt->m_sym);
                    LCOMPILERS_ASSERT(ASR::is_a<ASR::Struct_t>(*class_sym));
                    if (compiler_options.new_classes) {
                        llvm::Value* static_ptr = llvm_selector;
                        if (LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_selector))) {
                            static_ptr = llvm_utils->CreateLoad2(llvm_selector_type_, static_ptr);
                        }
                        if (ASRUtils::is_array(ASRUtils::expr_type(x.m_selector))) {
                            static_ptr = arr_descr->get_pointer_to_data(llvm_selector_type_, static_ptr);
                            static_ptr = llvm_utils->CreateLoad2(
                                llvm_utils->get_el_type(
                                    x.m_selector,
                                    ASRUtils::extract_type(ASRUtils::expr_type(x.m_selector)),
                                    module.get())->getPointerTo(),
                                static_ptr);
                        }

                        if (struct_api->newclass2vtab.find(class_sym) == struct_api->newclass2vtab.end()) {
                            struct_api->create_new_vtable_for_struct_type(class_sym, module.get());
                        }

                        if (ASRUtils::is_unlimited_polymorphic_type(x.m_selector)) {
                            llvm::Value* val = lfortran_dynamic_cast(
                                    static_ptr, struct_api->newclass2typeinfo.at(class_sym), false);
                            builder->CreateStore(builder->CreateICmpNE(
                                val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                        } else {
                            ASR::symbol_t* selector_sym = ASRUtils::symbol_get_past_external(
                                ASRUtils::get_struct_sym_from_struct_expr(x.m_selector));
                            llvm::Value* is_selector_null = builder->CreateICmpEQ(
                                builder->CreatePtrToInt(static_ptr, llvm::Type::getInt64Ty(context)),
                                llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), llvm::APInt(64, 0)));
                            llvm_utils->create_if_else(is_selector_null, [=]() {
                                llvm::Value* ptr_to_method = struct_api->get_pointer_to_method(selector_sym, module.get());
                                llvm::Value* vptr = llvm_utils->CreateAlloca(*builder, llvm_utils->vptr_type);
                                builder->CreateStore(ptr_to_method, vptr);
                                llvm::Value* val = lfortran_dynamic_cast(
                                    vptr, struct_api->newclass2typeinfo.at(class_sym), false);
                                builder->CreateStore(builder->CreateICmpNE(
                                    val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                            }, [=](){
                                llvm::Value* val = lfortran_dynamic_cast(
                                    static_ptr, struct_api->newclass2typeinfo.at(class_sym), false);
                                builder->CreateStore(builder->CreateICmpNE(
                                    val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                            });
                        }
                    } else {
                        llvm::Value* vptr_int_hash = llvm_utils->CreateLoad2(i64, llvm_utils->create_gep2(llvm_selector_type_, llvm_selector, 0));
                        llvm::Type* class_block_type = llvm_utils->getStructType(
                            ASR::down_cast<ASR::Struct_t>(class_sym), module.get(), false);

                        std::vector<llvm::Value*>& class_sym_vtabs = class2vtab[class_sym][current_scope];
                        std::vector<llvm::Value*> conds;
                        if (class_sym_vtabs.size() == 0) {
                            if ((type2vtab.find(class_sym) == type2vtab.end()) ||
                                (type2vtab[class_sym].find(current_scope) == type2vtab[class_sym].end())) {
                                if (!compiler_options.new_classes) {
                                    create_vtab_for_struct_type(class_sym, current_scope);
                                }
                            }
                            class_sym_vtabs.push_back(type2vtab[class_sym][current_scope]);
                        }
                        conds.reserve(class_sym_vtabs.size());
                        for( size_t i = 0; i < class_sym_vtabs.size(); i++ ) {
                            llvm::Value* vtab_obj_casted = builder->CreateBitCast(
                                class_sym_vtabs[i], class_block_type->getPointerTo());
                            conds.push_back(builder->CreateICmpEQ(
                                vptr_int_hash,
                                llvm_utils->CreateLoad2(i64, llvm_utils->create_gep2(class_block_type, vtab_obj_casted, 0)) ));
                        }
#if LLVM_VERSION_MAJOR >= 9
                        cond = builder->CreateOr(conds);
#else
                        // LLVM 8 doesn't have CreateOr(ArrayRef), manually chain Or operations
                        LCOMPILERS_ASSERT(conds.size() > 0);
                        cond = conds[0];
                        for( size_t i = 1; i < conds.size(); i++ ) {
                            cond = builder->CreateOr(cond, conds[i]);
                        }
#endif
                    }
                    type_block = class_stmt->m_body;
                    n_type_block = class_stmt->n_body;
                    break ;
                }
                case ASR::type_stmtType::TypeStmtType: {
                    ASR::ttype_t* selector_var_type = ASRUtils::expr_type(x.m_selector);
                    ASR::TypeStmtType_t* type_stmt_type_t = ASR::down_cast<ASR::TypeStmtType_t>(select_type_stmts[i]);
                    ASR::ttype_t* type_stmt_type = type_stmt_type_t->m_type;
                    int kind = ASRUtils::extract_kind_from_ttype_t(type_stmt_type);
                    if (compiler_options.new_classes) {
                        // If the intrinsic type's type-info does not exist, create it on the fly.
                        if (struct_api->intrinsic_type_info.find(
                                ASRUtils::intrinsic_type_to_str_with_kind(type_stmt_type, kind))
                            == struct_api->intrinsic_type_info.end()) {
                            struct_api->create_type_info_for_intrinsic_type(type_stmt_type, kind, module.get());
                        }
                        llvm::Value* static_ptr = llvm_selector;
                        llvm::Type* static_ptr_type = llvm_selector_type_;
                        // If selector is a pointer/allocatable type, load it first
                        if (LLVM::is_llvm_pointer(*selector_var_type)) {
                            static_ptr = llvm_utils->CreateLoad2(llvm_selector_type_, static_ptr);
                            selector_var_type = ASRUtils::type_get_past_allocatable_pointer(selector_var_type);
                            static_ptr_type = llvm_utils->get_type_from_ttype_t_util(x.m_selector, selector_var_type, module.get());
                        }
                        if (ASRUtils::is_array(selector_var_type)) {
                            static_ptr = arr_descr->get_pointer_to_data(static_ptr_type, static_ptr);
                            static_ptr = llvm_utils->CreateLoad2(
                                llvm_utils->get_el_type(
                                    x.m_selector,
                                    ASRUtils::type_get_past_array(selector_var_type),
                                    module.get())->getPointerTo(),
                                static_ptr);
                        }
                        llvm::Value* val = lfortran_dynamic_cast(
                            static_ptr,
                            struct_api->intrinsic_type_info.at(
                                ASRUtils::intrinsic_type_to_str_with_kind(type_stmt_type, kind)),
                            true);
                        builder->CreateStore(builder->CreateICmpNE(
                            val, llvm::ConstantPointerNull::get(llvm_utils->i8_ptr)), cond);
                    } else {
                        llvm::Value* intrinsic_type_id = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                            llvm::APInt(64, -((int) type_stmt_type->type) -
                                ASRUtils::extract_kind_from_ttype_t(type_stmt_type), true));
                        llvm::Value* _type_id = nullptr;
                        if( ASRUtils::is_array(selector_var_type) ) {
                            llvm::Type* el_type = llvm_utils->get_type_from_ttype_t_util(x.m_selector, ASRUtils::extract_type(selector_var_type), module.get());
                            llvm::Value* data_ptr = llvm_utils->CreateLoad2(el_type->getPointerTo(), arr_descr->get_pointer_to_data(llvm_selector_type_, llvm_selector));
                            _type_id = llvm_utils->CreateLoad2(llvm::Type::getInt64Ty(context), llvm_utils->create_gep2(el_type, data_ptr, 0));
                        } else {
                            _type_id = llvm_utils->CreateLoad2(llvm::Type::getInt64Ty(context), llvm_utils->create_gep2(llvm_selector_type_, llvm_selector, 0));
                        }
                        cond = builder->CreateICmpEQ(_type_id, intrinsic_type_id);
                    }
                    type_block = type_stmt_type_t->m_body;
                    n_type_block = type_stmt_type_t->n_body;
                    break;
                }
                default: {
                    throw CodeGenError("ASR::type_stmtType, " +
                                       std::to_string(x.m_body[i]->type) +
                                       " is not yet supported.");
                }
            }
            if (compiler_options.new_classes) {
                builder->CreateCondBr(llvm_utils->CreateLoad2(
                    llvm::Type::getInt1Ty(context), cond), thenBB, elseBB);
            } else {
                builder->CreateCondBr(cond, thenBB, elseBB);
            }
            builder->SetInsertPoint(thenBB);
            {
                if( n_type_block == 1 && ASR::is_a<ASR::BlockCall_t>(*type_block[0]) ) {
                    ASR::BlockCall_t* block_call = ASR::down_cast<ASR::BlockCall_t>(type_block[0]);
                    visit_BlockCall(*block_call);
                }
            }
            builder->CreateBr(mergeBB);

            start_new_block(elseBB);
        }
        if( x.n_default > 0 ) {
            for( size_t i = 0; i < x.n_default; i++ ) {
                this->visit_stmt(*x.m_default[i]);
            }
        }
        start_new_block(mergeBB);
    }

    void visit_IntegerCompare(const ASR::IntegerCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_load_wrapper(x.m_left,
            LLVM::is_llvm_pointer(*expr_type(x.m_left)) ? 2 : 1,
            true);
        llvm::Value *left = tmp;
        this->visit_expr_load_wrapper(x.m_right,
            LLVM::is_llvm_pointer(*expr_type(x.m_right)) ? 2 : 1,
            true);
        llvm::Value *right = tmp;
        load_non_array_non_character_pointers(x.m_left, ASRUtils::expr_type(x.m_left), left);
        load_non_array_non_character_pointers(x.m_right, ASRUtils::expr_type(x.m_right), right);
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                tmp = builder->CreateICmpEQ(left, right);
                break;
            }
            case (ASR::cmpopType::Gt) : {
                tmp = builder->CreateICmpSGT(left, right);
                break;
            }
            case (ASR::cmpopType::GtE) : {
                tmp = builder->CreateICmpSGE(left, right);
                break;
            }
            case (ASR::cmpopType::Lt) : {
                tmp = builder->CreateICmpSLT(left, right);
                break;
            }
            case (ASR::cmpopType::LtE) : {
                tmp = builder->CreateICmpSLE(left, right);
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                tmp = builder->CreateICmpNE(left, right);
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_UnsignedIntegerCompare(const ASR::UnsignedIntegerCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right = tmp;
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                tmp = builder->CreateICmpEQ(left, right);
                break;
            }
            case (ASR::cmpopType::Gt) : {
                tmp = builder->CreateICmpUGT(left, right);
                break;
            }
            case (ASR::cmpopType::GtE) : {
                tmp = builder->CreateICmpUGE(left, right);
                break;
            }
            case (ASR::cmpopType::Lt) : {
                tmp = builder->CreateICmpULT(left, right);
                break;
            }
            case (ASR::cmpopType::LtE) : {
                tmp = builder->CreateICmpULE(left, right);
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                tmp = builder->CreateICmpNE(left, right);
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_CPtrCompare(const ASR::CPtrCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left = tmp;
        left = builder->CreatePtrToInt(left, llvm_utils->getIntType(8, false));
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right = tmp;
        right = builder->CreatePtrToInt(right, llvm_utils->getIntType(8, false));
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                tmp = builder->CreateICmpEQ(left, right);
                break;
            }
            case (ASR::cmpopType::Gt) : {
                tmp = builder->CreateICmpSGT(left, right);
                break;
            }
            case (ASR::cmpopType::GtE) : {
                tmp = builder->CreateICmpSGE(left, right);
                break;
            }
            case (ASR::cmpopType::Lt) : {
                tmp = builder->CreateICmpSLT(left, right);
                break;
            }
            case (ASR::cmpopType::LtE) : {
                tmp = builder->CreateICmpSLE(left, right);
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                tmp = builder->CreateICmpNE(left, right);
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_RealCompare(const ASR::RealCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right = tmp;
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                tmp = builder->CreateFCmpOEQ(left, right);
                break;
            }
            case (ASR::cmpopType::Gt) : {
                tmp = builder->CreateFCmpOGT(left, right);
                break;
            }
            case (ASR::cmpopType::GtE) : {
                tmp = builder->CreateFCmpOGE(left, right);
                break;
            }
            case (ASR::cmpopType::Lt) : {
                tmp = builder->CreateFCmpOLT(left, right);
                break;
            }
            case (ASR::cmpopType::LtE) : {
                tmp = builder->CreateFCmpOLE(left, right);
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                tmp = builder->CreateFCmpUNE(left, right);
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_ComplexCompare(const ASR::ComplexCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right = tmp;
        llvm::Value* real_left = complex_re(left, left->getType());
        llvm::Value* real_right = complex_re(right, right->getType());
        llvm::Value* img_left = complex_im(left, left->getType());
        llvm::Value* img_right = complex_im(right, right->getType());
        llvm::Value *real_res, *img_res;
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                real_res = builder->CreateFCmpOEQ(real_left, real_right);
                img_res = builder->CreateFCmpOEQ(img_left, img_right);
                tmp = builder->CreateAnd(real_res, img_res);
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                real_res = builder->CreateFCmpONE(real_left, real_right);
                img_res = builder->CreateFCmpONE(img_left, img_right);
                tmp = builder->CreateOr(real_res, img_res);
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_StringCompare(const ASR::StringCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        llvm::Value *left, *left_len;
        llvm::Value *right , *right_len;
        std::tie(left, left_len) = get_string_data_and_length(x.m_left);
        std::tie(right, right_len) = get_string_data_and_length(x.m_right);

        bool is_single_char;
        { // Set `is_single_char` flag
            ASR::String_t* left_str = ASRUtils::get_string_type(x.m_left);
            ASR::String_t* right_str = ASRUtils::get_string_type(x.m_right);
            int64_t l_str_len, r_str_len;
            if( ASRUtils::is_value_constant(left_str->m_len, l_str_len) &&
                ASRUtils::is_value_constant(right_str->m_len, r_str_len)){// Check + Fetch len
                is_single_char = (l_str_len == 1) && (r_str_len == 1);
            } else {
                is_single_char = false;
            }
        }
        if( is_single_char ) {
            left = llvm_utils->CreateLoad2(llvm::Type::getInt8Ty(context), left);
            right = llvm_utils->CreateLoad2(llvm::Type::getInt8Ty(context), right);
        } else {
            tmp = lfortran_str_cmp(left, left_len, right, right_len);
        }
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                if( is_single_char ) {
                    tmp = builder->CreateICmpEQ(left, right);
                } else {
                    tmp = builder->CreateICmpEQ(tmp, llvm::ConstantInt::get(context, llvm::APInt(32,0)));
                }
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                if( is_single_char ) {
                    tmp = builder->CreateICmpNE(left, right);
                } else {
                    tmp = builder->CreateICmpNE(tmp, llvm::ConstantInt::get(context, llvm::APInt(32,0)));
                }
                break;
            }
            case (ASR::cmpopType::Gt) : {
                if( is_single_char ) {
                    tmp = builder->CreateICmpSGT(left, right);
                } else {
                    tmp = builder->CreateICmpSGT(tmp, llvm::ConstantInt::get(context, llvm::APInt(32,0)));
                }
                break;
            }
            case (ASR::cmpopType::GtE) : {
                if( is_single_char ) {
                    tmp = builder->CreateICmpSGE(left, right);
                } else {
                    tmp = builder->CreateICmpSGE(tmp, llvm::ConstantInt::get(context, llvm::APInt(32,0)));
                }
                break;
            }
            case (ASR::cmpopType::Lt) : {
                if( is_single_char ) {
                    tmp = builder->CreateICmpSLT(left, right);
                } else {
                    tmp = builder->CreateICmpSLT(tmp, llvm::ConstantInt::get(context, llvm::APInt(32,0)));
                }
                break;
            }
            case (ASR::cmpopType::LtE) : {
                if( is_single_char ) {
                    tmp = builder->CreateICmpSLE(left, right);
                } else {
                    tmp = builder->CreateICmpSLE(tmp, llvm::ConstantInt::get(context, llvm::APInt(32,0)));
                }
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_LogicalCompare(const ASR::LogicalCompare_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right = tmp;
        // i1 -> i32
        left = builder->CreateZExt(left, llvm::Type::getInt32Ty(context));
        right = builder->CreateZExt(right, llvm::Type::getInt32Ty(context));
        switch (x.m_op) {
            case (ASR::cmpopType::Eq) : {
                tmp = builder->CreateICmpEQ(left, right);
                break;
            }
            case (ASR::cmpopType::NotEq) : {
                tmp = builder->CreateICmpNE(left, right);
                break;
            }
            case (ASR::cmpopType::Gt) : {
                tmp = builder->CreateICmpUGT(left, right);
                break;
            }
            case (ASR::cmpopType::GtE) : {
                tmp = builder->CreateICmpUGE(left, right);
                break;
            }
            case (ASR::cmpopType::Lt) : {
                tmp = builder->CreateICmpULT(left, right);
                break;
            }
            case (ASR::cmpopType::LtE) : {
                tmp = builder->CreateICmpULE(left, right);
                break;
            }
            default : {
                throw CodeGenError("Comparison operator not implemented",
                        x.base.base.loc);
            }
        }
    }

    void visit_OverloadedCompare(const ASR::OverloadedCompare_t &x) {
        this->visit_expr(*x.m_overloaded);
    }

    void visit_If(const ASR::If_t &x) {
        llvm::Value **strings_to_be_deallocated_copy = strings_to_be_deallocated.p;
        size_t n = strings_to_be_deallocated.n;
        strings_to_be_deallocated.reserve(al, 1);
        this->visit_expr_wrapper(x.m_test, true);
        llvm_utils->create_if_else(tmp, [&]() {
            for (size_t i=0; i<x.n_body; i++) {
                this->visit_stmt(*x.m_body[i]);
            }
        }, [&]() {
            for (size_t i=0; i<x.n_orelse; i++) {
                this->visit_stmt(*x.m_orelse[i]);
            }
        }, x.m_name, loop_or_block_end, loop_or_block_end_names);
        strings_to_be_deallocated.reserve(al, n);
        strings_to_be_deallocated.n = n;
        strings_to_be_deallocated.p = strings_to_be_deallocated_copy;
    }

    void visit_IfExp(const ASR::IfExp_t &x) {
        // IfExp(expr test, expr body, expr orelse, ttype type, expr? value)
        this->visit_expr_wrapper(x.m_test, true);
        llvm::Value *cond = tmp;
        llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(x.m_test, x.m_type, module.get());
        llvm::Value* ifexp_res = llvm_utils->CreateAlloca(_type, nullptr, "");
        llvm_utils->create_if_else(cond, [&]() {
            this->visit_expr_wrapper(x.m_body, true);
            builder->CreateStore(tmp, ifexp_res);
        }, [&]() {
            this->visit_expr_wrapper(x.m_orelse, true);
            builder->CreateStore(tmp, ifexp_res);
        });
        tmp = llvm_utils->CreateLoad2(_type, ifexp_res);
    }

    // TODO: Implement visit_DooLoop
    //void visit_DoLoop(const ASR::DoLoop_t &x) {
    //}

    void visit_WhileLoop(const ASR::WhileLoop_t &x) {
        llvm::Value **strings_to_be_deallocated_copy = strings_to_be_deallocated.p;
        size_t n = strings_to_be_deallocated.n;
        strings_to_be_deallocated.reserve(al, 1);
        create_loop(x.m_name, [=]() {
            this->visit_expr_wrapper(x.m_test, true);
            return tmp;
        }, [&]() {
            for (size_t i=0; i<x.n_body; i++) {
                this->visit_stmt(*x.m_body[i]);
            }
        });
        strings_to_be_deallocated.reserve(al, n);
        strings_to_be_deallocated.n = n;
        strings_to_be_deallocated.p = strings_to_be_deallocated_copy;
    }

    bool case_insensitive_string_compare(const std::string& str1, const std::string& str2) {
        if (str1.size() != str2.size()) {
            return false;
        }
        for (std::string::const_iterator c1 = str1.begin(), c2 = str2.begin(); c1 != str1.end(); ++c1, ++c2) {
            if (tolower(static_cast<unsigned char>(*c1)) != tolower(static_cast<unsigned char>(*c2))) {
                return false;
            }
        }
        return true;
    }

    void visit_Exit(const ASR::Exit_t &x) {
        if (x.m_stmt_name) {
            std::string stmt_name = std::string(x.m_stmt_name) + ".end";
            std::string if_cont_name = std::string(x.m_stmt_name) + ".ifcont";
            int nested_block_depth = loop_or_block_end_names.size();
            int i = nested_block_depth - 1;
            for (; i >= 0; i--) {
                if (case_insensitive_string_compare(loop_or_block_end_names[i], stmt_name) ||
                    case_insensitive_string_compare(loop_or_block_end_names[i], if_cont_name)) {
                    break;
                }
            }
            if (i >= 0) {
                builder->CreateBr(loop_or_block_end[i]);
            } else {
                throw CodeGenError("Could not find block or loop named " + std::string(x.m_stmt_name) + " in parent scope to exit from.",
                x.base.base.loc);
            }
        } else {
            builder->CreateBr(loop_or_block_end.back());
        }
        llvm::BasicBlock *bb = llvm::BasicBlock::Create(context, "unreachable_after_exit");
        start_new_block(bb);
    }

    void visit_Cycle(const ASR::Cycle_t &x) {
        if (x.m_stmt_name) {
            std::string stmt_name = std::string(x.m_stmt_name) + ".head";
            int nested_block_depth = loop_head_names.size();
            int i = nested_block_depth - 1;
            for (; i >= 0; i--) {
                if (case_insensitive_string_compare(loop_head_names[i], stmt_name)) {
                    break;
                }
            }
            if (i >= 0) {
                builder->CreateBr(loop_head[i]);
            } else {
                throw CodeGenError("Could not find loop named " + std::string(x.m_stmt_name) + " in parent scope to cycle to.",
                x.base.base.loc);
            }
        } else {
            builder->CreateBr(loop_head.back());
        }
        llvm::BasicBlock *bb = llvm::BasicBlock::Create(context, "unreachable_after_cycle");
        start_new_block(bb);
    }

    void visit_Return(const ASR::Return_t & /* x */) {
        builder->CreateBr(proc_return);
        llvm::BasicBlock *bb = llvm::BasicBlock::Create(context, "unreachable_after_return");
        start_new_block(bb);
    }

    void visit_GoTo(const ASR::GoTo_t &x) {
        if (llvm_goto_targets.find(x.m_target_id) == llvm_goto_targets.end()) {
            // If the target does not exist yet, create it
            llvm::BasicBlock *new_target = llvm::BasicBlock::Create(context, "goto_target");
            llvm_goto_targets[x.m_target_id] = new_target;
        }
        llvm::BasicBlock *target = llvm_goto_targets[x.m_target_id];
        builder->CreateBr(target);
        llvm::BasicBlock *bb = llvm::BasicBlock::Create(context, "unreachable_after_goto");
        start_new_block(bb);
    }

    void visit_GoToTarget(const ASR::GoToTarget_t &x) {
        if (llvm_goto_targets.find(x.m_id) == llvm_goto_targets.end()) {
            // If the target does not exist yet, create it
            llvm::BasicBlock *new_target = llvm::BasicBlock::Create(context, "goto_target");
            llvm_goto_targets[x.m_id] = new_target;
        }
        llvm::BasicBlock *target = llvm_goto_targets[x.m_id];
        start_new_block(target);
    }

    void visit_LogicalBinOp(const ASR::LogicalBinOp_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left_val = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right_val = tmp;
        llvm::Value *zero, *cond;
        if (ASRUtils::is_integer(*x.m_type)) {
            int a_kind = down_cast<ASR::Integer_t>(x.m_type)->m_kind;
            int init_value_bits = 8*a_kind;
            zero = llvm::ConstantInt::get(context,
                            llvm::APInt(init_value_bits, 0));
            cond = builder->CreateICmpEQ(left_val, zero);
        } else if (ASRUtils::is_real(*x.m_type)) {
            int a_kind = down_cast<ASR::Real_t>(x.m_type)->m_kind;
            int init_value_bits = 8*a_kind;
            if (init_value_bits == 32) {
                zero = llvm::ConstantFP::get(context,
                                    llvm::APFloat((float)0));
            } else {
                zero = llvm::ConstantFP::get(context,
                                    llvm::APFloat((double)0));
            }
            cond = builder->CreateFCmpUEQ(left_val, zero);
        } else if (ASRUtils::is_character(*x.m_type)) {
            zero = llvm::Constant::getNullValue(character_type);
            llvm::Value* comp_res =lfortran_str_cmp(left_val, get_string_length(x.m_left),
                zero, llvm::ConstantInt::get(context, llvm::APInt(64, 0)));
            cond = builder->CreateICmpEQ(
                comp_res,
                llvm::ConstantInt::get(context, llvm::APInt(32, 0)));
        } else if (ASRUtils::is_logical(*x.m_type)) {
            zero = llvm::ConstantInt::get(context,
                            llvm::APInt(1, 0));
            cond = builder->CreateICmpEQ(left_val, zero);
        } else {
            throw CodeGenError("Only Integer, Real, Strings and Logical types are supported "
            "in logical binary operation.", x.base.base.loc);
        }
        switch (x.m_op) {
            case ASR::logicalbinopType::And: {
                tmp = builder->CreateSelect(cond, left_val, right_val);
                break;
            };
            case ASR::logicalbinopType::Or: {
                tmp = builder->CreateSelect(cond, right_val, left_val);
                break;
            };
            case ASR::logicalbinopType::Xor: {
                tmp = builder->CreateXor(left_val, right_val);
                break;
            };
            case ASR::logicalbinopType::NEqv: {
                tmp = builder->CreateXor(left_val, right_val);
                break;
            };
            case ASR::logicalbinopType::Eqv: {
                tmp = builder->CreateXor(left_val, right_val);
                tmp = builder->CreateNot(tmp);
            };
        }
    }

    void visit_StringRepeat(const ASR::StringRepeat_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        llvm::Value* left_val, *left_len;
        std::tie(left_val, left_len) = get_string_data_and_length(x.m_left);
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right_val = tmp;
        tmp = lfortran_strrepeat(left_val, right_val);
        right_val = llvm_utils->convert_kind(right_val, llvm::Type::getInt64Ty(context));
        tmp = llvm_utils->create_string_descriptor(tmp,
            builder->CreateMul(left_len, right_val), "strRepeat_desc");
    }

    void visit_StringConcat(const ASR::StringConcat_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        llvm::Value* left_val {}, *left_len {};
        llvm::Value* right_val {}, *right_len {};
        std::tie(left_val, left_len) = get_string_data_and_length(x.m_left);
        std::tie(right_val, right_len) = get_string_data_and_length(x.m_right);
        tmp = lfortran_strConcat(left_val, left_len, right_val, right_len);
        tmp = llvm_utils->create_string_descriptor(tmp,
            builder->CreateAdd(left_len, right_len), "strConcat_desc");
    }

    void visit_StringLen(const ASR::StringLen_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        tmp = get_string_length(x.m_arg); // `int64` value.
        tmp = llvm_utils->convert_kind(tmp,
            llvm::Type::getIntNTy(context, ASRUtils::extract_kind_from_ttype_t(x.m_type) * 8));
    }

    void visit_StringOrd(const ASR::StringOrd_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        tmp = get_string_data(x.m_arg);
        llvm::AllocaInst *parg = llvm_utils->CreateAlloca(*builder, character_type);
        builder->CreateStore(tmp, parg);
        tmp = lfortran_str_ord(parg);
    }

    void visit_StringChr(const ASR::StringChr_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_load_wrapper(x.m_arg, 1);
        tmp = lfortran_str_chr(tmp);
        tmp = llvm_utils->create_string_descriptor(tmp,
            llvm::ConstantInt::get(context, llvm::APInt(64, 1)), "stringChr_desc");
    }

    void visit_StringItem(const ASR::StringItem_t& x) {
        if (x.m_value) { return this->visit_expr_wrapper(x.m_value, true); }

        /*
            Create A StringView Over The Specified StringItem From Original String
        */

        /* Visit String + Visit Index */
        llvm::Value *idx {};
        llvm::Value *str {};
        this->visit_expr_load_wrapper(x.m_idx, LLVM::is_llvm_pointer(*expr_type(x.m_idx)) ? 2 : 1, true);
        idx = tmp;
        this->visit_expr_load_wrapper(x.m_arg, 0, true);
        str = tmp;

        /* Get StringItem */
        llvm::Value *str_item {};
        {
            llvm::Value* str_data /*  i8*  */ = llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_arg), str);
            llvm::Value* idx_INT64 = llvm_utils->convert_kind(idx, llvm::Type::getInt64Ty(context));
            llvm::Value* idx /* 0-based */ = builder->CreateSub(
                                                idx_INT64,
                                                llvm::ConstantInt::get(context, llvm::APInt(64, 1)));
            str_item = builder->CreateGEP(llvm::Type::getInt8Ty(context), str_data, idx);
        }

        /* Create StringView */
        tmp = llvm_utils->create_stringView(
            ASRUtils::get_string_type(x.m_type),
            str_item,
            llvm::ConstantInt::get(context, llvm::APInt(64, 1)),
            "StringItem");
    }

    void stringSection_helper_python(const ASR::StringSection_t &x){
        this->visit_expr_load_wrapper(x.m_arg, 0);
        llvm::Value *str = tmp;
        llvm::Value *left, *right, *step;
        llvm::Value *left_present, *right_present;
        if (x.m_start) {
            this->visit_expr_load_wrapper(x.m_start, 1);
            left = tmp;
            left_present = llvm::ConstantInt::get(context,
                llvm::APInt(1, 1));
        } else {
            left = llvm::Constant::getNullValue(llvm::Type::getInt32Ty(context));
            left_present = llvm::ConstantInt::get(context,
                llvm::APInt(1, 0));
        }
        if (x.m_end) {
            this->visit_expr_load_wrapper(x.m_end, 1);
            right = tmp;
            right_present = llvm::ConstantInt::get(context,
                llvm::APInt(1, 1));
        } else {
            right = llvm::Constant::getNullValue(llvm::Type::getInt32Ty(context));
            right_present = llvm::ConstantInt::get(context,
                llvm::APInt(1, 0));
        }
        if (x.m_step) {
            this->visit_expr_load_wrapper(x.m_step, 1);
            step = tmp;
        } else {
            step = llvm::ConstantInt::get(context,
                llvm::APInt(32, 1));
        }
        if(!x.m_start && !x.m_end && !x.m_step){
            tmp = str; // no need for slicing
        } else {
            llvm::Value* str_data{}, *str_len{};
            std::tie(str_data, str_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(x.m_arg), str);
            tmp = lfortran_str_slice(str_data, str_len, left, right, step, left_present, right_present);
            llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
            tmp = llvm_utils->create_string_descriptor(
                tmp, lfortran_str_len(type, tmp, false), "stringSection_desc");
        }
    }
    void stringSection_helper_fortran(const ASR::StringSection_t &x){
        /* Assertions */
        LCOMPILERS_ASSERT( x.m_step )
        LCOMPILERS_ASSERT( x.m_start )
        LCOMPILERS_ASSERT( x.m_end )
        LCOMPILERS_ASSERT(ASR::is_a<ASR::IntegerConstant_t>(*x.m_step))
        LCOMPILERS_ASSERT(ASR::down_cast<ASR::IntegerConstant_t>(x.m_step)->m_n == 1 /*Fortran only has step of 1*/)

        /* Evaluate String */
        llvm::Value *str {};
        this->visit_expr_load_wrapper(x.m_arg, 0);
        str = tmp;
        
        /* Evaluate Start + End */
        llvm::Value *start {};
        llvm::Value *end   {};
        {
            const int start_load = LLVM::is_llvm_pointer(*expr_type(x.m_start)) ? 2 : 1;
            this->visit_expr_load_wrapper(x.m_start, start_load, true);
            start = tmp;

            const int end_load = LLVM::is_llvm_pointer(*expr_type(x.m_end)) ? 2 : 1;
            this->visit_expr_load_wrapper(x.m_end, end_load, true);
            end = tmp;
        }
        
        /* Calculate Resulting Length */
        llvm::Value* str_section_len {};
        {
            llvm::Value* start_INT64 = llvm_utils->convert_kind(start, llvm::Type::getInt64Ty(context));
            llvm::Value* end_INT64   = llvm_utils->convert_kind(end, llvm::Type::getInt64Ty(context));
            str_section_len = builder->CreateAdd(
                                            builder->CreateSub(end_INT64, start_INT64),
                                            llvm::ConstantInt::get(context, llvm::APInt(64, 1)));
        }

        /* Get Start-String Ptr (GEP) */
        llvm::Value* str_data {}; // Shifted from Original by value = start
        {
            llvm::Value* str_data_orig = llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_arg), str);
            llvm::Value* start_INT64 = llvm_utils->convert_kind(start, llvm::Type::getInt64Ty(context));
            llvm::Value* start = builder->CreateSub(start_INT64, llvm::ConstantInt::get(context, llvm::APInt(64, 1)));
            str_data = builder->CreateGEP(llvm::Type::getInt8Ty(context), str_data_orig, start, "StrSliceGEP");
        }

        /* Create StringView */
        tmp = llvm_utils->create_stringView(ASRUtils::get_string_type(x.m_type), str_data, str_section_len, "StrSlice_StrView");
    }

    void visit_StringSection(const ASR::StringSection_t& x) {
        // Don't use compile-time constant value when this is an assignment target
        // For assignment targets, we need the actual mutable location in the string,
        // not a constant value that would cause writes to read-only constant memory
        if (x.m_value && !is_assignment_target) {
            return this->visit_expr_wrapper(x.m_value, true);
        }

        // Compute the actual substring location for reading or writing
        // TODO : Find some way to use the helper functions based on the frontend,
        // We are using fortran only for now.
        if(true){ // Fortran
            stringSection_helper_fortran(x);
        } else { // Python
            stringSection_helper_python(x);
        }
    }

    void visit_StringPhysicalCast(const ASR::StringPhysicalCast_t &x){
        if( x.m_old == ASR::string_physical_typeType::DescriptorString &&
            x.m_new == ASR::string_physical_typeType::CChar){
            // CChar -> is represented as `char*` in LLVM backend.
            this->visit_expr_load_wrapper(x.m_arg, 0);
            tmp = llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_arg), tmp);
        } else if (x.m_old == ASR::string_physical_typeType::CChar &&
            x.m_new == ASR::string_physical_typeType::DescriptorString){
            this->visit_expr_load_wrapper(x.m_arg, 0);// Typically a bind-C-function return

            int len = -1;
            bool is_const_len = ASRUtils::extract_value(
                ASRUtils::get_string_type(x.m_arg)->m_len, len);
            if(!is_const_len) throw LCompilersException("Unhandled CChar string physical type with non constant length");

            tmp = llvm_utils->create_string_descriptor(tmp,
                llvm::ConstantInt::get(context, llvm::APInt(64, len)),"stringCast_desc");
        } else {
            LCOMPILERS_ASSERT(false);
        }
    }

    void visit_RealCopySign(const ASR::RealCopySign_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr(*x.m_target);
        llvm::Value* target = tmp;

        this->visit_expr(*x.m_source);
        llvm::Value* source = tmp;

        llvm::Type *type;
        int a_kind;
        a_kind = down_cast<ASR::Real_t>(ASRUtils::type_get_past_pointer(x.m_type))->m_kind;
        type = llvm_utils->getFPType(a_kind);
        if (ASR::is_a<ASR::ArrayItem_t>(*(x.m_target))) {
            target = llvm_utils->CreateLoad2(type, target);
        }
        if (ASR::is_a<ASR::ArrayItem_t>(*(x.m_source))) {
            source = llvm_utils->CreateLoad2(type, source);
        }
        llvm::Value *ftarget = builder->CreateSIToFP(target,
                type);
        llvm::Value *fsource = builder->CreateSIToFP(source,
                type);
        std::string func_name = a_kind == 4 ? "llvm.copysign.f32" : "llvm.copysign.f64";
        llvm::Function *fn_copysign = module->getFunction(func_name);
        if (!fn_copysign) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    type, { type, type}, false);
            fn_copysign = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, func_name,
                    module.get());
        }
        tmp = builder->CreateCall(fn_copysign, {ftarget, fsource});
    }

    template <typename T>
    void handle_SU_IntegerBinOp(const T &x, bool signed_int) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_load_wrapper(x.m_left, LLVM::is_llvm_pointer(*expr_type(x.m_left)) ? 2 : 1, true);
        llvm::Value *left_val = tmp;
        this->visit_expr_load_wrapper(x.m_right, LLVM::is_llvm_pointer(*expr_type(x.m_right)) ? 2 : 1, true);
        llvm::Value *right_val = tmp;
        LCOMPILERS_ASSERT(ASRUtils::is_integer(*x.m_type) ||
            ASRUtils::is_unsigned_integer(*x.m_type))
        switch (x.m_op) {
            case ASR::binopType::Add: {
                tmp = builder->CreateAdd(left_val, right_val);
                break;
            };
            case ASR::binopType::Sub: {
                tmp = builder->CreateSub(left_val, right_val);
                break;
            };
            case ASR::binopType::Mul: {
                tmp = builder->CreateMul(left_val, right_val);
                break;
            };
            case ASR::binopType::Div: {
                if (signed_int) {
                    tmp = builder->CreateSDiv(left_val, right_val);
                } else {
                    tmp = builder->CreateUDiv(left_val, right_val);
                }
                break;
            };
            case ASR::binopType::Pow: {
                int64_t exponent_const =  INT64_MAX;
                ASRUtils::extract_value(x.m_right, exponent_const);
                // Handle simple-common exponent cases for faster computation.
                if (exponent_const == 0) {
                    // x^0 = 1
                    tmp = llvm::ConstantInt::get(left_val->getType(), 1);
                } else if (exponent_const == 1) {
                    // x^1 = x
                    tmp = left_val;
                } else if (exponent_const == 2) {
                    // x^2 = x * x
                    tmp = builder->CreateMul(left_val, left_val, "simplified_pow_operation");
                } else if (exponent_const == 3) {
                    tmp = builder->CreateMul(
                            left_val,
                            builder->CreateMul(
                                left_val,
                                left_val,
                                "simplified_pow_operation"),
                            "simplified_pow_operation");
                } else if (exponent_const == 4) {
                    // x^4 = (x*x) * (x*x)
                    llvm::Value* x2 = builder->CreateMul(left_val, left_val, "simplified_pow_operation");
                    tmp = builder->CreateMul(x2, x2, "simplified_pow_operation");
                } else if (exponent_const == 5) {
                    // x^5 = x^4 * x = (x*x)*(x*x) * x
                    llvm::Value* x2 = builder->CreateMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateMul(x2, x2, "simplified_pow_operation");
                    tmp = builder->CreateMul(x4, left_val, "simplified_pow_operation");
                } else if (exponent_const == 6) {
                    // x^6 = x^4 * x^2 = (x*x)*(x*x) * (x*x)
                    llvm::Value* x2 = builder->CreateMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateMul(x2, x2, "simplified_pow_operation");
                    tmp = builder->CreateMul(x4, x2, "simplified_pow_operation");
                } else if (exponent_const == 7) {
                    // x^7 = x^4 * x^2 * x
                    llvm::Value* x2 = builder->CreateMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateMul(x2, x2, "simplified_pow_operation");
                    llvm::Value* x6 = builder->CreateMul(x4, x2, "simplified_pow_operation");
                    tmp = builder->CreateMul(x6, left_val, "simplified_pow_operation");
                } else if (exponent_const == 8) {
                    // x^8 = (x^4)^2 = ((x*x)*(x*x))^2
                    llvm::Value* x2 = builder->CreateMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateMul(x2, x2, "simplified_pow_operation");
                    tmp = builder->CreateMul(x4, x4, "simplified_pow_operation");
                } else { // Use `pow` function for large or negative exponents
                    llvm::Type* const i64_ty = llvm::Type::getInt64Ty(context);
                    llvm::Value* _right = llvm_utils->convert_kind(right_val, i64_ty);
                    llvm::Value* _left = llvm_utils->convert_kind(left_val, i64_ty);
                    const std::string func_name = "_lfortran_integer_pow_64";
                    llvm::Function *fn_pow = module->getFunction(func_name);
                    if (!fn_pow) {
                        llvm::FunctionType *function_type = llvm::FunctionType::get(
                                i64_ty, {i64_ty, i64_ty}, false);
                        fn_pow = llvm::Function::Create(function_type,
                                llvm::Function::ExternalLinkage, func_name,
                                module.get());
                    }
                    tmp = builder->CreateCall(fn_pow, {_left, _right});
                    llvm::Type* const return_type =
                        llvm_utils->getIntType(
                            ASRUtils::extract_kind_from_ttype_t(x.m_type)); // returnType of the expression.
                    tmp = llvm_utils->convert_kind(tmp, return_type);
                }
                break;
            };
            case ASR::binopType::BitOr: {
                tmp = builder->CreateOr(left_val, right_val);
                break;
            }
            case ASR::binopType::BitAnd: {
                tmp = builder->CreateAnd(left_val, right_val);
                break;
            }
            case ASR::binopType::BitXor: {
                tmp = builder->CreateXor(left_val, right_val);
                break;
            }
            case ASR::binopType::BitLShift: {
                tmp = builder->CreateShl(left_val, right_val);
                break;
            }
            case ASR::binopType::BitRShift: {
                tmp = builder->CreateAShr(left_val, right_val);
                break;
            }
            case ASR::binopType::LBitRShift: {
                tmp = builder->CreateLShr(left_val, right_val);
                break;
            }
        }
    }

    void visit_IntegerBinOp(const ASR::IntegerBinOp_t &x) {
        handle_SU_IntegerBinOp(x, true);
    }

    void visit_UnsignedIntegerBinOp(const ASR::UnsignedIntegerBinOp_t &x) {
        handle_SU_IntegerBinOp(x, false);
    }

    void visit_RealBinOp(const ASR::RealBinOp_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        lookup_enum_value_for_nonints = true;
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left_val = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right_val = tmp;
        lookup_enum_value_for_nonints = false;
        LCOMPILERS_ASSERT(ASRUtils::is_real(*x.m_type))
        if (ASRUtils::is_simd_array(x.m_right) && is_a<ASR::Var_t>(*x.m_right)) {
            llvm::Type *right_type = llvm_utils->get_type_from_ttype_t_util(x.m_right, ASRUtils::expr_type(x.m_right), module.get());
            right_val = llvm_utils->CreateLoad2(right_type, right_val);
        }
        if (ASRUtils::is_simd_array(x.m_left) && is_a<ASR::Var_t>(*x.m_left)) {
            llvm::Type *left_type = llvm_utils->get_type_from_ttype_t_util(x.m_left, ASRUtils::expr_type(x.m_left), module.get());
            left_val = llvm_utils->CreateLoad2(left_type, left_val);
        }
        switch (x.m_op) {
            case ASR::binopType::Add: {
                tmp = builder->CreateFAdd(left_val, right_val);
                break;
            };
            case ASR::binopType::Sub: {
                tmp = builder->CreateFSub(left_val, right_val);
                break;
            };
            case ASR::binopType::Mul: {
                tmp = builder->CreateFMul(left_val, right_val);
                break;
            };
            case ASR::binopType::Div: {
                tmp = builder->CreateFDiv(left_val, right_val);
                break;
            };
            case ASR::binopType::Pow: {
                int64_t exponent_const =  INT64_MAX;
                ASRUtils::extract_value(x.m_right, exponent_const);
                // Handle simple-common exponent cases for faster computation.
                if (exponent_const == 0) {
                    tmp = llvm::ConstantFP::get(left_val->getType(), 1.0);
                } else if (exponent_const == 1) {
                    tmp = left_val;
                } else if (exponent_const == 2) {
                    tmp = builder->CreateFMul(left_val, left_val, "simplified_pow_operation");
                } else if (exponent_const == 3) {
                    tmp = builder->CreateFMul(
                            left_val,
                            builder->CreateFMul(
                                left_val,
                                left_val,
                                "simplified_pow_operation"),
                            "simplified_pow_operation");
                } else if (exponent_const == 4) {
                    llvm::Value* x2 = builder->CreateFMul(left_val, left_val, "simplified_pow_operation");
                    tmp = builder->CreateFMul(x2, x2, "simplified_pow_operation");
                } else if (exponent_const == 5) {
                    llvm::Value* x2 = builder->CreateFMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateFMul(x2, x2, "simplified_pow_operation");
                    tmp = builder->CreateFMul(x4, left_val, "simplified_pow_operation");
                } else if (exponent_const == 6) {
                    llvm::Value* x2 = builder->CreateFMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateFMul(x2, x2, "simplified_pow_operation");
                    tmp = builder->CreateFMul(x4, x2, "simplified_pow_operation");
                } else if (exponent_const == 7) {
                    llvm::Value* x2 = builder->CreateFMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateFMul(x2, x2, "simplified_pow_operation");
                    llvm::Value* x6 = builder->CreateFMul(x4, x2, "simplified_pow_operation");
                    tmp = builder->CreateFMul(x6, left_val, "simplified_pow_operation");
                } else if (exponent_const == 8) {
                    llvm::Value* x2 = builder->CreateFMul(left_val, left_val, "simplified_pow_operation");
                    llvm::Value* x4 = builder->CreateFMul(x2, x2, "simplified_pow_operation");
                    tmp = builder->CreateFMul(x4, x4, "simplified_pow_operation");
                } else { // Use `pow` function
                    const int return_kind = down_cast<ASR::Real_t>(ASRUtils::extract_type(x.m_type))->m_kind;
                    llvm::Type* const base_type = llvm_utils->getFPType(return_kind);
                    llvm::Type *exponent_type = nullptr;
                    std::string func_name;
                    // Choose the appropriate llvm_pow* intrinsic function + Set the exponent type.
                    if(ASRUtils::is_integer(*ASRUtils::expr_type(x.m_right))) {
#if LLVM_VERSION_MAJOR <= 12
                        func_name = (return_kind == 4) ? "llvm.powi.f32" : "llvm.powi.f64";
                        #else
                        func_name = (return_kind == 4) ? "llvm.powi.f32.i32" : "llvm.powi.f64.i32";
                        #endif
                        right_val = llvm_utils->convert_kind(right_val, llvm::Type::getInt32Ty(context)); // `llvm.powi` only has `i32` exponent.
                        exponent_type = llvm::Type::getInt32Ty(context);
                    } else if (ASRUtils::is_real(*ASRUtils::expr_type(x.m_right))) {
                        func_name = (return_kind == 4) ? "llvm.pow.f32" : "llvm.pow.f64";
                        right_val = llvm_utils->convert_kind(right_val, base_type); // `llvm.pow` exponent and base kinds have to match.
                        exponent_type = base_type;
                    } else {
                        LCOMPILERS_ASSERT_MSG(false, "Exponent in RealBinOp should either be [Integer or Real] only.")
                    }

                    llvm::Function *fn_pow = module->getFunction(func_name);
                    if (!fn_pow) {
                        llvm::FunctionType *function_type = llvm::FunctionType::get(
                                base_type, { base_type, exponent_type }, false);
                        fn_pow = llvm::Function::Create(function_type,
                                llvm::Function::ExternalLinkage, func_name,
                                module.get());
                    }
                    tmp = builder->CreateCall(fn_pow, {left_val, right_val});
                }
                break;
            };
            default: {
                throw CodeGenError("Binary operator '" + ASRUtils::binop_to_str_python(x.m_op) + "' not supported",
                    x.base.base.loc);
            }
        }
    }

    void visit_ComplexBinOp(const ASR::ComplexBinOp_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_left, true);
        llvm::Value *left_val = tmp;
        this->visit_expr_wrapper(x.m_right, true);
        llvm::Value *right_val = tmp;
        LCOMPILERS_ASSERT(ASRUtils::is_complex(*x.m_type));
        llvm::Type *type;
        int a_kind;
        a_kind = ASR::down_cast<ASR::Complex_t>(
            ASRUtils::type_get_past_array(
                ASRUtils::type_get_past_pointer(x.m_type)))->m_kind;
        type = llvm_utils->getComplexType(a_kind);
        if( left_val->getType()->isPointerTy() ) {
            llvm::Type *left_type = llvm_utils->get_type_from_ttype_t_util(x.m_left, ASRUtils::expr_type(x.m_left), module.get());
            left_val = llvm_utils->CreateLoad2(left_type, left_val);
        }
        if( right_val->getType()->isPointerTy() ) {
            llvm::Type *right_type = llvm_utils->get_type_from_ttype_t_util(x.m_right, ASRUtils::expr_type(x.m_right), module.get());
            right_val = llvm_utils->CreateLoad2(right_type, right_val);
        }
        std::string fn_name;
        switch (x.m_op) {
            case ASR::binopType::Add: {
                if (a_kind == 4) {
                    fn_name = "_lfortran_complex_add_32";
                } else {
                    fn_name = "_lfortran_complex_add_64";
                }
                break;
            };
            case ASR::binopType::Sub: {
                if (a_kind == 4) {
                    fn_name = "_lfortran_complex_sub_32";
                } else {
                    fn_name = "_lfortran_complex_sub_64";
                }
                break;
            };
            case ASR::binopType::Mul: {
                if (a_kind == 4) {
                    fn_name = "_lfortran_complex_mul_32";
                } else {
                    fn_name = "_lfortran_complex_mul_64";
                }
                break;
            };
            case ASR::binopType::Div: {
                if (a_kind == 4) {
                    fn_name = "_lfortran_complex_div_32";
                } else {
                    fn_name = "_lfortran_complex_div_64";
                }
                break;
            };
            case ASR::binopType::Pow: {
                if (a_kind == 4) {
                    fn_name = "_lfortran_complex_pow_32";
                } else {
                    fn_name = "_lfortran_complex_pow_64";
                }
                break;
            };
            default: {
                throw CodeGenError("Binary operator '" + ASRUtils::binop_to_str_python(x.m_op) + "' not supported",
                    x.base.base.loc);
            }
        }
        tmp = lfortran_complex_bin_op(left_val, right_val, fn_name, type);
    }

    void visit_OverloadedBinOp(const ASR::OverloadedBinOp_t &x) {
        this->visit_expr(*x.m_overloaded);
    }

    void visit_OverloadedBoolOp(const ASR::OverloadedBoolOp_t& x) {
        this->visit_expr(*x.m_overloaded);
    }

    void visit_OverloadedUnaryMinus(const ASR::OverloadedUnaryMinus_t &x) {
        this->visit_expr(*x.m_overloaded);
    }

    void visit_IntegerBitNot(const ASR::IntegerBitNot_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        tmp = builder->CreateNot(tmp);
    }

    void visit_UnsignedIntegerBitNot(const ASR::UnsignedIntegerBitNot_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        tmp = builder->CreateNot(tmp);
    }

    template <typename T>
    void handle_SU_IntegerUnaryMinus(const T& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        llvm::Value *zero = llvm::ConstantInt::get(context,
            llvm::APInt(ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(x.m_arg)) * 8, 0));
        tmp = builder->CreateSub(zero, tmp);
    }

    void visit_IntegerUnaryMinus(const ASR::IntegerUnaryMinus_t &x) {
        handle_SU_IntegerUnaryMinus(x);
    }

    void visit_UnsignedIntegerUnaryMinus(const ASR::UnsignedIntegerUnaryMinus_t &x) {
        handle_SU_IntegerUnaryMinus(x);
    }

    void visit_RealUnaryMinus(const ASR::RealUnaryMinus_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        tmp = builder->CreateFNeg(tmp);
    }

    void visit_ComplexUnaryMinus(const ASR::ComplexUnaryMinus_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        llvm::Type *type = tmp->getType();
        llvm::Value *re = complex_re(tmp, type);
        llvm::Value *im = complex_im(tmp, type);
        re = builder->CreateFNeg(re);
        im = builder->CreateFNeg(im);
        tmp = complex_from_floats(re, im, type);
    }

    template <typename T>
    void handle_SU_IntegerConstant(const T &x) {
        int64_t val = x.m_n;
        int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
        switch( a_kind ) {
            case 1: {
                tmp = llvm::ConstantInt::get(context, llvm::APInt(8, static_cast<int8_t>(val), true));
                break ;
            }
            case 2: {
                tmp = llvm::ConstantInt::get(context, llvm::APInt(16, static_cast<int16_t>(val), true));
                break ;
            }
            case 4 : {
                tmp = llvm::ConstantInt::get(context, llvm::APInt(32, static_cast<int32_t>(val), true));
                break;
            }
            case 8 : {
                tmp = llvm::ConstantInt::get(context, llvm::APInt(64, val, true));
                break;
            }
            default : {
                throw CodeGenError("Constant integers of " + std::to_string(a_kind)
                                    + " bytes aren't supported yet.");
            }

        }
    }

    void visit_IntegerConstant(const ASR::IntegerConstant_t &x) {
        handle_SU_IntegerConstant(x);
    }

    void visit_UnsignedIntegerConstant(const ASR::UnsignedIntegerConstant_t &x) {
        handle_SU_IntegerConstant(x);
    }

    void visit_RealConstant(const ASR::RealConstant_t &x) {
        double val = x.m_r;
        int a_kind = ((ASR::Real_t*)(&(x.m_type->base)))->m_kind;
        switch( a_kind ) {

            case 4 : {
                tmp = llvm::ConstantFP::get(context, llvm::APFloat((float)val));
                break;
            }
            case 8 : {
                tmp = llvm::ConstantFP::get(context, llvm::APFloat(val));
                break;
            }
            default : {
                break;
            }

        }

    }

    template <typename T>
    void visit_ArrayConstructorUtil(const T& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }

        llvm::Type* el_type = nullptr;
        ASR::ttype_t* x_m_type = ASRUtils::type_get_past_array(x.m_type);
        if (ASR::is_a<ASR::Integer_t>(*x_m_type)) {
            el_type = llvm_utils->getIntType(ASR::down_cast<ASR::Integer_t>(x_m_type)->m_kind);
        } else if (ASR::is_a<ASR::Real_t>(*x_m_type)) {
            switch (ASR::down_cast<ASR::Real_t>(x_m_type)->m_kind) {
                case (4) :
                    el_type = llvm::Type::getFloatTy(context); break;
                case (8) :
                    el_type = llvm::Type::getDoubleTy(context); break;
                default :
                    throw CodeGenError("ConstArray real kind not supported yet");
            }
        } else if (ASR::is_a<ASR::Logical_t>(*x_m_type)) {
            el_type = llvm::Type::getInt8Ty(context);
        } else if (ASR::is_a<ASR::String_t>(*x_m_type)) {
            el_type = character_type;
        } else if (ASR::is_a<ASR::Complex_t>(*x_m_type)) {
            int complex_kind = ASR::down_cast<ASR::Complex_t>(x_m_type)->m_kind;
            if( complex_kind == 4 ) {
                el_type = llvm_utils->complex_type_4;
            } else if( complex_kind == 8 ) {
                el_type = llvm_utils->complex_type_8;
            } else {
                LCOMPILERS_ASSERT(false);
            }
        } else {
            throw CodeGenError("ConstArray type not supported yet");
        }
        // Create <n x float> type, where `n` is the length of the `x` constant array
        llvm::Type* type_fxn = FIXED_VECTOR_TYPE::get(el_type, ASRUtils::get_fixed_size_of_array(x.m_type));
        // Create a pointer <n x float>* to a stack allocated <n x float>
        llvm::AllocaInst *p_fxn = llvm_utils->CreateAlloca(*builder, type_fxn);
        // Assign the array elements to `p_fxn`.
        for (size_t i=0; i < x.n_args; i++) {
            llvm::Value *llvm_el = llvm_utils->create_gep2(type_fxn, p_fxn, i);
            ASR::expr_t *el = x.m_args[i];
            int64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 2;
            this->visit_expr_wrapper(el, true);
            ptr_loads = ptr_loads_copy;
            if (ASRUtils::is_logical(*x_m_type) && tmp->getType()->isIntegerTy(1)) {
                tmp = builder->CreateZExt(tmp, llvm::Type::getInt8Ty(context));
            }
            builder->CreateStore(tmp, llvm_el);
        }
        // Return the vector as float* type:
        tmp = llvm_utils->create_gep2(type_fxn ,p_fxn, 0);
    }

    void visit_ArrayConstantUtil(const ASR::ArrayConstant_t &x) {
        llvm::Type* el_type = nullptr;
        ASR::ttype_t* x_m_type = ASRUtils::type_get_past_array(x.m_type);
        if (ASR::is_a<ASR::Integer_t>(*x_m_type)) {
            el_type = llvm_utils->getIntType(ASR::down_cast<ASR::Integer_t>(x_m_type)->m_kind);
        } else if (ASR::is_a<ASR::Real_t>(*x_m_type)) {
            switch (ASR::down_cast<ASR::Real_t>(x_m_type)->m_kind) {
                case (4) :
                    el_type = llvm::Type::getFloatTy(context); break;
                case (8) :
                    el_type = llvm::Type::getDoubleTy(context); break;
                default :
                    throw CodeGenError("ConstArray real kind not supported yet");
            }
        } else if (ASR::is_a<ASR::Logical_t>(*x_m_type)) {
            el_type = llvm::Type::getInt8Ty(context);
        } else if (ASR::is_a<ASR::String_t>(*x_m_type)) {
            el_type = llvm_utils->get_StringType(x_m_type);
        } else if (ASR::is_a<ASR::Complex_t>(*x_m_type)) {
            int complex_kind = ASR::down_cast<ASR::Complex_t>(x_m_type)->m_kind;
            if( complex_kind == 4 ) {
                el_type = llvm_utils->complex_type_4;
            } else if( complex_kind == 8 ) {
                el_type = llvm_utils->complex_type_8;
            } else {
                LCOMPILERS_ASSERT(false);
            }
        } else {
            throw CodeGenError("ConstArray type not supported yet");
        }

        // Declaring array constant as global constant and directly using it
        // instead of storing each element using CreateStore
        int64_t arr_size = ASRUtils::get_fixed_size_of_array(x.m_type);
        llvm::Type *Int32Ty = llvm::Type::getInt32Ty(context);
        llvm::ArrayType * arr_type = llvm::ArrayType::get(el_type, arr_size);
        std::vector<llvm::Constant *> values;

        if (ASRUtils::is_integer(*x_m_type)) {
            for (size_t i=0; i < (size_t) arr_size; i++) {
                ASR::expr_t *el = ASRUtils::fetch_ArrayConstant_value(al, x, i);
                values.push_back(llvm::ConstantInt::get(el_type, down_cast<ASR::IntegerConstant_t>(el)->m_n));
            }
        } else if (ASRUtils::is_real(*x_m_type)) {
            for (size_t i=0; i < (size_t) arr_size; i++) {
                ASR::expr_t *el = ASRUtils::fetch_ArrayConstant_value(al, x, i);
                values.push_back(llvm::ConstantFP::get(el_type, down_cast<ASR::RealConstant_t>(el)->m_r));
            }
        } else if (ASRUtils::is_logical(*x_m_type)) {
            for (size_t i=0; i < (size_t) arr_size; i++) {
                ASR::expr_t *el = ASRUtils::fetch_ArrayConstant_value(al, x, i);
                values.push_back(llvm::ConstantInt::get(
                    el_type, llvm::APInt(8, down_cast<ASR::LogicalConstant_t>(el)->m_value ? 1 : 0)));
            }
        } else if (ASRUtils::is_complex(*x_m_type)) {
            for (size_t i=0; i < (size_t) arr_size; i++) {
                ASR::expr_t *el = ASRUtils::fetch_ArrayConstant_value(al, x, i);
                ASR::ComplexConstant_t *comp_const = down_cast<ASR::ComplexConstant_t>(el);
                if (ASRUtils::extract_kind_from_ttype_t(comp_const->m_type) == 4) {
                    values.push_back(llvm::ConstantStruct::get(llvm_utils->complex_type_4,
                        {llvm::ConstantFP::get(llvm::Type::getFloatTy(context), comp_const->m_re),
                        llvm::ConstantFP::get(llvm::Type::getFloatTy(context), comp_const->m_im)}));
                } else {
                    values.push_back(llvm::ConstantStruct::get(llvm_utils->complex_type_8,
                        {llvm::ConstantFP::get(llvm::Type::getDoubleTy(context), comp_const->m_re),
                        llvm::ConstantFP::get(llvm::Type::getDoubleTy(context), comp_const->m_im)}));
                }
            }
        } else if (ASRUtils::is_character(*x_m_type)) { // Sepcial Case.
            tmp = llvm_utils->declare_constant_stringArray(al, &x);
            return;
        }

        llvm::Constant *ConstArray = llvm::ConstantArray::get(arr_type, values);
        llvm::GlobalVariable *global_var = new llvm::GlobalVariable(*module, arr_type, true,
            llvm::GlobalValue::PrivateLinkage, ConstArray, "global_array_" + std::to_string(global_array_count++));
        tmp = builder->CreateGEP(
            arr_type, global_var, {llvm::ConstantInt::get(Int32Ty, 0), llvm::ConstantInt::get(Int32Ty, 0)});
    }

    void visit_ArrayConstructor(const ASR::ArrayConstructor_t &x) {
        visit_ArrayConstructorUtil(x);
    }

    void visit_ArrayConstant(const ASR::ArrayConstant_t &x) {
        visit_ArrayConstantUtil(x);
    }

    void visit_Assert(const ASR::Assert_t &x) {
        if (compiler_options.emit_debug_info) debug_emit_loc(x);
        this->visit_expr_wrapper(x.m_test, true);
        llvm_utils->create_if_else(tmp, []() {}, [=]() {
            if (compiler_options.emit_debug_info) {
                llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, infile);
                llvm::Value *fmt_ptr1 = llvm::ConstantInt::get(context, llvm::APInt(
                    1, compiler_options.use_colors));
                call_print_stacktrace_addresses(context, *module, *builder,
                    {fmt_ptr, fmt_ptr1});
            }
            if (x.m_msg) {
                std::vector<std::string> fmt;
                std::vector<llvm::Value *> args;
                fmt.push_back("%s");
                args.push_back(LCompilers::create_global_string_ptr(context, *module, *builder, "AssertionError: "));
                compute_fmt_specifier_and_arg(fmt, args, x.m_msg, x.base.base.loc);
                fmt.push_back("%s");
                args.push_back(LCompilers::create_global_string_ptr(context, *module, *builder, "\n"));
                std::string fmt_str;
                for (size_t i=0; i<fmt.size(); i++) {
                    fmt_str += fmt[i];
                }
                llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, fmt_str);
                std::vector<llvm::Value *> print_error_args;
                print_error_args.push_back(fmt_ptr);
                print_error_args.insert(print_error_args.end(), args.begin(), args.end());
                print_error(context, *module, *builder, print_error_args);
            } else {
                llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, "AssertionError\n");
                print_error(context, *module, *builder, {fmt_ptr});
            }
            int exit_code_int = 1;
            llvm::Value *exit_code = llvm::ConstantInt::get(context,
                    llvm::APInt(32, exit_code_int));
            exit(context, *module, *builder, exit_code);
        });
    }

    void visit_ComplexConstructor(const ASR::ComplexConstructor_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_re, true);
        llvm::Value *re_val = tmp;

        this->visit_expr_wrapper(x.m_im, true);
        llvm::Value *im_val = tmp;

        int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);

        llvm::Value *re2, *im2;
        llvm::Type *type;
        switch( a_kind ) {
            case 4: {
                re2 = builder->CreateFPTrunc(re_val, llvm::Type::getFloatTy(context));
                im2 = builder->CreateFPTrunc(im_val, llvm::Type::getFloatTy(context));
                type = complex_type_4;
                break;
            }
            case 8: {
                re2 = builder->CreateFPExt(re_val, llvm::Type::getDoubleTy(context));
                im2 = builder->CreateFPExt(im_val, llvm::Type::getDoubleTy(context));
                type = complex_type_8;
                break;
            }
            default: {
                throw CodeGenError("kind type is not supported");
            }
        }
        tmp = complex_from_floats(re2, im2, type);
    }

    void visit_ComplexConstant(const ASR::ComplexConstant_t &x) {
        double re = x.m_re;
        double im = x.m_im;
        int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
        llvm::Constant *re2, *im2;
        llvm::Type *type;
        switch( a_kind ) {
            case 4: {
                re2 = llvm::ConstantFP::get(context, llvm::APFloat((float)re));
                im2 = llvm::ConstantFP::get(context, llvm::APFloat((float)im));
                type = complex_type_4;
                break;
            }
            case 8: {
                re2 = llvm::ConstantFP::get(context, llvm::APFloat(re));
                im2 = llvm::ConstantFP::get(context, llvm::APFloat(im));
                type = complex_type_8;
                break;
            }
            default: {
                throw CodeGenError("kind type is not supported");
            }
        }
        // Create a compile-time constant struct for ComplexConstant
        // Complex numbers are represented as {real, imaginary} structs
        std::vector<llvm::Constant*> elements = {re2, im2};
        llvm::StructType* struct_type = llvm::cast<llvm::StructType>(type);
        tmp = llvm::ConstantStruct::get(struct_type, elements);
    }

    void visit_LogicalConstant(const ASR::LogicalConstant_t &x) {
        int val;
        if (x.m_value == true) {
            val = 1;
        } else {
            val = 0;
        }
        tmp = llvm::ConstantInt::get(context, llvm::APInt(1, val));
    }

    void visit_LogicalNot(const ASR::LogicalNot_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        llvm::Value *arg = tmp;
        tmp = builder->CreateNot(arg);
    }

    void visit_StringConstant(const ASR::StringConstant_t &x) {
        tmp = llvm_utils->declare_string_constant(&x);
    }

    void visit_CompilerOptions(const ASR::CompilerOptions_t &x) {
        // Use the compiler options string stored in the ASR node
        std::string options_str = std::string(x.m_compiler_options_str);
        tmp = llvm_utils->declare_global_string(
            ASRUtils::get_string_type(x.m_type),
            options_str, true, "compiler_options_const");
    }

    inline void fetch_ptr(ASR::Variable_t* x) {
        uint32_t x_h = get_hash((ASR::asr_t*)x);
        LCOMPILERS_ASSERT(llvm_symtab.find(x_h) != llvm_symtab.end());
        llvm::Value* x_v = llvm_symtab[x_h];
        int64_t ptr_loads_copy = ptr_loads;
        tmp = x_v;
        llvm::Type* type_req = nullptr;
        int loads = 0;
        while( ptr_loads_copy-- ) {
            if( loads == 0 ) {
                type_req =  llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, x->base.base.loc, &x->base)),
                    x->m_type, module.get());

            } else {
                type_req =  llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, x->base.base.loc, &x->base)),
                    ASRUtils::type_get_past_allocatable_pointer(x->m_type),
                    module.get());
            }
            tmp = llvm_utils->CreateLoad2(type_req, tmp);
            loads++;
        }
    }

    inline bool is_cptr_dummy_passed_by_value(const ASR::Variable_t* x) const {
        return ASR::is_a<ASR::CPtr_t>(*x->m_type) &&
            ASRUtils::is_arg_dummy(x->m_intent) &&
            !(x->m_intent == ASR::intentType::Out ||
              x->m_intent == ASR::intentType::InOut ||
              (x->m_intent == ASR::intentType::Unspecified && !x->m_value_attr));
    }

    inline void fetch_val(ASR::Variable_t* x) {
        uint32_t x_h = get_hash((ASR::asr_t*)x);
        llvm::Value* x_v;
        LCOMPILERS_ASSERT(llvm_symtab.find(x_h) != llvm_symtab.end());
        x_v = llvm_symtab[x_h];
        if (x->m_abi == ASR::abiType::BindC && x->m_value_attr) {
            // Already a value, such as value argument to bind(c)
            tmp = x_v;
            return;
        }
        if (is_cptr_dummy_passed_by_value(x)) {
            // type(c_ptr) dummy arguments that are passed by value
            // are already the pointer value and must not be loaded.
            tmp = x_v;
            return;
        }
        if( ASRUtils::is_array(x->m_type) ) {
            tmp = x_v;
        } else {
            tmp = x_v;
            // Load only once since its a value
            if( ptr_loads > 0 ) {
                llvm::Type* x_llvm_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, x->base.base.loc, &x->base)), x->m_type, module.get());
                tmp = llvm_utils->CreateLoad2(x_llvm_type, tmp);
            }
        }
    }

    inline void fetch_var(ASR::Variable_t* x) {
        // Only do for constant variables
        if (x->m_value && x->m_storage == ASR::storage_typeType::Parameter) {
            this->visit_expr_wrapper(x->m_value, true);
            return;
        }
        ASR::ttype_t *t2_ = ASRUtils::type_get_past_array(x->m_type);
        switch( t2_->type ) {
            case ASR::ttypeType::Pointer:
            case ASR::ttypeType::Allocatable: {
                ASR::ttype_t *t2 = ASRUtils::extract_type(x->m_type);
                switch (t2->type) {
                    case ASR::ttypeType::Integer:
                    case ASR::ttypeType::UnsignedInteger:
                    case ASR::ttypeType::Real:
                    case ASR::ttypeType::Complex:
                    case ASR::ttypeType::StructType:
                    case ASR::ttypeType::String:
                    case ASR::ttypeType::Logical:
                    case ASR::ttypeType::CPtr:{
                        if( t2->type == ASR::ttypeType::StructType ) {
                            current_der_type_name = ASRUtils::symbol_name(
                                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(ASRUtils::EXPR(ASR::make_Var_t(al, x->base.base.loc, (ASR::symbol_t*) x)))));
                        }
                        if (ASRUtils::is_unlimited_polymorphic_type(ASRUtils::EXPR(ASR::make_Var_t(al, x->base.base.loc, (ASR::symbol_t*)x)))) {
                            uint32_t h = get_hash((ASR::asr_t*)x);
                            if( llvm_symtab.find(h) != llvm_symtab.end() ) {
                                tmp = llvm_symtab[h];
                            }
                        } else {
                            ASR::expr_t* var_expr = ASRUtils::EXPR(ASR::make_Var_t(al, x->base.base.loc, (ASR::symbol_t*)x));
                            ASR::ttype_t* value_type = ASRUtils::expr_type(var_expr);
                            // Throw runtime error for trying to get value of unallocated allocatable scalars
                            if (ptr_loads == 2 && // If ptr_loads == 2 then we are trying to read the value
                                compiler_options.po.bounds_checking &&
                                ASRUtils::is_allocatable(value_type) && !ASRUtils::is_array(value_type) &&
                                !ASRUtils::is_string_only(value_type) && !ASR::is_a<ASR::StructType_t>(*ASRUtils::type_get_past_allocatable(value_type))) {
                                llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(var_expr, ASRUtils::expr_type(var_expr), module.get());
                                int ptr_loads_copy = ptr_loads;
                                ptr_loads = 1;
                                fetch_ptr(x);
                                ptr_loads = ptr_loads_copy;
                                llvm::Value* cond = builder->CreateICmpEQ(
                                    builder->CreatePtrToInt(tmp,
                                        llvm::Type::getInt64Ty(context)),
                                    builder->CreatePtrToInt(llvm::ConstantPointerNull::get(type->getPointerTo()),
                                        llvm::Type::getInt64Ty(context)));
                                // TODO: Set location here
                                llvm_utils->generate_runtime_error(cond,
                                    "Variable '%s' is not allocated.",
                                    {LLVMUtils::RuntimeLabel("", {x->base.base.loc})},
                                    infile,
                                    location_manager,
                                    LCompilers::create_global_string_ptr(context, *module, *builder, x->m_name));
                            }
                            fetch_ptr(x);
                        }
                        break;
                    }
                    default:
                        break;
                }
                break;
            }
            case ASR::ttypeType::StructType: {
                ASR::Struct_t* der_type = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(x->m_type_declaration));
                current_der_type_name = std::string(der_type->m_name);
                uint32_t h = get_hash((ASR::asr_t*)x);
                if( llvm_symtab.find(h) != llvm_symtab.end() ) {
                    tmp = llvm_symtab[h];
                }
                break;
            }
            case ASR::ttypeType::UnionType: {
                ASR::Union_t* der_type = ASR::down_cast<ASR::Union_t>(
                    ASRUtils::symbol_get_past_external(x->m_type_declaration));
                current_der_type_name = std::string(der_type->m_name);
                uint32_t h = get_hash((ASR::asr_t*)x);
                if( llvm_symtab.find(h) != llvm_symtab.end() ) {
                    tmp = llvm_symtab[h];
                }
                break;
            }
            case ASR::ttypeType::FunctionType: {
                // break;
                uint32_t h = get_hash((ASR::asr_t*)x);
                uint32_t x_h = get_hash((ASR::asr_t*)x);
                if ( llvm_symtab_fn_arg.find(h) != llvm_symtab_fn_arg.end() ) {
                    tmp = llvm_symtab_fn_arg[h];
                } else if ( llvm_symtab.find(x_h) != llvm_symtab.end() ) {
                    tmp = llvm_symtab[x_h];
                } else if (llvm_symtab_fn.find(h) != llvm_symtab_fn.end()) {
                    tmp = llvm_symtab_fn[h];
                    tmp = llvm_utils->CreateLoad2(tmp->getType()->getPointerTo(), tmp);
                } else {
                    throw CodeGenError("Function type not supported yet");
                }
                if (x->m_abi == ASR::abiType::BindC && x->m_value_attr) {
                    // Already a value, such as value argument to bind(c)
                    break;
                }
                if( ASRUtils::is_array(x->m_type) ) {
                    break;
                } else {
                    // Load only once since its a value
                    if( ptr_loads > 0 ) {
                        llvm::Type* x_llvm_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                            al, x->base.base.loc, &x->base)), x->m_type, module.get());
                        tmp = llvm_utils->CreateLoad2(x_llvm_type, tmp);
                    }
                }
                break;
            } default: {
                fetch_val(x);
                break;
            }
        }
    }

    void visit_Var(const ASR::Var_t &x) {
        ASR::symbol_t* x_m_v = ASRUtils::symbol_get_past_external(x.m_v);
        switch( x_m_v->type ) {
            case ASR::symbolType::Variable: {
                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(x_m_v);
                fetch_var(v);
            break;
            }
            case ASR::symbolType::Function: {
                const uint32_t h = get_hash((ASR::asr_t*)x_m_v);
                if(llvm_symtab_fn_arg.find(h) != llvm_symtab_fn_arg.end()){ // Callback fn arg.
                    tmp = llvm_symtab_fn_arg[h];
                } else if( llvm_symtab_fn.find(h) != llvm_symtab_fn.end() ) {
                    tmp = llvm_symtab_fn[h];
                } else {
                    throw CodeGenError(std::string("Can't resolve var to Function '") + ASRUtils::symbol_name(x_m_v) + "'");
                }
            break;
            }
            default: {
                throw CodeGenError("Only function and variables supported so far");
            }
        }
    }

    inline ASR::ttype_t* extract_ttype_t_from_expr(ASR::expr_t* expr) {
        return ASRUtils::expr_type(expr);
    }

    void extract_kinds(const ASR::Cast_t& x,
                       int& arg_kind, int& dest_kind)
    {
        dest_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
        ASR::ttype_t* curr_type = extract_ttype_t_from_expr(x.m_arg);
        LCOMPILERS_ASSERT(curr_type != nullptr)
        arg_kind = ASRUtils::extract_kind_from_ttype_t(curr_type);
    }

    template <typename T>
    void handle_arr_for_complex_im_re(const T& t) {
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 2 - LLVM::is_llvm_pointer(*ASRUtils::expr_type(t.m_arg));
        this->visit_expr_wrapper(t.m_arg, false);
        ptr_loads = ptr_loads_copy;
        llvm::Value* des_complex_arr = tmp;
        llvm::Type* des_complex_type = llvm_utils->get_type_from_ttype_t_util(t.m_arg,
            ASRUtils::extract_type(ASRUtils::expr_type(t.m_arg)), module.get());
        llvm::Type* des_complex_type_ = llvm_utils->get_type_from_ttype_t_util(
            t.m_arg, ASRUtils::expr_type(t.m_arg), module.get());
        tmp = llvm_utils->CreateLoad2(des_complex_type->getPointerTo(), arr_descr->get_pointer_to_data(des_complex_type_, des_complex_arr));
        int kind = ASRUtils::extract_kind_from_ttype_t(t.m_type);
        llvm::Type* pointer_cast_type = nullptr;
        if (kind == 4) {
            pointer_cast_type = llvm::Type::getFloatTy(context)->getPointerTo();
        } else {
            pointer_cast_type = llvm::Type::getDoubleTy(context)->getPointerTo();
        }
        tmp = builder->CreateBitCast(tmp, pointer_cast_type);
        PointerToData_to_Descriptor(t.m_arg, t.m_type, t.m_type);
        llvm::Value* des_real_arr = tmp;
        llvm::Type* des_real_type = llvm_utils->get_type_from_ttype_t_util(t.m_arg, t.m_type, module.get());
        llvm::Value* arr_data = llvm_utils->CreateLoad2(
            des_complex_type->getPointerTo(), arr_descr->get_pointer_to_data(des_complex_type_, des_complex_arr));
        tmp = builder->CreateBitCast(arr_data, pointer_cast_type);
        builder->CreateStore(tmp, arr_descr->get_pointer_to_data(des_real_type,  des_real_arr));
        llvm::Type* idx_type = arr_descr->get_index_type();
        unsigned idx_bits = idx_type->getIntegerBitWidth();
        if (std::is_same<T, ASR::ComplexIm_t>::value) {
            llvm::Value* incremented_offset = builder->CreateAdd(
                arr_descr->get_offset(des_real_type, des_real_arr, true),
                llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 1)));
            builder->CreateStore(incremented_offset, arr_descr->get_offset(des_real_type, des_real_arr, false));
        }
        int n_dims = ASRUtils::extract_n_dims_from_ttype(t.m_type);
        llvm::Value* dim_des_real_arr = arr_descr->get_pointer_to_dimension_descriptor_array(des_real_type, des_real_arr, true);
        for (int i = 0; i < n_dims; i++) {
            llvm::Value* dim_idx = llvm::ConstantInt::get(context, llvm::APInt(32, i));
            llvm::Value* dim_des_real_arr_idx = arr_descr->get_pointer_to_dimension_descriptor(dim_des_real_arr, dim_idx);
            llvm::Value* doubled_stride = builder->CreateMul(
                arr_descr->get_stride(dim_des_real_arr_idx, true),
                llvm::ConstantInt::get(context, llvm::APInt(idx_bits, 2)));
            builder->CreateStore(doubled_stride, arr_descr->get_stride(dim_des_real_arr_idx, false));
        }
        tmp = des_real_arr;
    }

    void visit_ComplexRe(const ASR::ComplexRe_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        if (ASRUtils::is_array(x.m_type) && ASRUtils::is_array(ASRUtils::expr_type(x.m_arg))) {
            handle_arr_for_complex_im_re(x);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        ASR::ttype_t* curr_type = extract_ttype_t_from_expr(x.m_arg);
        int arg_kind = ASRUtils::extract_kind_from_ttype_t(curr_type);
        llvm::Value *re;
        if (arg_kind == 4) {
            re = complex_re(tmp, complex_type_4);
        } else if (arg_kind == 8) {
            re = complex_re(tmp, complex_type_8);
        } else {
            std::string msg = "Complex kind " + std::to_string(arg_kind) + " not implemented yet.";
            throw CodeGenError(msg);
        }
        tmp = re;
    }

    void visit_ComplexIm(const ASR::ComplexIm_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        if (ASRUtils::is_array(x.m_type) && ASRUtils::is_array(ASRUtils::expr_type(x.m_arg))) {
            handle_arr_for_complex_im_re(x);
            return;
        }
        this->visit_expr_wrapper(x.m_arg, true);
        ASR::ttype_t* curr_type = extract_ttype_t_from_expr(x.m_arg);
        int arg_kind = ASRUtils::extract_kind_from_ttype_t(curr_type);
        llvm::Value *im;
        if (arg_kind == 4) {
            im = complex_im(tmp, complex_type_4);
        } else if (arg_kind == 8) {
            im = complex_im(tmp, complex_type_8);
        } else {
            std::string msg = "Complex kind " + std::to_string(arg_kind) + " not implemented yet.";
            throw CodeGenError(msg);
        }
        tmp = im;
    }

    void visit_BitCast(const ASR::BitCast_t& x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        llvm::Value* source{};
        int64_t p_load = 0 ;
        if(ASRUtils::is_character(*expr_type(x.m_source))){
            const bool source_is_descriptor_array_= ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable_pointer(expr_type(x.m_source)))
                                                    && ASRUtils::extract_physical_type(expr_type(x.m_source)) == ASR::DescriptorArray;
            p_load = source_is_descriptor_array_? 1 : 0;
        } else {
            p_load = ptr_loads;
        }
        this->visit_expr_load_wrapper(x.m_source, p_load, true);
        source = tmp;
        llvm::Type* source_type = llvm_utils->get_type_from_ttype_t_util(x.m_source, ASRUtils::expr_type(x.m_source), module.get());
        llvm::Value* source_ptr;
        bool is_array = ASRUtils::is_array(ASRUtils::expr_type(x.m_source));
        if (ASRUtils::is_character(*expr_type(x.m_source))) {
            tmp = source_ptr = ASRUtils::is_array_of_strings(expr_type(x.m_source)) ?
                        llvm_utils->get_stringArray_data(expr_type(x.m_source), tmp) :
                        llvm_utils->get_string_data(ASRUtils::get_string_type(x.m_source), tmp);
        } else if(source->getType()->isPointerTy() || source_type->isArrayTy()){//Case: [n x i8]* type Arrays and ptr %
            source_ptr = source;
        } else if (is_array) {
            source_type = source->getType();
            source_ptr = llvm_utils->CreateAlloca(source_type, nullptr, "bitcast_source");
            builder->CreateStore(source, source_ptr);
            ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(
                ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(x.m_source)));
            llvm::Type* source_type_ = llvm_utils->get_type_from_ttype_t_util(x.m_source,
                ASRUtils::extract_type(ASRUtils::expr_type(x.m_source)), module.get());
            llvm::Type* llvm_source_type_ = llvm_utils->get_type_from_ttype_t_util(x.m_source,
                ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(x.m_source)), module.get());
            if (arr->m_physical_type == ASR::array_physical_typeType::DescriptorArray) {
                source_ptr = llvm_utils->create_gep2(llvm_source_type_, source_ptr, 0);
                source_ptr = builder->CreateLoad(source_type_->getPointerTo(), source_ptr);
            } else {      // For PointerArray source itself is a pointer to data
                source_ptr = source;
            }
        } else {
            source_ptr = llvm_utils->CreateAlloca(source_type, nullptr, "bitcast_source");
            builder->CreateStore(source, source_ptr);
        }

        /* Handle The Return Of The Expression (String, Array, Integer_8, etc.) */
        ASR::ttype_t* mold_type_unwrapped = ASRUtils::type_get_past_allocatable_pointer(expr_type(x.m_mold));
        switch(mold_type_unwrapped->type){
            case(ASR::Array) : {// Array result from transfer(source, array_mold)
                // Calculate number of elements = source_size / element_size
                ASR::Array_t* array_mold = ASR::down_cast<ASR::Array_t>(mold_type_unwrapped);
                ASR::ttype_t* element_type = array_mold->m_type;

                if (ASRUtils::is_character(*element_type)) {
                    // For character arrays: num_elements = source_bytes / element_bytes
                    // where element_bytes = kind * length for character(kind, len)
                    llvm::Value* source_length = get_string_length(x.m_source);

                    // Note: source_length is the total number of bytes in the source
                    // The ASR phase has already calculated the correct array dimension
                    // based on: num_elements = source_bytes / (kind * len)
                    // This string view just carries the raw byte data
                    llvm::Value* const casted_to_i8 = builder->CreateBitCast(source_ptr,
                        llvm::Type::getInt8Ty(context)->getPointerTo());

                    // Create a string view representing the whole source byte data
                    // The assignment handler will extract element_length bytes per iteration
                    llvm::Value* const str_view = llvm_utils->create_stringView(
                        ASRUtils::get_string_type(x.m_source),
                        casted_to_i8, source_length, "bit_cast_expr_return");
                    tmp = str_view;
                }
            break;
            }
            case(ASR::String) : {// Create StringView : data = bitcasted source, length = mold's length
                llvm::Value* const casted_to_i8 /* i8* */  = builder->CreateBitCast(source_ptr, llvm::Type::getInt8Ty(context)->getPointerTo());
                llvm::Value* const str_view /*non-owning*/ = llvm_utils->create_stringView(ASRUtils::get_string_type(x.m_mold), 
                                                                casted_to_i8, get_string_length(x.m_mold), "bit_cast_expr_return");
                tmp = str_view;
            break;
            } default : {
                // Do nothing for now.
            }
        }


        llvm::Type* target_base_type = llvm_utils->get_type_from_ttype_t_util(const_cast<ASR::expr_t*>(&x.base), ASRUtils::type_get_past_array(x.m_type), module.get());
        llvm::Type* target_llvm_type = target_base_type->getPointerTo();
        bool is_string_to_int8 = ASR::is_a<ASR::String_t>(*ASRUtils::extract_type(ASRUtils::expr_type(x.m_source))) &&
                                 ASRUtils::is_integer(*ASRUtils::extract_type(x.m_type)) &&
                                 ASR::down_cast<ASR::Integer_t>(ASRUtils::extract_type(x.m_type))->m_kind == 1;
        // For stringint8 with array result, skip load (assignment handles it)
        // For stringint8 with scalar result, do load (element-wise transfer case)
        bool skip_string_to_int8_load = is_string_to_int8 && ASRUtils::is_array(x.m_type);
        if ( !ASRUtils::types_equal(ASRUtils::extract_type(ASRUtils::expr_type(x.m_source)), ASRUtils::extract_type(x.m_type),
             x.m_source, const_cast<ASR::expr_t*>(&x.base), false) && !ASRUtils::is_string_only(expr_type(x.m_mold)) &&
                !skip_string_to_int8_load ) {
            tmp = llvm_utils->CreateLoad2(target_base_type, builder->CreateBitCast(source_ptr, target_llvm_type));
        }
    }

    llvm::Value* get_pointer_to_variable(ASR::expr_t* var) {
        if (llvm_symtab.find((uint64_t)var) != llvm_symtab.end()) {
            return llvm_symtab[(uint64_t)var];
        }
        this->visit_expr_wrapper(var, true);
        llvm::Value *val = tmp;
        llvm::AllocaInst *alloc = builder->CreateAlloca(val->getType(), nullptr);
        builder->CreateStore(val, alloc);
        llvm_symtab[(uint64_t)var] = alloc;
        return alloc;
    }

    void visit_Cast(const ASR::Cast_t &x) {
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return;
        }
        // Visit with appropriate load
        if (ASRUtils::is_string_only(expr_type(x.m_arg))) {
            this->visit_expr_load_wrapper(x.m_arg, 0);
        } else if(ASRUtils::is_pointer(expr_type(x.m_arg))){
            this->visit_expr_load_wrapper(x.m_arg, 2, true);
        } else {
            this->visit_expr_load_wrapper(x.m_arg, ptr_loads, true);
        }
        switch (x.m_kind) {
            case (ASR::cast_kindType::IntegerToReal) : {
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                tmp = builder->CreateSIToFP(tmp, llvm_utils->getFPType(a_kind, false));
                break;
            }
            case (ASR::cast_kindType::UnsignedIntegerToReal) : {
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                tmp = builder->CreateSIToFP(tmp, llvm_utils->getFPType(a_kind, false));
                break;
            }
            case (ASR::cast_kindType::LogicalToReal) : {
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                tmp = builder->CreateUIToFP(tmp, llvm_utils->getFPType(a_kind, false));
                break;
            }
            case (ASR::cast_kindType::RealToInteger) : {
                llvm::Type *target_type;
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                target_type = llvm_utils->getIntType(a_kind);
                tmp = builder->CreateFPToSI(tmp, target_type);
                break;
            }
            case (ASR::cast_kindType::RealToUnsignedInteger) : {
                llvm::Type *target_type;
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                target_type = llvm_utils->getIntType(a_kind);
                tmp = builder->CreateFPToSI(tmp, target_type);
                break;
            }
            case (ASR::cast_kindType::RealToComplex) : {
                llvm::Type *target_type;
                llvm::Value *zero;
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                switch(a_kind)
                {
                    case 4:
                        target_type = complex_type_4;
                        tmp = builder->CreateFPTrunc(tmp, llvm::Type::getFloatTy(context));
                        zero = llvm::ConstantFP::get(context, llvm::APFloat((float)0.0));
                        break;
                    case 8:
                        target_type = complex_type_8;
                        tmp = builder->CreateFPExt(tmp, llvm::Type::getDoubleTy(context));
                        zero = llvm::ConstantFP::get(context, llvm::APFloat(0.0));
                        break;
                    default:
                        throw CodeGenError("Only 32 and 64 bits real kinds are supported.");
                }
                tmp = complex_from_floats(tmp, zero, target_type);
                break;
            }
            case (ASR::cast_kindType::IntegerToComplex) : {
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                llvm::Type *target_type;
                llvm::Type *complex_type;
                llvm::Value *zero;
                switch(a_kind)
                {
                    case 4:
                        target_type = llvm::Type::getFloatTy(context);
                        complex_type = complex_type_4;
                        zero = llvm::ConstantFP::get(context, llvm::APFloat((float)0.0));
                        break;
                    case 8:
                        target_type = llvm::Type::getDoubleTy(context);
                        complex_type = complex_type_8;
                        zero = llvm::ConstantFP::get(context, llvm::APFloat(0.0));
                        break;
                    default:
                        throw CodeGenError("Only 32 and 64 bits real kinds are supported.");
                }
                tmp = builder->CreateSIToFP(tmp, target_type);
                tmp = complex_from_floats(tmp, zero, complex_type);
                break;
            }
            case (ASR::cast_kindType::IntegerToLogical) :
            case (ASR::cast_kindType::UnsignedIntegerToLogical) : {
                ASR::ttype_t* curr_type = extract_ttype_t_from_expr(x.m_arg);
                LCOMPILERS_ASSERT(curr_type != nullptr)
                int a_kind = ASRUtils::extract_kind_from_ttype_t(curr_type);
                switch (a_kind) {
                    case 1:
                        tmp = builder->CreateICmpNE(tmp, builder->getInt8(0));
                        break;
                    case 2:
                        tmp = builder->CreateICmpNE(tmp, builder->getInt16(0));
                        break;
                    case 4:
                        tmp = builder->CreateICmpNE(tmp, builder->getInt32(0));
                        break;
                    case 8:
                        tmp = builder->CreateICmpNE(tmp, builder->getInt64(0));
                        break;
                }
                break;
            }
            case (ASR::cast_kindType::RealToLogical) : {
                llvm::Value *zero;
                ASR::ttype_t* curr_type = extract_ttype_t_from_expr(x.m_arg);
                LCOMPILERS_ASSERT(curr_type != nullptr)
                int a_kind = ASRUtils::extract_kind_from_ttype_t(curr_type);
                if (a_kind == 4) {
                    zero = llvm::ConstantFP::get(context, llvm::APFloat((float)0.0));
                } else {
                    zero = llvm::ConstantFP::get(context, llvm::APFloat(0.0));
                }
                tmp = builder->CreateFCmpUNE(tmp, zero);
                break;
            }
            case (ASR::cast_kindType::StringToLogical) : {
                tmp = builder->CreateICmpNE(get_string_length(x.m_arg), builder->getInt32(0));
                break;
            }
            case (ASR::cast_kindType::StringToInteger) : {
                llvm::AllocaInst *parg = llvm_utils->CreateAlloca(*builder, character_type);
                builder->CreateStore(tmp, parg);
                tmp = lfortran_str_to_int(parg);
                break;
            }
            case (ASR::cast_kindType::ComplexToLogical) : {
                // !(c.real == 0.0 && c.imag == 0.0)
                llvm::Value *zero;
                ASR::ttype_t* curr_type = extract_ttype_t_from_expr(x.m_arg);
                LCOMPILERS_ASSERT(curr_type != nullptr)
                int a_kind = ASRUtils::extract_kind_from_ttype_t(curr_type);
                if (a_kind == 4) {
                    zero = llvm::ConstantFP::get(context, llvm::APFloat((float)0.0));
                } else {
                    zero = llvm::ConstantFP::get(context, llvm::APFloat(0.0));
                }
                llvm::Value *c_real = complex_re(tmp, tmp->getType());
                llvm::Value *real_check = builder->CreateFCmpUEQ(c_real, zero);
                llvm::Value *c_imag = complex_im(tmp, tmp->getType());
                llvm::Value *imag_check = builder->CreateFCmpUEQ(c_imag, zero);
                tmp = builder->CreateAnd(real_check, imag_check);
                tmp = builder->CreateNot(tmp);
                break;
            }
            case (ASR::cast_kindType::LogicalToInteger) : {
                int a_kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                tmp = builder->CreateZExt(tmp, llvm_utils->getIntType(a_kind));
                break;
            }
            case (ASR::cast_kindType::RealToReal) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                if( arg_kind > 0 && dest_kind > 0 &&
                    arg_kind != dest_kind )
                {
                    if( arg_kind == 4 && dest_kind == 8 ) {
                        tmp = builder->CreateFPExt(tmp, llvm::Type::getDoubleTy(context));
                    } else if( arg_kind == 8 && dest_kind == 4 ) {
                        tmp = builder->CreateFPTrunc(tmp, llvm::Type::getFloatTy(context));
                    } else {
                        std::string msg = "Conversion from " + std::to_string(arg_kind) +
                                          " to " + std::to_string(dest_kind) + " not implemented yet.";
                        throw CodeGenError(msg);
                    }
                }
                break;
            }
            case (ASR::cast_kindType::IntegerToInteger) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                if( arg_kind > 0 && dest_kind > 0 &&
                    arg_kind != dest_kind )
                {
                    if (dest_kind > arg_kind) {
                        tmp = builder->CreateSExt(tmp, llvm_utils->getIntType(dest_kind));
                    } else {
                        tmp = builder->CreateTrunc(tmp, llvm_utils->getIntType(dest_kind));
                    }
                }
                break;
            }
            case (ASR::cast_kindType::UnsignedIntegerToUnsignedInteger) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                if( arg_kind > 0 && dest_kind > 0 &&
                    arg_kind != dest_kind )
                {
                    if (dest_kind > arg_kind) {
                        tmp = builder->CreateZExt(tmp, llvm_utils->getIntType(dest_kind));
                    } else {
                        tmp = builder->CreateTrunc(tmp, llvm_utils->getIntType(dest_kind));
                    }
                }
                break;
            }
            case (ASR::cast_kindType::IntegerToUnsignedInteger) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                LCOMPILERS_ASSERT(arg_kind != -1 && dest_kind != -1)
                if( arg_kind > 0 && dest_kind > 0 &&
                    arg_kind != dest_kind )
                {
                    if (dest_kind > arg_kind) {
                        tmp = builder->CreateSExt(tmp, llvm_utils->getIntType(dest_kind));
                    } else {
                        tmp = builder->CreateTrunc(tmp, llvm_utils->getIntType(dest_kind));
                    }
                }
                break;
            }
            case (ASR::cast_kindType::UnsignedIntegerToInteger) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                LCOMPILERS_ASSERT(arg_kind != -1 && dest_kind != -1)
                if( arg_kind > 0 && dest_kind > 0 &&
                    arg_kind != dest_kind )
                {
                    if (dest_kind > arg_kind) {
                        tmp = builder->CreateZExt(tmp, llvm_utils->getIntType(dest_kind));
                    } else {
                        tmp = builder->CreateTrunc(tmp, llvm_utils->getIntType(dest_kind));
                    }
                }
                break;
            }
            case (ASR::cast_kindType::CPtrToUnsignedInteger) : {
                tmp = builder->CreatePtrToInt(tmp, llvm_utils->getIntType(8, false));
                break;
            }
            case (ASR::cast_kindType::UnsignedIntegerToCPtr) : {
                tmp = builder->CreateIntToPtr(tmp, llvm::Type::getVoidTy(context)->getPointerTo());
                break;
            }
            case (ASR::cast_kindType::ComplexToComplex) : {
                llvm::Type *target_type;
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                llvm::Value *re, *im;
                if( arg_kind > 0 && dest_kind > 0 &&
                    arg_kind != dest_kind )
                {
                    if( arg_kind == 4 && dest_kind == 8 ) {
                        target_type = complex_type_8;
                        re = complex_re(tmp, complex_type_4);
                        re = builder->CreateFPExt(re, llvm::Type::getDoubleTy(context));
                        im = complex_im(tmp, complex_type_4);
                        im = builder->CreateFPExt(im, llvm::Type::getDoubleTy(context));
                    } else if( arg_kind == 8 && dest_kind == 4 ) {
                        target_type = complex_type_4;
                        re = complex_re(tmp, complex_type_8);
                        re = builder->CreateFPTrunc(re, llvm::Type::getFloatTy(context));
                        im = complex_im(tmp, complex_type_8);
                        im = builder->CreateFPTrunc(im, llvm::Type::getFloatTy(context));
                    } else {
                        std::string msg = "Conversion from " + std::to_string(arg_kind) +
                                          " to " + std::to_string(dest_kind) + " not implemented yet.";
                        throw CodeGenError(msg);
                    }
                } else {
                    throw CodeGenError("Negative kinds are not supported.");
                }
                tmp = complex_from_floats(re, im, target_type);
                break;
            }
            case (ASR::cast_kindType::ComplexToReal) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                llvm::Value *re;
                if( arg_kind > 0 && dest_kind > 0)
                {
                    if( arg_kind == 4 && dest_kind == 4 ) {
                        // complex(4) -> real(4)
                        re = complex_re(tmp, complex_type_4);
                        tmp = re;
                    } else if( arg_kind == 4 && dest_kind == 8 ) {
                        // complex(4) -> real(8)
                        re = complex_re(tmp, complex_type_4);
                        tmp = builder->CreateFPExt(re, llvm::Type::getDoubleTy(context));
                    } else if( arg_kind == 8 && dest_kind == 4 ) {
                        // complex(8) -> real(4)
                        re = complex_re(tmp, complex_type_8);
                        tmp = builder->CreateFPTrunc(re, llvm::Type::getFloatTy(context));
                    } else if( arg_kind == 8 && dest_kind == 8 ) {
                        // complex(8) -> real(8)
                        re = complex_re(tmp, complex_type_8);
                        tmp = re;
                    } else {
                        std::string msg = "Conversion from " + std::to_string(arg_kind) +
                                          " to " + std::to_string(dest_kind) + " not implemented yet.";
                        throw CodeGenError(msg);
                    }
                } else {
                    throw CodeGenError("Negative kinds are not supported.");
                }
                break;
            }
            case (ASR::cast_kindType::ComplexToInteger) : {
                int arg_kind = -1, dest_kind = -1;
                extract_kinds(x, arg_kind, dest_kind);
                llvm::Value *re;
                if (arg_kind > 0 && dest_kind > 0)
                {
                    if (arg_kind == 4) {
                        // complex(4) -> real(8)
                        re = complex_re(tmp, complex_type_4);
                        tmp = re;
                    } else if (arg_kind == 8) {
                        // complex(8) -> real(8)
                        re = complex_re(tmp, complex_type_8);
                        tmp = re;
                    } else {
                        std::string msg = "Unsupported Complex type kind: " + std::to_string(arg_kind);
                        throw CodeGenError(msg);
                    }
                    llvm::Type *target_type;
                    target_type = llvm_utils->getIntType(dest_kind);
                    tmp = builder->CreateFPToSI(tmp, target_type);
                } else {
                    throw CodeGenError("Negative kinds are not supported.");
                }
                break;
             }
            case (ASR::cast_kindType::RealToString) : {
                /* Call Runtime Function `lfortran_float_to_str` */
                llvm::Value* casted_float {}; // float -> string
                { 
                    llvm::Value *arg = tmp;
                    ASR::ttype_t* arg_type = extract_ttype_t_from_expr(x.m_arg);
                    LCOMPILERS_ASSERT(arg_type != nullptr)
                    int arg_kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                    if (arg->getType()->isPointerTy()) {arg = llvm_utils->CreateLoad2(llvm_utils->getFPType(arg_kind), arg);}

                    casted_float = lfortran_type_to_str(arg, llvm_utils->getFPType(arg_kind), "float", arg_kind); // Returns i8*
                }


                /* Create A String To Hold The Runtime Function Return */
                llvm::Value* str {};
                {
                    str = llvm_utils->create_string(ASRUtils::get_string_type(x.m_type), "FloatToStringCast");
                    setup_string(str, x.m_type);
                    /*
                        Now we have an already set string matching `x.m_type`
                        (allocatable-deferred-len OR Expression-len OR allocatable-nondeferred-len)
                    */ 
                }

                /* Copy Runtime Function Return Into Our Created String*/
                {
                    llvm::Value *lhs_data, *lhs_len;
                    llvm::Value *rhs_data, *rhs_len;
                    std::tie(lhs_data, lhs_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(x.m_type), str, true, true);
                    rhs_data = casted_float;
                    llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
                    rhs_len = lfortran_str_len(type, casted_float);
                    llvm_utils->lfortran_str_copy_with_data(lhs_data, lhs_len, rhs_data, rhs_len, true, true);
                }
                
                /* Free Runtime Function Return */
                {
                    builder->CreateCall(llvm_utils->_Deallocate(), {casted_float});
                    casted_float = nullptr;
                }

                tmp = str;
                break;
            }
            case (ASR::cast_kindType::IntegerToString) : {
                /* Call Runtime Function `lfortran_int_to_str` */
                llvm::Value* casted_int {};
                { 
                    llvm::Value *arg = tmp;
                    ASR::ttype_t* arg_type = extract_ttype_t_from_expr(x.m_arg);
                    LCOMPILERS_ASSERT(arg_type != nullptr)
                    int arg_kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                    if (arg->getType()->isPointerTy()) {arg = llvm_utils->CreateLoad2(llvm_utils->getIntType(arg_kind), arg);}

                    casted_int = lfortran_type_to_str(arg, llvm_utils->getIntType(arg_kind), "int", arg_kind); // Returns i8*
                }


                /* Create A String To Hold The Runtime Function Return */
                llvm::Value* str {};
                {
                    str = llvm_utils->create_string(ASRUtils::get_string_type(x.m_type), "IntegerToStringCast");
                    setup_string(str, x.m_type);
                    /*
                        Now we have an already set string matching `x.m_type`
                        (allocatable-deferred-len OR Expression-len OR allocatable-nondeferred-len)
                    */ 
                }

                /* Copy Runtime Function Return Into Our Created String*/
                {
                    llvm::Value *lhs_data, *lhs_len;
                    llvm::Value *rhs_data, *rhs_len;
                    std::tie(lhs_data, lhs_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(x.m_type), str, true, true);
                    rhs_data = casted_int;
                    llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
                    rhs_len = lfortran_str_len(type, casted_int);
                    llvm_utils->lfortran_str_copy_with_data(lhs_data, lhs_len, rhs_data, rhs_len, true, true);
                }
                
                /* Free Runtime Function Return */
                {
                    builder->CreateCall(llvm_utils->_Deallocate(), {casted_int});
                    casted_int = nullptr;
                }

                tmp = str;
                break;
            }
            case (ASR::cast_kindType::LogicalToString) : {
                llvm::Value *cmp = builder->CreateICmpEQ(tmp, builder->getInt1(0));
                llvm::Value *zero_str = LCompilers::create_global_string_ptr(context, *module, *builder, "False");
                llvm::Value *one_str = LCompilers::create_global_string_ptr(context, *module, *builder, "True");
                tmp = builder->CreateSelect(cmp, zero_str, one_str);

                if (ASRUtils::is_allocatable(x.m_type)) {
                    llvm::Value* temp_str = builder->CreateAlloca(string_descriptor);
                    llvm_utils->set_string_memory_on_heap(
                        ASR::string_physical_typeType::DescriptorString,
                        temp_str, lfortran_str_len(string_descriptor, tmp)
                    );

                    llvm::Value *lhs_data, *lhs_len;
                    llvm::Value *rhs_data, *rhs_len;

                    std::tie(lhs_data, lhs_len) = llvm_utils->get_string_length_data(
                                                    ASR::down_cast<ASR::String_t>(ASRUtils::TYPE(ASR::make_String_t(
                                                        al, x.base.base.loc, 1, nullptr,
                                                        ASR::string_length_kindType::DeferredLength,
                                                        ASR::string_physical_typeType::DescriptorString))),
                                                    temp_str, true, true);
                    rhs_data = tmp;
                    rhs_len = lfortran_str_len(string_descriptor, tmp);

                    llvm_utils->lfortran_str_copy_with_data(lhs_data, lhs_len, rhs_data, rhs_len, true, true);
                    tmp = temp_str;
                }
                break;
            }
            case (ASR::cast_kindType::ListToArray) : {
                if( !ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(x.m_arg)) ) {
                    throw CodeGenError("The argument of ListToArray cast should "
                        "be a list/std::vector, found, " + ASRUtils::type_to_str_fortran_expr(
                            ASRUtils::expr_type(x.m_arg), x.m_arg));
                }
                int64_t ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr(*x.m_arg);
                ptr_loads = ptr_loads_copy;
                llvm::Type* list_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_arg, ASRUtils::expr_type(x.m_arg), module.get());
                tmp = llvm_utils->CreateLoad2(list_llvm_type, list_api->get_pointer_to_list_data_using_type(list_llvm_type, tmp));
                break;
            }
            case (ASR::cast_kindType::PointerToInteger): {
                llvm::Value *ptr = nullptr;
                if (ASR::is_a<ASR::Var_t>(*x.m_arg)) {
                    ptr = get_pointer_to_variable(x.m_arg);
                } else {
                    this->visit_expr(*x.m_arg);
                    llvm::Value *val = tmp;
                    llvm::AllocaInst *alloc = builder->CreateAlloca(val->getType(), nullptr);
                    builder->CreateStore(val, alloc);
                    ptr = alloc;
                }
                tmp = builder->CreatePtrToInt(ptr, llvm::Type::getInt64Ty(context));
                break;
            }
            case (ASR::cast_kindType::ClassToStruct): {
                ASR::symbol_t* struct_sym = nullptr;
                if (x.m_dest) {
                    struct_sym = ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(x.m_dest));
                }
                this->visit_expr_load_wrapper(x.m_arg, 0);
                ASR::expr_t* dest_arg = x.m_dest ? x.m_dest : const_cast<ASR::expr_t*>(&x.base);
                tmp = convert_class_to_type(x.m_arg, dest_arg, x.m_type, tmp);
                if (struct_sym) {
                    current_der_type_name = ASRUtils::symbol_name(struct_sym);
                }
                break;
            }
            case (ASR::cast_kindType::ClassToClass): {
                ASR::symbol_t* struct_sym = nullptr;
                if (x.m_dest) {
                    struct_sym = ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(x.m_dest));
                }
                this->visit_expr_load_wrapper(x.m_arg, 0);
                tmp = convert_class_to_class(x.m_arg, tmp, x.m_type, struct_sym);
                if (struct_sym) {
                    current_der_type_name = ASRUtils::symbol_name(struct_sym);
                }
                break;
            }
            case (ASR::cast_kindType::ClassToIntrinsic): {
                // Cast from class(*) to an intrinsic type (integer, real, complex, etc.)
                ASR::ttype_t* arg_type = ASRUtils::expr_type(x.m_arg);
                ASR::ttype_t* target_type = x.m_type;

                if (ASRUtils::is_array(arg_type) &&
                        ASRUtils::extract_physical_type(arg_type) == ASR::DescriptorArray) {
                    // Array case: delegate to convert_class_to_type
                    this->visit_expr_load_wrapper(x.m_arg, 0);
                    ASR::expr_t* dest_arg = const_cast<ASR::expr_t*>(&x.base);
                    tmp = convert_class_to_type(x.m_arg, dest_arg, target_type, tmp);
                } else {
                    // Scalar case: extract intrinsic value from polymorphic wrapper
                    this->visit_expr_load_wrapper(x.m_arg, 0);
                    llvm::Value* poly_ptr = tmp;
                    llvm::Type* poly_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_arg, ASRUtils::extract_type(arg_type), module.get());
                    llvm::Type* target_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                        const_cast<ASR::expr_t*>(&x.base),
                        ASRUtils::extract_type(target_type), module.get());
                    // Handle pointer/allocatable types (extra indirection level)
                    if (LLVM::is_llvm_pointer(*arg_type)) {
                        poly_ptr = llvm_utils->CreateLoad2(poly_llvm_type->getPointerTo(), poly_ptr);
                    }
                    // GEP to data pointer field (index 1 in polymorphic struct)
                    poly_ptr = llvm_utils->create_gep2(poly_llvm_type, poly_ptr, 1);
                    // Load the i8* data pointer
                    poly_ptr = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, poly_ptr);
                    // BitCast to target type pointer
                    poly_ptr = builder->CreateBitCast(poly_ptr, target_llvm_type->getPointerTo());
                    // Load the value if ptr_loads > 0 (caller wants value, not pointer)
                    // For ptr_loads == 0 (e.g., character passed to function), return pointer
                    if (ptr_loads > 0) {
                        tmp = llvm_utils->CreateLoad2(target_llvm_type, poly_ptr);
                    } else {
                        tmp = poly_ptr;
                    }
                }
                break;
            }
            case ASR::StringToArray :
                cast_string_to_array(&x);
            break;
            default : throw CodeGenError("Cast kind not implemented");
        }
    }

    void cast_string_to_array(const ASR::Cast_t* const cast){
        LCOMPILERS_ASSERT(cast->m_kind == ASR::StringToArray)
        LCOMPILERS_ASSERT(ASRUtils::is_array_of_strings(cast->m_type))

        visit_expr_load_wrapper(cast->m_arg, 0);
        llvm::Value* const string_llvm = tmp;
        tmp = nullptr; 

        ASR::Array_t* const array_ty = ASR::down_cast<ASR::Array_t>(ASRUtils::type_get_past_allocatable_pointer(cast->m_type));
        llvm::Type* const array_llvm_ty = llvm_utils->get_type_from_ttype_t_util(nullptr, cast->m_type, module.get());

        switch(array_ty->m_physical_type){
            case ASR::StringArraySinglePointer:
                tmp = llvm_utils->get_string_data(ASRUtils::get_string_type(cast->m_arg), string_llvm);
            break;
            case ASR::UnboundedPointerArray:
            case ASR::PointerArray:
                // Note: Under new_classes, unlimited polymorphic variables inside
                // select type blocks are either Cast-wrapped (ClassToIntrinsic) or
                // type-rewritten, so is_unlimited_polymorphic_type is always false.
                // The else branch is kept for the !new_classes legacy path.
                if (!ASRUtils::is_unlimited_polymorphic_type(cast->m_arg)) {
                    LCOMPILERS_ASSERT(ASRUtils::is_character_phsyical_types_matched(
                              ASRUtils::extract_type(expr_type(cast->m_arg))
                            , ASRUtils::extract_type(cast->m_type)))
                    tmp = string_llvm;
                } else {
                    tmp = string_llvm;
                }
            break;
            case ASR::DescriptorArray:{
                llvm::Value* const array_llvm = builder->CreateAlloca(array_llvm_ty);
                LCOMPILERS_ASSERT_MSG(array_ty->n_dims, "Array in StringToArray is expected to have dimensions")
                fill_array_details(array_llvm_ty, array_llvm 
                    , llvm_utils->get_StringType(array_ty->m_type)
                    , array_ty->m_dims, array_ty->n_dims);
                builder->CreateStore(string_llvm, arr_descr->get_pointer_to_data(array_llvm_ty, array_llvm));
                tmp = array_llvm;
            }
            break;
            case ASR::FixedSizeArray:
                throw LCompilersException("StringToArray Cast : Array of strings can't be of physicalType 'FixedSizeArray`");
            default:
                throw CodeGenError("StringToArray Cast : Casting to array physical type not implemented. Enum : "
                                    + std::to_string(array_ty->m_physical_type));
        }
    }

    std::string get_namelist_var_name(ASR::symbol_t *var_sym, ASR::Variable_t *var) {
        std::string var_name = std::string(var->m_name);
        if (ASR::is_a<ASR::ExternalSymbol_t>(*var_sym)) {
            ASR::ExternalSymbol_t* ext = ASR::down_cast<ASR::ExternalSymbol_t>(var_sym);
            if (ext->m_original_name) {
                var_name = ext->m_original_name;
            }
        }
        return LCompilers::to_lower(var_name);
    }

    // Helper to build namelist descriptor and call runtime function
    llvm::Value* build_namelist_descriptor(ASR::symbol_t* nml_sym) {
        // Unwrap external symbol if needed
        nml_sym = ASRUtils::symbol_get_past_external(nml_sym);
        ASR::Namelist_t* nml = ASR::down_cast<ASR::Namelist_t>(nml_sym);

        // Get group name (lowercase)
        std::string group_name = std::string(nml->m_group_name);
        std::transform(group_name.begin(), group_name.end(), group_name.begin(), ::tolower);

        // Create global constant for group name
        llvm::Value* group_name_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, group_name);

        // Build array of lfortran_nml_item_t structures
        std::vector<llvm::Value*> nml_items;

        // Define item struct type
        llvm::StructType* item_type = llvm::StructType::get(
            character_type,                               // name
            llvm::Type::getInt32Ty(context),             // type
            llvm::Type::getInt32Ty(context),             // rank
            llvm::Type::getInt64Ty(context),             // elem_len
            llvm::Type::getInt8Ty(context)->getPointerTo(), // data
            llvm::Type::getInt64Ty(context)->getPointerTo()  // shape
        );

        std::function<void(const std::string&, ASR::ttype_t*, llvm::Value*, ASR::symbol_t*)> add_namelist_item;
        std::function<void(const std::string&, ASR::Struct_t*, llvm::Value*)> add_struct_members;

        add_struct_members = [&](const std::string &prefix, ASR::Struct_t* struct_sym,
                                 llvm::Value* struct_ptr) {
            ASR::Struct_t* current_struct = struct_sym;
            llvm::Value* current_ptr = struct_ptr;
            while (current_struct) {
                std::string struct_name = current_struct->m_name;
                llvm::StructType* llvm_struct_type = name2dertype[struct_name];
                if (current_ptr->getType() != llvm_struct_type->getPointerTo()) {
                    current_ptr = builder->CreateBitCast(current_ptr, llvm_struct_type->getPointerTo());
                }

                for (auto item: current_struct->m_symtab->get_scope()) {
                    if (name2memidx[struct_name].find(item.first) == name2memidx[struct_name].end()) {
                        continue;
                    }
                    ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(item.second);
                    if (ASR::is_a<ASR::StructMethodDeclaration_t>(*sym) ||
                        ASR::is_a<ASR::GenericProcedure_t>(*sym) ||
                        ASR::is_a<ASR::Union_t>(*sym) ||
                        ASR::is_a<ASR::Struct_t>(*sym) ||
                        ASR::is_a<ASR::CustomOperator_t>(*sym)) {
                        continue;
                    }
                    if (!ASR::is_a<ASR::Variable_t>(*sym)) {
                        continue;
                    }
                    ASR::Variable_t* member_var = ASR::down_cast<ASR::Variable_t>(sym);
                    std::string member_name = LCompilers::to_lower(member_var->m_name);
                    int member_idx = name2memidx[struct_name][member_var->m_name];
                    llvm::Value* member_ptr = llvm_utils->create_gep2(llvm_struct_type, current_ptr, member_idx);
                    add_namelist_item(prefix + "%" + member_name, member_var->m_type, member_ptr,
                                      member_var->m_type_declaration);
                }

                if (!current_struct->m_parent) {
                    break;
                }
                current_ptr = llvm_utils->create_gep2(llvm_struct_type, current_ptr, 0);
                current_struct = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(current_struct->m_parent));
            }
        };

        add_namelist_item = [&](const std::string &item_name, ASR::ttype_t* item_type_asr,
                                llvm::Value* data_ptr, ASR::symbol_t* type_decl_sym) {
            // Determine type code
            ASR::ttype_t* var_type = ASRUtils::type_get_past_allocatable_pointer(item_type_asr);
            // For arrays, get the element type
            ASR::ttype_t* elem_type = ASRUtils::type_get_past_array(var_type);

            if (ASR::is_a<ASR::StructType_t>(*elem_type)) {
                if (ASRUtils::is_array(item_type_asr)) {
                    throw CodeGenError("Namelist arrays of derived types are not supported yet");
                }
                if (!type_decl_sym) {
                    throw CodeGenError("Namelist derived type is missing its declaration");
                }
                ASR::Struct_t* struct_sym = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(type_decl_sym));
                add_struct_members(LCompilers::to_lower(item_name), struct_sym, data_ptr);
                return;
            }

            int32_t type_code = -1;
            llvm::Value* elem_len_val = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
            llvm::Value* str_desc_ptr = nullptr;

            if (ASR::is_a<ASR::Integer_t>(*elem_type)) {
                int kind = ASRUtils::extract_kind_from_ttype_t(elem_type);
                if (kind == 1) type_code = 0; // LFORTRAN_NML_INT1
                else if (kind == 2) type_code = 1; // LFORTRAN_NML_INT2
                else if (kind == 4) type_code = 2; // LFORTRAN_NML_INT4
                else if (kind == 8) type_code = 3; // LFORTRAN_NML_INT8
            } else if (ASR::is_a<ASR::Real_t>(*elem_type)) {
                int kind = ASRUtils::extract_kind_from_ttype_t(elem_type);
                if (kind == 4) type_code = 4; // LFORTRAN_NML_REAL4
                else if (kind == 8) type_code = 5; // LFORTRAN_NML_REAL8
            } else if (ASR::is_a<ASR::Logical_t>(*elem_type)) {
                // For logicals, we'll determine the type code from the LLVM type
                type_code = -2; // Marker to set it later
            } else if (ASR::is_a<ASR::Complex_t>(*elem_type)) {
                int kind = ASRUtils::extract_kind_from_ttype_t(elem_type);
                if (kind == 4) type_code = 10; // LFORTRAN_NML_COMPLEX4
                else if (kind == 8) type_code = 11; // LFORTRAN_NML_COMPLEX8
            } else if (ASR::is_a<ASR::String_t>(*elem_type)) {
                type_code = 12; // LFORTRAN_NML_CHAR
                ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(elem_type);
                int len_val = 0;
                if (ASRUtils::extract_value(str_type->m_len, len_val)) {
                    elem_len_val = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), len_val);
                } else {
                    // Save the string descriptor pointer to extract length later
                    str_desc_ptr = data_ptr;
                }
            }

            // Get rank and shape
            int32_t rank = 0;
            llvm::Value* shape_ptr = llvm::ConstantPointerNull::get(llvm::Type::getInt64Ty(context)->getPointerTo());

            if (ASRUtils::is_array(item_type_asr)) {
                ASR::dimension_t* dims = nullptr;
                size_t n_dims = ASRUtils::extract_dimensions_from_ttype(item_type_asr, dims);
                rank = (int32_t)n_dims;

                if (rank > 0) {
                    // Check if this is a descriptor array (allocatable/pointer)
                    if (ASRUtils::extract_physical_type(item_type_asr) != ASR::array_physical_typeType::DescriptorArray) {
                        // Build compile-time constant shape array for fixed-size arrays
                        std::vector<llvm::Constant*> shape_vals;
                        for (size_t d = 0; d < n_dims; d++) {
                            if (dims[d].m_length) {
                                this->visit_expr(*dims[d].m_length);
                                llvm::Value* dim_len = tmp;
                                if (llvm::isa<llvm::Constant>(dim_len)) {
                                    llvm::Constant* dim_len_const = llvm::cast<llvm::Constant>(dim_len);
                                    // For integer constants, extract the value and create a new i64 constant
                                    // This avoids ConstantExpr issues in LLVM > 15
                                    if (llvm::isa<llvm::ConstantInt>(dim_len_const)) {
                                        llvm::ConstantInt* ci = llvm::cast<llvm::ConstantInt>(dim_len_const);
                                        int64_t val = ci->getSExtValue();
                                        dim_len_const = llvm::ConstantInt::get(context, llvm::APInt(64, val, true));
                                    } else if (dim_len_const->getType() != llvm::Type::getInt64Ty(context)) {
                                        if (!llvm::isa<llvm::IntegerType>(dim_len_const->getType())) {
                                            throw CodeGenError("Namelist array dimension must be an integer constant");
                                        }
                                        llvm::IntegerType* src_ty = llvm::cast<llvm::IntegerType>(dim_len_const->getType());
                                        unsigned src_bits = src_ty->getBitWidth();
                                        if (src_bits < 64) {
                                            dim_len_const = llvm::ConstantExpr::getCast(
                                                llvm::Instruction::SExt, dim_len_const,
                                                llvm::Type::getInt64Ty(context));
                                        } else if (src_bits > 64) {
                                            dim_len_const = llvm::ConstantExpr::getCast(
                                                llvm::Instruction::Trunc, dim_len_const,
                                                llvm::Type::getInt64Ty(context));
                                        }
                                    }
                                    shape_vals.push_back(dim_len_const);
                                } else {
                                    // Non-constant dimension - not supported in initial version
                                    throw CodeGenError("Namelist with non-constant array dimensions not yet supported");
                                }
                            } else {
                                throw CodeGenError("Namelist array must have explicit dimensions");
                            }
                        }

                        llvm::ArrayType* shape_arr_type = llvm::ArrayType::get(llvm::Type::getInt64Ty(context), n_dims);
                        llvm::Constant* shape_arr = llvm::ConstantArray::get(shape_arr_type, shape_vals);
                        std::string shape_name = "nml_shape_" + item_name;
                        std::replace(shape_name.begin(), shape_name.end(), '%', '_');
                        llvm::GlobalVariable* shape_global = new llvm::GlobalVariable(
                            *module, shape_arr_type, true, llvm::GlobalValue::PrivateLinkage,
                            shape_arr, shape_name);
                        shape_ptr = builder->CreateBitCast(shape_global, llvm::Type::getInt64Ty(context)->getPointerTo());
                    }
                    // For descriptor arrays, shape_ptr will be filled later after getting data_ptr
                }
            }

            if (type_code == -2) {
                llvm::Type* llvm_type = llvm_utils->get_type_from_ttype_t_util(nullptr, elem_type, module.get());
                if (llvm::isa<llvm::IntegerType>(llvm_type)) {
                    unsigned bit_width = llvm::cast<llvm::IntegerType>(llvm_type)->getBitWidth();
                    unsigned byte_size = (bit_width + 7) / 8; // Round up to nearest byte
                    if (byte_size == 1) type_code = 6; // LFORTRAN_NML_LOGICAL1
                    else if (byte_size == 2) type_code = 7; // LFORTRAN_NML_LOGICAL2
                    else if (byte_size == 4) type_code = 8; // LFORTRAN_NML_LOGICAL4
                    else if (byte_size == 8) type_code = 9; // LFORTRAN_NML_LOGICAL8
                } else {
                    throw CodeGenError("Unsupported logical LLVM type for namelist");
                }
            }

            // For strings, we need to extract the data pointer from the descriptor
            if (ASR::is_a<ASR::String_t>(*var_type)) {
                ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(var_type);
                llvm::Type* string_desc_type = llvm_utils->get_type_from_ttype_t_util(nullptr, var_type, module.get());
                // Extract the length from the string descriptor for deferred-length strings
                if (str_desc_ptr != nullptr) {
                    elem_len_val = llvm_utils->get_string_length(str_type, str_desc_ptr);
                }
                llvm::Value* str_data_ptr_ptr = llvm_utils->create_gep2(string_desc_type, data_ptr, 0);
                data_ptr = llvm_utils->CreateLoad2(character_type, str_data_ptr_ptr);
            }

            // For arrays, get the data pointer and extract dimensions for descriptor arrays
            if (ASRUtils::is_array(item_type_asr)) {
                ASR::ttype_t* past_alloc = ASRUtils::type_get_past_allocatable_pointer(item_type_asr);
                if (ASR::is_a<ASR::Array_t>(*past_alloc)) {
                    ASR::Array_t* arr_t = ASR::down_cast<ASR::Array_t>(past_alloc);
                    if (arr_t->m_physical_type == ASR::array_physical_typeType::DescriptorArray) {
                        // Get array type for descriptor operations
                        llvm::Type* arr_type = llvm_utils->get_type_from_ttype_t_util(nullptr, past_alloc, module.get());
                        // Get element type for loading data pointer
                        llvm::Type* llvm_elem_type = llvm_utils->get_type_from_ttype_t_util(nullptr, elem_type, module.get());
                        llvm::Value* arr_desc_loaded = llvm_utils->get_array_descriptor_ptr(
                            data_ptr, arr_type, ASRUtils::is_character(*item_type_asr));

                        // For descriptor arrays, extract dimensions at runtime if needed
                        if (rank > 0) {
                            ASR::dimension_t* dims = nullptr;
                            size_t n_dims = ASRUtils::extract_dimensions_from_ttype(item_type_asr, dims);
                            // Allocate array to store runtime dimensions
                            llvm::ArrayType* shape_arr_type = llvm::ArrayType::get(llvm::Type::getInt64Ty(context), n_dims);
                            llvm::Value* shape_arr = llvm_utils->CreateAlloca(*builder, shape_arr_type);

                            for (size_t d = 0; d < n_dims; d++) {
                                llvm::Value* dim_idx = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), d + 1); // 1-based
                                llvm::Value* dim_size = arr_descr->get_array_size(arr_type, arr_desc_loaded, dim_idx, 8, 4);
                                // Store in shape array
                                llvm::Value* shape_elem_ptr = builder->CreateConstGEP2_32(shape_arr_type, shape_arr, 0, d);
                                builder->CreateStore(dim_size, shape_elem_ptr);
                            }
                            // Get pointer to first element
                            shape_ptr = builder->CreateConstGEP2_32(shape_arr_type, shape_arr, 0, 0);
                        }

                        // Get data pointer from array descriptor
                        // Get pointer to data field, then load the data pointer
                        llvm::Value* data_ptr_field = arr_descr->get_pointer_to_data(arr_type, arr_desc_loaded);
                        if (ASR::is_a<ASR::String_t>(*elem_type)) {
                            ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(elem_type);
                            llvm::Value* str_desc = llvm_utils->CreateLoad2(
                                llvm_utils->get_StringType(elem_type)->getPointerTo(), data_ptr_field);
                            data_ptr = llvm_utils->get_string_data(str_type, str_desc);
                        } else {
                            data_ptr = llvm_utils->CreateLoad2(llvm_elem_type->getPointerTo(), data_ptr_field);
                        }
                    } else if (arr_t->m_physical_type == ASR::array_physical_typeType::FixedSizeArray) {
                        // For FixedSizeArray, data_ptr points to [N x Type]*, we need Type*
                        // Use GEP with indices [0, 0] to get pointer to first element
                        llvm::Type* arr_type = llvm_utils->get_type_from_ttype_t_util(nullptr, past_alloc, module.get());
                        data_ptr = builder->CreateConstGEP2_32(arr_type, data_ptr, 0, 0);
                    } else if (arr_t->m_physical_type == ASR::array_physical_typeType::PointerArray) {
                        if (ASRUtils::is_array_of_strings(item_type_asr)) {
                            data_ptr = llvm_utils->get_stringArray_data(item_type_asr, data_ptr);
                        }
                    }
                }
            }

            data_ptr = builder->CreateBitCast(data_ptr, llvm::Type::getInt8Ty(context)->getPointerTo());

            // Create lfortran_nml_item_t struct
            llvm::Value* item = llvm_utils->CreateAlloca(*builder, item_type);
            llvm::Value* item_name_ptr = LCompilers::create_global_string_ptr(
                context, *module, *builder, LCompilers::to_lower(item_name));
            builder->CreateStore(item_name_ptr, builder->CreateStructGEP(item_type, item, 0));
            builder->CreateStore(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), type_code),
                                 builder->CreateStructGEP(item_type, item, 1));
            builder->CreateStore(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), rank),
                                 builder->CreateStructGEP(item_type, item, 2));
            builder->CreateStore(elem_len_val,
                                 builder->CreateStructGEP(item_type, item, 3));
            builder->CreateStore(data_ptr, builder->CreateStructGEP(item_type, item, 4));
            builder->CreateStore(shape_ptr, builder->CreateStructGEP(item_type, item, 5));

            nml_items.push_back(item);
        };

        for (size_t i = 0; i < nml->n_var_list; i++) {
            ASR::symbol_t* var_sym = nml->m_var_list[i];
            ASR::symbol_t* var_sym_past = ASRUtils::symbol_get_past_external(var_sym);
            ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(var_sym_past);

            // Get variable name (lowercase)
            std::string var_name = get_namelist_var_name(var_sym, var);

            uint32_t var_hash = get_hash((ASR::asr_t*)var);
            llvm::Value* data_ptr = llvm_symtab[var_hash];
            if (!data_ptr) {
                throw CodeGenError("Variable " + var_name + " not found in symbol table");
            }

            add_namelist_item(var_name, var->m_type, data_ptr, var->m_type_declaration);
        }

        // Create items array
        llvm::ArrayType* items_array_type = llvm::ArrayType::get(item_type, nml_items.size());
        llvm::Value* items_array = llvm_utils->CreateAlloca(*builder, items_array_type);

        // Copy items into array
        for (size_t i = 0; i < nml_items.size(); i++) {
            llvm::Value* dest_ptr = builder->CreateConstGEP2_32(items_array_type, items_array, 0, i);
            llvm::Value* src_item = builder->CreateLoad(item_type, nml_items[i]);
            builder->CreateStore(src_item, dest_ptr);
        }

        // Get pointer to first element of items array
        llvm::Value* items_ptr = builder->CreateConstGEP2_32(items_array_type, items_array, 0, 0);

        // Create lfortran_nml_group_t struct
        // struct { const char *group_name, int32_t n_items, lfortran_nml_item_t *items }
        llvm::StructType* group_type = llvm::StructType::get(
            character_type,                           // group_name
            llvm::Type::getInt32Ty(context),         // n_items
            item_type->getPointerTo()                // items
        );

        llvm::Value* group = llvm_utils->CreateAlloca(*builder, group_type);
        builder->CreateStore(group_name_ptr, builder->CreateStructGEP(group_type, group, 0));
        builder->CreateStore(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), nml_items.size()),
                           builder->CreateStructGEP(group_type, group, 1));
        builder->CreateStore(items_ptr, builder->CreateStructGEP(group_type, group, 2));

        return group;
    }

    // All read functions now have a unified signature with iostat as the last parameter.
    // Pass NULL for iostat when not needed (will exit on error), or a valid pointer
    // (will set iostat and return on error).
    llvm::Function* get_read_function(ASR::ttype_t *type) {
        type = ASRUtils::type_get_past_allocatable(
            ASRUtils::type_get_past_pointer(type));
        llvm::Function *fn = nullptr;
        switch (type->type) {
            case (ASR::ttypeType::Integer): {
                std::string runtime_func_name;
                llvm::Type *type_arg;
                int a_kind = ASRUtils::extract_kind_from_ttype_t(type);
                if ( a_kind == 2 ) {
                    runtime_func_name = "_lfortran_read_int16";
                    type_arg = llvm::Type::getInt16Ty(context);
                } else if (a_kind == 4) {
                    runtime_func_name = "_lfortran_read_int32";
                    type_arg = llvm::Type::getInt32Ty(context);
                } else if (a_kind == 8) {
                    runtime_func_name = "_lfortran_read_int64";
                    type_arg = llvm::Type::getInt64Ty(context);
                } else {
                    throw CodeGenError("Read Integer function not implemented "
                        "for integer kind: " + std::to_string(a_kind));
                }
                fn = module->getFunction(runtime_func_name);
                if (!fn) {
                    std::vector<llvm::Type*> args{
                        type_arg->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context)->getPointerTo()
                    };
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                            llvm::Type::getVoidTy(context), args, false);
                    fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                }
                break;
            }
            case (ASR::ttypeType::String): {
                std::string runtime_func_name = "_lfortran_read_char";
                fn = module->getFunction(runtime_func_name);
                if (!fn) {
                    std::vector<llvm::Type*> args{
                        character_type->getPointerTo(), // Str_data
                        llvm::Type::getInt64Ty(context), // Str_len
                        llvm::Type::getInt32Ty(context), // Unit_num
                        llvm::Type::getInt32Ty(context)->getPointerTo() // iostat
                    };
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                            llvm::Type::getVoidTy(context), args, false);
                    fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                }
                break;
            }

            case (ASR::ttypeType::Logical):{
                // All logical kinds use the same runtime function - it reads T/F
                // into a bool. The LLVM type is i1 regardless of Fortran kind.
                std::string runtime_func_name = "_lfortran_read_logical";
                llvm::Type *type_arg = llvm::Type::getInt1Ty(context);

                fn = module->getFunction(runtime_func_name);
                if (!fn) {
                    std::vector<llvm::Type*> args{
                        type_arg->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context)->getPointerTo()
                    };
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                            llvm::Type::getVoidTy(context), args, false);
                    fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                }
                break;
            }
            case (ASR::ttypeType::Real): {
                std::string runtime_func_name;
                llvm::Type *type_arg;
                int a_kind = ASRUtils::extract_kind_from_ttype_t(type);
                if (a_kind == 4) {
                    runtime_func_name = "_lfortran_read_float";
                    type_arg = llvm::Type::getFloatTy(context);
                } else {
                    runtime_func_name = "_lfortran_read_double";
                    type_arg = llvm::Type::getDoubleTy(context);
                }
                fn = module->getFunction(runtime_func_name);
                if (!fn) {
                    std::vector<llvm::Type*> args{
                        type_arg->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context)->getPointerTo()
                    };
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                            llvm::Type::getVoidTy(context), args, false);
                    fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                }
                break;
            }
            case (ASR::ttypeType::Complex): {
                std::string runtime_func_name;
                llvm::Type *type_arg;
                int a_kind = ASRUtils::extract_kind_from_ttype_t(type);
                if (a_kind == 4) {
                    runtime_func_name = "_lfortran_read_complex_float";
                    type_arg = complex_type_4;
                } else if (a_kind == 8) {
                    runtime_func_name = "_lfortran_read_complex_double";
                    type_arg = complex_type_8;
                } else {
                    throw CodeGenError("Read Complex function not implemented "
                        "for complex kind: " + std::to_string(a_kind));
                }
                fn = module->getFunction(runtime_func_name);
                if (!fn) {
                    std::vector<llvm::Type*> args{
                        type_arg->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context)->getPointerTo()
                    };
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                            llvm::Type::getVoidTy(context), args, false);
                    fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                }
                break;
            }
            case (ASR::ttypeType::Array): {
                type = ASRUtils::type_get_past_array(type);
                int a_kind = ASRUtils::extract_kind_from_ttype_t(type);
                std::string runtime_func_name;
                llvm::Type *type_arg;
                if (ASR::is_a<ASR::Integer_t>(*type)) {
                    if (a_kind == 1) {
                        runtime_func_name = "_lfortran_read_array_int8";
                        type_arg = llvm::Type::getInt8Ty(context);
                    } else if ( a_kind == 2) {
                        runtime_func_name = "_lfortran_read_array_int16";
                        type_arg = llvm::Type::getInt16Ty(context);
                    } else if (a_kind == 4) {
                        runtime_func_name = "_lfortran_read_array_int32";
                        type_arg = llvm::Type::getInt32Ty(context);
                    } else if (a_kind == 8) {
                        runtime_func_name = "_lfortran_read_array_int64";
                        type_arg = llvm::Type::getInt64Ty(context);
                    } else {
                        throw CodeGenError("Integer arrays of kind 1 or 4 only supported for now. Found kind: "
                                            + std::to_string(a_kind));
                    }
                } else if (ASR::is_a<ASR::Real_t>(*type)) {
                    if (a_kind == 4) {
                        runtime_func_name = "_lfortran_read_array_float";
                        type_arg = llvm::Type::getFloatTy(context);
                    } else if (a_kind == 8) {
                        runtime_func_name = "_lfortran_read_array_double";
                        type_arg = llvm::Type::getDoubleTy(context);
                    } else {
                        throw CodeGenError("Real arrays of kind 4 or 8 only supported for now. Found kind: "
                                            + std::to_string(a_kind));
                    }
                } else if (ASR::is_a<ASR::Complex_t>(*type)) {
                    if ( a_kind == 4 ) {
                        runtime_func_name = "_lfortran_read_array_complex_float";
                        type_arg = complex_type_4;
                    } else if ( a_kind == 8 ) {
                        runtime_func_name = "_lfortran_read_array_complex_double";
                        type_arg = complex_type_8;
                    } else {
                        throw CodeGenError("Complex arrays of kind 4 or 8 only supported for now. Found kind: "
                                            + std::to_string(a_kind));
                    }
                } else if (ASR::is_a<ASR::String_t>(*type)) {
                    runtime_func_name = "_lfortran_read_array_char";
                    type_arg = llvm::Type::getInt8Ty(context);
                } else if (ASR::is_a<ASR::Logical_t>(*type)) {
                    runtime_func_name = "_lfortran_read_array_logical";
                    type_arg = llvm::Type::getInt8Ty(context);
                } else {
                    throw CodeGenError("Type not supported.");
                }
                fn = module->getFunction(runtime_func_name);
                if (!fn) {
                    std::vector<llvm::Type*> types {
                        type_arg->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt32Ty(context)->getPointerTo()};
                    if(runtime_func_name == "_lfortran_read_array_char"){
                        types.insert(types.begin()+1, llvm::Type::getInt64Ty(context));
                    }
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), types, false);
                    fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                }
                break;
            }
            default: {
                std::string s_type = ASRUtils::type_to_str_fortran_expr(type, nullptr);
                throw CodeGenError("Read function not implemented for: " + s_type);
            }
        }
        return fn;
    }

    void generate_read_implied_do_loop(ASR::ImpliedDoLoop_t* idl,
            llvm::Value* unit_val, llvm::Value* iostat) {
        ASR::Variable_t* loop_var_sym = ASR::down_cast<ASR::Variable_t>(
            ASR::down_cast<ASR::Var_t>(idl->m_var)->m_v);

        this->visit_expr_wrapper(idl->m_start, true);
        llvm::Value* start_val = tmp;
        this->visit_expr_wrapper(idl->m_end, true);
        llvm::Value* end_val = tmp;
        llvm::Value* inc_val;
        if (idl->m_increment) {
            this->visit_expr_wrapper(idl->m_increment, true);
            inc_val = tmp;
        } else {
            inc_val = llvm::ConstantInt::get(start_val->getType(), 1);
        }

        uint32_t loop_var_hash = get_hash((ASR::asr_t*)loop_var_sym);
        llvm::Value* loop_var_ptr;
        if (llvm_symtab.find(loop_var_hash) == llvm_symtab.end()) {
            loop_var_ptr = builder->CreateAlloca(start_val->getType(), nullptr,
                loop_var_sym->m_name);
            llvm_symtab[loop_var_hash] = loop_var_ptr;
        } else {
            loop_var_ptr = llvm_symtab[loop_var_hash];
        }

        builder->CreateStore(start_val, loop_var_ptr);
        llvm::Function* fn = builder->GetInsertBlock()->getParent();
        llvm::BasicBlock* loop_cond = llvm::BasicBlock::Create(context, "idl.cond", fn);
        llvm::BasicBlock* loop_body = llvm::BasicBlock::Create(context, "idl.body", fn);
        llvm::BasicBlock* loop_inc = llvm::BasicBlock::Create(context, "idl.inc", fn);
        llvm::BasicBlock* loop_end = llvm::BasicBlock::Create(context, "idl.end", fn);

        builder->CreateBr(loop_cond);
        builder->SetInsertPoint(loop_cond);
        llvm::Value* curr_val = builder->CreateLoad(start_val->getType(), loop_var_ptr);
        llvm::Value* cond = builder->CreateICmpSLE(curr_val, end_val);
        builder->CreateCondBr(cond, loop_body, loop_end);
        builder->SetInsertPoint(loop_body);

        if (idl->n_values == 1 && ASR::is_a<ASR::ImpliedDoLoop_t>(*idl->m_values[0])) {
            ASR::ImpliedDoLoop_t* inner_idl = ASR::down_cast<ASR::ImpliedDoLoop_t>(idl->m_values[0]);
            generate_read_implied_do_loop(inner_idl, unit_val, iostat);
        } else {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr(*idl->m_values[0]);
            llvm::Value* elem_ptr = tmp;
            ptr_loads = ptr_loads_copy;

            ASR::ttype_t* elem_type = ASRUtils::expr_type(idl->m_values[0]);
            llvm::Function* read_fn = get_read_function(elem_type);
            llvm::Value* read_elem_ptr = elem_ptr;
            llvm::Type* expected_param_type = read_fn->getFunctionType()->getParamType(0);
            if (read_elem_ptr->getType() != expected_param_type) {
                read_elem_ptr = builder->CreateBitCast(read_elem_ptr, expected_param_type);
            }
            builder->CreateCall(read_fn, {read_elem_ptr, unit_val, iostat});
        }

        builder->CreateBr(loop_inc);
        builder->SetInsertPoint(loop_inc);
        llvm::Value* next_val = builder->CreateAdd(
            builder->CreateLoad(start_val->getType(), loop_var_ptr), inc_val);
        builder->CreateStore(next_val, loop_var_ptr);
        builder->CreateBr(loop_cond);
        builder->SetInsertPoint(loop_end);
    }

    void visit_FileRead(const ASR::FileRead_t &x) {
        if( x.m_overloaded ) {
            this->visit_stmt(*x.m_overloaded);
            return ;
        }

        // Handle namelist read
        if (x.m_nml) {
            llvm::Value *unit_val, *iostat;
            bool is_string = false;
            bool is_string_array = false;

            if (x.m_unit == nullptr) {
                unit_val = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, -1, true));
            } else {
                ASR::ttype_t* unit_type = expr_type(x.m_unit);
                is_string = ASRUtils::is_character(*unit_type);
                is_string_array = is_string && ASRUtils::is_array(unit_type);
                if (is_string) {
                    if (is_string_array) {
                        // For character arrays, we need the address of the first element
                        this->visit_expr_wrapper(x.m_unit, false);
                        unit_val = tmp;
                    } else {
                        // For scalar strings
                        this->visit_expr_load_wrapper(x.m_unit, 0, true);
                        unit_val = tmp;
                    }
                } else {
                    this->visit_expr_wrapper(x.m_unit, true);
                    unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
                }
            }

            if (x.m_iostat) {
                int ptr_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr_wrapper(x.m_iostat, false);
                ptr_loads = ptr_copy;
                iostat = tmp;
            } else {
                iostat = llvm::ConstantPointerNull::get(llvm::Type::getInt32Ty(context)->getPointerTo());
            }

            // Build namelist descriptor and call _lfortran_namelist_read
            llvm::Value* nml_group = build_namelist_descriptor(x.m_nml);

            // Get or create _lfortran_namelist_read function
            std::string func_name;
            if (is_string_array) {
                func_name = "_lfortran_namelist_read_str_array";
            } else if (is_string) {
                func_name = "_lfortran_namelist_read_str";
            } else {
                func_name = "_lfortran_namelist_read";
            }
            llvm::Function* fn = module->getFunction(func_name);
            if (!fn) {
                // Define item struct type (must match build_namelist_descriptor)
                llvm::StructType* item_type = llvm::StructType::get(
                    character_type,                               // name
                    llvm::Type::getInt32Ty(context),             // type
                    llvm::Type::getInt32Ty(context),             // rank
                    llvm::Type::getInt64Ty(context),             // elem_len
                    llvm::Type::getInt8Ty(context)->getPointerTo(), // data
                    llvm::Type::getInt64Ty(context)->getPointerTo()  // shape
                );
                llvm::StructType* group_type = llvm::StructType::get(
                    character_type,
                    llvm::Type::getInt32Ty(context),
                    item_type->getPointerTo()
                );
                std::vector<llvm::Type*> args;
                if (is_string_array) {
                    args = {
                        llvm::Type::getInt8Ty(context)->getPointerTo(), // data
                        llvm::Type::getInt64Ty(context),        // elem_len
                        llvm::Type::getInt64Ty(context),        // n_elems
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // iostat
                        group_type->getPointerTo()              // group
                    };
                } else if (is_string) {
                    args = {
                        character_type,                         // data
                        llvm::Type::getInt64Ty(context),        // data_len
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // iostat
                        group_type->getPointerTo()              // group
                    };
                } else {
                    args = {
                        llvm::Type::getInt32Ty(context),         // unit_num
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // iostat
                        group_type->getPointerTo()              // group
                    };
                }
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), args, false);
                fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, func_name, module.get());
            }

            if (is_string_array) {
                // Get array dimensions and element length
                ASR::ttype_t* unit_type = expr_type(x.m_unit);
                ASR::dimension_t* dims = nullptr;
                size_t n_dims = ASRUtils::extract_dimensions_from_ttype(unit_type, dims);
                LCOMPILERS_ASSERT(n_dims >= 1);

                // Get element length
                ASR::String_t* str_type = ASRUtils::get_string_type(unit_type);
                llvm::Value* elem_len;
                if (str_type->m_len && ASR::is_a<ASR::IntegerConstant_t>(*str_type->m_len)) {
                    ASR::IntegerConstant_t* len_const = ASR::down_cast<ASR::IntegerConstant_t>(str_type->m_len);
                    elem_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context),
                        llvm::APInt(64, len_const->m_n));
                } else {
                    // Dynamic length - need to evaluate the expression
                    this->visit_expr_wrapper(str_type->m_len, true);
                    elem_len = tmp;
                    tmp = nullptr;
                }

                // Calculate total number of elements
                int64_t n_elems_val = ASRUtils::get_fixed_size_of_array(dims, n_dims);
                llvm::Value* n_elems = llvm::ConstantInt::get(
                    llvm::Type::getInt64Ty(context), llvm::APInt(64, n_elems_val));

                // Get data pointer from array
                llvm::Value* data_ptr;
                ASR::array_physical_typeType storage_type = ASRUtils::extract_physical_type(unit_type);
                if (storage_type == ASR::PointerArray && ASRUtils::is_array_of_strings(unit_type)) {
                    // For pointer arrays of strings, use get_stringArray_data
                    data_ptr = llvm_utils->get_stringArray_data(unit_type, unit_val);
                } else if (storage_type == ASR::PointerArray) {
                    // For pointer arrays of other types
                    data_ptr = arr_descr->get_pointer_to_data(x.m_unit, unit_type, unit_val, module.get());
                } else {
                    // For fixed arrays, unit_val is already the data pointer
                    data_ptr = unit_val;
                }
                data_ptr = builder->CreateBitCast(data_ptr,
                    llvm::Type::getInt8Ty(context)->getPointerTo());

                builder->CreateCall(fn, {data_ptr, elem_len, n_elems, iostat, nml_group});
            } else if (is_string) {
                llvm::Value *data_ptr, *data_len;
                std::tie(data_ptr, data_len) = llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_unit), unit_val);
                builder->CreateCall(fn, {data_ptr, data_len, iostat, nml_group});
            } else {
                builder->CreateCall(fn, {unit_val, iostat, nml_group});
            }
            return;
        }

        llvm::Value *unit_val, *iostat, *iostat_for_empty_read, *read_size;
        llvm::Value *advance, *advance_length;
        bool is_string = false;
        if (x.m_unit == nullptr) {
            // Read from stdin
            unit_val = llvm::ConstantInt::get(
                    llvm::Type::getInt32Ty(context), llvm::APInt(32, -1, true));
        } else {
            is_string = ASRUtils::is_character(*expr_type(x.m_unit));
            this->visit_expr_load_wrapper(x.m_unit, (is_string ? 0 : 1), true);
            unit_val = tmp;
            if(ASRUtils::is_integer(*ASRUtils::expr_type(x.m_unit))){
                // Convert the unit to 32 bit integer (We only support unit number up to 1000).
                unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
            }
        }

        if (x.m_iostat) {
            int ptr_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_iostat, false);
            ptr_loads = ptr_copy;
            iostat = tmp;
            iostat_for_empty_read = iostat;
        } else {
            // Pass NULL to read functions so runtime prints specific error messages
            iostat = llvm::ConstantPointerNull::get(
                        llvm::Type::getInt32Ty(context)->getPointerTo());
            // Create internal iostat for empty_read
            iostat_for_empty_read = llvm_utils->CreateAlloca(*builder,
                        llvm::Type::getInt32Ty(context));
            builder->CreateStore(
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0),
                iostat_for_empty_read);
        }

        if (x.m_advance) {
            this->visit_expr_load_wrapper(x.m_advance, 0, true);
            LCOMPILERS_ASSERT(ASRUtils::is_character(*expr_type(x.m_advance)))
            std::tie(advance, advance_length) = llvm_utils->get_string_length_data(
                                                    ASRUtils::get_string_type(x.m_advance),
                                                    tmp);
        } else {
            std::string yes("yes");
            advance = LCompilers::create_global_string_ptr(context, *module, *builder, yes);
            advance_length = llvm::ConstantInt::get(context, llvm::APInt(64, yes.size()));
        }

        if (x.m_size) {
            int ptr_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_size, false);
            ptr_loads = ptr_copy;
            read_size = tmp;
        } else {
            read_size = llvm_utils->CreateAlloca(*builder,
                        llvm::Type::getInt32Ty(context));
        }

        // Handle pos= specifier: seek to the specified position before reading
        if (x.m_pos && !is_string) {
            this->visit_expr_wrapper(x.m_pos, true);
            llvm::Value* pos_val = tmp;
            // Convert to i64 for file position
            pos_val = builder->CreateIntCast(pos_val, llvm::Type::getInt64Ty(context), true);

            std::string runtime_func_name = "_lfortran_file_seek";
            llvm::Function *fn = module->getFunction(runtime_func_name);
            if (!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), {
                            llvm::Type::getInt32Ty(context),  // unit
                            llvm::Type::getInt64Ty(context),  // pos
                            llvm::Type::getInt32Ty(context)->getPointerTo()  // iostat
                        }, false);
                fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, runtime_func_name,
                            module.get());
            }
            builder->CreateCall(fn, {unit_val, pos_val, iostat});
        }

        if (x.m_rec && !is_string) {
            emit_seek_record_from_rec(x.m_rec, unit_val, iostat);
        }

        if (x.m_fmt) {
            emit_formatted_read(x, unit_val, iostat, read_size, advance, advance_length, is_string);
        } else {
            llvm::Value* var_to_read_into = nullptr; // Var expression that we'll read into.
            for (size_t i=0; i<x.n_values; i++) {
                // Handle ImpliedDoLoop: read(10,*) (vals(j), j=1,n)
                // Transform to reading n elements into vals starting at start index
                if (ASR::is_a<ASR::ImpliedDoLoop_t>(*x.m_values[i])) {
                    ASR::ImpliedDoLoop_t* idl = ASR::down_cast<ASR::ImpliedDoLoop_t>(x.m_values[i]);
                    // Handle simple case: single ArrayItem with loop var as index
                    if (idl->n_values == 1 && ASR::is_a<ASR::ArrayItem_t>(*idl->m_values[0])) {
                        ASR::ArrayItem_t* arr_item = ASR::down_cast<ASR::ArrayItem_t>(idl->m_values[0]);
                        if (arr_item->n_args == 1 && arr_item->m_args[0].m_right &&
                            ASR::is_a<ASR::Var_t>(*arr_item->m_args[0].m_right)) {
                            ASR::Var_t* idx_var = ASR::down_cast<ASR::Var_t>(arr_item->m_args[0].m_right);
                            ASR::Var_t* loop_var = ASR::down_cast<ASR::Var_t>(idl->m_var);
                            if (idx_var->m_v == loop_var->m_v) {
                                // Get array data pointer
                                int ptr_loads_copy = ptr_loads;
                                ptr_loads = 0;
                                this->visit_expr(*arr_item->m_v);
                                llvm::Value* arr_ptr = tmp;
                                ptr_loads = ptr_loads_copy;

                                ASR::ttype_t* arr_type = ASRUtils::expr_type(arr_item->m_v);
                                ASR::ttype_t* elem_type = ASRUtils::type_get_past_array(
                                    ASRUtils::type_get_past_allocatable_pointer(arr_type));
                                llvm::Type* llvm_elem_type = llvm_utils->get_type_from_ttype_t_util(
                                    arr_item->m_v, elem_type, module.get());

                                // Get data pointer - match existing array handling pattern
                                llvm::Value* data_ptr = arr_ptr;
                                ASR::ttype_t* past_alloc_type = ASRUtils::type_get_past_allocatable_pointer(arr_type);
                                ASR::Array_t* arr_t = ASR::down_cast<ASR::Array_t>(past_alloc_type);
                                llvm::Type* llvm_arr_type = llvm_utils->get_type_from_ttype_t_util(
                                    arr_item->m_v, past_alloc_type, module.get());

                                if (arr_t->m_physical_type == ASR::array_physical_typeType::FixedSizeArray) {
                                    // For FixedSizeArray, arr_ptr is [N x Type]*, just use element pointer
                                    // GEP with indices [0, offset] to get element pointer
                                    this->visit_expr_wrapper(idl->m_start, true);
                                    llvm::Value* start_idx = tmp;
                                    llvm::Value* offset = builder->CreateSub(start_idx,
                                        llvm::ConstantInt::get(start_idx->getType(), 1));
                                    llvm::Value* section_ptr = builder->CreateGEP(llvm_arr_type, arr_ptr,
                                        {llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0), offset});

                                    // Compute size: (end - start) / inc + 1
                                    this->visit_expr_wrapper(idl->m_end, true);
                                    llvm::Value* end_idx = tmp;
                                    llvm::Value* size;
                                    if (idl->m_increment) {
                                        this->visit_expr_wrapper(idl->m_increment, true);
                                        llvm::Value* inc = tmp;
                                        llvm::Value* diff = builder->CreateSub(end_idx, start_idx);
                                        llvm::Value* quot = builder->CreateSDiv(diff, inc);
                                        size = builder->CreateAdd(quot,
                                            llvm::ConstantInt::get(quot->getType(), 1));
                                    } else {
                                        llvm::Value* diff = builder->CreateSub(end_idx, start_idx);
                                        size = builder->CreateAdd(diff,
                                            llvm::ConstantInt::get(diff->getType(), 1));
                                    }
                                    size = builder->CreateIntCast(size, llvm::Type::getInt32Ty(context), true);

                                    llvm::Function* fn = get_read_function(arr_type);
                                    builder->CreateCall(fn, {section_ptr, size, unit_val, iostat});
                                    continue;
                                }

                                bool is_pointer_array = (arr_t->m_physical_type == ASR::array_physical_typeType::PointerArray ||
                                    arr_t->m_physical_type == ASR::array_physical_typeType::UnboundedPointerArray);
                                if (is_pointer_array) {
                                    // Check if this is a dummy argument (passed by value as pointer)
                                    // vs local variable (stored as pointer-to-pointer, needs load)
                                    bool is_dummy_arg = false;
                                    if (ASR::is_a<ASR::Var_t>(*arr_item->m_v)) {
                                        ASR::Variable_t* arr_var = ASRUtils::EXPR2VAR(arr_item->m_v);
                                        is_dummy_arg = is_arg_dummy(arr_var->m_intent);
                                    }
                                    if (is_dummy_arg) {
                                        // For dummy arguments, arr_ptr is already Type* (data pointer)
                                        data_ptr = arr_ptr;
                                    } else {
                                        // For local pointer arrays, arr_ptr is Type**, load to get Type*
                                        data_ptr = llvm_utils->CreateLoad2(llvm_elem_type->getPointerTo(), arr_ptr);
                                    }
                                } else {
                                    data_ptr = arr_descr->get_pointer_to_data(llvm_arr_type, arr_ptr);
                                }

                                // Compute pointer to start element (1-based indexing)
                                this->visit_expr_wrapper(idl->m_start, true);
                                llvm::Value* start_idx = tmp;
                                llvm::Value* offset = builder->CreateSub(start_idx,
                                    llvm::ConstantInt::get(start_idx->getType(), 1));
                                llvm::Value* section_ptr = is_pointer_array ?
                                    llvm_utils->create_ptr_gep2(llvm_elem_type, data_ptr, offset) :
                                    llvm_utils->create_gep2(llvm_elem_type, data_ptr, offset);

                                // Compute size: (end - start) / inc + 1
                                this->visit_expr_wrapper(idl->m_end, true);
                                llvm::Value* end_idx = tmp;
                                llvm::Value* size;
                                if (idl->m_increment) {
                                    this->visit_expr_wrapper(idl->m_increment, true);
                                    llvm::Value* inc = tmp;
                                    llvm::Value* diff = builder->CreateSub(end_idx, start_idx);
                                    llvm::Value* quot = builder->CreateSDiv(diff, inc);
                                    size = builder->CreateAdd(quot,
                                        llvm::ConstantInt::get(quot->getType(), 1));
                                } else {
                                    llvm::Value* diff = builder->CreateSub(end_idx, start_idx);
                                    size = builder->CreateAdd(diff,
                                        llvm::ConstantInt::get(diff->getType(), 1));
                                }
                                // Convert size to i32
                                size = builder->CreateIntCast(size, llvm::Type::getInt32Ty(context), true);

                                // Call array read function
                                llvm::Function* fn = get_read_function(arr_type);
                                builder->CreateCall(fn, {section_ptr, size, unit_val, iostat});
                                continue;
                            }
                        }
                    }
                    // General case: generate a loop to read elements one by one
                    // This handles multi-dimensional arrays like (a(i,j), j=1,n)
                    {
                        bool can_handle = (idl->n_values == 1 &&
                            (ASR::is_a<ASR::ArrayItem_t>(*idl->m_values[0]) ||
                             ASR::is_a<ASR::ImpliedDoLoop_t>(*idl->m_values[0])));
                        if (can_handle) {
                            generate_read_implied_do_loop(idl, unit_val, iostat);
                            continue;
                        }
                    }
                    // Unsupported ImpliedDoLoop pattern - fall through to default handling
                }

                int ptr_loads_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr(*x.m_values[i]);
                var_to_read_into = tmp; tmp =nullptr;
                ptr_loads = ptr_loads_copy;
                ASR::ttype_t* type = ASRUtils::expr_type(x.m_values[i]);
                llvm::Function *fn;
                if (ASR::is_a<ASR::Var_t>(*x.m_values[i]) &&
                    ASR::is_a<ASR::ExternalSymbol_t>(*ASR::down_cast<ASR::Var_t>(x.m_values[i])->m_v)) {
                    ASR::Variable_t *asr_target = EXPR2VAR(x.m_values[i]);
                    uint32_t h = get_hash((ASR::asr_t*)asr_target);
                    var_to_read_into = llvm_symtab[h];
                }
                if (is_string) {
                    // TODO: Support multiple arguments and fmt
                    std::string runtime_func_name = "_lfortran_string_read_" +
                                            ASRUtils::type_to_str_python_expr(ASRUtils::extract_type(type), x.m_values[i]);
                    if (ASRUtils::is_array(type)) {
                        runtime_func_name += "_array";
                    }
                    llvm::Function* fn = module->getFunction(runtime_func_name);
                    if (!fn) {
                        llvm::FunctionType *function_type;
                        if(ASRUtils::is_string_only(type)){
                            function_type = llvm::FunctionType::get(
                                llvm::Type::getVoidTy(context),
                                {
                                    character_type /*src_data*/,
                                    llvm::Type::getInt64Ty(context) /*src_length*/,
                                    character_type /*dest_data*/,
                                    llvm::Type::getInt64Ty(context) /*dest_length*/
                                },
                                false);
                        } else if (ASRUtils::is_array(type)) {
                            function_type = llvm::FunctionType::get(
                                llvm::Type::getVoidTy(context),
                                {   character_type /*src_data*/,
                                    llvm::Type::getInt64Ty(context)/*src_length*/,
                                    character_type,
                                    llvm_utils->get_type_from_ttype_t_util(
                                        x.m_values[i],
                                        ASRUtils::type_get_past_allocatable_pointer(type),
                                        module.get()
                                    )->getPointerTo()
                                },
                                false);
                        } else {
                            function_type = llvm::FunctionType::get(
                                llvm::Type::getVoidTy(context),
                                {   character_type /*src_data*/,
                                    llvm::Type::getInt64Ty(context)/*src_length*/,
                                    character_type,
                                    llvm_utils->get_type_from_ttype_t_util(
                                        x.m_values[i],
                                        ASRUtils::type_get_past_allocatable_pointer(type),
                                        module.get()
                                    )->getPointerTo(),
                                    llvm::Type::getInt32Ty(context)->getPointerTo() /*iostat*/
                                },
                                false);
                        }
                        fn = llvm::Function::Create(function_type,
                                llvm::Function::ExternalLinkage, runtime_func_name, module.get());
                    }
                    llvm::Value *fmt = nullptr;
                    if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_array(
                            ASRUtils::type_get_past_allocatable_pointer(type)))) {
                        ASR::Integer_t* int_type = ASR::down_cast<ASR::Integer_t>(ASRUtils::type_get_past_array(
                                ASRUtils::type_get_past_allocatable_pointer(type)));
                        fmt = int_type->m_kind == 4 ? LCompilers::create_global_string_ptr(context, *module, *builder, "%d")
                                                    : LCompilers::create_global_string_ptr(context, *module, *builder, "%ld");
                    } else if (ASR::is_a<ASR::Real_t>(*ASRUtils::type_get_past_array(
                                   ASRUtils::type_get_past_allocatable_pointer(type)))) {
                        ASR::Real_t* real_type = ASR::down_cast<ASR::Real_t>(ASRUtils::type_get_past_array(
                                ASRUtils::type_get_past_allocatable_pointer(type)));
                        fmt = real_type->m_kind == 4 ? LCompilers::create_global_string_ptr(context, *module, *builder, "%f")
                                                     : LCompilers::create_global_string_ptr(context, *module, *builder, "%lf");
                    } else if (ASR::is_a<ASR::String_t>(*ASRUtils::type_get_past_array(
                                   ASRUtils::type_get_past_allocatable_pointer(type)))) {
                        fmt = LCompilers::create_global_string_ptr(context, *module, *builder, "%s");
                    } else if (ASR::is_a<ASR::Logical_t>(*ASRUtils::type_get_past_array(
                                   ASRUtils::type_get_past_allocatable_pointer(type)))) {
                        fmt = LCompilers::create_global_string_ptr(context, *module, *builder, "%d");
                    } else if (ASR::is_a<ASR::Complex_t>(*ASRUtils::type_get_past_array(
                                   ASRUtils::type_get_past_allocatable_pointer(type)))) {
                        ASR::Complex_t* complex_type = ASR::down_cast<ASR::Complex_t>(ASRUtils::type_get_past_array(
                                ASRUtils::type_get_past_allocatable_pointer(type)));
                        fmt = complex_type->m_kind == 4 ? LCompilers::create_global_string_ptr(context, *module, *builder, " (%f,%f)")
                                                       : LCompilers::create_global_string_ptr(context, *module, *builder, " (%lf,%lf)");
                    }
                    llvm::Value *src_data, *src_len;
                    std::tie(src_data, src_len) = llvm_utils->get_string_length_data(
                        ASRUtils::get_string_type(x.m_unit), unit_val);

                    if(ASRUtils::is_string_only(type)){
                        llvm::Value* dest_data, *dest_len;
                        std::tie(dest_data, dest_len) = llvm_utils->get_string_length_data(
                            ASRUtils::get_string_type(x.m_values[i]), var_to_read_into);
                        builder->CreateCall(fn, { src_data, src_len, dest_data, dest_len });
                    } else if (ASRUtils::is_array(type)) {
                        llvm::Value* arr_data = var_to_read_into;
                        if (ASR::is_a<ASR::Allocatable_t>(*type) ||
                                ASR::is_a<ASR::Pointer_t>(*type)) {
                            llvm::Type *el_type = llvm_utils->get_el_type(
                                x.m_values[i], ASRUtils::extract_type(type), module.get());
                            llvm::Type* desc_ptr_type = llvm_utils->get_type_from_ttype_t_util(
                                x.m_values[i],
                                ASRUtils::type_get_past_allocatable_pointer(type),
                                module.get())->getPointerTo();
                            arr_data = llvm_utils->CreateLoad2(desc_ptr_type, var_to_read_into);
                            ASR::Array_t *arr_tp = ASR::down_cast<ASR::Array_t>(
                                ASRUtils::type_get_past_allocatable_pointer(type));
                            if (arr_tp->m_physical_type !=
                                    ASR::array_physical_typeType::PointerArray) {
                                arr_data = arr_descr->get_pointer_to_data(
                                    llvm_utils->get_type_from_ttype_t_util(x.m_values[i],
                                        ASRUtils::type_get_past_allocatable_pointer(type),
                                        module.get()),
                                    arr_data);
                                arr_data = llvm_utils->CreateLoad2(
                                    el_type->getPointerTo(), arr_data);
                            }
                            llvm::Type* fn_param_type = fn->getFunctionType()->getParamType(3);
                            if (arr_data->getType() != fn_param_type) {
                                arr_data = builder->CreateBitCast(arr_data, fn_param_type);
                            }
                        }
                        builder->CreateCall(fn, { src_data, src_len, fmt, arr_data });
                    } else {
                        if (ASR::is_a<ASR::Allocatable_t>(*type) ||
                                ASR::is_a<ASR::Pointer_t>(*type)) {
                            llvm::Type* t = llvm_utils->get_type_from_ttype_t_util(
                                x.m_values[i],
                                ASRUtils::type_get_past_allocatable_pointer(type),
                                module.get())->getPointerTo();
                            var_to_read_into = llvm_utils->CreateLoad2(t, var_to_read_into);
                        }
                        builder->CreateCall(fn, { src_data, src_len, fmt, var_to_read_into, iostat });
                    }
                    return;
                } else {
                    fn = get_read_function(type);
                }
                if (ASRUtils::is_array(type)) {
                    llvm::Type *el_type = llvm_utils->get_el_type(
                        x.m_values[i], ASRUtils::extract_type(type), module.get());
                    if (ASR::is_a<ASR::Allocatable_t>(*type)
                        || ASR::is_a<ASR::Pointer_t>(*type)) {
                        llvm::Type* t = llvm_utils->get_type_from_ttype_t_util(
                            x.m_values[i],
                            ASRUtils::type_get_past_allocatable_pointer(type),
                            module.get())->getPointerTo();
                        var_to_read_into = llvm_utils->CreateLoad2(t, var_to_read_into);
                    }
                    llvm::Value* original_array_representation = var_to_read_into; // Loaded (if necessary)
                    ASR::Array_t *arr_tp = ASR::down_cast<ASR::Array_t>(
                        ASRUtils::type_get_past_allocatable_pointer(type));
                    if (arr_tp->m_physical_type != ASR::array_physical_typeType::PointerArray) {
                        var_to_read_into = arr_descr->get_pointer_to_data(llvm_utils->get_type_from_ttype_t_util(x.m_values[i], ASRUtils::type_get_past_allocatable_pointer(type), module.get()), var_to_read_into);
                    }
                    if (ASR::is_a<ASR::Allocatable_t>(*type)
                        || ASR::is_a<ASR::Pointer_t>(*type)) {
                        var_to_read_into = llvm_utils->CreateLoad2(el_type->getPointerTo(), var_to_read_into);
                    }
                    llvm::Value *arr = var_to_read_into;
                    ASR::ttype_t *type32 = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
                    ASR::ArraySize_t* array_size = ASR::down_cast2<ASR::ArraySize_t>(ASR::make_ArraySize_t(al, x.base.base.loc,
                        x.m_values[i], nullptr, type32, nullptr));
                    visit_ArraySize(*array_size);
                    if(ASRUtils::is_array_of_strings(type)){
                        builder->CreateCall(fn, {
                            llvm_utils->get_stringArray_data(type, original_array_representation),
                            llvm_utils->get_stringArray_length(type, original_array_representation),
                            tmp, unit_val, iostat});
                        tmp = nullptr;
                    } else {
                        builder->CreateCall(fn, {arr, tmp, unit_val, iostat});
                        tmp = nullptr;
                    }
                } else {
                    if(ASRUtils::is_string_only(type)){
                        llvm::Value* str_data, *str_len;
                        std::tie(str_data, str_len) = llvm_utils->get_string_length_data(ASRUtils::get_string_type(type), var_to_read_into, true);
                        builder->CreateCall(fn, {str_data, str_len, unit_val, iostat});
                    } else {
                        if (ASR::is_a<ASR::Allocatable_t>(*type)
                            || ASR::is_a<ASR::Pointer_t>(*type)) {
                            llvm::Type* t = llvm_utils->get_type_from_ttype_t_util(
                                x.m_values[i],
                                ASRUtils::type_get_past_allocatable_pointer(type),
                                module.get())->getPointerTo();
                            var_to_read_into = llvm_utils->CreateLoad2(t, var_to_read_into);
                        }
                        llvm::Value* read_ptr = var_to_read_into;
                        llvm::Type* expected_type = fn->getFunctionType()->getParamType(0);
                        if (read_ptr->getType() != expected_type) {
                            read_ptr = builder->CreateBitCast(read_ptr, expected_type);
                        }
                        builder->CreateCall(fn, {read_ptr, unit_val, iostat});
                    }
                }
            }

            // In Fortran, read(u, *) is used to read the entire line. The
            // next read(u, *) function is intended to read the next entire
            // line. Let's take an example: `read(u, *) n`, where n is an
            // integer. The first occurance of the integer value will be
            // read, and anything after that will be skipped.
            // Here, we can use `_lfortran_empty_read` function to move to the
            // pointer to the next line.
            std::string runtime_func_name = "_lfortran_empty_read";
            llvm::Function *fn = module->getFunction(runtime_func_name);
            if (!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), {
                            llvm::Type::getInt32Ty(context),
                            llvm::Type::getInt32Ty(context)->getPointerTo()
                        }, false);
                fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, runtime_func_name,
                            module.get());
            }
            // When x.m_iostat is provided and values were read (n_values > 0),
            // only call empty_read if no error occurred during value reads.
            // When n_values == 0, no reads happened yet so call unconditionally.
            if (x.m_iostat && x.n_values > 0) {
                llvm::Value* iostat_val = builder->CreateLoad(
                    llvm::Type::getInt32Ty(context), iostat_for_empty_read);
                llvm::Value* iostat_is_zero = builder->CreateICmpEQ(
                    iostat_val, llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0));
                llvm_utils->create_if_else(iostat_is_zero, [&]() {
                    builder->CreateCall(fn, {unit_val, iostat_for_empty_read});
                }, [](){});
            } else {
                builder->CreateCall(fn, {unit_val, iostat_for_empty_read});
            }
        }
    }

    void add_formatted_read_arg(std::vector<llvm::Value*>& args, ASR::ttype_t* val_type,
            llvm::Value* elem_ptr) {
        constexpr int32_t kChar = 0;
        constexpr int32_t kLogical = 1;
        constexpr int32_t kInt32 = 2;
        constexpr int32_t kInt64 = 3;
        constexpr int32_t kFloat = 4;
        constexpr int32_t kDouble = 5;
        constexpr int32_t kComplex4 = 6;
        constexpr int32_t kComplex8 = 7;

        if (ASR::is_a<ASR::String_t>(*val_type)) {
            args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, kChar)));
            auto [str_data, str_len] = llvm_utils->get_string_length_data(
                ASRUtils::get_string_type(val_type), elem_ptr, true);
            args.push_back(str_data);
            args.push_back(str_len);
        } else if (ASR::is_a<ASR::Logical_t>(*val_type)) {
            args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, kLogical)));
            args.push_back(elem_ptr);
        } else if (ASR::is_a<ASR::Integer_t>(*val_type)) {
            ASR::Integer_t* int_type = ASR::down_cast<ASR::Integer_t>(val_type);
            int32_t type_code = (int_type->m_kind <= 4) ? kInt32 : kInt64;
            args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, type_code)));
            args.push_back(elem_ptr);
        } else if (ASR::is_a<ASR::Real_t>(*val_type)) {
            ASR::Real_t* real_type = ASR::down_cast<ASR::Real_t>(val_type);
            int32_t type_code = (real_type->m_kind == 4) ? kFloat : kDouble;
            args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, type_code)));
            args.push_back(elem_ptr);
        } else if (ASR::is_a<ASR::Complex_t>(*val_type)) {
            ASR::Complex_t* complex_type = ASR::down_cast<ASR::Complex_t>(val_type);
            int32_t type_code = (complex_type->m_kind == 4) ? kComplex4 : kComplex8;
            args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, type_code)));
            args.push_back(elem_ptr);
        } else {
            throw CodeGenError("Unsupported type in formatted read");
        }
    }


    void emit_seek_record(llvm::Value* unit_val, llvm::Value* rec_val, llvm::Value* iostat) {
        llvm::Value *unit_i32 = unit_val;
        if (unit_i32->getType()->isPointerTy()) {
            unit_i32 = llvm_utils->CreateLoad2(llvm::Type::getInt32Ty(context), unit_i32);
        }
        unit_i32 = llvm_utils->convert_kind(unit_i32, llvm::Type::getInt32Ty(context));

        std::string seek_name = "_lfortran_seek_record";
        llvm::Function *seek_fn = module->getFunction(seek_name);
        if (!seek_fn) {
            llvm::FunctionType *seek_ft = llvm::FunctionType::get(
                llvm::Type::getVoidTy(context),
                { llvm::Type::getInt32Ty(context), llvm::Type::getInt32Ty(context),
                  llvm::Type::getInt32Ty(context)->getPointerTo() },
                false);
            seek_fn = llvm::Function::Create(seek_ft, llvm::Function::ExternalLinkage, seek_name, module.get());
        }
        builder->CreateCall(seek_fn, { unit_i32, rec_val, iostat });
    }

    void emit_seek_record_from_rec(ASR::expr_t* rec_expr, llvm::Value* unit_val, llvm::Value* iostat) {
        int ptr_copy_rec = ptr_loads;
        ptr_loads = 0;
        this->visit_expr_wrapper(rec_expr, true);
        ptr_loads = ptr_copy_rec;

        llvm::Value *rec_val = tmp;
        if (rec_val->getType()->isPointerTy()) {
            rec_val = llvm_utils->CreateLoad2(llvm::Type::getInt32Ty(context), rec_val);
        }
        rec_val = llvm_utils->convert_kind(rec_val, llvm::Type::getInt32Ty(context));

        emit_seek_record(unit_val, rec_val, iostat);
    }

    void emit_single_formatted_read(ASR::expr_t *val_expr, llvm::Value *unit_val,
                                    llvm::Value *iostat, llvm::Value *read_size,
                                    llvm::Value *advance, llvm::Value *advance_len,
                                    llvm::Value *fmt_data, llvm::Value *fmt_len,
                                    bool is_string, const ASR::FileRead_t &x) {
        ASR::ttype_t *expr_type_full = ASRUtils::expr_type(val_expr);
        ASR::ttype_t *val_type = ASRUtils::type_get_past_array(
            ASRUtils::type_get_past_allocatable_pointer(expr_type_full));

        int ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        bool is_assignment_target_copy = is_assignment_target;
        is_assignment_target = true;
        this->visit_expr(*val_expr);
        is_assignment_target = is_assignment_target_copy;
        llvm::Value *var_ptr = tmp;
        ptr_loads = ptr_loads_copy;

        std::vector<llvm::Value *> single_args;
        if (is_string) {
            llvm::Value *src_data, *src_len;
            std::tie(src_data, src_len) = llvm_utils->get_string_length_data(
                ASRUtils::get_string_type(x.m_unit), unit_val);
            single_args.push_back(src_data);
            single_args.push_back(src_len);
        } else {
            single_args.push_back(unit_val);
        }
        single_args.push_back(iostat);
        single_args.push_back(read_size);
        single_args.push_back(advance);
        single_args.push_back(advance_len);
        single_args.push_back(fmt_data);
        single_args.push_back(fmt_len);

        if (ASRUtils::is_array(expr_type_full) && ASRUtils::is_fixed_size_array(expr_type_full)) {
            int64_t array_size = ASRUtils::get_fixed_size_of_array(expr_type_full);
            single_args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, array_size)));
            
            ASR::Array_t *arr_type = ASR::down_cast<ASR::Array_t>(
                ASRUtils::type_get_past_allocatable_pointer(expr_type_full));
            llvm::Type *llvm_arr_type = llvm_utils->get_type_from_ttype_t_util(
                val_expr, ASRUtils::type_get_past_allocatable_pointer(expr_type_full), module.get());
            llvm::Type *llvm_elem_type = llvm_utils->get_type_from_ttype_t_util(
                val_expr, val_type, module.get());

            for (int64_t elem_idx = 0; elem_idx < array_size; elem_idx++) {
                llvm::Value *elem_ptr;
                if (arr_type->m_physical_type == ASR::array_physical_typeType::FixedSizeArray) {
                    elem_ptr = builder->CreateGEP(llvm_arr_type, var_ptr,
                                                  {llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0),
                                                   llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), elem_idx)});
                } else if (ASR::is_a<ASR::String_t>(*val_type)) {
                    ASR::String_t* str_type = ASRUtils::get_string_type(val_type);
                    elem_ptr = llvm_utils->get_string_element_in_array(
                        str_type, var_ptr,
                        llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), elem_idx));
                } else {
                    llvm::Value *data_ptr = arr_descr->get_pointer_to_data(llvm_arr_type, var_ptr);
                    data_ptr = llvm_utils->CreateLoad2(llvm_elem_type->getPointerTo(), data_ptr);
                    elem_ptr = builder->CreateGEP(llvm_elem_type, data_ptr,
                                                  llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), elem_idx));
                }
                add_formatted_read_arg(single_args, val_type, elem_ptr);
            }
        } else {
            single_args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, 1)));
            add_formatted_read_arg(single_args, val_type, var_ptr);
        }

        std::string runtime_func_name = is_string ? "_lfortran_string_formatted_read"
                                                  : "_lfortran_formatted_read";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            std::vector<llvm::Type *> param_types;
            if (is_string) {
                param_types.push_back(character_type);
                param_types.push_back(llvm::Type::getInt64Ty(context));
            } else {
                param_types.push_back(llvm::Type::getInt32Ty(context));
            }
            param_types.push_back(llvm::Type::getInt32Ty(context)->getPointerTo());
            param_types.push_back(llvm::Type::getInt32Ty(context)->getPointerTo());
            param_types.push_back(character_type);
            param_types.push_back(llvm::Type::getInt64Ty(context));
            param_types.push_back(character_type);
            param_types.push_back(llvm::Type::getInt64Ty(context));
            param_types.push_back(llvm::Type::getInt32Ty(context));

            llvm::FunctionType *function_type = llvm::FunctionType::get(
                llvm::Type::getVoidTy(context), param_types, true);
            fn = llvm::Function::Create(function_type, llvm::Function::ExternalLinkage,
                                        runtime_func_name, module.get());
        }
        builder->CreateCall(fn, single_args);
    }

    void emit_formatted_read_with_idl(const ASR::FileRead_t &x, llvm::Value *unit_val,
            llvm::Value *iostat, llvm::Value *read_size, llvm::Value *advance,
            llvm::Value *advance_length, bool is_string, ASR::expr_t* fmt_expr) {
        (void)iostat;
        (void)advance;
        (void)advance_length;
        ASR::expr_t** values = x.m_values;
        size_t n_values = x.n_values;

        llvm::Value* fmt_data;
        llvm::Value* fmt_len;
        std::tie(fmt_data, fmt_len) = get_string_data_and_length(fmt_expr);

        llvm::Constant *no_advance_const = llvm::ConstantDataArray::getString(context, "NO", false);
        llvm::GlobalVariable *no_advance_global = new llvm::GlobalVariable(
            *module,
            no_advance_const->getType(),
            true,
            llvm::GlobalValue::PrivateLinkage,
            no_advance_const,
            ".str.no_advance_idl"
        );
        no_advance_global->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);
        no_advance_global->setAlignment(llvm::Align(1));
        llvm::Value* no_advance_str = builder->CreateBitCast(no_advance_global, character_type);
        llvm::Value* no_advance_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 2);

        llvm::AllocaInst* loop_iostat = builder->CreateAlloca(llvm::Type::getInt32Ty(context), nullptr, "loop_iostat");
        builder->CreateStore(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0), loop_iostat);

        for (size_t i = 0; i < n_values; i++) {
            ASR::expr_t* val_expr = values[i];

            if (ASR::is_a<ASR::ImpliedDoLoop_t>(*val_expr)) {
                ASR::ImpliedDoLoop_t* idl = ASR::down_cast<ASR::ImpliedDoLoop_t>(val_expr);

                int ptr_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr_wrapper(idl->m_start, true);
                ptr_loads = ptr_copy;
                llvm::Value* loop_start = tmp;
                if (loop_start->getType()->isPointerTy()) {
                    ASR::ttype_t* t = ASRUtils::expr_type(idl->m_start);
                    llvm::Type* ty = llvm_utils->get_type_from_ttype_t_util(idl->m_start, t, module.get());
                    loop_start = llvm_utils->CreateLoad2(ty, loop_start);
                }
                loop_start = llvm_utils->convert_kind(loop_start, llvm::Type::getInt64Ty(context));

                ptr_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr_wrapper(idl->m_end, true);
                ptr_loads = ptr_copy;
                llvm::Value* loop_end = tmp;
                if (loop_end->getType()->isPointerTy()) {
                    ASR::ttype_t* t = ASRUtils::expr_type(idl->m_end);
                    llvm::Type* ty = llvm_utils->get_type_from_ttype_t_util(idl->m_end, t, module.get());
                    loop_end = llvm_utils->CreateLoad2(ty, loop_end);
                }
                loop_end = llvm_utils->convert_kind(loop_end, llvm::Type::getInt64Ty(context));

                llvm::Value* loop_step = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 1);
                if (idl->m_increment) {
                    ptr_copy = ptr_loads;
                    ptr_loads = 0;
                    this->visit_expr_wrapper(idl->m_increment, true);
                    ptr_loads = ptr_copy;
                    loop_step = tmp;
                    if (loop_step->getType()->isPointerTy()) {
                        ASR::ttype_t* t = ASRUtils::expr_type(idl->m_increment);
                        llvm::Type* ty = llvm_utils->get_type_from_ttype_t_util(idl->m_increment, t, module.get());
                        loop_step = llvm_utils->CreateLoad2(ty, loop_step);
                    }
                    loop_step = llvm_utils->convert_kind(loop_step, llvm::Type::getInt64Ty(context));
                }

                llvm::AllocaInst* loop_var_alloca = builder->CreateAlloca(
                    llvm::Type::getInt64Ty(context), nullptr);
                builder->CreateStore(loop_start, loop_var_alloca);

                llvm::Function* fn_ptr = builder->GetInsertBlock()->getParent();
                llvm::BasicBlock* loop_cond_bb = llvm::BasicBlock::Create(context, "idl_cond", fn_ptr);
                llvm::BasicBlock* loop_body_bb = llvm::BasicBlock::Create(context, "idl_body", fn_ptr);
                llvm::BasicBlock* loop_end_bb = llvm::BasicBlock::Create(context, "idl_end", fn_ptr);

                builder->CreateBr(loop_cond_bb);
                builder->SetInsertPoint(loop_cond_bb);

                llvm::Value* cur = builder->CreateLoad(llvm::Type::getInt64Ty(context), loop_var_alloca);
                llvm::Value* is_pos = builder->CreateICmpSGT(loop_step, 
                    llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0));
                llvm::Value* cond_pos = builder->CreateICmpSLE(cur, loop_end);
                llvm::Value* cond_neg = builder->CreateICmpSGE(cur, loop_end);
                llvm::Value* cond = builder->CreateSelect(is_pos, cond_pos, cond_neg);
                builder->CreateCondBr(cond, loop_body_bb, loop_end_bb);

                builder->SetInsertPoint(loop_body_bb);

                for (size_t j = 0; j < idl->n_values; ++j) {
                    ASR::expr_t* idl_val = idl->m_values[j];
                    if (ASR::is_a<ASR::ImpliedDoLoop_t>(*idl_val)) {
                        throw CodeGenError("Nested implied-do in formatted READ not yet supported");
                    }

                    llvm::Value* cur_val = builder->CreateLoad(llvm::Type::getInt64Ty(context), loop_var_alloca);
                    llvm::Type* loop_var_type = llvm_utils->get_type_from_ttype_t_util(
                        idl->m_var, ASRUtils::expr_type(idl->m_var), module.get());
                    cur_val = llvm_utils->convert_kind(cur_val, loop_var_type);

                    ASR::symbol_t* loop_var_sym = ASR::down_cast<ASR::Var_t>(idl->m_var)->m_v;
                    llvm::AllocaInst* temp_loop_var = builder->CreateAlloca(loop_var_type, nullptr);
                    builder->CreateStore(cur_val, temp_loop_var);

                    uint64_t var_hash = (uint64_t)loop_var_sym;
                    llvm::Value* prev_symtab_val = nullptr;
                    auto it = llvm_symtab.find(var_hash);
                    if (it != llvm_symtab.end()) {
                        prev_symtab_val = it->second;
                    }
                    llvm_symtab[var_hash] = temp_loop_var;

                    {
                        int ptr_copy_inner = ptr_loads;
                        ptr_loads = 0;
                        bool iat_copy_inner = is_assignment_target;
                        is_assignment_target = true;
                        this->visit_expr(*idl->m_var);
                        llvm::Value* real_var_ptr = tmp;
                        is_assignment_target = iat_copy_inner;
                        ptr_loads = ptr_copy_inner;

                        if (real_var_ptr && real_var_ptr->getType()->isPointerTy()) {
                             builder->CreateStore(cur_val, real_var_ptr);
                        }
                    }

                    emit_single_formatted_read(idl_val, unit_val, loop_iostat, read_size,
                                               no_advance_str, no_advance_len,
                                               fmt_data, fmt_len, is_string, x);

                    if (prev_symtab_val) {
                        llvm_symtab[var_hash] = prev_symtab_val;
                    } else {
                        llvm_symtab.erase(var_hash);
                    }
                }

                cur = builder->CreateLoad(llvm::Type::getInt64Ty(context), loop_var_alloca);
                cur = builder->CreateAdd(cur, loop_step);
                builder->CreateStore(cur, loop_var_alloca);
                builder->CreateBr(loop_cond_bb);

                builder->SetInsertPoint(loop_end_bb);
            } else {
                emit_single_formatted_read(val_expr, unit_val, loop_iostat, read_size,
                                           no_advance_str, no_advance_len,
                                           fmt_data, fmt_len, is_string, x);
            }
        }
    }

    void emit_formatted_read(const ASR::FileRead_t &x, llvm::Value *unit_val,
            llvm::Value *iostat, llvm::Value *read_size, llvm::Value *advance,
            llvm::Value *advance_length, bool is_string) {
        ASR::expr_t* fmt_expr = x.m_fmt;
        ASR::expr_t** values = x.m_values;
        size_t n_values = x.n_values;

        if (ASR::is_a<ASR::IntegerConstant_t>(*fmt_expr) &&
                n_values == 1 && ASR::is_a<ASR::StringFormat_t>(*values[0])) {
            ASR::StringFormat_t* sf = ASR::down_cast<ASR::StringFormat_t>(values[0]);
            fmt_expr = sf->m_fmt;
            values = sf->m_args;
            n_values = sf->n_args;
        }

        bool has_implied_do = false;
        for (size_t i = 0; i < n_values; i++) {
            if (ASR::is_a<ASR::ImpliedDoLoop_t>(*values[i])) {
                has_implied_do = true;
                break;
            }
        }

        if (has_implied_do) {
            ASR::FileRead_t x2 = x;
            x2.m_values = values;
            x2.n_values = n_values;
            emit_formatted_read_with_idl(x2, unit_val, iostat, read_size, advance, advance_length, is_string, fmt_expr);
            return;
        }

        size_t total_scalar_values = 0;
        for (size_t i = 0; i < n_values; i++) {
            ASR::ttype_t* expr_type = ASRUtils::expr_type(values[i]);
            if (ASRUtils::is_array(expr_type) && ASRUtils::is_fixed_size_array(expr_type)) {
                total_scalar_values += ASRUtils::get_fixed_size_of_array(expr_type);
            } else {
                total_scalar_values++;
            }
        }

        std::vector<llvm::Value*> args;
        args.reserve(8 + 3 * total_scalar_values);
        if (is_string) {
            llvm::Value *src_data, *src_len;
            std::tie(src_data, src_len) = llvm_utils->get_string_length_data(
                ASRUtils::get_string_type(x.m_unit), unit_val);
            args.push_back(src_data);
            args.push_back(src_len);
        } else {
            args.push_back(unit_val);
        }
        args.push_back(iostat);
        args.push_back(read_size);
        args.push_back(advance);
        args.push_back(advance_length);
        llvm::Value* fmt_data;
        llvm::Value* fmt_len;
        std::tie(fmt_data, fmt_len) = get_string_data_and_length(fmt_expr);
        args.push_back(fmt_data);
        args.push_back(fmt_len);

        args.push_back(llvm::ConstantInt::get(context, llvm::APInt(32, total_scalar_values)));

        for (size_t i = 0; i < n_values; i++) {
            ASR::expr_t* val_expr = values[i];
            ASR::ttype_t* expr_type_full = ASRUtils::expr_type(val_expr);
            ASR::ttype_t* val_type = ASRUtils::type_get_past_array(
                ASRUtils::type_get_past_allocatable_pointer(expr_type_full));

            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            bool is_assignment_target_copy = is_assignment_target;
            is_assignment_target = true;
            this->visit_expr(*val_expr);
            is_assignment_target = is_assignment_target_copy;
            llvm::Value* var_ptr = tmp;
            ptr_loads = ptr_loads_copy;

            if (ASRUtils::is_array(expr_type_full) && ASRUtils::is_fixed_size_array(expr_type_full)) {
                int64_t array_size = ASRUtils::get_fixed_size_of_array(expr_type_full);
                ASR::Array_t* arr_type = ASR::down_cast<ASR::Array_t>(
                    ASRUtils::type_get_past_allocatable_pointer(expr_type_full));
                llvm::Type* llvm_arr_type = llvm_utils->get_type_from_ttype_t_util(
                    val_expr, ASRUtils::type_get_past_allocatable_pointer(expr_type_full), module.get());
                llvm::Type* llvm_elem_type = llvm_utils->get_type_from_ttype_t_util(
                    val_expr, val_type, module.get());

                for (int64_t elem_idx = 0; elem_idx < array_size; elem_idx++) {
                    llvm::Value* elem_ptr;
                    if (arr_type->m_physical_type == ASR::array_physical_typeType::FixedSizeArray) {
                        elem_ptr = builder->CreateGEP(llvm_arr_type, var_ptr,
                            {llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0),
                             llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), elem_idx)});
                    } else if (ASR::is_a<ASR::String_t>(*val_type)) {
                        ASR::String_t* str_type = ASRUtils::get_string_type(val_type);
                        elem_ptr = llvm_utils->get_string_element_in_array(
                            str_type, var_ptr,
                            llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), elem_idx));
                    } else {
                        llvm::Value* data_ptr = arr_descr->get_pointer_to_data(llvm_arr_type, var_ptr);
                        data_ptr = llvm_utils->CreateLoad2(llvm_elem_type->getPointerTo(), data_ptr);
                        elem_ptr = builder->CreateGEP(llvm_elem_type, data_ptr,
                            llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), elem_idx));
                    }
                    add_formatted_read_arg(args, val_type, elem_ptr);
                }
            } else {
                add_formatted_read_arg(args, val_type, var_ptr);
            }
        }

        std::string runtime_func_name;
        llvm::Function *fn;

        if (is_string) {
            runtime_func_name = "_lfortran_string_formatted_read";
            fn = module->getFunction(runtime_func_name);
            if (!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), {
                            character_type,                                  // src_data
                            llvm::Type::getInt64Ty(context),                 // src_len
                            llvm::Type::getInt32Ty(context)->getPointerTo(), // Iostat
                            llvm::Type::getInt32Ty(context)->getPointerTo(), // Chunk
                            character_type,                                  // advance
                            llvm::Type::getInt64Ty(context),                 // advance_length
                            character_type,                                  // fmt
                            llvm::Type::getInt64Ty(context),                 // fmt_len
                            llvm::Type::getInt32Ty(context)                  // no_of_args
                        }, true);
                fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, runtime_func_name, module.get());
            }
        } else {
            // File read
            runtime_func_name = "_lfortran_formatted_read";
            fn = module->getFunction(runtime_func_name);
            if (!fn) {
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getVoidTy(context), {
                            llvm::Type::getInt32Ty(context),                 // Unit
                            llvm::Type::getInt32Ty(context)->getPointerTo(), // Iostat
                            llvm::Type::getInt32Ty(context)->getPointerTo(), // Chunk
                            character_type,                                  // advance
                            llvm::Type::getInt64Ty(context),                 // advance_length
                            character_type,                                  // fmt
                            llvm::Type::getInt64Ty(context),                 // fmt_len
                            llvm::Type::getInt32Ty(context)                  // no_of_args
                        }, true);
                fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, runtime_func_name, module.get());
            }
        }

        builder->CreateCall(fn, args);
    }

    void visit_FileOpen(const ASR::FileOpen_t &x) {
        llvm::Value *unit_val = nullptr;
        llvm::Value* f_name_data{}, *f_name_len{};
        llvm::Value *status_data{}, *status_len{};
        llvm::Value *form_data{},   *form_len{};
        llvm::Value *access_data{}, *access_len{};
        llvm::Value *iomsg_data{},  *iomsg_len{};
        llvm::Value *iostat{};
        llvm::Value *action{}, *action_len{};
        llvm::Value *delim{}, *delim_len{};
        llvm::Value *position{}, *position_len{};
        llvm::Value *blank{}, *blank_len{};
        llvm::Value *recl{};
        llvm::Value *encoding_data{}, *encoding_len{};
        llvm::Value *sign_data{}, *sign_len{};

        this->visit_expr_wrapper(x.m_newunit, true);
        unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
        int ptr_copy = ptr_loads;
        if (x.m_filename) {
            std::tie(f_name_data, f_name_len) = get_string_data_and_length(x.m_filename);
        } else {
            f_name_data = llvm::Constant::getNullValue(character_type);
            f_name_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }
        if (x.m_status) {
            std::tie(status_data, status_len) = get_string_data_and_length(x.m_status);
        } else {
            status_data = llvm::Constant::getNullValue(character_type);
            status_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }
        if (x.m_form) {
            std::tie(form_data, form_len) = get_string_data_and_length(x.m_form);
        } else {
            form_data = llvm::Constant::getNullValue(character_type);
            form_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }
        if (x.m_access) {
            std::tie(access_data, access_len) = get_string_data_and_length(x.m_access);
        } else {
            access_data = llvm::Constant::getNullValue(character_type);
            access_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }
        if (x.m_iostat) {
            int ptr_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_iostat, false);
            ptr_loads = ptr_copy;
            iostat = tmp;
        } else {
            iostat = llvm::ConstantInt::getNullValue(llvm::Type::getInt32Ty(context)->getPointerTo());
        }
        if (x.m_iomsg) {
            std::tie(iomsg_data, iomsg_len) = get_string_data_and_length(x.m_iomsg);
        } else {
            iomsg_data = llvm::Constant::getNullValue(character_type);
            iomsg_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        } if (x.m_action) {
            std::tie(action, action_len) = get_string_data_and_length(x.m_action);
        } else {
            action = llvm::Constant::getNullValue(character_type);
            action_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        } if (x.m_delim) {
            std::tie(delim, delim_len) = get_string_data_and_length(x.m_delim);
        } else {
            delim = llvm::Constant::getNullValue(character_type);
            delim_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        } if (x.m_position) {
            std::tie(position, position_len) = get_string_data_and_length(x.m_position);
        } else {
            position = llvm::Constant::getNullValue(character_type);
            position_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        } if (x.m_blank) {
            std::tie(blank, blank_len) = get_string_data_and_length(x.m_blank);
        } else {
            blank = llvm::Constant::getNullValue(character_type);
            blank_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }
        recl = llvm::ConstantPointerNull::get(
            llvm::Type::getInt32Ty(context)->getPointerTo());

        if (x.m_recl) {                                      
            this->visit_expr_wrapper(x.m_recl, true);       
            llvm::Value *recl_val = llvm_utils->convert_kind(
                tmp, llvm::Type::getInt32Ty(context));
            llvm::AllocaInst *alloc =                        
                builder->CreateAlloca(llvm::Type::getInt32Ty(context));
            builder->CreateStore(recl_val, alloc);            
            recl = alloc;                                  
        } else {
            recl = llvm::ConstantPointerNull::get(
                llvm::Type::getInt32Ty(context)->getPointerTo());
        }
        if (x.m_encoding) {
            std::tie(encoding_data, encoding_len) = get_string_data_and_length(x.m_encoding);
        } else {
            encoding_data = llvm::Constant::getNullValue(character_type);
            encoding_len  = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }
        if (x.m_sign) {
            std::tie(sign_data, sign_len) = get_string_data_and_length(x.m_sign);
        } else {
            sign_data = llvm::Constant::getNullValue(character_type);
            sign_len  = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }

        ptr_loads = ptr_copy;
        std::string runtime_func_name = "_lfortran_open";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::Type *i64 = llvm::Type::getInt64Ty(context);
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    i64,
                    {llvm::Type::getInt32Ty(context),
                        character_type, i64, //f_name, f_name_length
                        character_type, i64, //status, status_len
                        character_type, i64, //form, form_length
                        character_type, i64, //access, access_len
                        character_type, i64, //iomsg, iomsg_len
                        llvm::Type::getInt32Ty(context)->getPointerTo(),
                        character_type, i64, // action, action_len
                        character_type, i64, // delim, delim_len
                        character_type, i64, // position, position_len
                        character_type, i64,  // blank, blank_len
                        character_type, i64, //encoding_data, encoding_len
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // recl
                        character_type, i64  // sign_data, sign_len
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, {unit_val,
            f_name_data, f_name_len,
            status_data, status_len,
            form_data, form_len,
            access_data, access_len,
            iomsg_data, iomsg_len,
            iostat,
            action, action_len,
            delim, delim_len,
            position, position_len,
            blank, blank_len,
            encoding_data, encoding_len,
            recl,
            sign_data, sign_len
        });
    }

    void visit_FileInquire(const ASR::FileInquire_t &x) {
        llvm::Value *exist_val {};
        llvm::Value* f_name_data {}, *f_name_len{};
        llvm::Value *unit {}, *opened_val {}, *size_val {}, *pos_val {};
        llvm::Value *write{}, *write_len{};
        llvm::Value *read{}, *read_len{};
        llvm::Value *readwrite{}, *readwrite_len{};
        llvm::Value *access_val{}, *access_len{};
        llvm::Value *name_val{}, *name_len{};
        llvm::Value *blank_val{}, *blank_len{};
        llvm::Value *recl{}, *number{};
        llvm::Value *named{}, *sequential{}, *sequential_len{};
        llvm::Value *direct{}, *direct_len{};
        llvm::Value *form{}, *form_len{};
        llvm::Value *formatted{} , *formatted_len{};
        llvm::Value *unformatted{}, *unformatted_len{};
        llvm::Value *iostat{}, *nextrec{};

        if (x.m_file) {
            std::tie(f_name_data, f_name_len) = get_string_data_and_length(x.m_file);
        } else {
            f_name_data = llvm::Constant::getNullValue(character_type);
            f_name_len = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
        }
        if (x.m_exist) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_exist, true);
            exist_val = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            exist_val = llvm_utils->CreateAlloca(*builder,
                            llvm::Type::getInt1Ty(context));
        }

        if (x.m_unit) {
            this->visit_expr_wrapper(x.m_unit, true);
            unit = tmp;
        } else {
            unit = llvm::ConstantInt::get(
                    llvm::Type::getInt32Ty(context), llvm::APInt(32, -1, true));
        }
        if (x.m_opened) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_opened, true);
            opened_val = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            opened_val = llvm_utils->CreateAlloca(*builder,
                            llvm::Type::getInt1Ty(context));
        }

        if (x.m_size) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_size, true);
            size_val = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            size_val = llvm_utils->CreateAlloca(*builder,
                            llvm::Type::getInt32Ty(context));
        }

        if (x.m_pos) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_pos, true);
            pos_val = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            pos_val = llvm_utils->CreateAlloca(*builder,
                            llvm::Type::getInt32Ty(context));
        }

        if (x.m_write) {
            this->visit_expr_load_wrapper(x.m_write, 0);
            std::tie(write, write_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_write),
                    tmp);
        } else {
            write = llvm::Constant::getNullValue(character_type);
            write_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_read) {
            this->visit_expr_load_wrapper(x.m_read, 0);
            std::tie(read, read_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_read),
                    tmp);
        } else {
            read = llvm::Constant::getNullValue(character_type);
            read_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_readwrite) {
            this->visit_expr_load_wrapper(x.m_readwrite, 0);
            std::tie(readwrite, readwrite_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_readwrite),
                    tmp);
        } else {
            readwrite = llvm::Constant::getNullValue(character_type);
            readwrite_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_access) {
            this->visit_expr_load_wrapper(x.m_access, 0);
            std::tie(access_val, access_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_access),
                    tmp);
        } else {
            access_val = llvm::Constant::getNullValue(character_type);
            access_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_name) {
            this->visit_expr_load_wrapper(x.m_name, 0);
            std::tie(name_val, name_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_name),
                    tmp);
        } else {
            name_val = llvm::Constant::getNullValue(character_type);
            name_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_blank) {
            this->visit_expr_load_wrapper(x.m_blank, 0);
            std::tie(blank_val, blank_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_blank),
                    tmp);
        } else {
            blank_val = llvm::Constant::getNullValue(character_type);
            blank_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }
        if (x.m_recl) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_recl, false);
            recl = tmp;

            ptr_loads = ptr_loads_copy;
        } else {
            recl = llvm::ConstantPointerNull::get(
                llvm::Type::getInt32Ty(context)->getPointerTo());
        }

        if (x.n_iolength_vars > 0 && x.m_iolength) {
            // INQUIRE(IOLENGTH=iol) var_list
            // Computes the number of file storage units (bytes) required to store
            // the output list using unformatted sequential I/O
            llvm::Value* total_size = llvm::ConstantInt::get(
                llvm::Type::getInt64Ty(context), 0);
            
            for (size_t i = 0; i < x.n_iolength_vars; i++) {
                ASR::expr_t* var_expr = x.m_iolength_vars[i];
                ASR::ttype_t* var_type = ASRUtils::expr_type(var_expr);
                ASR::ttype_t* var_type_base = ASRUtils::type_get_past_array(
                    ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(var_type)));
                llvm::Value* var_size = nullptr;
                llvm::Value* elem_size = nullptr;

                if (ASR::is_a<ASR::String_t>(*var_type_base)) {
                    ASR::String_t *s = ASR::down_cast<ASR::String_t>(var_type_base);
                    this->visit_expr_wrapper(s->m_len, true);
                    elem_size = builder->CreateZExtOrTrunc(
                        tmp, llvm::Type::getInt64Ty(context));
                } else {
                    int64_t kind = ASRUtils::extract_kind_from_ttype_t(var_type_base);
                    if (ASR::is_a<ASR::Complex_t>(*var_type_base)) {
                        kind *= 2;
                    }
                    elem_size = llvm::ConstantInt::get(
                        llvm::Type::getInt64Ty(context), kind);
                }

                var_size = elem_size;

                if (ASRUtils::is_array(var_type)) {
                    ASR::ttype_t* int_type = ASRUtils::TYPE(
                        ASR::make_Integer_t(al, x.base.base.loc, 4));
                    visit_ArraySizeUtil(var_expr, int_type, nullptr, nullptr);
                    llvm::Value* num_elements = builder->CreateZExtOrTrunc(
                        tmp, llvm::Type::getInt64Ty(context));
                    var_size = builder->CreateMul(elem_size, num_elements);
                }

                total_size = builder->CreateAdd(total_size, var_size);
            }
            
            // Store the result in the iolength variable
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_iolength, false);
            ptr_loads = ptr_loads_copy;
            llvm::Value* iolength_ptr = tmp;
            ASR::ttype_t* iolength_type = ASRUtils::expr_type(x.m_iolength);
            int iolength_kind = ASRUtils::extract_kind_from_ttype_t(iolength_type);
            llvm::Type* iolength_llvm_type = llvm::Type::getIntNTy(
                context, iolength_kind * 8);
            llvm::Value* result = builder->CreateTrunc(total_size, iolength_llvm_type);
            builder->CreateStore(result, iolength_ptr);
            return;
        }

        if (x.m_number) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_number, true);
            number = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            number = llvm::ConstantPointerNull::get(
                llvm::Type::getInt32Ty(context)->getPointerTo());
        }

        if (x.m_named) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_named, true);
            named = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            named = llvm::ConstantPointerNull::get(
                llvm::Type::getInt1Ty(context)->getPointerTo());
        }

        if (x.m_sequential) {
            this->visit_expr_load_wrapper(x.m_sequential, 0);
            std::tie(sequential, sequential_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_sequential),
                    tmp);
        } else {
            sequential = llvm::Constant::getNullValue(character_type);
            sequential_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_direct) {
            this->visit_expr_load_wrapper(x.m_direct, 0);
            std::tie(direct, direct_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_direct),
                    tmp);
        } else {
            direct = llvm::Constant::getNullValue(character_type);
            direct_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_form) {
            this->visit_expr_load_wrapper(x.m_form, 0);
            std::tie(form, form_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_form),
                    tmp);
        } else {
            form = llvm::Constant::getNullValue(character_type);
            form_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_formatted) {
            this->visit_expr_load_wrapper(x.m_formatted, 0);
            std::tie(formatted, formatted_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_formatted),
                    tmp);
        } else {
            formatted = llvm::Constant::getNullValue(character_type);
            formatted_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_unformatted) {
            this->visit_expr_load_wrapper(x.m_unformatted, 0);
            std::tie(unformatted, unformatted_len) =
                llvm_utils->get_string_length_data(
                    ASRUtils::get_string_type(x.m_unformatted),
                    tmp);
        } else {
            unformatted = llvm::Constant::getNullValue(character_type);
            unformatted_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }

        if (x.m_iostat) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_iostat, true);
            iostat = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            iostat = llvm::ConstantPointerNull::get(
                llvm::Type::getInt32Ty(context)->getPointerTo());
        }

        if (x.m_nextrec) {
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_nextrec, true);
            nextrec = tmp;
            ptr_loads = ptr_loads_copy;
        } else {
            nextrec = llvm::ConstantPointerNull::get(
                llvm::Type::getInt32Ty(context)->getPointerTo());
        }

        std::string runtime_func_name = "_lfortran_inquire";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        character_type, llvm::Type::getInt64Ty(context),
                        llvm::Type::getInt1Ty(context)->getPointerTo(),
                        llvm::Type::getInt32Ty(context),
                        llvm::Type::getInt1Ty(context)->getPointerTo(),
                        llvm::Type::getInt32Ty(context)->getPointerTo(),
                        llvm::Type::getInt32Ty(context)->getPointerTo(),
                        character_type, llvm::Type::getInt64Ty(context), // write_data, write_len
                        character_type, llvm::Type::getInt64Ty(context), // read_data, read_len
                        character_type, llvm::Type::getInt64Ty(context), // readwrite_data, readwrite_len
                        character_type, llvm::Type::getInt64Ty(context), // access_data, access_len
                        character_type, llvm::Type::getInt64Ty(context),  // name_data, name_len
                        character_type, llvm::Type::getInt64Ty(context),  // blank_data, blank_len
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // recl
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // number
                        llvm::Type::getInt1Ty(context)->getPointerTo(),  // named
                        character_type, llvm::Type::getInt64Ty(context), // sequential, sequential_len
                        character_type, llvm::Type::getInt64Ty(context), // direct, direct_len
                        character_type, llvm::Type::getInt64Ty(context), // form, form_len
                        character_type, llvm::Type::getInt64Ty(context), // formatted, formatted_len
                        character_type, llvm::Type::getInt64Ty(context), // unformatted, unformatted_len
                        llvm::Type::getInt32Ty(context)->getPointerTo(), // iostat
                        llvm::Type::getInt32Ty(context)->getPointerTo()  // nextrec
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, {f_name_data, f_name_len,
            exist_val, unit,
            opened_val, size_val,
            pos_val,
            write, write_len,
            read, read_len,
            readwrite, readwrite_len,
            access_val, access_len,
            name_val, name_len,
            blank_val, blank_len,
            recl, number, named,
            sequential, sequential_len,
            direct, direct_len,
            form, form_len,
            formatted, formatted_len,
            unformatted, unformatted_len,
            iostat, nextrec});
    }

    void visit_Flush(const ASR::Flush_t& x) {
        std::string runtime_func_name = "_lfortran_flush";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        this->visit_expr_wrapper(x.m_unit, true);
        llvm::Value *unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
        builder->CreateCall(fn, {unit_val});
    }

    void visit_FileRewind(const ASR::FileRewind_t &x) {
        std::string runtime_func_name = "_lfortran_rewind";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        this->visit_expr_wrapper(x.m_unit, true);
        llvm::Value *unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
        builder->CreateCall(fn, {unit_val});
    }

    void visit_FileEndfile(const ASR::FileEndfile_t &x) {
        std::string runtime_func_name = "_lfortran_endfile";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        this->visit_expr_wrapper(x.m_unit, true);
        llvm::Value *unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
        builder->CreateCall(fn, {unit_val});
    }

    void visit_FileBackspace(const ASR::FileBackspace_t &x) {
        std::string runtime_func_name = "_lfortran_backspace";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context)
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        this->visit_expr_wrapper(x.m_unit, true);
        llvm::Value *unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
        builder->CreateCall(fn, {unit_val});
    }

    void visit_FileClose(const ASR::FileClose_t &x) {
        llvm::Value *unit_val;
        llvm::Value *status, *status_len;
        llvm::Value *iostat;
        if (ASRUtils::is_character(*expr_type(x.m_unit))) {
            if (x.m_iostat) {
                int ptr_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr_wrapper(x.m_iostat, false);
                ptr_loads = ptr_copy;
                iostat = tmp;
                builder->CreateStore(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0), iostat);
            }
            return;
        }
        this->visit_expr_wrapper(x.m_unit, true);
        unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
        if (x.m_status) {
            this->visit_expr_load_wrapper(x.m_status, 0);
            status = tmp;
            std::tie(status, status_len) = llvm_utils->get_string_length_data(
                                            ASRUtils::get_string_type(x.m_status),
                                            tmp);
        } else {
            status = llvm::Constant::getNullValue(character_type);
            status_len = llvm::ConstantInt::get(context, llvm::APInt(64, 0));
        }
        if (x.m_iostat) {
            int ptr_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_iostat, false);
            ptr_loads = ptr_copy;
            iostat = tmp;
        } else {
            iostat = llvm::ConstantInt::getNullValue(llvm::Type::getInt32Ty(context)->getPointerTo());
        }
        std::string runtime_func_name = "_lfortran_close";
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {
            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), {
                        llvm::Type::getInt32Ty(context),
                        character_type, llvm::Type::getInt64Ty(context), llvm::Type::getInt32Ty(context)->getPointerTo()
                    }, false);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, {unit_val, status, status_len, iostat});
    }

    void visit_Print(const ASR::Print_t &x) {
        handle_print(x.m_text, nullptr);
    }

    void visit_FileWrite(const ASR::FileWrite_t &x) {
        if( x.m_overloaded ) {
            this->visit_stmt(*x.m_overloaded);
            return ;
        }

        // Handle namelist write
        if (x.m_nml) {
            llvm::Value *unit_val, *iostat;

            if (x.m_unit == nullptr) {
                unit_val = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, 6, true));
            } else {
                this->visit_expr_wrapper(x.m_unit, true);
                unit_val = llvm_utils->convert_kind(tmp, llvm::Type::getInt32Ty(context));
            }

            if (x.m_iostat) {
                int ptr_copy = ptr_loads;
                ptr_loads = 0;
                this->visit_expr_wrapper(x.m_iostat, false);
                ptr_loads = ptr_copy;
                iostat = tmp;
            } else {
                iostat = llvm::ConstantPointerNull::get(llvm::Type::getInt32Ty(context)->getPointerTo());
            }

            // Build namelist descriptor and call _lfortran_namelist_write
            llvm::Value* nml_group = build_namelist_descriptor(x.m_nml);

            // Get or create _lfortran_namelist_write function
            std::string func_name = "_lfortran_namelist_write";
            llvm::Function* fn = module->getFunction(func_name);
            if (!fn) {
                // Define item struct type (must match build_namelist_descriptor)
                llvm::StructType* item_type = llvm::StructType::get(
                    character_type,                               // name
                    llvm::Type::getInt32Ty(context),             // type
                    llvm::Type::getInt32Ty(context),             // rank
                    llvm::Type::getInt64Ty(context),             // elem_len
                    llvm::Type::getInt8Ty(context)->getPointerTo(), // data
                    llvm::Type::getInt64Ty(context)->getPointerTo()  // shape
                );
                llvm::StructType* group_type = llvm::StructType::get(
                    character_type,
                    llvm::Type::getInt32Ty(context),
                    item_type->getPointerTo()
                );
                std::vector<llvm::Type*> args{
                    llvm::Type::getInt32Ty(context),         // unit_num
                    llvm::Type::getInt32Ty(context)->getPointerTo(), // iostat
                    group_type->getPointerTo()              // group
                };
                llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), args, false);
                fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, func_name, module.get());
            }

            builder->CreateCall(fn, {unit_val, iostat, nml_group});
            return;
        }

        if (x.m_unit == nullptr) {
            if(x.n_values  == 0){ // TODO : We should remove any function that creates a `FileWrite` with no args
                llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, "%s%s");
                llvm::Value *str_data, *str_len;
                // For empty output, use a space (like old behavior)
                str_data = LCompilers::create_global_string_ptr(context, *module, *builder, " ");
                str_len = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
                llvm::Value *end_data, *end_len;
                if (x.m_end) {
                    std::tie(end_data, end_len) = get_string_data_and_length(x.m_end);
                    end_len = builder->CreateTrunc(end_len, llvm::Type::getInt32Ty(context));
                } else {
                    end_data = LCompilers::create_global_string_ptr(context, *module, *builder, "\n");
                    end_len = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
                }
                printf(context, *module, *builder, { fmt_ptr, str_data, str_len, end_data, end_len });
            } else if (x.n_values == 1){
                handle_print(x.m_values[0], x.m_end);
            } else {
                throw CodeGenError("File write should have single argument of type character)", x.base.base.loc);
            }
            return;
        }
        std::vector<llvm::Value *> args;
        std::vector<llvm::Type *> args_type;
        std::vector<std::string> fmt;
        llvm::Value *sep_data {}, *sep_len {};
        llvm::Value *end_data {}, *end_len {};
        llvm::Value *unit = nullptr;
        llvm::Value *iostat = nullptr;
        std::string runtime_func_name;
        bool is_string = ASRUtils::is_character(*expr_type(x.m_unit));

        int ptr_loads_copy = ptr_loads;
        if ( is_string ) {
            ptr_loads = 0;
            runtime_func_name = "_lfortran_string_write";
            args_type.push_back(character_type->getPointerTo());// str_holder
            args_type.push_back(llvm::Type::getInt8Ty(context)); // is_allocatable
            args_type.push_back(llvm::Type::getInt8Ty(context)); // is_deferred
            args_type.push_back(llvm::Type::getInt64Ty(context)->getPointerTo()); //len
            args_type.push_back(llvm::Type::getInt32Ty(context)->getPointerTo()); //iostat
            args_type.push_back(llvm::Type::getInt8Ty(context)->getPointerTo()); //format_data
            args_type.push_back(llvm::Type::getInt64Ty(context)); // format_len
        } else if ( ASRUtils::is_integer(*expr_type(x.m_unit)) ) {
            ptr_loads = 1;
            runtime_func_name = "_lfortran_file_write";
            args_type.push_back(llvm::Type::getInt32Ty(context)); //unit_num
            args_type.push_back(llvm::Type::getInt32Ty(context)->getPointerTo()); //iostat
            args_type.push_back(llvm::Type::getInt8Ty(context)->getPointerTo()); //format_data
            args_type.push_back(llvm::Type::getInt64Ty(context));//format_len

        } else {
            throw CodeGenError("Unsupported type for `unit` in write(..)");
        }
        // Don't use constant value optimization for assignments to string-sections
        if (is_string && ASR::is_a<ASR::StringSection_t>(*x.m_unit)) {
            bool is_assignment_target_temp = is_assignment_target;
            is_assignment_target = true;
            this->visit_expr_wrapper(x.m_unit);
            is_assignment_target = is_assignment_target_temp;
        } else {
            this->visit_expr_wrapper(x.m_unit);
        }
        ptr_loads = ptr_loads_copy;

        llvm::Value* string_len;
        if(!is_string){
            unit = tmp;
            if (unit->getType()->isPointerTy()) {
                unit = llvm_utils->CreateLoad2(llvm::Type::getInt32Ty(context), unit);
            } else if (unit->getType()->isIntegerTy() &&
                       unit->getType()->getIntegerBitWidth() > 32) {
                // Truncate i64 to i32 for runtime function (ILP64 mode)
                unit = builder->CreateTrunc(unit, llvm::Type::getInt32Ty(context));
            }
        } else { // String Write
            std::tie(unit, string_len) = llvm_utils->get_string_length_data(
                ASRUtils::get_string_type(x.m_unit), tmp, true, true);
        }
        ptr_loads = ptr_loads_copy;

        if (x.m_iostat) {
            int ptr_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_iostat, false);
            ptr_loads = ptr_copy;
            iostat = tmp;
        } else {
            iostat = llvm_utils->CreateAlloca(*builder,
                        llvm::Type::getInt32Ty(context)->getPointerTo());
            builder->CreateStore(llvm::ConstantInt::getNullValue(
                llvm::Type::getInt32Ty(context)->getPointerTo()), iostat);
            iostat = llvm_utils->CreateLoad2(llvm::Type::getInt32Ty(context)->getPointerTo(), iostat);
        }
        
        if (x.m_rec && !is_string) {
            emit_seek_record_from_rec(x.m_rec, unit, iostat);
        }

        if (x.m_separator) {
            std::tie(sep_data, sep_len) = get_string_data_and_length(x.m_separator);
        } else {
            sep_data = LCompilers::create_global_string_ptr(context, *module, *builder, " ");
            sep_len = llvm::ConstantInt::get(context, llvm::APInt(64, 1));
        }
        if (x.m_end) {
            std::tie(end_data, end_len) = get_string_data_and_length(x.m_end);
        } else {
            end_data = LCompilers::create_global_string_ptr(context, *module, *builder, "\n");
            end_len = llvm::ConstantInt::get(context, llvm::APInt(64, 1));
        }
        size_t n_values = x.n_values; ASR::expr_t **m_values = x.m_values;
        for (size_t i=0; i<n_values; i++) {
            if (i != 0 && !is_string && x.m_is_formatted) {
                fmt.push_back("%s");
                args.push_back(sep_data);
                args.push_back(sep_len);
            }
            if (!x.m_is_formatted) {
                ASR::ttype_t* value_type = ASRUtils::extract_type(ASRUtils::expr_type(m_values[i]));
                ASR::ttype_t* value_type_base = ASRUtils::type_get_past_array(value_type);
                int kind = ASRUtils::extract_kind_from_ttype_t(value_type_base);
                if (ASR::is_a<ASR::Complex_t>(*value_type_base)) {
                    kind *= 2;
                }
                llvm::Value* kind_val = llvm::ConstantInt::get(context, llvm::APInt(32, kind, true));
                ASR::ttype_t *type32 = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
                if (ASRUtils::is_array(ASRUtils::expr_type(m_values[i])) &&
                    ASR::is_a<ASR::Logical_t>(*value_type_base)) {
                    ASR::ArraySize_t* array_size_node = ASR::down_cast2<ASR::ArraySize_t>(
                        ASR::make_ArraySize_t(al, m_values[i]->base.loc,
                            m_values[i], nullptr, type32, nullptr));
                    visit_ArraySize(*array_size_node);
                    llvm::Value* array_size_val = tmp;
                    args.push_back(builder->CreateMul(kind_val, array_size_val));
                    {
                        int64_t ptr_loads_save = ptr_loads;
                        int reduce_loads = 0;
                        ptr_loads = 2;
                        if (ASR::is_a<ASR::Var_t>(*m_values[i])) {
                            ASR::Variable_t* var = ASRUtils::EXPR2VAR(m_values[i]);
                            reduce_loads = var->m_intent == ASRUtils::intent_in;
                            if (LLVM::is_llvm_pointer(*var->m_type)) {
                                ptr_loads = 1;
                            }
                        }
                        ptr_loads = ptr_loads - reduce_loads;
                        ASR::ttype_t *arr_t = ASRUtils::expr_type(m_values[i]);
                        this->visit_expr_load_wrapper(m_values[i], (ASRUtils::is_character(*arr_t) ? 0 : ptr_loads), true);
                        ptr_loads = ptr_loads_save;
                        load_non_array_non_character_pointers(m_values[i], arr_t, tmp);
                        if (ASRUtils::is_array(arr_t) && ASRUtils::is_allocatable(arr_t)) {
                            llvm::Type *llvm_type = llvm_utils->get_type_from_ttype_t_util(m_values[i],
                                ASRUtils::extract_type(arr_t), module.get());
                            tmp = llvm_utils->CreateLoad2(llvm_type->getPointerTo(), tmp);
                        }
                    }
                    llvm::Value* src_ptr = tmp;
                    llvm::Type* i8_ptr_ty = llvm::PointerType::getUnqual(llvm::Type::getInt8Ty(context));
                    if (src_ptr->getType() != i8_ptr_ty) {
                        src_ptr = builder->CreateBitCast(src_ptr, i8_ptr_ty);
                    }

                    llvm::Value* tmp_i32_arr = llvm_utils->CreateAlloca(
                        *builder, llvm::Type::getInt32Ty(context), array_size_val);

                    llvm::BasicBlock *loop_head = llvm::BasicBlock::Create(
                        context, "logical_expand_head", builder->GetInsertBlock()->getParent());
                    llvm::BasicBlock *loop_body = llvm::BasicBlock::Create(
                        context, "logical_expand_body", builder->GetInsertBlock()->getParent());
                    llvm::BasicBlock *loop_end = llvm::BasicBlock::Create(
                        context, "logical_expand_end", builder->GetInsertBlock()->getParent());

                    llvm::Value* idx_ptr = llvm_utils->CreateAlloca(
                        *builder, llvm::Type::getInt32Ty(context));
                    builder->CreateStore(
                        llvm::ConstantInt::get(context, llvm::APInt(32, 0)), idx_ptr);
                    builder->CreateBr(loop_head);
                    
                    builder->SetInsertPoint(loop_head);
                    llvm::Value* idx = llvm_utils->CreateLoad2(
                        llvm::Type::getInt32Ty(context), idx_ptr);
                    llvm::Value* cond = builder->CreateICmpSLT(idx, array_size_val);
                    builder->CreateCondBr(cond, loop_body, loop_end);

                    builder->SetInsertPoint(loop_body);
                    idx = llvm_utils->CreateLoad2(llvm::Type::getInt32Ty(context), idx_ptr);
                    llvm::Value* src_elem_ptr = builder->CreateGEP(
                        llvm::Type::getInt8Ty(context), src_ptr, idx);
                    llvm::Value* elem_i8 = llvm_utils->CreateLoad2(
                        llvm::Type::getInt8Ty(context), src_elem_ptr);
                    llvm::Value* elem_i32 = builder->CreateZExt(
                        elem_i8, llvm::Type::getInt32Ty(context));
                    llvm::Value* dst_elem_ptr = builder->CreateGEP(
                        llvm::Type::getInt32Ty(context), tmp_i32_arr, idx);
                    builder->CreateStore(elem_i32, dst_elem_ptr);
                    llvm::Value* next_idx = builder->CreateAdd(
                        idx, llvm::ConstantInt::get(context, llvm::APInt(32, 1)));
                    builder->CreateStore(next_idx, idx_ptr);
                    builder->CreateBr(loop_head);
                    
                    builder->SetInsertPoint(loop_end);
                    args.push_back(tmp_i32_arr);
                    continue;
                } else if (ASRUtils::is_array(ASRUtils::expr_type(m_values[i]))) {
                    ASR::ArraySize_t* array_size = ASR::down_cast2<ASR::ArraySize_t>(ASR::make_ArraySize_t(al, m_values[i]->base.loc,
                        m_values[i], nullptr, type32, nullptr));
                    visit_ArraySize(*array_size);
                    args.push_back(builder->CreateMul(kind_val, tmp));
                } else if (ASRUtils::is_character(*ASRUtils::expr_type(m_values[i]))) {
                    ASR::StringLen_t * strlen = ASR::down_cast2<ASR::StringLen_t>(ASR::make_StringLen_t(al,
                        m_values[i]->base.loc, m_values[i], type32, nullptr));
                    visit_StringLen(*strlen);
                    args.push_back(builder->CreateMul(kind_val, tmp));
                    ptr_loads = 0;
                    this->visit_expr_wrapper(m_values[i], true);
                    ptr_loads = ptr_loads_copy;
                    llvm::Value* str_data = llvm_utils->get_string_data(ASRUtils::get_string_type(m_values[i]), tmp);
                    args.push_back(str_data);
                    continue;
                } else if (ASR::is_a<ASR::Logical_t>(*value_type_base)) {
                    args.push_back(kind_val);
                    this->visit_expr_wrapper(m_values[i], true);
                    llvm::Value* logical_val = tmp;
                    if (logical_val->getType()->isPointerTy()) {
                        logical_val = llvm_utils->CreateLoad2(llvm::Type::getInt1Ty(context), logical_val);
                    }
                    llvm::Value* logical_i32 = builder->CreateZExt(
                        logical_val, llvm::Type::getInt32Ty(context));
                    llvm::Value* logical_ptr = llvm_utils->CreateAlloca(
                        *builder, llvm::Type::getInt32Ty(context));
                    builder->CreateStore(logical_i32, logical_ptr);
                    args.push_back(logical_ptr);
                    continue;
                } else {
                    args.push_back(kind_val);
                    this->visit_expr_wrapper(m_values[i], true);
                    llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(m_values[i], ASRUtils::expr_type(m_values[i]), module.get());
                    llvm::Value* llvm_arg = llvm_utils->CreateAlloca(*builder, type);
                    builder->CreateStore(tmp, llvm_arg);
                    args.push_back(llvm_arg);
                    continue;

                }
            }
            compute_fmt_specifier_and_arg(fmt, args, m_values[i],
                x.base.base.loc); // return of visited expression `m_values[i]` stored in `tmp`

            // Push the length of the string to args
            ASR::ttype_t *t = ASRUtils::extract_type(ASRUtils::expr_type(m_values[i]));
            if (x.m_is_formatted && ASRUtils::is_character(*t)) {
                llvm::Value *str_len = llvm_utils->get_string_length(ASRUtils::get_string_type(t), tmp);
                args.push_back(str_len);
            }
        }
        if (!x.m_is_formatted) {  // give -1 argument for end of arguments
            llvm::Value* minus_one = llvm::ConstantInt::get(context, llvm::APInt(32, -1, true));
            args.push_back(minus_one);
        } else if (!is_string) {
            fmt.push_back("%s");
            args.push_back(end_data);
            args.push_back(end_len);
        }
        std::string fmt_str {};
        if(x.m_is_formatted){
            for (size_t i=0; i<fmt.size(); i++) {
                fmt_str += fmt[i];
            }
        } else {
            // Don't provide format.
        }
        llvm::Value *fmt_data = LCompilers::create_global_string_ptr(context, *module, *builder, fmt_str);
        llvm::Value *fmt_len = llvm::ConstantInt::get(context, llvm::APInt(64, fmt_str.length()));


        std::vector<llvm::Value *> printf_args;
        printf_args.push_back(unit);
        if(is_string){
            llvm::Value* is_allocatable = llvm::ConstantInt::get(context, llvm::APInt(8,
                ASRUtils::is_allocatable(ASRUtils::expr_type(x.m_unit))));
            llvm::Value* is_deferred = llvm::ConstantInt::get(context, llvm::APInt(8,
                ASRUtils::is_deferredLength_string(ASRUtils::expr_type(x.m_unit))));
            printf_args.push_back(is_allocatable);
            printf_args.push_back(is_deferred);
            printf_args.push_back(string_len);
        }
        printf_args.push_back(iostat);
        printf_args.push_back(fmt_data);
        printf_args.push_back(fmt_len);
        printf_args.insert(printf_args.end(), args.begin(), args.end());
        llvm::Function *fn = module->getFunction(runtime_func_name);
        if (!fn) {

            llvm::FunctionType *function_type = llvm::FunctionType::get(
                    llvm::Type::getVoidTy(context), args_type, true);
            fn = llvm::Function::Create(function_type,
                    llvm::Function::ExternalLinkage, runtime_func_name, module.get());
        }
        tmp = builder->CreateCall(fn, printf_args);
        llvm_utils->stringFormat_return.free();
    }

    std::string serialize_structType_symbols(ASR::symbol_t* sym){
        std::string res {};
        ASR::Struct_t* StructSymbol = ASR::down_cast<ASR::Struct_t>(sym);
        for(size_t i=0; i < StructSymbol->n_members; i++){
            ASR::symbol_t* StructMember = StructSymbol->m_symtab->
                                            get_symbol(StructSymbol->m_members[i]);
            res += SerializeType(ASRUtils::get_expr_from_sym(al, StructMember), ASRUtils::symbol_type(StructMember), true);
            if(i < StructSymbol->n_members-1){
                res += ",";
            }
        }
        return res;
    }

    /*
        [ ] --> Array
        ( ) --> Struct
        I   --> Integer
        R   --> Real
        S-PhysicalType-len? --> Character [S-DESC-10, S-CCHAR-1, S-DESC]
        L   --> Logical
        { } --> Struct for COMPLEX
        The serialization corresponds to how these arguments are represented in LLVM backend;
        So, Complex type results in `{R, R}` as it's a struct of floating types in the backend.
    */

    // Serialize `type` using symbols above.
    std::string SerializeType(ASR::expr_t* expr, ASR::ttype_t* type, bool in_struct) {
        std::string res {};
        type = ASRUtils::type_get_past_allocatable(
                ASRUtils::type_get_past_pointer(type));
        if (ASR::is_a<ASR::Integer_t>(*type)) {
            res += "I";
            res += std::to_string(ASRUtils::extract_kind_from_ttype_t(type));
        } else if (ASR::is_a<ASR::UnsignedInteger_t>(*type)) {
            res += "U";
            res += std::to_string(ASRUtils::extract_kind_from_ttype_t(type));
        } else if (ASR::is_a<ASR::Real_t>(*type)) {
            res += "R";
            res += std::to_string(ASRUtils::extract_kind_from_ttype_t(type));
        } else if (ASR::is_a<ASR::String_t>(*type)) {
            res += "S-";
            ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(type);
            if(str_type->m_physical_type == ASR::DescriptorString) res += "DESC";
            else if(str_type->m_physical_type == ASR::CChar) res +="CCHAR";
            else throw LCompilersException("Unhandled string physical type");
            int len;
            if(ASRUtils::extract_value(str_type->m_len, len)){res += "-" + std::to_string(len);}
        } else if (ASR::is_a<ASR::Complex_t>(*type)){
            res += "{R" + std::to_string(ASRUtils::extract_kind_from_ttype_t(type))+
                    ",R" + std::to_string(ASRUtils::extract_kind_from_ttype_t(type))+
                    "}";
        } else if (ASR::is_a<ASR::Array_t>(*type)) {
            // push array size only if it's not a struct member.
            if(in_struct && ASRUtils::is_fixed_size_array(type)){
                res += std::to_string(ASRUtils::get_fixed_size_of_array(type));
            } else if (in_struct && !ASRUtils::is_fixed_size_array(type)){
                // TODO : Throw a semantic error instead.
                throw CodeGenError("Can't print type variable with dynamic array member");
            }
            res += "[";
            res += SerializeType(expr, ASR::down_cast<ASR::Array_t>(type)->m_type, in_struct);
            res += "]";
        } else if (ASR::is_a<ASR::StructType_t>(*type)) {
            res += "(";
            res += serialize_structType_symbols(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(expr)));
            res += ")";
        } else if (ASR::is_a<ASR::Logical_t>(*type)) {
            res += "L";
        } else if(ASR::is_a<ASR::CPtr_t>(*type)){
            res += "CPtr";
        } else {
            throw CodeGenError("Printing support is not available for `" +
                ASRUtils::type_to_str_fortran_expr(type, expr) + "` type.");
        }
        return res;
    }
    // Serializes the types of a list of expressions.
    llvm::Value* SerializeExprTypes(ASR::expr_t** args, size_t n_args){
        std::string serialization_res = "";
        for (size_t i=0; i<n_args; i++) {
            serialization_res += SerializeType(args[i], ASRUtils::expr_type(args[i]), false);
            if(i != n_args-1){
                serialization_res += ",";
            }
        }
        return LCompilers::create_global_string_ptr(context, *module, *builder, serialization_res, "serialization_info");
    }

    void compute_fmt_specifier_and_arg(std::vector<std::string> &fmt,
        std::vector<llvm::Value *> &args, ASR::expr_t *v, const Location &loc) {
        int64_t ptr_loads_copy = ptr_loads;
        int reduce_loads = 0;
        ptr_loads = 2;
        if( ASR::is_a<ASR::Var_t>(*v) ) {
            ASR::Variable_t* var = ASRUtils::EXPR2VAR(v);
            reduce_loads = var->m_intent == ASRUtils::intent_in;
            if( LLVM::is_llvm_pointer(*var->m_type) ) {
                ptr_loads = 1;
            }
        }

        ptr_loads = ptr_loads - reduce_loads;
        lookup_enum_value_for_nonints = true;
        ASR::ttype_t *t = ASRUtils::expr_type(v);
        this->visit_expr_load_wrapper(v, (ASRUtils::is_character(*t) ? 0 : ptr_loads), true);
        lookup_enum_value_for_nonints = false;
        ptr_loads = ptr_loads_copy;

        if ((t->type == ASR::ttypeType::CPtr && !ASRUtils::is_array(t)) ||
            (t->type == ASR::ttypeType::Pointer &&
                (ASR::is_a<ASR::Var_t>(*v) || ASR::is_a<ASR::GetPointer_t>(*v))
                && !ASRUtils::is_array(t) && !ASRUtils::is_character(*t))
            ) {
            fmt.push_back("%lld");
            llvm::Value* d = builder->CreatePtrToInt(tmp, llvm_utils->getIntType(8, false));
            args.push_back(d);
            return ;
        }

        load_non_array_non_character_pointers(v, ASRUtils::expr_type(v), tmp);
        if (ASRUtils::is_array(t) && ASRUtils::is_allocatable(t)) {
            llvm::Type *llvm_type = llvm_utils->get_type_from_ttype_t_util(v,
                ASRUtils::extract_type(t), module.get());
            tmp = llvm_utils->CreateLoad2(llvm_type->getPointerTo(), tmp);
        }
        t = ASRUtils::extract_type(t);
        int a_kind = ASRUtils::extract_kind_from_ttype_t(t);

        if (ASRUtils::is_integer(*t)) {
            switch( a_kind ) {
                case 1 : {
                    fmt.push_back("%hhi");
                    break;
                }
                case 2 : {
                    fmt.push_back("%hi");
                    break;
                }
                case 4 : {
                    fmt.push_back("%d");
                    break;
                }
                case 8 : {
                    fmt.push_back("%lld");
                    break;
                }
                default: {
                    throw CodeGenError(R"""(Printing support is available only
                                        for 8, 16, 32, and 64 bit integer kinds.)""",
                                        loc);
                }
            }
            args.push_back(tmp);
        } else if (ASRUtils::is_unsigned_integer(*t)) {
            switch( a_kind ) {
                case 1 : {
                    fmt.push_back("%hhu");
                    break;
                }
                case 2 : {
                    fmt.push_back("%hu");
                    break;
                }
                case 4 : {
                    fmt.push_back("%u");
                    break;
                }
                case 8 : {
                    fmt.push_back("%llu");
                    break;
                }
                default: {
                    throw CodeGenError(R"""(Printing support is available only
                                        for 8, 16, 32, and 64 bit unsigned integer kinds.)""",
                                        loc);
                }
            }
            args.push_back(tmp);
        } else if (ASRUtils::is_real(*t)) {
            switch( a_kind ) {
                case 4 : {
                        fmt.push_back("%13.8e");
                    break;
                }
                case 8 : {
                        fmt.push_back("%23.17e");
                    break;
                }
                default: {
                    throw CodeGenError(R"""(Printing support is available only
                                        for 32, and 64 bit real kinds.)""",
                                        loc);
                }
            }
            args.push_back(tmp);
        } else if (t->type == ASR::ttypeType::String) {
            fmt.push_back("%s");
            args.push_back(llvm_utils->get_string_data(ASRUtils::get_string_type(t), tmp));
        } else if (ASRUtils::is_logical(*t)) {
            fmt.push_back("%s");
            args.push_back(tmp);
        } else if (ASRUtils::is_complex(*t)) {
            switch( a_kind ) {
                case 4 : {
                    fmt.push_back("(%f,%f)");
                    break;
                }
                case 8 : {
                    fmt.push_back("(%lf,%lf)");
                    break;
                }
                default: {
                    throw CodeGenError(R"""(Printing support is available only
                                        for 32, and 64 bit complex kinds.)""",
                                        loc);
                }
            }
            args.push_back(tmp);
        } else if (t->type == ASR::ttypeType::CPtr) {
            fmt.push_back("%lld");
            args.push_back(tmp);
        } else if (t->type == ASR::ttypeType::EnumType) {
            // TODO: Use recursion to generalise for any underlying type in enum
            fmt.push_back("%d");
            args.push_back(tmp);
        } else {
            throw CodeGenError("Printing support is not available for `" +
                ASRUtils::type_to_str_fortran_expr(t, v) + "` type.", loc);
        }
    }

    void handle_print(ASR::expr_t* arg, ASR::expr_t* end_expr)
    {
        ASR::ttype_t* t = ASRUtils::expr_type(arg);
        llvm::Value* main_data = nullptr;
        llvm::Value* main_len = nullptr;

        // End string (always computed once)
        llvm::Value *end_data, *end_len;
        if (end_expr == nullptr) {
            end_data = LCompilers::create_global_string_ptr(context, *module, *builder, "\n");
            end_len = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
        } else {
            std::tie(end_data, end_len) = get_string_data_and_length(end_expr);
            end_len = builder->CreateTrunc(end_len, llvm::Type::getInt32Ty(context));
        }

        std::string fmt_str;

        if (ASRUtils::is_character(*t)) {
            // --- String path ---
            std::tie(main_data, main_len) = get_string_data_and_length(arg);
            main_len = builder->CreateTrunc(main_len, llvm::Type::getInt32Ty(context));
            fmt_str = "%s";
        } else {
            // --- Non-string path ---
            // Evaluate once
            this->visit_expr_wrapper(arg, true);
            llvm::Value* val = tmp;  // integer/real/etc value
            main_len = llvm::ConstantInt::get(context, llvm::APInt(32, 0));  // no length for non-string

            // Determine correct printf specifier
            std::vector<std::string> fmt_parts;
            std::vector<llvm::Value*> dummy_args;
            dummy_args.push_back(nullptr);
            compute_fmt_specifier_and_arg(fmt_parts, dummy_args, arg, arg->base.loc);

            fmt_str.clear();
            for (auto& f : fmt_parts)
                fmt_str += f;
            llvm::Value* as_i32 = builder->CreateSExtOrBitCast(val, llvm::Type::getInt32Ty(context));
            main_data = builder->CreateIntToPtr(as_i32, llvm::PointerType::getUnqual(llvm::Type::getInt8Ty(context)));
        }
        fmt_str += "%s";
        llvm::Value* fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, fmt_str);
        printf(context, *module, *builder, { fmt_ptr, main_data, main_len, end_data, end_len });
        llvm_utils->stringFormat_return.free();
    }

    void handle_bitcast_assignment_char(const ASR::Assignment_t &x) {
        // Handler for BitCast (transfer intrinsic) to character arrays
        // Used for Element by Element assignment
        // Note: Called only when element type to be assigned is character array
        ASR::ttype_t* target_type = ASRUtils::expr_type(x.m_target);
        ASR::ttype_t* elem_type = target_type;
        if (ASRUtils::is_array(target_type)) {
            elem_type = ASRUtils::extract_type(target_type);
        }
        auto with_value_semantics = [&](auto func) {
            int64_t saved = ptr_loads;
            ptr_loads = 0;
            func();
            ptr_loads = saved;
        };
        LCOMPILERS_ASSERT(x.m_target->type == ASR::exprType::ArrayItem);
        ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(x.m_target);
        is_assignment_target = true;
        visit_expr(*x.m_target);
        is_assignment_target = false;
        llvm::Value* target_ptr = tmp;

        visit_expr_wrapper(array_item->m_args[0].m_right, true);
        llvm::Value* array_index = tmp;
        llvm::Value* zero_based_idx = builder->CreateSub(array_index,
            llvm::ConstantInt::get(array_index->getType(), 1));
        
        // Calculate byte offset: index * element_length
        // For character(len=2): element 0 at byte 0, element 1 at byte 2, etc.
        ASR::String_t* src_str_type = ASR::down_cast<ASR::String_t>(
            ASRUtils::type_get_past_array(ASRUtils::expr_type(x.m_value)));

        ASR::String_t* dest_str_type = ASR::down_cast<ASR::String_t>(elem_type);
        llvm::Value* element_length_val;
        if (dest_str_type->m_len && ASR::is_a<ASR::IntegerConstant_t>(*dest_str_type->m_len)) {
            ASR::IntegerConstant_t* len = ASR::down_cast<ASR::IntegerConstant_t>(dest_str_type->m_len);
            element_length_val = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), len->m_n);
        } else {
            // If runtime-sized, extract it or default is set at len=1 
            element_length_val = llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 1);
        }

        llvm::Value* bitcast_descriptor;
        with_value_semantics([&]() { visit_expr_wrapper(x.m_value, true); bitcast_descriptor = tmp; });
        llvm::Value* byte_offset = builder->CreateMul(zero_based_idx, element_length_val);
        llvm::Value* byte_ptr = builder->CreateGEP(llvm::Type::getInt8Ty(context),
            llvm_utils->get_string_data(src_str_type, bitcast_descriptor), byte_offset);
        
        // Get destination string descriptor pointers and copy element_length bytes
        auto [dest_data_ptr, dest_len_ptr] = llvm_utils->get_string_length_data(
            dest_str_type, target_ptr, true, true);
        llvm::Value* copy_length;
        if (dest_str_type->m_len && ASR::is_a<ASR::IntegerConstant_t>(*dest_str_type->m_len)) {
            ASR::IntegerConstant_t* len = ASR::down_cast<ASR::IntegerConstant_t>(dest_str_type->m_len);
            copy_length = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), len->m_n);
        } else {
            copy_length = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 1);
        }
        llvm_utils->lfortran_str_copy_with_data(dest_data_ptr, dest_len_ptr, byte_ptr,
            copy_length, false, false);
        tmp = nullptr;
        return;
    }

    void construct_stop(llvm::Value* exit_code, std::string stop_msg, ASR::expr_t* stop_code, Location /*loc*/) {
        std::string fmt {};
        std::vector<llvm::Value*> args;
        args.push_back(nullptr); // reserve space for fmt_str

        /* STOP MSG ("ERROR STOP") */
        {
            llvm::Value* STOP_MSG {};
            STOP_MSG = module->getNamedGlobal(stop_msg);
            if(!STOP_MSG) {STOP_MSG = builder->CreateGlobalString(stop_msg, stop_msg);} 
            STOP_MSG = builder->CreateBitCast(STOP_MSG, llvm::Type::getInt8Ty(context)->getPointerTo());
            fmt += "%s";
            args.push_back(STOP_MSG); // Null-Terminated String
        }

        /* SPACE + STOP CODE */
        if (stop_code && ASR::is_a<ASR::Integer_t>(*expr_type(stop_code))) {
            if(ASRUtils::extract_kind_from_ttype_t(expr_type(stop_code)) != 4) throw LCompilersException("Kind in Stop code should be = 4");
            fmt += " %d";
            visit_expr(*stop_code);
            llvm::Value* stop_code_int = tmp; tmp = nullptr;
            args.push_back(stop_code_int);
        } else if(stop_code && ASRUtils::is_string_only(expr_type(stop_code))){
            fmt += " %.*s";
            visit_expr_load_wrapper(stop_code, 0);
            llvm::Value* stop_code_str = tmp; tmp = nullptr;
            args.push_back(llvm_utils->get_string_length(ASRUtils::get_string_type(stop_code), stop_code_str));
            args.push_back(llvm_utils->get_string_data  (ASRUtils::get_string_type(stop_code), stop_code_str));
        } else if (stop_code){
            throw LCompilersException(
                "Stop Code should be of type [String, Integer].\n"
                "CurrentType : "+ASRUtils::type_to_str_fortran_expr(expr_type(stop_code), stop_code));
        } else if(!stop_code){
            // Do Nothing. Stop With No Error Message.
        }
        
        /* NEWLINE */
        {
            llvm::Value* NEWLINE = LCompilers::create_global_string_ptr(context, *module, *builder, "\n");
            fmt += "%s";
            args.push_back(NEWLINE); // Null-Terminated
        }

        /* PRINT ERROR */
        llvm::Value *fmt_ptr {};
        fmt_ptr = module->getNamedGlobal(fmt);
        if(!fmt_ptr) {fmt_ptr = builder->CreateGlobalString(fmt);}
        fmt_ptr = builder->CreateBitCast(fmt_ptr, llvm::Type::getInt8Ty(context)->getPointerTo());

        args[0] = fmt_ptr;
        print_error(context, *module, *builder, args);

        /* EXIT WITH CODE */
        if (stop_code && is_a<ASR::Integer_t>(*ASRUtils::expr_type(stop_code))) {
            this->visit_expr(*stop_code);
            exit_code = tmp;
        }
        exit(context, *module, *builder, exit_code);
    }

    void visit_Stop(const ASR::Stop_t &x) {
        if (compiler_options.emit_debug_info) {
            debug_emit_loc(x);
            if (x.m_code && is_a<ASR::Integer_t>(*ASRUtils::expr_type(x.m_code))) {
                llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, infile);
                llvm::Value *fmt_ptr1 = llvm::ConstantInt::get(context, llvm::APInt(
                    1, compiler_options.use_colors));
                this->visit_expr(*x.m_code);
                llvm::Value *test = builder->CreateICmpNE(tmp, builder->getInt32(0));
                llvm_utils->create_if_else(test, [=]() {
                    call_print_stacktrace_addresses(context, *module, *builder,
                        {fmt_ptr, fmt_ptr1});
                }, [](){});
            }
        }

        int exit_code_int = 0;
        llvm::Value *exit_code = llvm::ConstantInt::get(context,
                llvm::APInt(32, exit_code_int));
        construct_stop(exit_code, "STOP", x.m_code, x.base.base.loc);
    }

    void visit_ErrorStop(const ASR::ErrorStop_t &x) {
        if (compiler_options.emit_debug_info) {
            debug_emit_loc(x);
            llvm::Value *fmt_ptr = LCompilers::create_global_string_ptr(context, *module, *builder, infile);
            llvm::Value *fmt_ptr1 = llvm::ConstantInt::get(context, llvm::APInt(
                1, compiler_options.use_colors));
            call_print_stacktrace_addresses(context, *module, *builder,
                {fmt_ptr, fmt_ptr1});
        }

        int exit_code_int = 1;
        llvm::Value *exit_code = llvm::ConstantInt::get(context,
                llvm::APInt(32, exit_code_int));
        construct_stop(exit_code, "ERROR STOP", x.m_code, x.base.base.loc);
    }

    template <typename T>
    inline void set_func_subrout_params(T* func_subrout, ASR::abiType& x_abi,
                                        std::uint32_t& m_h, ASR::Variable_t*& orig_arg,
                                        std::string& orig_arg_name, ASR::intentType& arg_intent,
                                        size_t arg_idx) {
        m_h = get_hash((ASR::asr_t*)func_subrout);
        LCOMPILERS_ASSERT(arg_idx < func_subrout->n_args);
        if( ASR::is_a<ASR::Var_t>(*func_subrout->m_args[arg_idx]) ) {
            ASR::Var_t* arg_var = ASR::down_cast<ASR::Var_t>(func_subrout->m_args[arg_idx]);
            ASR::symbol_t* arg_sym = symbol_get_past_external(arg_var->m_v);
            if( ASR::is_a<ASR::Variable_t>(*arg_sym) ) {
                orig_arg = ASR::down_cast<ASR::Variable_t>(arg_sym);
                orig_arg_name = orig_arg->m_name;
                arg_intent = orig_arg->m_intent;
            }
        }
        x_abi = ASRUtils::get_FunctionType(func_subrout)->m_abi;
    }

    /// Checks if types are of matching stringPhysicalType.
    /// If expressions aren't of string type, Do NOTHING.
    void check_strings_phsyicalType_match(ASR::ttype_t* const a, ASR::ttype_t* const b){
        if(ASRUtils::type_get_past_allocatable(a)->type == ASR::Array
        || ASRUtils::type_get_past_allocatable(b)->type == ASR::Array) return; //Don't Check - Workaround for now

        if(ASRUtils::extract_type(a)->type == ASR::String
            && ASRUtils::extract_type(b)->type == ASR::String){
            LCOMPILERS_ASSERT_MSG(
                ASRUtils::is_character_phsyical_types_matched(
                    ASRUtils::extract_type(a),
                    ASRUtils::extract_type(b)),
                "Unmatching String Physical Types");
        }        
    }

    template <typename T>
    std::vector<llvm::Value*> convert_call_args(const T &x, bool is_method) {
        std::vector<llvm::Value *> args;
        convert_call_args_depth++;
        // Only reset alloca pool indices at outermost call to avoid
        // nested calls (in argument expressions) clobbering allocas
        if (convert_call_args_depth == 1) {
            reset_call_arg_alloca_pool();
        }
        for (size_t i=0; i<x.n_args; i++) {
            ASR::symbol_t* func_subrout = symbol_get_past_external(x.m_name);
            ASR::abiType x_abi = (ASR::abiType) 0;
            ASR::intentType orig_arg_intent = ASR::intentType::Unspecified;
            std::uint32_t m_h;
            ASR::Variable_t *orig_arg = nullptr;
            std::string orig_arg_name = "";
            if( func_subrout->type == ASR::symbolType::Function ) {
                ASR::Function_t* func = down_cast<ASR::Function_t>(func_subrout);
                set_func_subrout_params(func, x_abi, m_h, orig_arg, orig_arg_name, orig_arg_intent, i + is_method);
            } else if( func_subrout->type == ASR::symbolType::StructMethodDeclaration ) {
                ASR::StructMethodDeclaration_t* clss_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(func_subrout);
                if( clss_proc->m_proc->type == ASR::symbolType::Function ) {
                    ASR::Function_t* func = down_cast<ASR::Function_t>(clss_proc->m_proc);
                    set_func_subrout_params(func, x_abi, m_h, orig_arg, orig_arg_name, orig_arg_intent, i + is_method);
                    func_subrout = clss_proc->m_proc;
                }
            } else if( func_subrout->type == ASR::symbolType::Variable ) {
                ASR::Variable_t* v = down_cast<ASR::Variable_t>(func_subrout);
                if (v->m_type_declaration != nullptr) {
                    ASR::Function_t* func = down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(v->m_type_declaration));
                    func_subrout = ASRUtils::symbol_get_past_external(v->m_type_declaration);
                    set_func_subrout_params(func, x_abi, m_h, orig_arg, orig_arg_name, orig_arg_intent, i + is_method);
                }
                // If m_type_declaration is nullptr (implicit interface without call),
                // continue with default values for x_abi, orig_arg, etc.
            } else {
                LCOMPILERS_ASSERT(false)
            }

            if(orig_arg && x.m_args[i].m_value){
                check_strings_phsyicalType_match(orig_arg->m_type, expr_type(x.m_args[i].m_value));
            }
            
            if( x.m_args[i].m_value == nullptr ) {
                LCOMPILERS_ASSERT(orig_arg != nullptr);
                llvm::Type* llvm_orig_arg_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, orig_arg->base.base.loc, &orig_arg->base)),
                    orig_arg->m_type, module.get());
                llvm::Value* llvm_arg = llvm_utils->CreateAlloca(*builder, llvm_orig_arg_type);
                args.push_back(llvm_arg);
                continue ;
            }

            if (ASR::is_a<ASR::Var_t>(*x.m_args[i].m_value)) {
                ASR::symbol_t* var_sym = ASRUtils::symbol_get_past_external(
                    ASR::down_cast<ASR::Var_t>(x.m_args[i].m_value)->m_v);
                if (ASR::is_a<ASR::Variable_t>(*var_sym)) {
                    ASR::Variable_t *arg = EXPR2VAR(x.m_args[i].m_value);
                    uint32_t h = get_hash((ASR::asr_t*)arg);
                    if (llvm_symtab.find(h) != llvm_symtab.end()) {
                        if (llvm_symtab_deep_copy.find({h, current_scope}) != llvm_symtab_deep_copy.end()) {
                            tmp = llvm_symtab_deep_copy[{h, current_scope}];
                        } else {
                            tmp = llvm_symtab[h];
                        }
                        if( !ASRUtils::is_array(arg->m_type) ) {

                            if ((x_abi == ASR::abiType::Source || x_abi == ASR::abiType::ExternalUndefined)
                                     && ASR::is_a<ASR::CPtr_t>(*arg->m_type)) {
                                if ( orig_arg_intent != ASRUtils::intent_out &&
                                        arg->m_intent == intent_local ) {
                                    // Local variable of type
                                    // CPtr is a void**, so we
                                    // have to load it
                                    llvm::Type* cptr_type = llvm::Type::getVoidTy(context)->getPointerTo();
                                    tmp = llvm_utils->CreateLoad2(cptr_type, tmp);
                                }
                            } else if ( x_abi == ASR::abiType::BindC && orig_arg != nullptr ) {
                                if (orig_arg->m_abi == ASR::abiType::BindC && orig_arg->m_value_attr) {
                                    ASR::ttype_t* arg_type = arg->m_type;
                                    llvm::Type* arg_llvm_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                                        al, arg->base.base.loc, &arg->base)), arg_type, module.get());
                                    if (ASR::is_a<ASR::Complex_t>(*arg_type)) {
                                        if (!startswith(compiler_options.target, "wasm")) {
                                            int c_kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                                            if (c_kind == 4) {
                                                if (compiler_options.platform == Platform::Windows) {
                                                    // tmp is {float, float}*
                                                    // type_fx2 is i64
                                                    llvm::Type* type_fx2 = llvm::Type::getInt64Ty(context);
                                                    tmp = llvm_utils->CreateLoad2(type_fx2, tmp);
                                                } else if (compiler_options.platform == Platform::macOS_ARM) {
                                                    // tmp is {float, float}*
                                                    // type_fx2 is [2 x float]
                                                    llvm::Type* type_fx2 = llvm::ArrayType::get(llvm::Type::getFloatTy(context), 2);
                                                    // we bitcast complex_type_4 to [2 x float]*
                                                    llvm::Value *complex_as_array_ptr = builder->CreateBitCast(tmp, type_fx2->getPointerTo());
                                                    tmp = llvm_utils->CreateLoad2(type_fx2, complex_as_array_ptr);
                                                } else {
                                                    // tmp is {float, float}*
                                                    // type_fx2 is <2 x float>
                                                    llvm::Type* type_fx2 = FIXED_VECTOR_TYPE::get(llvm::Type::getFloatTy(context), 2);
                                                    tmp = llvm_utils->CreateLoad2(type_fx2, tmp);
                                                }
                                            } else {
                                                LCOMPILERS_ASSERT(c_kind == 8)
                                                if (compiler_options.platform == Platform::Windows) {
                                                    // 128 bit aggregate type is passed by reference
                                                } else {
                                                    // Pass by value
                                                    tmp = llvm_utils->CreateLoad2(arg_llvm_type, tmp);
                                                }
                                            }
                                        }
                                    } else if (is_a<ASR::CPtr_t>(*arg_type)) {
                                        if ( arg->m_intent == intent_local ||
                                                arg->m_intent == ASRUtils::intent_out) {
                                            // Local variable or Dummy out argument
                                            // of type CPtr is a void**, so we
                                            // have to load it
                                            llvm::Type* cptr_type = llvm::Type::getVoidTy(context)->getPointerTo();
                                            tmp = llvm_utils->CreateLoad2(cptr_type, tmp);
                                        }
                                    } else {
                                        if (!arg->m_value_attr && !ASR::is_a<ASR::String_t>(*arg_type)) {
                                            // Dereference the pointer argument (unless it is a CPtr)
                                            // to pass by value
                                            // E.g.:
                                            // i32* -> i32
                                            // {double,double}* -> {double,double}
                                            tmp = llvm_utils->CreateLoad2(arg_llvm_type, tmp);
                                        }
                                    }
                                }
                                if (!orig_arg->m_value_attr && arg->m_value_attr) {
                                    llvm::Type *target_type = tmp->getType();
                                    llvm::AllocaInst *target = get_call_arg_alloca(target_type);
                                    builder->CreateStore(tmp, target);
                                    tmp = target;
                                }
                            } else {
                                if( arg->m_intent == intent_local && ASR::is_a<ASR::FunctionType_t>(*arg->m_type) ) {
                                    // (FunctionType**) --> (FunctionType*)
                                    bool pass_by_value = true;
                                    if ( ASR::is_a<ASR::Function_t>(*func_subrout) ) {
                                        ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(func_subrout);
                                        size_t arg_idx = i + is_method;
                                        if ( arg_idx < func->n_args && ASR::is_a<ASR::Var_t>(*func->m_args[arg_idx]) ){
                                            ASR::symbol_t* func_var_sym = ASRUtils::symbol_get_past_external(
                                                ASR::down_cast<ASR::Var_t>(func->m_args[arg_idx])->m_v);
                                            if ( ASR::is_a<ASR::Variable_t>(*func_var_sym) ) {
                                                ASR::Variable_t* func_variable = ASR::down_cast<ASR::Variable_t>(func_var_sym);
                                                if ( func_variable->m_intent == ASRUtils::intent_inout || func_variable->m_intent == ASRUtils::intent_out ) {
                                                    pass_by_value = false;
                                                }
                                            }
                                        }
                                    }

                                    if ( pass_by_value ) {
                                        // Pass-by-Value
                                        tmp = llvm_utils->CreateLoad2(llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                                            al, arg->base.base.loc, &arg->base)), arg->m_type, module.get()), tmp);
                                    }
                                }
                                if( orig_arg &&
                                    !LLVM::is_llvm_pointer(*orig_arg->m_type) &&
                                    LLVM::is_llvm_pointer(*arg->m_type) &&
                                    !ASRUtils::is_character(*arg->m_type) &&
                                    !ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable_pointer(arg->m_type)) && 
                                    !(compiler_options.new_classes &&
                                     ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable_pointer(orig_arg->m_type)))) {
                                    // TODO: Remove call to ASRUtils::check_equal_type
                                    // pass(rhs) is not respected in integration_tests/class_08.f90

                                    llvm::Type* load_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg->m_type, module.get());
                                    tmp = llvm_utils->CreateLoad2(load_type, tmp);
                                }
                                if (ASRUtils::is_class_type(
                                        ASRUtils::extract_type(arg->m_type))
                                    && (!ASRUtils::is_unlimited_polymorphic_type(x.m_args[i].m_value) || compiler_options.new_classes)
                                    && !ASRUtils::is_class_type(
                                        ASRUtils::extract_type(orig_arg->m_type)) ) {
                                    tmp = convert_class_to_type(x.m_args[i].m_value, ASRUtils::EXPR(ASR::make_Var_t(
                                        al, orig_arg->base.base.loc, &orig_arg->base)), orig_arg->m_type, tmp);
                                }
                            }
                        } else {
                            if( orig_arg &&
                                !LLVM::is_llvm_pointer(*orig_arg->m_type) &&
                                LLVM::is_llvm_pointer(*arg->m_type) ) {
                                llvm::Type* ptr_load_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg->m_type, module.get());
                                tmp = llvm_utils->CreateLoad2(ptr_load_type, tmp);
                            }
                            // If both are struct arrays and types don't match, bitcast to orig_arg_type
                            if (ASRUtils::is_array(orig_arg->m_type) && ASRUtils::is_array(arg->m_type) &&
                                !ASRUtils::is_class_type(ASRUtils::extract_type(orig_arg->m_type)) &&
                                ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(orig_arg->m_type)) &&
                                ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(arg->m_type))) {
                                llvm::Type* llvm_orig_arg_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                                    al, orig_arg->base.base.loc, &orig_arg->base)),
                                    orig_arg->m_type, module.get());
                                llvm::Type* llvm_arg_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg->m_type, module.get());
                                if (llvm_orig_arg_type != llvm_arg_type) {
                                    tmp = builder->CreateBitCast(tmp, llvm_orig_arg_type->getPointerTo());
                                }
                            }
                            if (orig_arg &&
                                ASRUtils::is_array(orig_arg->m_type) &&
                                ASRUtils::is_array(arg->m_type) &&
                                ASRUtils::is_class_type(ASRUtils::extract_type(arg->m_type)) &&
                                !ASRUtils::is_class_type(ASRUtils::extract_type(orig_arg->m_type))) {
                                tmp = convert_class_to_type(x.m_args[i].m_value, ASRUtils::EXPR(ASR::make_Var_t(
                                    al, orig_arg->base.base.loc, &orig_arg->base)), orig_arg->m_type, tmp);
                            }
                        }
                    } else {
                        if ( arg->m_type_declaration && ASR::is_a<ASR::Function_t>(
                                *ASRUtils::symbol_get_past_external(arg->m_type_declaration)) ) {
                            ASR::Function_t* fn = ASR::down_cast<ASR::Function_t>(
                                symbol_get_past_external(arg->m_type_declaration));
                            uint32_t h = get_hash((ASR::asr_t*)fn);
                            if (ASRUtils::get_FunctionType(fn)->m_deftype == ASR::deftypeType::Implementation) {
                                LCOMPILERS_ASSERT(llvm_symtab_fn.find(h) != llvm_symtab_fn.end());
                                tmp = llvm_symtab_fn[h];
                            } else {
                                // Must be an argument/chained procedure pass
                                tmp = llvm_symtab_fn_arg[h];
                            }
                        } else {
                            if (arg->m_value == nullptr) {
                                throw CodeGenError(std::string(arg->m_name) + " isn't defined in any scope.");
                            }
                            this->visit_expr_wrapper(arg->m_value, true);
                            if( x_abi != ASR::abiType::BindC &&
                                !ASR::is_a<ASR::ArrayConstant_t>(*arg->m_value) ) {
                                llvm::Type* alloca_type = llvm_utils->get_type_from_ttype_t_util(
                                    ASRUtils::EXPR(ASR::make_Var_t(
                                    al, arg->base.base.loc, &arg->base)), arg->m_type, module.get());
                                llvm::AllocaInst *target = get_call_arg_alloca(alloca_type);
                                builder->CreateStore(tmp, target);
                                tmp = target;
                            }
                        }
                    }
                    if (orig_arg &&
                        LLVM::is_llvm_pointer(*orig_arg->m_type) &&
                        !LLVM::is_llvm_pointer(*arg->m_type)) {
                        llvm::Value* ptr_to_tmp = llvm_utils->CreateAlloca(*builder, tmp->getType());
                        builder->CreateStore(tmp, ptr_to_tmp);
                        tmp = ptr_to_tmp;
                    }
                    // Bitcast procedure pointer if types don't match (implicit interface)
                    // Only for procedure values passed by value (not intent inout/out)
                    if (orig_arg && ASR::is_a<ASR::FunctionType_t>(*arg->m_type) &&
                            ASR::is_a<ASR::FunctionType_t>(*orig_arg->m_type) &&
                            orig_arg_intent != ASR::intentType::InOut &&
                            orig_arg_intent != ASR::intentType::Out) {
                        llvm::Type* expected_type = llvm_utils->get_type_from_ttype_t_util(
                            ASRUtils::EXPR(ASR::make_Var_t(al, orig_arg->base.base.loc, &orig_arg->base)),
                            orig_arg->m_type, module.get());
                        if (tmp->getType() != expected_type) {
                            tmp = builder->CreateBitCast(tmp, expected_type);
                        }
                    }
                } else if (ASR::is_a<ASR::Function_t>(*var_sym)) {
                    ASR::Function_t* fn = ASR::down_cast<ASR::Function_t>(var_sym);
                    uint32_t h = get_hash((ASR::asr_t*)fn);
                    if (ASRUtils::get_FunctionType(fn)->m_deftype == ASR::deftypeType::Implementation) {
                        LCOMPILERS_ASSERT(llvm_symtab_fn.find(h) != llvm_symtab_fn.end());
                        tmp = llvm_symtab_fn[h];
                    } else if (llvm_symtab_fn_arg.find(h) == llvm_symtab_fn_arg.end() &&
                                ASR::is_a<ASR::Function_t>(*var_sym) &&
                                ASRUtils::get_FunctionType(fn)->m_deftype == ASR::deftypeType::Interface ) {
                        LCOMPILERS_ASSERT(llvm_symtab_fn.find(h) != llvm_symtab_fn.end());
                        tmp = llvm_symtab_fn[h];
                        LCOMPILERS_ASSERT(tmp != nullptr)
                    } else {
                        // Must be an argument/chained procedure pass
                        LCOMPILERS_ASSERT(llvm_symtab_fn_arg.find(h) != llvm_symtab_fn_arg.end());
                        tmp = llvm_symtab_fn_arg[h];
                        LCOMPILERS_ASSERT(tmp != nullptr)
                    }
                }
            } else if (ASR::is_a<ASR::ArrayPhysicalCast_t>(*x.m_args[i].m_value)) {
                this->visit_expr_wrapper(x.m_args[i].m_value);
                if (ASRUtils::is_class_type(
                        ASRUtils::extract_type(ASRUtils::expr_type(x.m_args[i].m_value)))
                    && !ASRUtils::is_class_type(
                        ASRUtils::extract_type(orig_arg->m_type)) ) {
                    tmp = convert_class_to_type(x.m_args[i].m_value, ASRUtils::EXPR(ASR::make_Var_t(
                        al, orig_arg->base.base.loc, &orig_arg->base)), orig_arg->m_type, tmp);
                }
            } else if (ASR::is_a<ASR::Cast_t>(*x.m_args[i].m_value) &&
                        ASR::down_cast<ASR::Cast_t>(x.m_args[i].m_value)->m_kind ==
                            ASR::cast_kindType::ClassToIntrinsic) {
                // ClassToIntrinsic cast: visit with ptr_loads=0 to get pointer
                // to the intrinsic data inside the polymorphic wrapper.
                // This ensures write-through for intent(out)/(inout) arguments.
                this->visit_expr_load_wrapper(x.m_args[i].m_value, 0);
            } else if((ASR::is_a<ASR::Cast_t>(*x.m_args[i].m_value) && 
                        ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(ASRUtils::expr_type(x.m_args[i].m_value))) && 
                        !ASRUtils::is_class_type(ASRUtils::extract_type(orig_arg->m_type)))) {
                this->visit_expr_wrapper(x.m_args[i].m_value);
                if (ASRUtils::is_class_type(
                        ASRUtils::extract_type(ASRUtils::expr_type(x.m_args[i].m_value)))) {
                    tmp = convert_class_to_type(x.m_args[i].m_value, ASRUtils::EXPR(ASR::make_Var_t(
                        al, orig_arg->base.base.loc, &orig_arg->base)), orig_arg->m_type, tmp);
                } else if( orig_arg &&
                    !LLVM::is_llvm_pointer(*orig_arg->m_type) &&
                    LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_args[i].m_value)) ) {
                    llvm::Type* ptr_load_type = llvm_utils->get_type_from_ttype_t_util(
                        x.m_args[i].m_value, ASRUtils::expr_type(x.m_args[i].m_value), module.get());
                    tmp = llvm_utils->CreateLoad2(ptr_load_type, tmp);
                }
            } else if( ASR::is_a<ASR::FunctionType_t>(
                *ASRUtils::type_get_past_pointer(
                    ASRUtils::type_get_past_allocatable(
                        ASRUtils::expr_type(x.m_args[i].m_value)))) ) {
                this->visit_expr_wrapper(x.m_args[i].m_value, true);
            } else {
                ASR::ttype_t* arg_type = expr_type(x.m_args[i].m_value);
                this->visit_expr_wrapper(x.m_args[i].m_value);
                if( x_abi == ASR::abiType::BindC ) {
                    if( (ASR::is_a<ASR::ArrayItem_t>(*x.m_args[i].m_value) &&
                         orig_arg_intent ==  ASR::intentType::In) ||
                        ASR::is_a<ASR::StructInstanceMember_t>(*x.m_args[i].m_value) ||
                        (ASR::is_a<ASR::CPtr_t>(*arg_type) &&
                         ASR::is_a<ASR::StructInstanceMember_t>(*x.m_args[i].m_value)) ) {
                        if( ASR::is_a<ASR::StructInstanceMember_t>(*x.m_args[i].m_value) &&
                            ASRUtils::is_array(arg_type) ) {
                            ASR::dimension_t* arg_m_dims = nullptr;
                            size_t n_dims = ASRUtils::extract_dimensions_from_ttype(arg_type, arg_m_dims);
                            if( !(ASRUtils::is_fixed_size_array(arg_m_dims, n_dims) &&
                                  ASRUtils::expr_abi(x.m_args[i].m_value) == ASR::abiType::BindC) ) {
                                llvm::Type* elem_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, ASRUtils::get_contained_type(arg_type), module.get());
                                llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type, module.get());
                                tmp = llvm_utils->CreateLoad2(elem_type->getPointerTo(), arr_descr->get_pointer_to_data(_type, tmp));
                            } else {
                                llvm::Type* arg_llvm_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type, module.get());
                                tmp = llvm_utils->create_gep2(arg_llvm_type, tmp, llvm::ConstantInt::get(
                                        llvm::Type::getInt32Ty(context), llvm::APInt(32, 0)));
                            }
                        } else if (orig_arg && orig_arg->m_abi == ASR::abiType::BindC &&
                                   orig_arg->m_value_attr) {
                            // Only load scalar StructInstanceMember for true BindC
                            // pass-by-value (m_value_attr = true). For implicit
                            // interfaces, m_value_attr is false and the callee
                            // expects a pointer.
                            llvm::Type* load_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type, module.get());
                            tmp = llvm_utils->CreateLoad2(load_type, tmp);
                        }
                    }
                }
                if (ASRUtils::is_pointer(arg_type) && !ASRUtils::is_array(arg_type) &&
                        ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(arg_type)) &&
                        (!compiler_options.new_classes || !ASRUtils::is_class_type(
                            ASRUtils::extract_type(orig_arg->m_type))) &&
                        !LLVM::is_llvm_pointer(*orig_arg->m_type)) {
                    llvm::Type *el_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, orig_arg->base.base.loc, &orig_arg->base)), orig_arg->m_type, module.get());
                    tmp = llvm_utils->CreateLoad2(el_type->getPointerTo(), tmp);
                }
                llvm::Value *value = tmp;
                if (orig_arg_intent == ASR::intentType::In ||
                    orig_arg_intent == ASR::intentType::InOut ||
                    orig_arg_intent == ASR::intentType::Out) {
                    /*
                        For the cases where argument intent is In or InOut or Out, we
                        cannot pass the evaluated value of expression directly to it. Currently
                        the value of `value` is the evaluated value of expression and this is because
                        for every expression we visit, we have a check to prefer the evaluated value.

                        To avoid this problem, we manually set the expr value to nullptr.
                        For example, refer integration_tests/intent_03.f90
                    */
                    // TODO: this is possible in other cases as well, support those.
                    if ( ASR::is_a<ASR::ArrayItem_t>(*x.m_args[i].m_value) ) {
                        ASR::ArrayItem_t* arr_item = ASR::down_cast<ASR::ArrayItem_t>(x.m_args[i].m_value);
                        arr_item->m_value = nullptr;
                        this->visit_expr_wrapper((ASR::expr_t*)arr_item);
                        value = tmp;
                    }
                }
                // TODO: we are getting a warning of uninitialized variable,
                // there might be a bug below.
                llvm::Type *target_type = nullptr;
                ASR::ttype_t* arg_type_ = ASRUtils::type_get_past_array(arg_type);
                switch (arg_type_->type) {
                    case (ASR::ttypeType::Integer) : {
                        int a_kind = down_cast<ASR::Integer_t>(arg_type_)->m_kind;
                        target_type = llvm_utils->getIntType(a_kind);
                        break;
                    }
                    case (ASR::ttypeType::UnsignedInteger) : {
                        int a_kind = down_cast<ASR::UnsignedInteger_t>(arg_type_)->m_kind;
                        target_type = llvm_utils->getIntType(a_kind);
                        break;
                    }
                    case (ASR::ttypeType::Real) : {
                        int a_kind = down_cast<ASR::Real_t>(arg_type_)->m_kind;
                        target_type = llvm_utils->getFPType(a_kind);
                        break;
                    }
                    case (ASR::ttypeType::Complex) : {
                        int a_kind = down_cast<ASR::Complex_t>(arg_type_)->m_kind;
                        target_type = llvm_utils->getComplexType(a_kind);
                        break;
                    }
                    case (ASR::ttypeType::String) : {
                        target_type = llvm_utils->get_StringType(arg_type_);
                        break;
                    }
                    case (ASR::ttypeType::Logical) :
                        if (orig_arg && ASRUtils::is_array(orig_arg->m_type)) {
                            target_type = llvm::Type::getInt8Ty(context);
                        } else {
                            target_type = llvm::Type::getInt1Ty(context);
                        }
                        break;
                    case (ASR::ttypeType::EnumType) :
                        target_type = llvm::Type::getInt32Ty(context);
                        break;
                    case (ASR::ttypeType::StructType) :
                        break;
                    case (ASR::ttypeType::CPtr) :
                        target_type = llvm::Type::getVoidTy(context)->getPointerTo();
                        break;
                    case ASR::ttypeType::Allocatable:
                    case (ASR::ttypeType::Pointer) : {
                        ASR::ttype_t* type_ = ASRUtils::get_contained_type(arg_type);
                        target_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, type_, module.get());
                        target_type = target_type->getPointerTo();
                        break;
                    }
                    case (ASR::ttypeType::List) : {
                        target_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type_, module.get());
                        break ;
                    }
                    case (ASR::ttypeType::Tuple) : {
                        target_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type_, module.get());
                        break ;
                    }
                    case (ASR::ttypeType::FunctionType): {
                        target_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type_, module.get());
                        break;
                    }
                    default :
                        throw CodeGenError("Type " + ASRUtils::type_to_str_fortran_expr(arg_type, x.m_args[i].m_value) + " not implemented yet.");
                }
                if( ASR::is_a<ASR::EnumValue_t>(*x.m_args[i].m_value) ) {
                    target_type = llvm::Type::getInt32Ty(context);
                }
                if (ASR::is_a<ASR::StructType_t>(*arg_type) && !ASRUtils::is_class_type(arg_type)) {
                    bool pass_by_value = false;
                    ASR::Variable_t *struct_orig_arg = nullptr;
                    if (func_subrout->type == ASR::symbolType::Function) {
                        ASR::Function_t* func = down_cast<ASR::Function_t>(func_subrout);
                        size_t arg_idx = i + is_method;
                        if (arg_idx < func->n_args && func->m_args[arg_idx] != nullptr) {
                            struct_orig_arg = EXPR2VAR(func->m_args[arg_idx]);
                            if (struct_orig_arg && struct_orig_arg->m_abi == ASR::abiType::BindC
                                && struct_orig_arg->m_value_attr) {
                                pass_by_value = true;
                            }
                        }
                    }
                    if (!pass_by_value && !value->getType()->isPointerTy()) {
                        // Value is not a pointer but callee expects pointer - allocate temp storage
                        llvm::Type* struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                            x.m_args[i].m_value, arg_type, module.get());
                        llvm::AllocaInst *target = get_call_arg_alloca(struct_llvm_type);
                        builder->CreateStore(value, target);
                        tmp = target;
                    } else {
                        tmp = value;
                    }
                } else if(ASR::is_a<ASR::String_t>(*arg_type)){
                    if (!value->getType()->isPointerTy()) {
                        // String value was loaded (e.g., from ClassToIntrinsic cast);
                        // store to temp to pass by reference
                        llvm::AllocaInst *target = get_call_arg_alloca(target_type);
                        builder->CreateStore(value, target);
                        tmp = target;
                    } else {
                        tmp = value;
                    }
                }else {
                    bool use_value = false;
                    ASR::Variable_t *orig_arg = nullptr;
                    if( func_subrout->type == ASR::symbolType::Function ) {
                        ASR::Function_t* func = down_cast<ASR::Function_t>(func_subrout);
                        size_t arg_idx = i + is_method;
                        LCOMPILERS_ASSERT(arg_idx < func->n_args);
                        LCOMPILERS_ASSERT(func->m_args[arg_idx] != nullptr);
                        orig_arg = EXPR2VAR(func->m_args[arg_idx]);
                    } else {
                        LCOMPILERS_ASSERT(false)
                    }
                    if (orig_arg != nullptr && orig_arg->m_abi == ASR::abiType::BindC
                        && orig_arg->m_value_attr) {
                        use_value = true;
                    }
                    if (ASR::is_a<ASR::ArrayItem_t>(*x.m_args[i].m_value)) {
                        if (ASRUtils::is_class_type(
                                ASRUtils::extract_type(arg_type))
                            && !ASRUtils::is_class_type(
                                ASRUtils::extract_type(orig_arg->m_type))) {
                            value = convert_class_to_type(x.m_args[i].m_value, ASRUtils::EXPR(ASR::make_Var_t(
                                al, orig_arg->base.base.loc, &orig_arg->base)),
                                orig_arg->m_type, value);
                        }
                        use_value = true;
                    }
                    if (use_value) {
                        tmp = value;
                        // Logical array elements are i8*; subroutine args expect i1*.
                        if (ASRUtils::is_logical(*arg_type_) && tmp->getType()->isPointerTy()) {
                            llvm::Type* expected = llvm::Type::getInt1Ty(context)->getPointerTo();
                            if (tmp->getType() != expected)
                                tmp = builder->CreateBitCast(tmp, expected);
                        }
                    }
                    if (!use_value && orig_arg != nullptr) {
                        // Create alloca to get a pointer, but do it
                        // at the beginning of the function to avoid
                        // using alloca inside a loop, which would
                        // run out of stack
                        if (((ASR::is_a<ASR::StructInstanceMember_t>(*x.m_args[i].m_value)
                                    && ((!ASRUtils::is_allocatable(orig_arg->m_type)
                                        && ASRUtils::is_allocatable(arg_type))
                                        || !ASRUtils::is_allocatable(arg_type))
                                    && (ASRUtils::is_array(arg_type)
                                        || ASR::is_a<ASR::CPtr_t>(
                                            *ASRUtils::expr_type(x.m_args[i].m_value))))
                                || (ASR::is_a<ASR::StructInstanceMember_t>(*x.m_args[i].m_value)
                                    && ASRUtils::is_allocatable(arg_type)
                                    && !ASRUtils::is_allocatable(orig_arg->m_type)
                                    && (orig_arg->m_intent == ASR::intentType::Out
                                        || orig_arg->m_intent == ASR::intentType::InOut)))
                            && value->getType()->isPointerTy()
                            && !ASRUtils::is_character(*arg_type)) {
                                if (ASRUtils::is_class_type(
                                        ASRUtils::extract_type(arg_type))
                                    && !ASRUtils::is_class_type(
                                        ASRUtils::extract_type(orig_arg->m_type))) {
                                    value = convert_class_to_type(x.m_args[i].m_value, ASRUtils::EXPR(ASR::make_Var_t(
                                        al, orig_arg->base.base.loc, &orig_arg->base)),
                                        orig_arg->m_type, value);
                                } else if (!compiler_options.new_classes || !ASRUtils::is_class_type(
                                        ASRUtils::type_get_past_allocatable(orig_arg->m_type))) {
                                    if (!ASRUtils::is_array(ASRUtils::expr_type(x.m_args[i].m_value))) {
                                        check_and_allocate_scalar(x.m_args[i].m_value);
                                    }
                                    llvm::Type* value_type = llvm_utils->get_type_from_ttype_t_util(x.m_args[i].m_value, arg_type, module.get());
                                    value = llvm_utils->CreateLoad2(value_type, value);
                                }
                        }
                        if( !ASR::is_a<ASR::CPtr_t>(*arg_type) &&
                            !(orig_arg && !LLVM::is_llvm_pointer(*orig_arg->m_type) &&
                            LLVM::is_llvm_pointer(*arg_type)) &&
                            !ASRUtils::is_character(*arg_type) &&
                            !ASRUtils::is_class_type(arg_type) &&
                            (!ASR::is_a<ASR::StructInstanceMember_t>(*x.m_args[i].m_value) || ASRUtils::is_value_constant(x.m_args[i].m_value)) ) {
                            llvm::AllocaInst *target = get_call_arg_alloca(target_type);
                            if( ASR::is_a<ASR::Tuple_t>(*arg_type) ||
                                ASR::is_a<ASR::List_t>(*arg_type) ) {
                                    llvm_utils->deepcopy(x.m_args[i].m_value, value, target, arg_type, arg_type, module.get());
                            } else {
                                if (value->getType() == llvm::Type::getInt1Ty(context)
                                        && target_type == llvm::Type::getInt8Ty(context)) {
                                    value = builder->CreateZExt(value, target_type);
                                }
                                builder->CreateStore(value, target);
                            }
                            tmp = target;
                        } else {
                            tmp = value;
                        }
                    } else if (!use_value) {
                        // orig_arg is null (implicit interface without arg info)
                        // Just pass the value as-is
                        tmp = value;
                    }
                }
            }

            if( orig_arg && ASRUtils::is_assumed_rank_array(orig_arg->m_type) &&
                !ASRUtils::is_array(ASRUtils::expr_type(x.m_args[i].m_value)) ) {
                llvm::Type* descriptor_type = llvm_utils->get_type_from_ttype_t_util(
                    ASRUtils::EXPR(ASR::make_Var_t(al, orig_arg->base.base.loc, &orig_arg->base)),
                    orig_arg->m_type, module.get());
                llvm::Value* descriptor = llvm_utils->CreateAlloca(*builder, descriptor_type);
                llvm::Value* data_ptr = arr_descr->get_pointer_to_data(descriptor_type, descriptor);
                // If target is unlimited polymorphic, wrap the scalar in a polymorphic type
                ASR::ttype_t* orig_arg_type_past_pointer = ASRUtils::type_get_past_allocatable(
                    ASRUtils::type_get_past_pointer(orig_arg->m_type));
                if (ASRUtils::is_unlimited_polymorphic_type(ASRUtils::EXPR(
                        ASR::make_Var_t(al, orig_arg->base.base.loc, &orig_arg->base)))) {
                    // Get the element type of the polymorphic array (unlimited_polymorphic_type)
                    llvm::Type* poly_elem_type = llvm_utils->get_el_type(
                        ASRUtils::EXPR(ASR::make_Var_t(al, orig_arg->base.base.loc, &orig_arg->base)),
                        ASRUtils::type_get_past_array(orig_arg_type_past_pointer), module.get());
                    llvm::Value* poly_wrapper = llvm_utils->CreateAlloca(*builder, poly_elem_type);
                    
                    // Store vptr for intrinsic type
                    ASR::ttype_t* arg_type = ASRUtils::expr_type(x.m_args[i].m_value);
                    struct_api->store_intrinsic_type_vptr(arg_type,
                        ASRUtils::extract_kind_from_ttype_t(arg_type), poly_wrapper, module.get());
                    
                    // Store data pointer (bitcast scalar pointer to i8*)
                    llvm::Value* poly_data_ptr = llvm_utils->create_gep2(poly_elem_type, poly_wrapper, 1);
                    builder->CreateStore(builder->CreateBitCast(tmp, llvm_utils->i8_ptr), poly_data_ptr);
                    
                    // Store the polymorphic wrapper pointer in the descriptor
                    builder->CreateStore(poly_wrapper, data_ptr);
                } else {
                    builder->CreateStore(tmp, data_ptr);
                }
                
                llvm::Value* offset_ptr = llvm_utils->create_gep2(descriptor_type, descriptor, 1);
                builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(32, 0)), offset_ptr);
                llvm::Value* dim_des_ptr = llvm_utils->create_gep2(descriptor_type, descriptor, 2);
                llvm::Type* dim_des_type = arr_descr->create_dimension_descriptor_array_type();
                builder->CreateStore(
                    llvm::ConstantPointerNull::get(llvm::cast<llvm::PointerType>(dim_des_type)),
                    dim_des_ptr);
                llvm::Value* is_allocated_ptr = llvm_utils->create_gep2(descriptor_type, descriptor, 3);
                builder->CreateStore(llvm::ConstantInt::get(context, llvm::APInt(1, 1)), is_allocated_ptr);
                arr_descr->set_rank(descriptor_type, descriptor, llvm::ConstantInt::get(context, llvm::APInt(32, 0)));
                tmp = descriptor;
            }

            // To avoid segmentation faults when original argument
            // is not a ASR::Variable_t like callbacks.
            // Skip polymorphic conversion if we've already wrapped the scalar in an assumed-rank
            // polymorphic descriptor above
            bool skip_polymorphic_conversion = orig_arg && 
                ASRUtils::is_assumed_rank_array(orig_arg->m_type) &&
                !ASRUtils::is_array(ASRUtils::expr_type(x.m_args[i].m_value)) &&
                ASRUtils::is_unlimited_polymorphic_type(ASRUtils::EXPR(
                    ASR::make_Var_t(al, orig_arg->base.base.loc, &orig_arg->base)));
            if( orig_arg && !skip_polymorphic_conversion ) {
                tmp = convert_to_polymorphic_arg(x.m_args[i].m_value, tmp,
                    ASRUtils::EXPR(ASR::make_Var_t(al, orig_arg->base.base.loc, &orig_arg->base)),
                    ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(orig_arg->m_type)),
                    ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(ASRUtils::expr_type(x.m_args[i].m_value))));
            }

            // For bind(c) character array arguments passed as Var, extract the raw data pointer
            // from the string descriptor. For other expression types, the conversion may have
            // already occurred via ArrayPhysicalCast or other mechanisms.
            if (orig_arg && x_abi == ASR::abiType::BindC &&
                ASRUtils::is_character(*orig_arg->m_type) &&
                ASRUtils::is_array(orig_arg->m_type) &&
                ASR::is_a<ASR::Var_t>(*x.m_args[i].m_value)) {
                ASR::array_physical_typeType phys_type = ASRUtils::extract_physical_type(orig_arg->m_type);
                if (phys_type == ASR::array_physical_typeType::PointerArray ||
                    phys_type == ASR::array_physical_typeType::StringArraySinglePointer) {
                    // tmp is a string_descriptor* - extract the char* data pointer (field 0)
                    llvm::Value* data_ptr = llvm_utils->CreateGEP2(llvm_utils->string_descriptor, tmp, 0);
                    tmp = llvm_utils->CreateLoad2(llvm::Type::getInt8Ty(context)->getPointerTo(), data_ptr);
                }
            }

            args.push_back(tmp);
        }
        convert_call_args_depth--;
        return args;
    }

    llvm::Value *convert_class_to_type(ASR::expr_t *arg, ASR::expr_t* dest_arg, ASR::ttype_t *dest_type, llvm::Value *class_value) {
        // if the required argument is of struct type, we need to pass
        // in the struct pointer to it
        ASR::ttype_t *arg_type = ASRUtils::expr_type(arg);
        if (compiler_options.new_classes) {
            bool is_unlimited_polymorphic = ASRUtils::is_unlimited_polymorphic_type(arg);
            // Handle arrays
            if (ASRUtils::is_array(arg_type) &&
                    ASRUtils::extract_physical_type(arg_type) == ASR::DescriptorArray) {
                // For descriptor arrays, we need to create a new array descriptor
                // with the correct element type and copy the data pointer from the polymorphic wrapper
                ASR::ttype_t *dest_arr_type = ASRUtils::type_get_past_allocatable_pointer(dest_type);
                ASR::ttype_t *src_arr_asr_type = ASRUtils::type_get_past_allocatable_pointer(arg_type);
                llvm::Type *dest_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    dest_arg, dest_arr_type, module.get());
                llvm::Type *src_arr_type = llvm_utils->get_type_from_ttype_t_util(
                    arg, src_arr_asr_type, module.get());
                llvm::Type *src_elem_type = llvm_utils->get_type_from_ttype_t_util(
                    arg, ASRUtils::extract_type(arg_type), module.get());

                if (LLVM::is_llvm_pointer(*arg_type)) {
                    class_value = llvm_utils->CreateLoad2(src_arr_type->getPointerTo(), class_value);
                }

                // Create new array descriptor
                llvm::Value* new_descriptor = llvm_utils->CreateAlloca(*builder, dest_llvm_type, nullptr, "array_descriptor");
                
                // Get source array's data pointer (from polymorphic wrapper's data field)
                llvm::Value* src_data_ptr = llvm_utils->create_gep2(src_arr_type, class_value, 0);
                src_data_ptr = llvm_utils->CreateLoad2(src_elem_type->getPointerTo(), src_data_ptr);
                
                // Get offset from source - index into array based on offset
                llvm::Value* src_offset_ptr = llvm_utils->create_gep2(src_arr_type, class_value, 1);
                llvm::Value* src_offset = llvm_utils->CreateLoad2(llvm_utils->getIntType(4), src_offset_ptr);
                                
                // Extract data pointer from the polymorphic wrapper (field at index 1)
                if (is_unlimited_polymorphic) {
                    src_data_ptr = llvm_utils->CreateLoad2(
                        llvm_utils->i8_ptr, llvm_utils->create_gep2(src_elem_type, src_data_ptr, 1));
                } else {
                    llvm::Type* src_elem_struct_type = llvm_utils->getStructType(
                        ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(arg))), module.get());
                    src_data_ptr = llvm_utils->CreateLoad2(
                        src_elem_struct_type->getPointerTo(),
                        llvm_utils->create_gep2(src_elem_type, src_data_ptr, 1));
                }

                // Cast to destination element *storage* pointer type and store in new descriptor.
                // (LLVM < 15 uses typed pointers and requires an exact match; logical arrays are i8-backed.)
                llvm::Type* dest_data_type = llvm_utils->get_el_type(
                    dest_arg, ASRUtils::extract_type(dest_type), module.get());
                llvm::Value* dest_data_ptr = src_data_ptr;
                llvm::Type* expected_data_ptr_type = dest_data_type->getPointerTo();
                if (dest_data_ptr->getType() != expected_data_ptr_type) {
                    dest_data_ptr = builder->CreateBitCast(dest_data_ptr, expected_data_ptr_type);
                }
                llvm::Value* new_data_ptr_ptr = llvm_utils->create_gep2(dest_llvm_type, new_descriptor, 0);
                builder->CreateStore(dest_data_ptr, new_data_ptr_ptr);
                
                // Copy offset (set to 0 since we're starting fresh)
                llvm::Value* new_offset_ptr = llvm_utils->create_gep2(dest_llvm_type, new_descriptor, 1);
                builder->CreateStore(src_offset, new_offset_ptr);
                
                // Copy dimension descriptor pointer
                llvm::Value* src_dim_ptr_ptr = llvm_utils->create_gep2(src_arr_type, class_value, 2);
                llvm::Value* src_dim_ptr = llvm_utils->CreateLoad2(
                    arr_descr->get_dimension_descriptor_type(false)->getPointerTo(), src_dim_ptr_ptr);
                llvm::Value* new_dim_ptr_ptr = llvm_utils->create_gep2(dest_llvm_type, new_descriptor, 2);
                builder->CreateStore(src_dim_ptr, new_dim_ptr_ptr);
                
                // Copy rank
                llvm::Value* src_rank_ptr = llvm_utils->create_gep2(src_arr_type, class_value, 4);
                llvm::Value* src_rank = llvm_utils->CreateLoad2(llvm_utils->getIntType(4), src_rank_ptr);
                llvm::Value* new_rank_ptr = llvm_utils->create_gep2(dest_llvm_type, new_descriptor, 4);
                builder->CreateStore(src_rank, new_rank_ptr);
                
                // If dest_type is Pointer(Array(...)), we need an extra level of indirection
                // so that when the caller loads from the returned value, they get the descriptor pointer
                if (LLVM::is_llvm_pointer(*dest_type)) {
                    llvm::Value* desc_ptr_ptr = llvm_utils->CreateAlloca(*builder, dest_llvm_type->getPointerTo(), nullptr, "array_descriptor_ptr");
                    builder->CreateStore(new_descriptor, desc_ptr_ptr);
                    return desc_ptr_ptr;
                }
                
                return new_descriptor;
            }
            
            if (LLVM::is_llvm_pointer(*arg_type)) {
                check_and_allocate_scalar(arg, dest_arg, dest_type);
            }
            llvm::Type* arg_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                                        arg, ASRUtils::extract_type(arg_type), module.get());
            if (LLVM::is_llvm_pointer(*arg_type) &&
                    (!LLVM::is_llvm_pointer(*ASRUtils::expr_type(dest_arg)) || ASRUtils::is_class_type(
                        ASRUtils::type_get_past_allocatable_pointer(arg_type)))) {
                class_value = llvm_utils->CreateLoad2(arg_llvm_type->getPointerTo(), class_value);
            }
            if (is_unlimited_polymorphic) {
                class_value = llvm_utils->CreateLoad2(
                    llvm_utils->i8_ptr, llvm_utils->create_gep2(arg_llvm_type, class_value, 1));
            } else {
                ASR::ttype_t* struct_type = ASRUtils::make_StructType_t_util(
                    al, arg_type->base.loc, ASRUtils::symbol_get_past_external(
                    ASRUtils::get_struct_sym_from_struct_expr(arg)), true);
                llvm::Type* llvm_struct_type = llvm_utils->get_type_from_ttype_t_util(
                    arg, struct_type, module.get());
                class_value = llvm_utils->create_gep2(arg_llvm_type, class_value, 1);
                if (!LLVM::is_llvm_pointer(*dest_type)) {
                    class_value = llvm_utils->CreateLoad2(
                        llvm_struct_type->getPointerTo(), class_value);
                }         
            }
            llvm::Type* dest_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    dest_arg, dest_type, module.get());
            return builder->CreateBitCast(class_value, dest_llvm_type->getPointerTo());
        }
        llvm::Value *value = nullptr;
        ASR::ttype_t* ext_arg_type = ASRUtils::type_get_past_allocatable_pointer(arg_type);
        LCOMPILERS_ASSERT(ASRUtils::is_class_type(ext_arg_type) &&
                          !ASRUtils::is_class_type(ASRUtils::type_get_past_allocatable_pointer(dest_type)));
        if (ASRUtils::is_allocatable(arg_type)) {
            check_and_allocate_scalar(arg, dest_arg, dest_type);
        }
        ASR::ttype_t* struct_type = ASRUtils::make_StructType_t_util(
                                        al, arg_type->base.loc,
                                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg)), true);
        llvm::Type* llvm_struct_type = llvm_utils->get_type_from_ttype_t_util(arg, struct_type,
                module.get())->getPointerTo();
        llvm::Value* struct_ptr = llvm_utils->create_gep2(
                                llvm_utils->get_type_from_ttype_t_util(arg, ext_arg_type, module.get()),
                                class_value, 1);

        if (ASRUtils::is_class_type(ext_arg_type)
            && !ASR::is_a<ASR::Allocatable_t>(*dest_type)) {
            value = llvm_utils->CreateLoad2(llvm_struct_type, struct_ptr);
            value = builder->CreateBitCast(value, llvm_utils->get_type_from_ttype_t_util(dest_arg, dest_type, module.get())->getPointerTo());
        } else {
            value = struct_ptr;
        }

        return value;
    }

    // Convert from one polymorphic class type to another (class is() in select type)
    llvm::Value* convert_class_to_class(ASR::expr_t* arg_expr, llvm::Value* dt,
            ASR::ttype_t* dest_type, ASR::symbol_t* dest_sym) {
        ASR::ttype_t* arg_type = ASRUtils::expr_type(arg_expr);
        
        if (!ASRUtils::is_class_type(ASRUtils::extract_type(dest_type)) || 
            !ASRUtils::is_class_type(ASRUtils::extract_type(arg_type))) {
            return dt;
        }
        
        // TODO: Handle arrays properly here
        if (ASRUtils::is_array(arg_type) && 
            ASRUtils::extract_physical_type(arg_type) == ASR::array_physical_typeType::DescriptorArray) {
            // TODO: Handle this properly 
            llvm::Type* dest_array_type = llvm_utils->get_type_from_ttype_t_util(
                nullptr, dest_type, module.get());
            return builder->CreateBitCast(dt, dest_array_type);
        }
    
        llvm::Type* call_arg_struct_type = llvm_utils->get_type_from_ttype_t_util(
            arg_expr, ASRUtils::extract_type(arg_type), module.get());
        
        if (LLVM::is_llvm_pointer(*arg_type) &&
                !LLVM::is_llvm_pointer(*dest_type)) {
            dt = llvm_utils->CreateLoad2(call_arg_struct_type->getPointerTo(), dt);
        }
        llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(
            dest_type, dest_sym, module.get());
        if (!ASRUtils::is_array(dest_type)) {
            return builder->CreateBitCast(dt, type->getPointerTo());
        } else {
            return builder->CreateBitCast(dt, type);
        }
    }

    void generate_flip_sign(ASR::call_arg_t* m_args) {
        this->visit_expr_wrapper(m_args[0].m_value, true);
        llvm::Value* signal = tmp;
        LCOMPILERS_ASSERT(m_args[1].m_value->type == ASR::exprType::Var);
        ASR::Var_t* asr_var = ASR::down_cast<ASR::Var_t>(m_args[1].m_value);
        ASR::Variable_t* asr_variable = ASR::down_cast<ASR::Variable_t>(asr_var->m_v);
        uint32_t x_h = get_hash((ASR::asr_t*)asr_variable);
        llvm::Value* variable = llvm_symtab[x_h];
        // variable = xor(shiftl(int(Nd), 63), variable)
        ASR::ttype_t* signal_type = ASRUtils::expr_type(m_args[0].m_value);
        int signal_kind = ASRUtils::extract_kind_from_ttype_t(signal_type);
        llvm::Value* num_shifts = llvm::ConstantInt::get(context, llvm::APInt(32, signal_kind * 8 - 1));
        llvm::Value* shifted_signal = builder->CreateShl(signal, num_shifts);
        llvm::Type* variable_load_type = llvm_utils->get_type_from_ttype_t_util(&asr_var->base, asr_variable->m_type, module.get());
        llvm::Value* int_var = builder->CreateBitCast(llvm_utils->CreateLoad2(variable_load_type, variable), shifted_signal->getType());        tmp = builder->CreateXor(shifted_signal, int_var);
        llvm::Type* variable_type = llvm_utils->get_type_from_ttype_t_util(&asr_var->base, asr_variable->m_type, module.get());
        tmp = builder->CreateBitCast(tmp, variable_type);
    }

    void generate_fma(ASR::call_arg_t* m_args) {
        this->visit_expr_wrapper(m_args[0].m_value, true);
        llvm::Value* a = tmp;
        this->visit_expr_wrapper(m_args[1].m_value, true);
        llvm::Value* b = tmp;
        this->visit_expr_wrapper(m_args[2].m_value, true);
        llvm::Value* c = tmp;
#if LLVM_VERSION_MAJOR >= 8
        tmp = builder->CreateIntrinsic(llvm::Intrinsic::fma,
                {a->getType()},
                {b, c, a});
#else
        // LLVM 7: Use getDeclaration instead
        llvm::Function *fn = llvm::Intrinsic::getDeclaration(module.get(), llvm::Intrinsic::fma, {a->getType()});
        tmp = builder->CreateCall(fn, {b, c, a});
#endif
    }

    void generate_sign_from_value(ASR::call_arg_t* m_args) {
        this->visit_expr_wrapper(m_args[0].m_value, true);
        llvm::Value* arg0 = tmp;
        this->visit_expr_wrapper(m_args[1].m_value, true);
        llvm::Value* arg1 = tmp;
        llvm::Type* common_llvm_type = arg0->getType();
        ASR::ttype_t *arg1_type = ASRUtils::expr_type(m_args[1].m_value);
        uint64_t kind = ASRUtils::extract_kind_from_ttype_t(arg1_type);
        llvm::Value* num_shifts = llvm::ConstantInt::get(context, llvm::APInt(kind * 8, kind * 8 - 1));
        llvm::Value* shifted_one = builder->CreateShl(llvm::ConstantInt::get(context, llvm::APInt(kind * 8, 1)), num_shifts);
        arg1 = builder->CreateBitCast(arg1, shifted_one->getType());
        arg0 = builder->CreateBitCast(arg0, shifted_one->getType());
        tmp = builder->CreateXor(arg0, builder->CreateAnd(shifted_one, arg1));
        tmp = builder->CreateBitCast(tmp, common_llvm_type);
    }

    template <typename T>
    bool generate_optimization_instructions(const T* routine, ASR::call_arg_t* m_args) {
        std::string routine_name = std::string(routine->m_name);
        if( routine_name.find("flipsign") != std::string::npos ) {
            generate_flip_sign(m_args);
            return true;
        } else if( routine_name.find("fma") != std::string::npos ) {
            generate_fma(m_args);
            return true;
        } else if( routine_name.find("signfromvalue") != std::string::npos ) {
            generate_sign_from_value(m_args);
            return true;
        }
        return false;
    }

    int get_class_hash(ASR::symbol_t* class_sym) {
        if( type2vtabid.find(class_sym) == type2vtabid.end() ) {
            type2vtabid[class_sym] = type2vtabid.size();
        }
        return type2vtabid[class_sym];
    }

    llvm::Value* convert_to_polymorphic_arg(ASR::expr_t* arg_expr, llvm::Value* dt, ASR::expr_t* s_m_args0,
        ASR::ttype_t* s_m_args0_type, ASR::ttype_t* arg_type) {
        if ( compiler_options.new_classes ) {
            if( !ASRUtils::is_class_type(ASRUtils::extract_type(
                    ASRUtils::expr_type(s_m_args0))) ) {
                return dt;
            }
            if (ASRUtils::is_unlimited_polymorphic_type(s_m_args0)) {
                if (ASRUtils::is_unlimited_polymorphic_type(arg_expr)) {
                    if (LLVM::is_llvm_pointer(*ASRUtils::expr_type(arg_expr)) &&
                            !LLVM::is_llvm_pointer(*ASRUtils::expr_type(s_m_args0))) {
                        llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(
                            arg_expr, ASRUtils::expr_type(arg_expr), module.get());
                        dt = llvm_utils->CreateLoad2(_type, dt);
                    }
                    return dt;
                }
                if (ASRUtils::is_array(arg_type)) {
                    llvm::Type* actual_array_type = llvm_utils->get_type_from_ttype_t_util(
                        arg_expr, arg_type, module.get());
                    // Use the array element *storage* type (e.g. logical arrays are i8-backed).
                    llvm::Type* actual_array_data_type = llvm_utils->get_el_type(
                        arg_expr, ASRUtils::extract_type(arg_type), module.get());
                    llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(
                        s_m_args0, s_m_args0_type, module.get());
                    llvm::Value* unlimited_polymorphic_type_array = llvm_utils->CreateAlloca(*builder, array_type);
                    llvm::Type* array_data_type = llvm_utils->get_el_type(
                        s_m_args0, ASRUtils::extract_type(s_m_args0_type), module.get());
                    llvm::Value* array_data = llvm_utils->CreateAlloca(*builder, array_data_type);
                    builder->CreateStore(
                        array_data, arr_descr->get_pointer_to_data(array_type, unlimited_polymorphic_type_array));
                    arr_descr->fill_array_details(arg_expr,
                                                s_m_args0,
                                                dt,
                                                unlimited_polymorphic_type_array,
                                                arg_type,
                                                s_m_args0_type,
                                                module.get(),
                                                true);
                    llvm::Value* unlimited_polymorphic_struct = llvm_utils->CreateLoad2(
                        array_data_type->getPointerTo(),
                        arr_descr->get_pointer_to_data(array_type, unlimited_polymorphic_type_array));

                    llvm::Value* data_ptr = llvm_utils->create_gep2(array_data_type, unlimited_polymorphic_struct, 1);
                    llvm::Value* actual_data = llvm_utils->CreateLoad2(
                        actual_array_data_type->getPointerTo(), llvm_utils->create_gep2(actual_array_type, dt, 0));
                    arg_type = ASRUtils::extract_type(arg_type);

                    // Store intrinsic type vptr
                    struct_api->store_intrinsic_type_vptr(arg_type,
                        ASRUtils::extract_kind_from_ttype_t(arg_type), unlimited_polymorphic_struct, module.get());
                    // Store inrinsic type data ptr
                    builder->CreateStore(builder->CreateBitCast(actual_data, llvm_utils->i8_ptr),
                                        data_ptr);
                    return unlimited_polymorphic_type_array;
                } else {
                    llvm::Type* unlimited_polymorphic_type = llvm_utils->get_type_from_ttype_t_util(
                            s_m_args0, s_m_args0_type, module.get());
                    llvm::Value* unlimited_polymorphic_struct = llvm_utils->CreateAlloca(unlimited_polymorphic_type);
                    llvm::Value* data_ptr = llvm_utils->create_gep2(unlimited_polymorphic_type, unlimited_polymorphic_struct, 1);

                    if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(arg_type))) {
                        // Store Vptr from original struct
                        llvm::Value* vptr;
                        if (ASRUtils::is_class_type(arg_type)) {
                            vptr = builder->CreateBitCast(dt, llvm_utils->vptr_type->getPointerTo());
                            vptr = llvm_utils->CreateLoad2(llvm_utils->vptr_type, vptr);
                        } else {
                            vptr = struct_api->get_pointer_to_method(ASRUtils::symbol_get_past_external(
                                ASRUtils::get_struct_sym_from_struct_expr(arg_expr)), module.get());
                        }
                        builder->CreateStore(vptr, llvm_utils->create_gep2(
                            unlimited_polymorphic_type, unlimited_polymorphic_struct, 0));
                    } else {
                        // An intrinsic type scalar is passes as argument to a `class(*)` function parameter
                        struct_api->store_intrinsic_type_vptr(arg_type,
                                                    ASRUtils::extract_kind_from_ttype_t(arg_type),
                                                    unlimited_polymorphic_struct, module.get());
                    }
                                               
                    builder->CreateStore(builder->CreateBitCast(dt, llvm_utils->i8_ptr), data_ptr);
                    return unlimited_polymorphic_struct;
                }
            } else if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(arg_type))) {
                if (ASRUtils::is_array(arg_type) && 
                    ASRUtils::extract_physical_type(arg_type) == ASR::array_physical_typeType::DescriptorArray) {
                    if (ASRUtils::is_class_type(ASRUtils::extract_type(arg_type))) {
                        return dt;
                    }
                    // For struct array arguments: wrap each struct* in a class wrapper (vptr + struct*)
                    // The class wrapper array has class_elem_type = {vptr, struct*}
                    llvm::Type* target_array_type = llvm_utils->get_type_from_ttype_t_util(
                        s_m_args0, s_m_args0_type, module.get());
                    llvm::Type* target_array_data_type = llvm_utils->get_el_type(
                        s_m_args0, ASRUtils::extract_type(s_m_args0_type), module.get());
                    llvm::Type* actual_array_type = llvm_utils->get_type_from_ttype_t_util(
                        arg_expr, arg_type, module.get());
                    llvm::Type* actual_array_data_type = llvm_utils->get_el_type(
                        arg_expr, ASRUtils::extract_type(arg_type), module.get());
                    ASR::symbol_t* target_struct_sym = ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(s_m_args0));
                    llvm::Type* target_struct_type = llvm_utils->getStructType(
                        ASR::down_cast<ASR::Struct_t>(target_struct_sym), module.get());

                    // Allocate the target class array descriptor
                    llvm::Value* class_array = llvm_utils->CreateAlloca(target_array_type);
                    
                    // Allocate buffer for class wrapper array (vptr + struct_ptr per element)
                    llvm::Value* class_array_data = llvm_utils->CreateAlloca(
                        target_array_data_type);
                    builder->CreateStore(class_array_data,
                        arr_descr->get_pointer_to_data(target_array_type, class_array));

                    // Copy dimension descriptors from source to target
                    llvm::Value* actual_dim_des = 
                        arr_descr->get_pointer_to_dimension_descriptor_array(actual_array_type, dt);
                    llvm::Value* target_dim_des_ptr = arr_descr->get_pointer_to_dimension_descriptor_array(target_array_type, class_array, false);
                    builder->CreateStore(actual_dim_des, target_dim_des_ptr);
                    
                    // Copy rank and offset
                    llvm::Value* actual_offset = arr_descr->get_offset(actual_array_type, dt, true);
                    builder->CreateStore(actual_offset,
                        arr_descr->get_offset(target_array_type, class_array, false));
                    
                    llvm::Value* actual_rank = arr_descr->get_rank(actual_array_type, dt, false);
                    arr_descr->set_rank(target_array_type, class_array, actual_rank);

                    // Get source struct array data
                    llvm::Value* actual_array_data = llvm_utils->CreateLoad2(
                        actual_array_data_type->getPointerTo(),
                        arr_descr->get_pointer_to_data(actual_array_type, dt));
                    builder->CreateStore(builder->CreateBitCast(
                        actual_array_data, target_struct_type->getPointerTo()),
                        llvm_utils->create_gep2(target_array_data_type, class_array_data, 1));
                    
                    // Get vptr for the struct type
                    ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(arg_expr));
                    llvm::Value* vptr_val = struct_api->get_pointer_to_method(struct_sym, module.get());
                    builder->CreateStore(vptr_val,
                        llvm_utils->create_gep2(target_array_data_type, class_array_data, 0));

                    return class_array;
                }

                // Create Class wrapper
                llvm::Type* target_struct_type = llvm_utils->get_type_from_ttype_t_util(
                    s_m_args0, ASRUtils::extract_type(s_m_args0_type), module.get());
                llvm::Type* call_arg_struct_type = llvm_utils->get_type_from_ttype_t_util(
                    arg_expr, ASRUtils::extract_type(arg_type), module.get());

                if (ASRUtils::is_class_type(ASRUtils::extract_type(arg_type))) {
                    if (LLVM::is_llvm_pointer(*ASRUtils::expr_type(arg_expr)) &&
                            !LLVM::is_llvm_pointer(*ASRUtils::expr_type(s_m_args0))) {
                        dt = llvm_utils->CreateLoad2(call_arg_struct_type->getPointerTo(), dt);
                    }
                    llvm::Type* type = llvm_utils->get_type_from_ttype_t_util(
                        s_m_args0, ASRUtils::expr_type(s_m_args0), module.get());
                    if (!ASRUtils::is_array(ASRUtils::expr_type(s_m_args0))) {
                        return builder->CreateBitCast(dt, type->getPointerTo());
                    } else {
                        return builder->CreateBitCast(dt, type);
                    }
                }

                if (LLVM::is_llvm_pointer(*ASRUtils::expr_type(arg_expr)) &&
                        !ASRUtils::is_array(ASRUtils::expr_type(s_m_args0))) {
                    dt = llvm_utils->CreateLoad2(call_arg_struct_type->getPointerTo(), dt);
                }

                llvm::Value* class_wrapper;
                llvm::Value* class_value;

                if (LLVM::is_llvm_pointer(*ASRUtils::expr_type(s_m_args0))) {
                    // For POINTER parameters, we need two levels:
                    // 1. Allocate the actual class structure
                    // 2. Allocate a pointer to it
                    class_value = llvm_utils->CreateAlloca(target_struct_type);
                    class_wrapper = llvm_utils->CreateAlloca(target_struct_type->getPointerTo());
                    builder->CreateStore(class_value, class_wrapper);
                } else {
                    // For non-POINTER parameters, allocate class structure directly
                    class_wrapper = llvm_utils->CreateAlloca(
                        llvm_utils->get_type_from_ttype_t_util(s_m_args0,
                        ASRUtils::type_get_past_array(ASRUtils::expr_type(s_m_args0)), module.get()));
                    class_value = class_wrapper;
                }

                // Store Vptr and its member from original struct
                if (ASRUtils::is_class_type(ASRUtils::extract_type(arg_type))) {
                    llvm::Value* vptr = builder->CreateBitCast(dt, llvm_utils->vptr_type->getPointerTo());
                    vptr = llvm_utils->CreateLoad2(llvm_utils->vptr_type, vptr);
                    builder->CreateStore(vptr, llvm_utils->create_gep2(
                        target_struct_type, class_value, 0));
                    llvm::Value* actual_struct = llvm_utils->create_gep2(call_arg_struct_type, dt, 1);

                    actual_struct = llvm_utils->CreateLoad2(llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg_expr))), module.get(), true), actual_struct);
                    builder->CreateStore(builder->CreateBitCast(actual_struct, llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))), module.get(), true)),
                        llvm_utils->create_gep2(target_struct_type, class_value, 1));
                } else {
                    builder->CreateStore(struct_api->get_pointer_to_method(ASRUtils::symbol_get_past_external(
                        ASRUtils::get_struct_sym_from_struct_expr(arg_expr)), module.get()),
                        llvm_utils->create_gep2(target_struct_type, class_value, 0));
                    builder->CreateStore(builder->CreateBitCast(dt, llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))), module.get(), true)),
                        llvm_utils->create_gep2(target_struct_type, class_value, 1));
                }
                return class_wrapper;
            } else {
                return dt;
            }
        }
        if( !ASRUtils::is_class_type(ASRUtils::type_get_past_array(s_m_args0_type)) ) {
            return dt;
        }

        if( ASRUtils::is_unlimited_polymorphic_type(s_m_args0) ) {
            if (ASRUtils::is_class_type(arg_type)) {
                if( ASRUtils::is_array(s_m_args0_type) ) {
                    // TODO: Handle this case
                    return dt;
                } else {
                    llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(s_m_args0, s_m_args0_type, module.get());
                    llvm::Type* dt_type = llvm_utils->get_type_from_ttype_t_util(arg_expr, arg_type, module.get());
                    ASR::ttype_t* wrapped_struct_type = ASRUtils::make_StructType_t_util(al, arg_expr->base.loc,
                                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg_expr)), true);
                    llvm::Type* wrapped_struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(arg_expr, wrapped_struct_type, module.get());
                    llvm::Value* abstract_ = llvm_utils->CreateAlloca(_type);
                    llvm::Value* polymorphic_addr = llvm_utils->create_gep2(_type, abstract_, 1);
                    builder->CreateStore(
                        builder->CreateBitCast(
                            llvm_utils->CreateLoad2(wrapped_struct_llvm_type->getPointerTo(),
                                                    llvm_utils->create_gep2(dt_type, dt, 1)),
                            llvm::Type::getVoidTy(context)->getPointerTo()),
                        polymorphic_addr);
                    llvm::Value* type_id_addr = llvm_utils->create_gep2(_type, abstract_, 0);
                    if (ASR::is_a<ASR::StructType_t>(*arg_type)) {
                        llvm::Value* hash = llvm_utils->create_gep2(dt_type, dt, 0);
                        hash = llvm_utils->CreateLoad2(llvm_utils->getIntType(8), hash);
                        builder->CreateStore(hash, type_id_addr);
                    } else {
                        // Case: when integer, real, character etc. passed to class(*) argument
                        llvm::Value* hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                            llvm::APInt(64, -((int) arg_type->type) -
                            ASRUtils::extract_kind_from_ttype_t(arg_type), true));
                        builder->CreateStore(hash, type_id_addr);
                    }
                    return abstract_;
                }
            }
            if( ASRUtils::is_array(s_m_args0_type) ) {
                llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(s_m_args0, s_m_args0_type, module.get());
                llvm::Value* abstract_array = llvm_utils->CreateAlloca(array_type);
                llvm::Type* array_data_type = llvm_utils->get_el_type(s_m_args0,
                    ASRUtils::type_get_past_array(s_m_args0_type), module.get());
                llvm::Type* dt_array_data_type = llvm_utils->get_el_type(arg_expr,
                    ASRUtils::type_get_past_array(arg_type), module.get());
                llvm::Value* array_data = llvm_utils->CreateAlloca(array_data_type);
                builder->CreateStore(array_data,
                    arr_descr->get_pointer_to_data(array_type, abstract_array));
                arr_descr->fill_array_details(arg_expr, s_m_args0, dt, abstract_array, arg_type, s_m_args0_type, module.get(), true);
                llvm::Value* polymorphic_data = llvm_utils->CreateLoad2(array_data_type->getPointerTo(),
                    arr_descr->get_pointer_to_data(array_type, abstract_array));
                llvm::Value* polymorphic_data_addr = llvm_utils->create_gep2(array_data_type, polymorphic_data, 1);
                llvm::Value* dt_data = llvm_utils->CreateLoad2(dt_array_data_type->getPointerTo(), arr_descr->get_pointer_to_data(arg_expr, arg_type, dt, module.get()));
                builder->CreateStore(
                    builder->CreateBitCast(dt_data, llvm::Type::getVoidTy(context)->getPointerTo()),
                    polymorphic_data_addr);
                llvm::Value* type_id_addr = llvm_utils->create_gep2(array_data_type, polymorphic_data, 0);
                builder->CreateStore(
                    llvm::ConstantInt::get(llvm_utils->getIntType(8),
                        llvm::APInt(64, -((int) ASRUtils::type_get_past_array(arg_type)->type) -
                            ASRUtils::extract_kind_from_ttype_t(arg_type), true)),
                    type_id_addr);
                return abstract_array;
            } else {
                llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(s_m_args0, s_m_args0_type, module.get());
                llvm::Value* abstract_ = llvm_utils->CreateAlloca(_type);
                llvm::Value* polymorphic_addr = llvm_utils->create_gep2(_type, abstract_, 1);
                builder->CreateStore(
                    builder->CreateBitCast(dt, llvm::Type::getVoidTy(context)->getPointerTo()),
                    polymorphic_addr);
                llvm::Value* type_id_addr = llvm_utils->create_gep2(_type, abstract_, 0);
                if (ASR::is_a<ASR::StructType_t>(*arg_type) && !ASRUtils::is_class_type(arg_type)) {
                    ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg_expr)));
                    llvm::Value* hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                    llvm::APInt(64, get_class_hash(struct_sym)));
                    builder->CreateStore(hash, type_id_addr);
                } else {
                    // Case: when integer, real, character etc. passed to class(*) argument
                    llvm::Value* hash = llvm::ConstantInt::get(llvm_utils->getIntType(8),
                        llvm::APInt(64, -((int) arg_type->type) -
                        ASRUtils::extract_kind_from_ttype_t(arg_type), true));
                    builder->CreateStore(hash, type_id_addr);
                }
                return abstract_;
            }
        } else if( ASR::is_a<ASR::StructType_t>(*ASRUtils::type_get_past_array(arg_type)) ) {
            ASR::StructType_t* struct_t = ASR::down_cast<ASR::StructType_t>(ASRUtils::type_get_past_array(arg_type));
            if (struct_t->m_is_cstruct) {
                ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg_expr)));
                if( type2vtab.find(struct_sym) == type2vtab.end() &&
                    type2vtab[struct_sym].find(current_scope) == type2vtab[struct_sym].end() ) {
                    if (compiler_options.new_classes) {
                        // struct_api->create_new_vtable_for_struct_type(struct_sym, module.get());
                    } else {
                        create_vtab_for_struct_type(struct_sym, current_scope);
                    }
                }
                if (ASRUtils::is_array(s_m_args0_type) &&
                    ASRUtils::extract_physical_type(s_m_args0_type) == ASR::array_physical_typeType::DescriptorArray) {
                    // TODO: Handle convert of descriptor arrays
                }
                if ( compiler_options.new_classes ) {
                    return builder->CreateBitCast(dt, llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))), module.get(), true));
                } else {
                    llvm::Value* dt_polymorphic = llvm_utils->CreateAlloca(
                        llvm_utils->getClassType(ASR::down_cast<ASR::Struct_t>(
                                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))),
                                LLVM::is_llvm_pointer(*s_m_args0_type)));

                    llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(s_m_args0,
                        ASRUtils::type_get_past_array(s_m_args0_type), module.get());

                    llvm::Value* hash_ptr = llvm_utils->create_gep2(_type, dt_polymorphic, 0);
                    llvm::Value* hash = llvm::ConstantInt::get(llvm_utils->getIntType(8), llvm::APInt(64, get_class_hash(struct_sym)));
                    builder->CreateStore(hash, hash_ptr);
                    llvm::Value* class_ptr = llvm_utils->create_gep2(_type, dt_polymorphic, 1);

                    builder->CreateStore(builder->CreateBitCast(dt, llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))), module.get(), true)), class_ptr);

                    return dt_polymorphic;
                }
            } else {
                // No need to convert if types are same
                if (llvm_utils->getClassType(
                        ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))),
                        true)
                    == llvm_utils->getClassType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg_expr))), true)) {
                    return dt;
                }
                ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(arg_expr)));
                if( type2vtab.find(struct_sym) == type2vtab.end() &&
                    type2vtab[struct_sym].find(current_scope) == type2vtab[struct_sym].end() ) {
                    if (compiler_options.new_classes) {
                        // struct_api->create_new_vtable_for_struct_type(struct_sym, module.get());
                    } else {
                        create_vtab_for_struct_type(struct_sym, current_scope);
                    }
                }

                llvm::Value* dt_polymorphic = llvm_utils->CreateAlloca(
                llvm_utils->getClassType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0))), LLVM::is_llvm_pointer(*s_m_args0_type)));
                llvm::Type* _type = llvm_utils->get_type_from_ttype_t_util(s_m_args0, s_m_args0_type, module.get());
                llvm::Value* hash_ptr = llvm_utils->create_gep2(_type, dt_polymorphic, 0);
                llvm::Value* hash = llvm::ConstantInt::get(llvm_utils->getIntType(8), llvm::APInt(64, get_class_hash(struct_sym)));
                builder->CreateStore(hash, hash_ptr);

                llvm::Type* dt_base_type = llvm_utils->get_type_from_ttype_t_util(arg_expr, arg_type, module.get());
                // Convert input arg from polymorphic to normal
                dt = llvm_utils->create_gep2(dt_base_type, dt, 1);
                dt = llvm_utils->CreateLoad2(dt_base_type->getPointerTo(),dt);

                ASR::symbol_t* dest_struct_sym = ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(s_m_args0)));
                llvm::Type* dest_ty = name2dertype[ASRUtils::symbol_name(dest_struct_sym)]->getPointerTo();
                dt = builder->CreateBitCast(dt, dest_ty);

                llvm::Value* class_ptr = llvm_utils->create_gep2(_type, dt_polymorphic, 1);
                builder->CreateStore(dt, class_ptr);

                return dt_polymorphic;
            }
        }
        return dt;
    }

    llvm::Value* get_array_size_from_asr_type(ASR::ttype_t* type) {
        ASR::dimension_t* m_dims = nullptr;
        int n_dims = ASRUtils::extract_dimensions_from_ttype(type, m_dims);
        if( ASRUtils::extract_physical_type(type) == ASR::array_physical_typeType::FixedSizeArray ) {
            int64_t size = ASRUtils::get_fixed_size_of_array(m_dims, n_dims);
            return llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, size));
        } else {
            llvm::Value* llvm_size = llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, 1));
            int ptr_loads_copy = ptr_loads;
            ptr_loads = 2;
            for( int i = 0; i < n_dims; i++ ) {
                if (m_dims[i].m_length) {
                    load_array_size_deep_copy(m_dims[i].m_length);
                    tmp = builder->CreateSExtOrTrunc(tmp, llvm_utils->getIntType(4));
                    llvm_size = builder->CreateMul(tmp, llvm_size);
                }
            }
            ptr_loads = ptr_loads_copy;
            return llvm_size;
        }
    }

    llvm::Value* expr_is_unallocated(ASR::expr_t* arg_expr) {
        ASR::ttype_t* arg_expr_type = ASRUtils::expr_type(arg_expr);
        LCOMPILERS_ASSERT(ASRUtils::is_allocatable(arg_expr_type))
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 1 - !LLVM::is_llvm_pointer(*arg_expr_type);
        this->visit_expr_wrapper(arg_expr, true);
        ptr_loads = ptr_loads_copy;

        llvm::Value* cond = nullptr;
        llvm::Type* arg_expr_llvm_type = llvm_utils->get_type_from_ttype_t_util(arg_expr, arg_expr_type, module.get());
        const bool is_descriptor_array = ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable_pointer(arg_expr_type))
                                                && ASRUtils::extract_physical_type(arg_expr_type) == ASR::DescriptorArray;
        if (is_descriptor_array) {
            llvm::Value* is_allocated = arr_descr->get_is_allocated_flag(tmp, arg_expr);
            cond = builder->CreateNot(is_allocated);
        } else if (ASRUtils::is_string_only(arg_expr_type)) {
            tmp = llvm_utils->get_string_data(ASR::down_cast<ASR::String_t>(ASRUtils::type_get_past_allocatable_pointer(arg_expr_type)), tmp);
            cond = builder->CreateICmpEQ(
                builder->CreatePtrToInt(tmp,
                    llvm::Type::getInt64Ty(context)),
                builder->CreatePtrToInt(llvm::ConstantPointerNull::get(arg_expr_llvm_type->getPointerTo()),
                    llvm::Type::getInt64Ty(context)));
        } else {
            cond = builder->CreateICmpEQ(
                builder->CreatePtrToInt(tmp,
                    llvm::Type::getInt64Ty(context)),
                builder->CreatePtrToInt(llvm::ConstantPointerNull::get(arg_expr_llvm_type->getPointerTo()),
                    llvm::Type::getInt64Ty(context)));
        }

        return cond;
    }

    template<typename T>
    void bounds_check_call(T& x, bool subroutinecall_was_functioncall = false) {
        ASR::Function_t* function = nullptr;
        ASR::symbol_t* m_name = ASRUtils::symbol_get_past_external(x.m_name);
        bool is_nopass = false;
        if (ASR::is_a<ASR::Function_t>(*m_name)) {
            function = ASR::down_cast<ASR::Function_t>(m_name);
        } else if (ASR::is_a<ASR::StructMethodDeclaration_t>(*m_name)) {
            ASR::StructMethodDeclaration_t *clss_proc = ASR::down_cast<
                ASR::StructMethodDeclaration_t>(m_name);
            function = ASR::down_cast<ASR::Function_t>(clss_proc->m_proc);
            is_nopass = clss_proc->m_is_nopass;
        } else if (ASR::is_a<ASR::Variable_t>(*m_name)) {
            // Ignore functions passed in as arguments
            return;
        } else {
            throw CodeGenError("bounds_check_call: Symbol type not supported");
        }
        bool is_method = x.m_dt && !is_nopass;
        for (size_t i = 0; i < x.n_args; i++) {
            ASR::expr_t* arg_expr = x.m_args[i].m_value;
            ASR::ttype_t* arg_expr_type = ASRUtils::expr_type(x.m_args[i].m_value);
            if (ASR::is_a<ASR::ArrayPhysicalCast_t>(*arg_expr)) {
                ASR::ArrayPhysicalCast_t* arr_cast = ASR::down_cast<ASR::ArrayPhysicalCast_t>(arg_expr);
                // Use strict bounds checking if SubroutineCall was a FunctionCall before getting converted by subroutine_from_function
                // Last argument of converted subroutine is the return value of the FunctionCall
                // This argument should be checked strictly. It's size must be exactly equal to the expected size, it cannot be larger
                bool is_return_value = subroutinecall_was_functioncall && i == (x.n_args - 1);

                llvm::Value* is_present_flag = nullptr;
                llvm::BasicBlock *optional_check_mergeBB = nullptr;
                if (i + 1 < x.n_args && x.m_args[i + 1].m_value != nullptr) {
                    ASR::expr_t* next_arg = x.m_args[i + 1].m_value;
                    if (ASR::is_a<ASR::Var_t>(*next_arg)) {
                        ASR::Variable_t* next_var = ASRUtils::EXPR2VAR(next_arg);
                        std::string var_name = std::string(next_var->m_name);
                        ASR::ttype_t* var_type = ASRUtils::type_get_past_pointer(next_var->m_type);
                        std::string prefix = "__libasr_is_present_";
                        if (var_name.size() > prefix.size() && 
                            var_name.substr(0, prefix.size()) == prefix &&
                            ASR::is_a<ASR::Logical_t>(*var_type)) {
                          
                            this->visit_expr_wrapper(next_arg, true);
                            is_present_flag = tmp; 
                            
                            llvm::Function *fn = builder->GetInsertBlock()->getParent();
                            llvm::BasicBlock *present_checkBB = llvm::BasicBlock::Create(context, "optional_present", fn);
                            optional_check_mergeBB = llvm::BasicBlock::Create(context, "optional_merge");
                            builder->CreateCondBr(is_present_flag, present_checkBB, optional_check_mergeBB);
                            builder->SetInsertPoint(present_checkBB);
                        }
                    }
                }

                if (arr_cast->m_old == ASR::DescriptorArray && (arr_cast->m_new == ASR::PointerArray || arr_cast->m_new == ASR::FixedSizeArray)) {
                    int64_t ptr_loads_copy = ptr_loads;
                    ptr_loads = 1 - !LLVM::is_llvm_pointer(*ASRUtils::expr_type(arr_cast->m_arg));
                    this->visit_expr_wrapper(arr_cast->m_arg, true);
                    ptr_loads = ptr_loads_copy;

                    llvm::Type* arr_type = llvm_utils->get_type_from_ttype_t_util(arr_cast->m_arg,
                        ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(arr_cast->m_arg)),
                        module.get());
                    llvm::Value* arg = tmp;

                    // Throw error if descriptor array is not allocated
                    llvm::Value* is_allocated = arr_descr->get_is_allocated_flag(arg, arr_cast->m_arg);
                    llvm_utils->generate_runtime_error(builder->CreateNot(is_allocated),
                            "Argument %d of subroutine %s is unallocated.",
                            {LLVMUtils::RuntimeLabel("This is unallocated", {arg_expr->base.loc}, {})},
                            infile,
                            location_manager,
                            llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)),
                            LCompilers::create_global_string_ptr(context, *module, *builder, ASRUtils::symbol_name(x.m_name)));

                    // Throw error if shapes don't match
                    ASR::dimension_t* m_dims = nullptr;
                    int n_dims = ASRUtils::extract_dimensions_from_ttype(arr_cast->m_type, m_dims);
                    llvm::Value* desc_rank = arr_descr->get_rank(arr_type, arg);
                    llvm::Value* pointer_rank = llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, n_dims));
                    llvm::Function *fn = builder->GetInsertBlock()->getParent();

                    llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
                    llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");
                    llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");

                    builder->CreateCondBr(builder->CreateICmpEQ(desc_rank, pointer_rank), thenBB, elseBB);
                    builder->SetInsertPoint(thenBB);
                    for (int j = 0; j < n_dims; j++) {
                        if (m_dims[j].m_length) {
                            llvm::Value* dim = llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, j + 1));
                            llvm::Value* descriptor_length = arr_descr->get_array_size(arr_type, arg, dim, 4);
                            load_array_size_deep_copy(m_dims[j].m_length);
                            // Convert user dimension expression to i32 to match descriptor format
                            llvm::Value* pointer_length = builder->CreateSExtOrTrunc(
                                tmp, llvm::Type::getInt32Ty(context));
                            llvm::Value* cond = nullptr;
                            if (compiler_options.po.strict_bounds_checking || is_return_value) {
                                cond = builder->CreateICmpNE(descriptor_length, pointer_length);
                            } else {
                                cond = builder->CreateICmpSLT(descriptor_length, pointer_length);
                            }
                            llvm_utils->generate_runtime_error(cond,
                                    "Array shape mismatch in subroutine '%s'. Tried to match size %d of dimension %d of argument number %d, but expected size is %d",
                                    {LLVMUtils::RuntimeLabel("", {arg_expr->base.loc}),
                                        function->m_start_name ? LLVMUtils::RuntimeLabel("Here", {*function->m_start_name}, {}, false): LLVMUtils::RuntimeLabel("", {}),
                                        LLVMUtils::RuntimeLabel("Parameter is size %d, argument is size %d", {m_dims[j].loc}, {pointer_length, descriptor_length}, false)},
                                    infile,
                                    location_manager,
                                    LCompilers::create_global_string_ptr(context, *module, *builder, ASRUtils::symbol_name(x.m_name)),
                                    descriptor_length,
                                    dim,
                                    llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)),
                                    pointer_length);
                        }
                    }
                    builder->CreateBr(mergeBB);
                    start_new_block(elseBB);
                    llvm::Value* desc_size = arr_descr->get_array_size(arr_type, arg, nullptr, 4);
                    // Convert user array size to i32 to match descriptor format
                    llvm::Value* pointer_size = builder->CreateSExtOrTrunc(
                        get_array_size_from_asr_type(arr_cast->m_type),
                        llvm::Type::getInt32Ty(context));
                    llvm::Value* cond = nullptr;
                    if (compiler_options.po.strict_bounds_checking || is_return_value) {
                        cond = builder->CreateICmpNE(desc_size, pointer_size);
                    } else {
                        cond = builder->CreateICmpSLT(desc_size, pointer_size);
                    }
                    llvm_utils->generate_runtime_error(cond,
                            "Array size mismatch in subroutine '%s'. Tried to match size %d of argument number %d, but expected size is %d",
                            {LLVMUtils::RuntimeLabel("", {arg_expr->base.loc})},
                            infile,
                            location_manager,
                            LCompilers::create_global_string_ptr(context, *module, *builder, ASRUtils::symbol_name(x.m_name)),
                            desc_size,
                            llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)),
                            pointer_size);
                    builder->CreateBr(mergeBB);
                    start_new_block(mergeBB);
                } else if (arr_cast->m_old == ASR::FixedSizeArray && arr_cast->m_new == ASR::PointerArray) {
                    ASR::ttype_t* fixed_size_type = ASRUtils::expr_type(arr_cast->m_arg);
                    ASR::dimension_t* m_dims_fixed = nullptr;
                    int n_dims_fixed = ASRUtils::extract_dimensions_from_ttype(fixed_size_type, m_dims_fixed);

                    ASR::dimension_t* m_dims_pointer = nullptr;
                    int n_dims_pointer = ASRUtils::extract_dimensions_from_ttype(arr_cast->m_type, m_dims_pointer);

                    if (n_dims_fixed == n_dims_pointer) {
                        for (int j = 0; j < n_dims_fixed; j++) {
                            if (m_dims_pointer[j].m_length) {
                                llvm::Value* dim = llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, j + 1));
                                llvm::Value* fixed_length = llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, ASRUtils::extract_dim_value_int(m_dims_fixed[j].m_length)));
                                load_array_size_deep_copy(m_dims_pointer[j].m_length);
                                // Convert user dimension expression to i32 to match fixed-size format
                                llvm::Value* pointer_length = builder->CreateSExtOrTrunc(
                                    tmp, llvm::Type::getInt32Ty(context));
                                llvm::Value* cond = nullptr;
                                if (compiler_options.po.strict_bounds_checking || is_return_value) {
                                    cond = builder->CreateICmpNE(fixed_length, pointer_length);
                                } else {
                                    cond = builder->CreateICmpSLT(fixed_length, pointer_length);
                                }
                                llvm_utils->generate_runtime_error(cond,
                                        "Runtime error: Array shape mismatch in subroutine '%s'\n\n"
                                        "Tried to match size %d of dimension %d of argument number %d, but expected size is %d\n",
                                        {LLVMUtils::RuntimeLabel("", {arg_expr->base.loc})},
                                        infile,
                                        location_manager,
                                        LCompilers::create_global_string_ptr(context, *module, *builder, ASRUtils::symbol_name(x.m_name)),
                                        fixed_length,
                                        dim,
                                        llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)),
                                        pointer_length);
                            }
                        }
                    } else {
                        llvm::Value* fixed_size = llvm::ConstantInt::get(llvm_utils->getIntType(4), ASRUtils::get_fixed_size_of_array(fixed_size_type));
                        // Convert user array size to i32 to match fixed-size format
                        llvm::Value* pointer_size = builder->CreateSExtOrTrunc(
                            get_array_size_from_asr_type(arr_cast->m_type),
                            llvm::Type::getInt32Ty(context));
                        llvm::Value* cond = nullptr;
                        if (compiler_options.po.strict_bounds_checking || is_return_value) {
                            cond = builder->CreateICmpNE(fixed_size, pointer_size);
                        } else {
                            cond = builder->CreateICmpSLT(fixed_size, pointer_size);
                        }
                        llvm_utils->generate_runtime_error(cond,
                                "Runtime error: Array size mismatch in subroutine '%s'\n\n"
                                "Tried to match size %d of argument number %d, but expected size is %d\n",
                                {LLVMUtils::RuntimeLabel("", {arg_expr->base.loc})},
                                infile,
                                location_manager,
                                LCompilers::create_global_string_ptr(context, *module, *builder, ASRUtils::symbol_name(x.m_name)),
                                fixed_size,
                                llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)),
                                pointer_size);
                    }
                }

                if (optional_check_mergeBB != nullptr) {
                    builder->CreateBr(optional_check_mergeBB);
                    start_new_block(optional_check_mergeBB);
                }
            } else if (ASRUtils::is_allocatable(arg_expr_type)) {
                ASR::FunctionType_t *ft = ASRUtils::get_FunctionType(function);
                ASR::Variable_t *func_arg_variable = ASRUtils::expr_to_variable_or_null(function->m_args[i + is_method]);
                LCOMPILERS_ASSERT(func_arg_variable != nullptr);
                if (!ASRUtils::is_allocatable(ft->m_arg_types[i + is_method]) &&
                    ASRUtils::symbol_intent((ASR::symbol_t *)func_arg_variable) != ASRUtils::intent_out) {
                    llvm_utils->generate_runtime_error(expr_is_unallocated(arg_expr),
                            "Argument %d of subroutine %s is unallocated.",
                            {LLVMUtils::RuntimeLabel("This is unallocated", {arg_expr->base.loc})},
                            infile,
                            // arg_expr->base.loc,
                            location_manager,
                            llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)),
                            LCompilers::create_global_string_ptr(context, *module, *builder, ASRUtils::symbol_name(x.m_name)));
                }
            }
        }
    }

    void visit_SubroutineCall(const ASR::SubroutineCall_t &x) {
        if (compiler_options.emit_debug_info) debug_emit_loc(x);
        if( ASRUtils::is_intrinsic_optimization(x.m_name) ) {
            ASR::Function_t* routine = ASR::down_cast<ASR::Function_t>(
                        ASRUtils::symbol_get_past_external(x.m_name));
            if( generate_optimization_instructions(routine, x.m_args) ) {
                return ;
            }
        }

        // Generate runtime error if array arguments' shape doesn't match
        if (compiler_options.po.bounds_checking) {
            bounds_check_call(x, x.m_strict_bounds_checking);
        }

        std::vector<llvm::Value*> args;
        if( x.m_dt && ASR::is_a<ASR::StructInstanceMember_t>(*x.m_dt) &&
            ASR::is_a<ASR::Variable_t>(*ASRUtils::symbol_get_past_external(x.m_name)) &&
            ASR::is_a<ASR::FunctionType_t>(*ASRUtils::symbol_type(x.m_name)) ) {
            uint64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 1;
            this->visit_expr(*x.m_dt);
            ptr_loads = ptr_loads_copy;
            llvm::Type* func_ptr_type = llvm_utils->get_type_from_ttype_t_util(x.m_dt, ASRUtils::symbol_type(x.m_name), module.get());
            llvm::Value* callee = llvm_utils->CreateLoad2(func_ptr_type, tmp);

            args = convert_call_args(x, false);
            ASR::Function_t* func = nullptr;
            if (ASR::is_a<ASR::Variable_t>(*ASRUtils::symbol_get_past_external(x.m_name))) {
                ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(
                    ASRUtils::symbol_get_past_external(x.m_name));
                func = ASR::down_cast<ASR::Function_t>(
                    ASRUtils::symbol_get_past_external(var->m_type_declaration));
            } else if (ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(x.m_name))) {
                func = ASR::down_cast<ASR::Function_t>(
                    ASRUtils::symbol_get_past_external(x.m_name));
            }
            llvm::FunctionType* fntype = llvm_utils->get_function_type(*func, module.get());
            tmp = builder->CreateCall(fntype, callee, args);
            return ;
        }

        const ASR::symbol_t *proc_sym = symbol_get_past_external(x.m_name);
        std::string proc_sym_name = "";
        bool is_runtime_polymorphism = false;
        bool is_nopass = false;
        if( ASR::is_a<ASR::StructMethodDeclaration_t>(*proc_sym) ) {
            ASR::StructMethodDeclaration_t* class_proc =
                ASR::down_cast<ASR::StructMethodDeclaration_t>(proc_sym);
            is_runtime_polymorphism = ASRUtils::is_class_type(ASRUtils::extract_type(ASRUtils::expr_type(x.m_dt)));
            proc_sym_name = class_proc->m_name;
            is_nopass = class_proc->m_is_nopass;
        }
        ASR::Function_t *s;
        char* self_argument = nullptr;
        llvm::Value* pass_arg = nullptr;
        if (ASR::is_a<ASR::Function_t>(*proc_sym)) {
            s = ASR::down_cast<ASR::Function_t>(proc_sym);
        } else if (ASR::is_a<ASR::StructMethodDeclaration_t>(*proc_sym)) {
            ASR::StructMethodDeclaration_t *clss_proc = ASR::down_cast<
                ASR::StructMethodDeclaration_t>(proc_sym);
            s = ASR::down_cast<ASR::Function_t>(clss_proc->m_proc);
            self_argument = clss_proc->m_self_argument;
            proc_sym = clss_proc->m_proc;
        } else if (ASR::is_a<ASR::Variable_t>(*proc_sym)) {
            ASR::symbol_t *type_decl = ASR::down_cast<ASR::Variable_t>(proc_sym)->m_type_declaration;
            LCOMPILERS_ASSERT(type_decl && ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(type_decl)));
            s = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(type_decl));
        } else {
            throw CodeGenError("SubroutineCall: Symbol type not supported");
        }
        if( s == nullptr ) {
            s = ASR::down_cast<ASR::Function_t>(symbol_get_past_external(x.m_name));
        }
        bool is_method = false;
        if (x.m_dt && (!is_nopass)) {
            is_method = true;
            ASR::expr_t* dt_expr = x.m_dt;
            if (ASR::is_a<ASR::Cast_t>(*dt_expr)) {
                ASR::Cast_t* cast = ASR::down_cast<ASR::Cast_t>(dt_expr);
                dt_expr = cast->m_arg;
            }
            if (ASR::is_a<ASR::Var_t>(*dt_expr)) {
                ASR::Variable_t *caller = EXPR2VAR(dt_expr);
                std::uint32_t h = get_hash((ASR::asr_t*)caller);
                // declared variable in the current scope
                llvm::Value* dt = llvm_symtab[h];
                // Function class type
                ASR::ttype_t* s_m_args0_type = ASRUtils::type_get_past_pointer(
                                                ASRUtils::expr_type(s->m_args[0]));
                // derived type declared type
                ASR::ttype_t* dt_type = ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(caller->m_type));
                dt = convert_to_polymorphic_arg(dt_expr, dt, s->m_args[0], s_m_args0_type, dt_type);
                args.push_back(dt);
            } else if (ASR::is_a<ASR::StructInstanceMember_t>(*dt_expr)) {
                // Declared struct variable
                this->visit_expr(*dt_expr);
                llvm::Value* dt = tmp;
                ASR::ttype_t* caller_type = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(dt_expr));

                // Function's class type
                ASR::ttype_t *s_m_args0_type;
                ASR::expr_t* s_m_args0 = nullptr;
                if (self_argument != nullptr) {
                    ASR::symbol_t *class_sym = s->m_symtab->resolve_symbol(self_argument);
                    ASR::Variable_t *var = ASR::down_cast<ASR::Variable_t>(class_sym);
                    s_m_args0 = ASRUtils::EXPR(ASR::make_Var_t(al, var->base.base.loc, &var->base));
                    s_m_args0_type = ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(var->m_type));
                    s_m_args0 = ASRUtils::EXPR(ASR::make_Var_t(al, var->base.base.loc, (ASR::symbol_t*) var));
                } else {
                    s_m_args0 = s->m_args[0];
                    s_m_args0_type = ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(
                        ASRUtils::expr_type(s->m_args[0])));
                }

                // Convert to polymorphic argument
                llvm::Value* dt_polymorphic = convert_to_polymorphic_arg(dt_expr, dt, s_m_args0, s_m_args0_type, caller_type);

                if (self_argument == nullptr) {
                    args.push_back(dt_polymorphic);
                } else {
                    pass_arg = dt_polymorphic;
                }
            } else if (ASR::is_a<ASR::ArrayItem_t>(*dt_expr)){
                this->visit_expr(*dt_expr);
                llvm::Value* dt = tmp;
                llvm::Value* dt_polymorphic = tmp;
                dt_polymorphic = convert_to_polymorphic_arg(dt_expr, dt, s->m_args[0], ASRUtils::expr_type(s->m_args[0]),
                                                ASRUtils::expr_type(dt_expr));
                args.push_back(dt_polymorphic);
            } else {
                throw CodeGenError("SubroutineCall: StructType symbol type not supported");
            }
        }
        if (is_runtime_polymorphism) {
            if (is_nopass || args.empty()) {
                visit_RuntimePolymorphicSubroutineCall(x, proc_sym_name, nullptr);
            } else {
                visit_RuntimePolymorphicSubroutineCall(x, proc_sym_name, args[0]);
            }
            return;
        }
        std::string sub_name = s->m_name;
        uint32_t h;
        ASR::FunctionType_t* s_func_type = ASR::down_cast<ASR::FunctionType_t>(s->m_function_signature);
        if (s_func_type->m_abi == ASR::abiType::LFortranModule) {
            throw CodeGenError("Subroutine LCompilers interfaces not implemented yet");
        } else if (s_func_type->m_abi == ASR::abiType::ExternalUndefined) {
            h = get_hash((ASR::asr_t*)proc_sym);
        } else if (s_func_type->m_abi == ASR::abiType::Source) {
            h = get_hash((ASR::asr_t*)proc_sym);
        } else if (s_func_type->m_abi == ASR::abiType::BindC) {
            h = get_hash((ASR::asr_t*)proc_sym);
        } else if (s_func_type->m_abi == ASR::abiType::Intrinsic) {
            if (sub_name == "get_command_argument") {
                llvm::Function *fn = module->getFunction("_lpython_get_argv");
                if (!fn) {
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                        character_type, {
                            llvm::Type::getInt32Ty(context)
                        }, false);
                    fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, "_lpython_get_argv", module.get());
                }
                args = convert_call_args(x, is_method);
                LCOMPILERS_ASSERT(args.size() > 0);
                tmp = builder->CreateCall(fn, {llvm_utils->CreateLoad2(
                    llvm::Type::getInt32Ty(context), args[0])});
                if (args.size() > 1)
                    builder->CreateStore(tmp, args[1]);
                return;
            } else if (sub_name == "get_environment_variable") {
                llvm::Function *fn = module->getFunction("_lfortran_get_env_variable");
                if (!fn) {
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                        character_type, {
                            character_type
                        }, false);
                    fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, "_lfortran_get_env_variable", module.get());
                }
                args = convert_call_args(x, is_method);
                LCOMPILERS_ASSERT(args.size() > 0);
                tmp = builder->CreateCall(fn, { llvm_utils->CreateLoad2(character_type, args[0]) });
                if (args.size() > 1)
                    builder->CreateStore(tmp, args[1]);
                return;
            } else if (sub_name == "_lcompilers_execute_command_line_" ||
                       sub_name == "_lcompilers_system_") {
                llvm::Function *fn = module->getFunction("_lfortran_exec_command");
                if (!fn) {
                    llvm::FunctionType *function_type = llvm::FunctionType::get(
                        llvm::Type::getInt32Ty(context), {
                            character_type
                        }, false);
                    fn = llvm::Function::Create(function_type,
                        llvm::Function::ExternalLinkage, "_lfortran_exec_command", module.get());
                }
                args = convert_call_args(x, is_method);
                LCOMPILERS_ASSERT(args.size() > 0);
                tmp = builder->CreateCall(fn, { llvm_utils->CreateLoad2(character_type, args[0]) });
                return;
            }
            h = get_hash((ASR::asr_t*)proc_sym);
        } else {
            throw CodeGenError("ABI type not implemented yet in SubroutineCall.");
        }
        if (llvm_symtab_fn_arg.find(h) != llvm_symtab_fn_arg.end()) {
            // Check if this is a callback function
            llvm::Value* fn = llvm_symtab_fn_arg[h];
            llvm::FunctionType* fntype = llvm_symtab_fn[h]->getFunctionType();
            std::string m_name = ASRUtils::symbol_name(x.m_name);
            if ( x.m_original_name && ASR::is_a<ASR::Variable_t>(*x.m_original_name) ) {
                ASR::Variable_t* x_m_original_name = ASR::down_cast<ASR::Variable_t>(x.m_original_name);
                if ( x_m_original_name->m_intent == ASRUtils::intent_out || x_m_original_name->m_intent == ASRUtils::intent_inout ) {
                    fn = llvm_utils->CreateLoad2(llvm_utils->get_type_from_ttype_t_util(ASRUtils::EXPR(ASR::make_Var_t(
                    al, x_m_original_name->base.base.loc, &x_m_original_name->base)), x_m_original_name->m_type, module.get()), fn);
                }
            }
            args = convert_call_args(x, is_method);
            tmp = builder->CreateCall(fntype, fn, args);
        } else if (ASR::is_a<ASR::Variable_t>(*proc_sym) &&
                llvm_symtab.find(h) != llvm_symtab.end()) {
            llvm::Value* fn = llvm_symtab[h];
            ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(proc_sym);
            if (v->m_type_declaration == nullptr) {
                throw CodeGenError("Procedure variable '" + std::string(v->m_name)
                    + "' has no interface. Add explicit interface or ensure it is called somewhere.");
            }
            llvm::FunctionType* fntype = llvm_utils->get_function_type(*ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(v->m_type_declaration)), module.get());
            fn = llvm_utils->CreateLoad2(fntype->getPointerTo(), fn);
            std::string m_name = ASRUtils::symbol_name(x.m_name);
            args = convert_call_args(x, is_method);
            tmp = builder->CreateCall(fntype, fn, args);
        } else if (llvm_symtab_fn.find(h) == llvm_symtab_fn.end()) {
            throw CodeGenError("Subroutine code not generated for '"
                + std::string(s->m_name) + "'");
            return;
        } else {
            llvm::Function *fn = llvm_symtab_fn[h];
            std::string m_name = ASRUtils::symbol_name(x.m_name);
            std::vector<llvm::Value *> args2 = convert_call_args(x, is_method);
            args.insert(args.end(), args2.begin(), args2.end());
            // check if type of each arg is same as type of each arg in subrout_called
            if (ASR::is_a<ASR::Function_t>(*symbol_get_past_external(x.m_name))) {
                ASR::Function_t* subrout_called = ASR::down_cast<ASR::Function_t>(symbol_get_past_external(x.m_name));
                for (size_t i = 0; i < subrout_called->n_args; i++) {
                    ASR::expr_t* expected_arg = subrout_called->m_args[i];
                    ASR::expr_t* passed_arg = x.m_args[i].m_value;
                    ASR::ttype_t* expected_arg_type = ASRUtils::expr_type(expected_arg);
                    ASR::ttype_t* passed_arg_type = ASRUtils::expr_type(passed_arg);
                    if (ASR::is_a<ASR::ArrayItem_t>(*passed_arg)) {
                        if (!ASRUtils::types_equal(expected_arg_type, passed_arg_type, expected_arg, passed_arg, true)) {
                            if (ASRUtils::is_array(expected_arg_type) &&
                                !ASRUtils::is_array(passed_arg_type)) {
                                ASR::dimension_t* expected_dims = nullptr;
                                int expected_n_dims = ASRUtils::extract_dimensions_from_ttype(
                                    expected_arg_type, expected_dims);
                                bool is_assumed_size = expected_n_dims > 0 &&
                                    expected_dims[expected_n_dims - 1].m_length == nullptr;
                                ASR::ttype_t* expected_elem_type = ASRUtils::type_get_past_array(expected_arg_type);
                                if (is_assumed_size &&
                                    ASRUtils::types_equal(expected_elem_type, passed_arg_type,
                                        expected_arg, passed_arg, true)) {
                                    continue;
                                }
                            }
                            throw CodeGenError("Type mismatch in subroutine call, expected `" + ASRUtils::type_to_str_python_expr(expected_arg_type, expected_arg)
                                    + "`, passed `" + ASRUtils::type_to_str_python_expr(passed_arg_type, passed_arg) + "`", x.m_args[i].m_value->base.loc);
                        }
                    }
                }
            }
            if (pass_arg) {
                args.push_back(pass_arg);
            }
            builder->CreateCall(fn, args);
        }
    }

    void handle_allocated(ASR::expr_t* arg) {
        ASR::ttype_t* asr_type = ASRUtils::expr_type(arg);
        int64_t ptr_loads_copy = ptr_loads;
        if (ASRUtils::is_class_type(ASRUtils::extract_type(asr_type))) {
            bool ref = false;
            if (compiler_options.new_classes) {
                ptr_loads = 1;
                if (ASR::is_a<ASR::StructInstanceMember_t>(*arg)) {
                    ref = true;
                }
            } else {
                ptr_loads = 0;
            }
            visit_expr_wrapper(arg, ref);
        } else {
            ptr_loads = 1;
            visit_expr_wrapper(arg, true);
        }
        ptr_loads = ptr_loads_copy;
        int n_dims = ASRUtils::extract_n_dims_from_ttype(asr_type);
        if (ASRUtils::is_class_type(ASRUtils::extract_type(asr_type)) && !compiler_options.new_classes) {
            // If the pointer is class, get its type pointer
            llvm::Type* class_type = llvm_utils->get_type_from_ttype_t_util(arg, asr_type, module.get());
            tmp = llvm_utils->create_gep2(class_type, tmp, 1);
            tmp = llvm_utils->CreateLoad2(class_type->getPointerTo(), tmp);
        }
        if (ASRUtils::is_class_type(ASRUtils::extract_type(asr_type)) && compiler_options.new_classes &&
                ASRUtils::is_unlimited_polymorphic_type(arg) &&
                !ASR::is_a<ASR::StructInstanceMember_t>(*arg)) {
            // For unlimited polymorphic Var with new_classes, fetch_var returns
            // the raw alloca; load once to get the actual pointer value.
            // StructInstanceMember is already loaded via ref=true above.
            llvm::Type* class_type = llvm_utils->get_type_from_ttype_t_util(arg, asr_type, module.get());
            tmp = llvm_utils->CreateLoad2(class_type, tmp);
        }
        if( n_dims > 0 ) {
            visit_expr_load_wrapper(arg, 1, true);
            tmp = arr_descr->get_is_allocated_flag(tmp, arg);
        } else if (ASRUtils::is_character(*expr_type(arg))) {
            visit_expr_load_wrapper(arg, 0);
            tmp = builder->CreateICmpNE(
                llvm_utils->get_string_data(
                    ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(expr_type(arg))),
                    tmp),
                llvm::ConstantPointerNull::get(
                    character_type));
        } else {
            tmp = builder->CreateICmpNE(
                builder->CreatePtrToInt(tmp, llvm::Type::getInt64Ty(context)),
                    llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), llvm::APInt(64, 0)) );
        }
    }

    llvm::Value* CreatePointerToStructTypeReturnValue(llvm::FunctionType* fnty,
                                                  llvm::Value* return_value,
                                                  ASR::ttype_t* asr_return_type) {
        if( !LLVM::is_llvm_struct(asr_return_type) ) {
            return return_value;
        }

        // Call to LLVM APIs not needed to fetch the return type of the function.
        // We can use asr_return_type as well but anyways for compactness I did it here.
        llvm::Value* pointer_to_struct = llvm_utils->CreateAlloca(*builder, fnty->getReturnType());
        LLVM::CreateStore(*builder, return_value, pointer_to_struct);
        return pointer_to_struct;
    }

    llvm::Value* CreateCallUtil(llvm::FunctionType* fnty, llvm::Function* fn,
                                std::vector<llvm::Value*>& args,
                                ASR::ttype_t* asr_return_type) {
        if (fnty->getReturnType()->isVoidTy()) {
            // Windows complex(kind=8) uses a hidden first argument (sret-style):
            // the function returns `void` and writes the result into the first
            // argument. The ASR still models it as a function with a return
            // variable, so we materialize the return value here.
            if (ASR::is_a<ASR::Complex_t>(*asr_return_type) &&
                ASRUtils::extract_kind_from_ttype_t(asr_return_type) == 8 &&
                compiler_options.platform == Platform::Windows) {
                llvm::Value* sret_tmp = llvm_utils->CreateAlloca(complex_type_8, nullptr, "complex_ret_tmp");
                args.insert(args.begin(), sret_tmp);
                builder->CreateCall(fn, args);
                return llvm_utils->CreateLoad2(complex_type_8, sret_tmp);
            }
        }
        llvm::Value* return_value = builder->CreateCall(fn, args);
        return CreatePointerToStructTypeReturnValue(fnty, return_value,
                                                asr_return_type);
    }

    llvm::Value* CreateCallUtil(llvm::Function* fn, std::vector<llvm::Value*>& args,
                                ASR::ttype_t* asr_return_type) {
        return CreateCallUtil(fn->getFunctionType(), fn, args, asr_return_type);
    }

    void visit_RuntimePolymorphicSubroutineCall(const ASR::SubroutineCall_t& x, std::string proc_sym_name, llvm::Value *llvm_polymorphic) {
        if (compiler_options.new_classes) {
            bool is_pointer = LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_dt));
            uint64_t ptr_loads_copy = ptr_loads;
            ptr_loads = is_pointer;
            this->visit_expr_wrapper(x.m_dt, is_pointer);
            ptr_loads = ptr_loads_copy;
            llvm::Value* llvm_dt = tmp;
            ASR::symbol_t* func_sym = ASRUtils::symbol_get_past_StructMethodDeclaration(
                ASRUtils::symbol_get_past_external(x.m_name));
            ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(
                ASRUtils::get_struct_sym_from_struct_expr(x.m_dt));
            llvm::FunctionType* fnTy = llvm_utils->get_function_type(
                *ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(func_sym)),
                module.get());
            llvm::PointerType *fnPtrTy = llvm::PointerType::get(fnTy, 0);
            llvm::PointerType *fnPtrPtrTy = llvm::PointerType::get(fnPtrTy, 0);
            llvm::PointerType *fnPtrPtrPtrTy = llvm::PointerType::get(fnPtrPtrTy, 0);

            // Convert function args
            std::vector<llvm::Value*> args;
            struct_api->create_new_vtable_for_struct_type(struct_sym, module.get());
            ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(struct_sym);
            ASR::symbol_t* s_class_proc = struct_type_t->m_symtab->get_symbol(proc_sym_name);
            while(!s_class_proc && struct_type_t->m_parent) {
                struct_type_t = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(struct_type_t->m_parent));
                s_class_proc = struct_type_t->m_symtab->get_symbol(proc_sym_name);
            }
            s_class_proc = ASRUtils::symbol_get_past_external(s_class_proc);
            ASR::StructMethodDeclaration_t* class_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(s_class_proc);
            ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(
                ASRUtils::symbol_get_past_external(class_proc->m_proc));
            if (!class_proc->m_is_nopass) {
                llvm::Type* target_struct_type = llvm_utils->get_type_from_ttype_t_util(func->m_args[0], 
                    ASRUtils::extract_type(ASRUtils::expr_type(func->m_args[0])), module.get());
                llvm_dt = builder->CreateBitCast(llvm_dt, target_struct_type->getPointerTo());
                args.push_back(llvm_dt);
            }
            std::vector<llvm::Value *> args2 = convert_call_args(x, !class_proc->m_is_nopass);
            args.insert(args.end(), args2.begin(), args2.end());

            // Get VTable pointer
            if (ASR::is_a<ASR::ArrayItem_t>(*x.m_dt)) {
                ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(x.m_dt);
                int ptr_loads_copy = ptr_loads;
                ptr_loads = 1;
                this->visit_expr_wrapper(array_item->m_v, true);
                ptr_loads = ptr_loads_copy;
                llvm::Type* struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    array_item->m_v, ASRUtils::extract_type(array_item->m_type), module.get());
                if (ASRUtils::extract_physical_type(
                        ASRUtils::expr_type(array_item->m_v)) == ASR::array_physical_typeType::DescriptorArray) {
                    llvm_dt = llvm_utils->CreateLoad2(
                        struct_llvm_type->getPointerTo(), arr_descr->get_pointer_to_data(
                        array_item->m_v, ASRUtils::expr_type(array_item->m_v), tmp, module.get()));
                } else {
                    llvm_dt = tmp;
                }
            }
            llvm::Value* vtable_ptr = builder->CreateBitCast(llvm_dt, fnPtrPtrPtrTy);
            vtable_ptr = llvm_utils->CreateLoad2(fnPtrPtrTy, vtable_ptr);

            // Get function pointer from VTable
            llvm::Value* fn = (llvm_utils->create_ptr_gep2(fnPtrTy,
                vtable_ptr, struct_api->struct_vtab_function_offset[struct_sym][proc_sym_name]));
            fn = llvm_utils->CreateLoad2(fnPtrTy, fn);
            builder->CreateCall(fnTy, fn, args);
            return;
        }
        std::vector<std::pair<llvm::Value*, ASR::symbol_t*>> vtabs;
        ASR::Struct_t* dt_sym_type = nullptr;
        ASR::ttype_t* dt_ttype_t = ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(
                                        ASRUtils::expr_type(x.m_dt)));
        if( ASR::is_a<ASR::StructType_t>(*dt_ttype_t) ) {
            dt_sym_type = ASR::down_cast<ASR::Struct_t>(
                ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_dt))));
            if (!compiler_options.new_classes) {
                create_vtab_for_struct_type(&dt_sym_type->base, current_scope);
            }
        }
        LCOMPILERS_ASSERT(dt_sym_type != nullptr);
        for( auto& item: type2vtab ) {
            ASR::Struct_t* a_dt = ASR::down_cast<ASR::Struct_t>(item.first);
            if( !a_dt->m_is_abstract &&
                (a_dt == dt_sym_type ||
                ASRUtils::is_parent(a_dt, dt_sym_type) ||
                ASRUtils::is_parent(dt_sym_type, a_dt)) ) {
                for( auto& item2: item.second ) {
                    if( item2.first == current_scope ) {
                        // Find the Struct symbol to which the StructMethodDeclaration belongs
                        bool found = false;
                        while (a_dt) {
                            for (auto &member : a_dt->m_symtab->get_scope()) {
                                if (ASR::is_a<ASR::StructMethodDeclaration_t>(*member.second)) {
                                    ASR::StructMethodDeclaration_t *proc_s = ASR::down_cast<ASR::StructMethodDeclaration_t>(member.second);
                                    if (proc_s->m_name == proc_sym_name) {
                                        found = true;
                                        break;
                                    }
                                }
                            }

                            if (found)
                                break;

                            if (a_dt->m_parent != nullptr) {
                                a_dt = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(a_dt->m_parent));
                            } else {
                                a_dt = nullptr;
                            }
                        }
                        if (a_dt) vtabs.push_back(std::make_pair(item2.second, (ASR::symbol_t *)a_dt));
                    }
                }
            }
        }

        llvm::Value *llvm_dt = nullptr;
        if (llvm_polymorphic == nullptr) {
            uint64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 0;
            this->visit_expr_wrapper(x.m_dt);
            ptr_loads = ptr_loads_copy;
            llvm_dt = tmp;
        } else {
            llvm_dt = llvm_polymorphic;
        }
        llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");
        llvm::Type* i64 = llvm::Type::getInt64Ty(context);
        llvm::Type* llvm_dt_type = nullptr;
        llvm_dt_type = llvm_utils->get_type_from_ttype_t_util(x.m_dt,
            ASRUtils::extract_type(ASRUtils::expr_type(x.m_dt)), module.get());
        llvm_dt = builder->CreateBitCast(llvm_dt, llvm_dt_type->getPointerTo());
        for( size_t i = 0; i < vtabs.size(); i++ ) {
            llvm::Function *fn = builder->GetInsertBlock()->getParent();

            llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
            llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

            llvm::Value* vptr_int_hash = llvm_utils->CreateLoad2(i64, llvm_utils->create_gep2(llvm_dt_type, llvm_dt, 0));
            llvm::Type *dt_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                        ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_dt))), module.get(), true);
            llvm::Value* dt_data = llvm_utils->CreateLoad2(dt_type, llvm_utils->create_gep2(llvm_dt_type, llvm_dt, 1));
            ASR::ttype_t* selector_var_type = ASRUtils::expr_type(x.m_dt);
            if( ASRUtils::is_array(selector_var_type) ) {
                vptr_int_hash = llvm_utils->CreateLoad2(vptr_int_hash->getType()->getPointerTo(), llvm_utils->create_gep2(vptr_int_hash->getType(), vptr_int_hash, 0));
            }
            ASR::symbol_t* type_sym = ASRUtils::symbol_get_past_external(vtabs[i].second);
            llvm::Value* type_sym_vtab = vtabs[i].first;
            llvm::Type* struct_ty = llvm::StructType::get(context, { i64 }, true);
            llvm::Value* vtab_obj_casted = builder->CreateBitCast(type_sym_vtab, struct_ty->getPointerTo());
            llvm::Value* cond = builder->CreateICmpEQ(
                                    vptr_int_hash,
                                    llvm_utils->CreateLoad2(i64,
                                        llvm_utils->create_gep2(struct_ty, vtab_obj_casted, 0) ) );

            builder->CreateCondBr(cond, thenBB, elseBB);
            builder->SetInsertPoint(thenBB);
            {
                std::vector<llvm::Value*> args;
                ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(type_sym);

                ASR::symbol_t* s_class_proc = struct_type_t->m_symtab->resolve_symbol(proc_sym_name);
                ASR::StructMethodDeclaration_t* class_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(s_class_proc);
                if (!class_proc->m_is_nopass) {
                    // add the self argument only when the class procedure has the `pass` attribute
                    llvm::Type* target_dt_type = llvm_utils->getStructType(struct_type_t, module.get(), true);
                    llvm::Type* target_class_dt_type = llvm_utils->getClassType(struct_type_t);
                    llvm::Value* target_dt = llvm_utils->CreateAlloca(*builder, target_class_dt_type);
                    llvm::Value* target_dt_hash_ptr = llvm_utils->create_gep2(target_class_dt_type, target_dt, 0);
                    builder->CreateStore(vptr_int_hash, target_dt_hash_ptr);
                    llvm::Value* target_dt_data_ptr = llvm_utils->create_gep2(target_class_dt_type, target_dt, 1);
                    builder->CreateStore(builder->CreateBitCast(dt_data, target_dt_type),
                                        target_dt_data_ptr);
                    args.push_back(target_dt);
                    std::string captured_global_name
                        = "__lcompilers_created__nested_context__" + proc_sym_name + "_self";
                    llvm::GlobalVariable* nested_global
                        = module->getNamedGlobal(captured_global_name);
                    if (nested_global) {
                        llvm::Type* nested_global_type = nested_global->getValueType();
                        llvm::Value* global_hash_ptr = llvm_utils->create_gep2(nested_global_type, nested_global, 0);
                        llvm::Value* global_data_ptr = llvm_utils->create_gep2(nested_global_type, nested_global, 1);
                        // Use the correct types for loading
                        llvm::Type* target_dt_hash_type = llvm::Type::getInt64Ty(context);
                        llvm::Type* target_dt_data_type = llvm_utils->getStructType(struct_type_t, module.get(), true);
                        llvm::Value* local_hash_val = llvm_utils->CreateLoad2(target_dt_hash_type,target_dt_hash_ptr);
                        llvm::Value* local_data_val = llvm_utils->CreateLoad2(target_dt_data_type, target_dt_data_ptr);

                        // Store the loaded values
                        builder->CreateStore(local_hash_val, global_hash_ptr);
                        builder->CreateStore(local_data_val, global_data_ptr);
                    }
                }
                ASR::symbol_t* s_proc = ASRUtils::symbol_get_past_external(class_proc->m_proc);
                uint32_t h = get_hash((ASR::asr_t*) s_proc);
                llvm::Function* fn = llvm_symtab_fn[h];
                std::vector<llvm::Value *> args2 = convert_call_args(x, !class_proc->m_is_nopass);
                args.insert(args.end(), args2.begin(), args2.end());
                builder->CreateCall(fn, args);
            }
            builder->CreateBr(mergeBB);

            start_new_block(elseBB);
        }
        start_new_block(mergeBB);
    }

    void visit_RuntimePolymorphicFunctionCall(const ASR::FunctionCall_t& x, std::string proc_sym_name) {
        if (compiler_options.new_classes) {
            bool is_pointer = LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_dt));
            uint64_t ptr_loads_copy = ptr_loads;
            ptr_loads = is_pointer;
            this->visit_expr_wrapper(x.m_dt, is_pointer);
            ptr_loads = ptr_loads_copy;
            llvm::Value* llvm_dt = tmp;
            ASR::symbol_t* func_sym = ASRUtils::symbol_get_past_StructMethodDeclaration(
                ASRUtils::symbol_get_past_external(x.m_name));
            ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(
                ASRUtils::get_struct_sym_from_struct_expr(x.m_dt));
            llvm::FunctionType* fnTy = llvm_utils->get_function_type(
                *ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(func_sym)),
                module.get());
            llvm::PointerType *fnPtrTy = llvm::PointerType::get(fnTy, 0);
            llvm::PointerType *fnPtrPtrTy = llvm::PointerType::get(fnPtrTy, 0);
            llvm::PointerType *fnPtrPtrPtrTy = llvm::PointerType::get(fnPtrPtrTy, 0);

            // Convert function args
            std::vector<llvm::Value*> args;
            struct_api->create_new_vtable_for_struct_type(struct_sym, module.get());
            ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(struct_sym);
            ASR::symbol_t* s_class_proc = struct_type_t->m_symtab->get_symbol(proc_sym_name);
            while(!s_class_proc && struct_type_t->m_parent) {
                struct_type_t = ASR::down_cast<ASR::Struct_t>(
                    ASRUtils::symbol_get_past_external(struct_type_t->m_parent));
                s_class_proc = struct_type_t->m_symtab->get_symbol(proc_sym_name);
            }
            s_class_proc = ASRUtils::symbol_get_past_external(s_class_proc);
            ASR::StructMethodDeclaration_t* class_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(s_class_proc);
            ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(
                ASRUtils::symbol_get_past_external(class_proc->m_proc));
            if (!class_proc->m_is_nopass) {
                llvm::Type* target_struct_type = llvm_utils->get_type_from_ttype_t_util(func->m_args[0],
                    ASRUtils::extract_type(ASRUtils::expr_type(func->m_args[0])), module.get());
                llvm_dt = builder->CreateBitCast(llvm_dt, target_struct_type->getPointerTo());

                // If the parameter is a POINTER, we need an extra level of indirection
                if (LLVM::is_llvm_pointer(*ASRUtils::expr_type(func->m_args[0]))) {
                    // Allocate space for a pointer on the stack
                    llvm::Value* ptr_storage = llvm_utils->CreateAlloca(*builder, target_struct_type->getPointerTo());
                    // Store the loaded class descriptor pointer into it
                    builder->CreateStore(llvm_dt, ptr_storage);
                    // Pass the address of the storage (which is now a pointer-to-pointer)
                    args.push_back(ptr_storage);
                } else {
                    args.push_back(llvm_dt);
                }
            }
            std::vector<llvm::Value *> args2 = convert_call_args(x, !class_proc->m_is_nopass);
            args.insert(args.end(), args2.begin(), args2.end());

            // Get Runtime VTable Pointer
            if (ASR::is_a<ASR::ArrayItem_t>(*x.m_dt)) {
                ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(x.m_dt);
                ptr_loads_copy = ptr_loads;
                ptr_loads = LLVM::is_llvm_pointer(*ASRUtils::expr_type(array_item->m_v));
                this->visit_expr_wrapper(array_item->m_v, true);
                ptr_loads = ptr_loads_copy;
                llvm::Type* struct_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                    array_item->m_v, ASRUtils::extract_type(array_item->m_type), module.get());
                if (ASRUtils::extract_physical_type(
                        ASRUtils::expr_type(array_item->m_v)) == ASR::array_physical_typeType::DescriptorArray) {
                    llvm_dt = llvm_utils->CreateLoad2(
                        struct_llvm_type->getPointerTo(), arr_descr->get_pointer_to_data(
                        array_item->m_v, ASRUtils::expr_type(array_item->m_v), tmp, module.get()));
                } else {
                    llvm_dt = tmp;
                }
            }
            llvm::Value* vtable_ptr = builder->CreateBitCast(llvm_dt, fnPtrPtrPtrTy);
            vtable_ptr = llvm_utils->CreateLoad2(fnPtrPtrTy, vtable_ptr);

            // Get function pointer from VTable
            llvm::Value* fn = (llvm_utils->create_ptr_gep2(fnPtrTy,
                vtable_ptr, struct_api->struct_vtab_function_offset[struct_sym][proc_sym_name]));
            fn = llvm_utils->CreateLoad2(fnPtrTy, fn);
            tmp = builder->CreateCall(fnTy, fn, args);
            return;
        }
        std::vector<std::pair<llvm::Value*, ASR::symbol_t*>> vtabs;
        ASR::Struct_t* dt_sym_type = nullptr;
        ASR::ttype_t* dt_ttype_t = ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(
                                        ASRUtils::expr_type(x.m_dt)));
        if( ASR::is_a<ASR::StructType_t>(*dt_ttype_t) ) {
            dt_sym_type = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_dt)));
        }
        LCOMPILERS_ASSERT(dt_sym_type != nullptr);
        for( auto& item: type2vtab ) {
            ASR::Struct_t* a_dt = ASR::down_cast<ASR::Struct_t>(item.first);
            if( !a_dt->m_is_abstract &&
                (a_dt == dt_sym_type ||
                ASRUtils::is_parent(a_dt, dt_sym_type) ||
                ASRUtils::is_parent(dt_sym_type, a_dt)) ) {
                for( auto& item2: item.second ) {
                    if( item2.first == current_scope ) {
                        vtabs.push_back(std::make_pair(item2.second, item.first));
                    }
                }
            }
        }

        uint64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 0;
        this->visit_expr_wrapper(x.m_dt);
        ptr_loads = ptr_loads_copy;
        llvm::Value* llvm_dt = tmp;
        tmp = llvm_utils->CreateAlloca(*builder, llvm_utils->get_type_from_ttype_t_util(const_cast<ASR::expr_t*>(&x.base), x.m_type, module.get()));
        llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");
        llvm::Type* i64 = llvm::Type::getInt64Ty(context);
        llvm::Type* llvm_dt_type = nullptr;
        llvm_dt_type = llvm_utils->get_type_from_ttype_t_util(x.m_dt,
            ASRUtils::extract_type(ASRUtils::expr_type(x.m_dt)), module.get());
        llvm_dt = builder->CreateBitCast(llvm_dt, llvm_dt_type->getPointerTo());
        if ( compiler_options.new_classes ) {
            // TODO: handle function call without `xx_polymorphic`
        } else {
            for( size_t i = 0; i < vtabs.size(); i++ ) {
                llvm::Function *fn = builder->GetInsertBlock()->getParent();

                llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
                llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

                llvm::Value* vptr_int_hash = llvm_utils->CreateLoad2(i64, llvm_utils->create_gep2(llvm_dt_type, llvm_dt, 0));
                llvm::Type *dt_type = llvm_utils->getStructType(ASR::down_cast<ASR::Struct_t>(
                            ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(x.m_dt))), module.get(), true);
                llvm::Value* dt_data = llvm_utils->CreateLoad2(dt_type, llvm_utils->create_gep2(llvm_dt_type, llvm_dt, 1));
                ASR::ttype_t* selector_var_type = ASRUtils::expr_type(x.m_dt);
                if( ASRUtils::is_array(selector_var_type) ) {
                    vptr_int_hash = llvm_utils->CreateLoad2(vptr_int_hash->getType()->getPointerTo(), llvm_utils->create_gep2(vptr_int_hash->getType(), vptr_int_hash, 0));
                }
                ASR::symbol_t* type_sym = ASRUtils::symbol_get_past_external(vtabs[i].second);
                llvm::Value* type_sym_vtab = vtabs[i].first;
                llvm::Type* struct_ty = llvm::StructType::get(context, { i64 }, true);
                llvm::Value* vtab_obj_casted = builder->CreateBitCast(type_sym_vtab, struct_ty->getPointerTo());
                llvm::Value* cond = builder->CreateICmpEQ(
                                        vptr_int_hash,
                                        llvm_utils->CreateLoad2(i64,
                                            llvm_utils->create_gep2(struct_ty, vtab_obj_casted, 0) ) );

                builder->CreateCondBr(cond, thenBB, elseBB);
                builder->SetInsertPoint(thenBB);
                {
                    std::vector<llvm::Value*> args;
                    ASR::Struct_t* struct_type_t = ASR::down_cast<ASR::Struct_t>(type_sym);
                    ASR::symbol_t* s_class_proc = struct_type_t->m_symtab->resolve_symbol(proc_sym_name);
                    ASR::StructMethodDeclaration_t* class_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(s_class_proc);
                    if (!class_proc->m_is_nopass) {
                        // add the self argument only when the class procedure has the `pass` attribute
                        llvm::Type* target_dt_type = llvm_utils->getStructType(struct_type_t, module.get(), true);
                        llvm::Type* target_class_dt_type = llvm_utils->getClassType(struct_type_t);
                        llvm::Value* target_dt = llvm_utils->CreateAlloca(*builder, target_class_dt_type);
                        llvm::Value* target_dt_hash_ptr = llvm_utils->create_gep2(target_class_dt_type, target_dt, 0);
                        builder->CreateStore(vptr_int_hash, target_dt_hash_ptr);
                        llvm::Value* target_dt_data_ptr = llvm_utils->create_gep2(target_class_dt_type, target_dt, 1);
                        builder->CreateStore(builder->CreateBitCast(dt_data, target_dt_type),
                                            target_dt_data_ptr);
                        args.push_back(target_dt);
                    }
                    ASR::symbol_t* s_proc = ASRUtils::symbol_get_past_external(class_proc->m_proc);
                    uint32_t h = get_hash((ASR::asr_t*) s_proc);
                    llvm::Function* fn = llvm_symtab_fn[h];
                    ASR::Function_t* s = ASR::down_cast<ASR::Function_t>(s_proc);
                    LCOMPILERS_ASSERT(s != nullptr);
                    std::vector<llvm::Value *> args2 = convert_call_args(x, !class_proc->m_is_nopass);
                    args.insert(args.end(), args2.begin(), args2.end());
                    ASR::ttype_t *return_var_type0 = EXPR2VAR(s->m_return_var)->m_type;
                    builder->CreateStore(CreateCallUtil(fn, args, return_var_type0), tmp);
                }
                builder->CreateBr(mergeBB);

                start_new_block(elseBB);
            }
            start_new_block(mergeBB);
        }
        llvm::Type* result_type = llvm_utils->get_type_from_ttype_t_util(ASRUtils::expr_type(&(x.base)), nullptr, module.get());
        tmp = llvm_utils->CreateLoad2(result_type, tmp);
    }

    void visit_FunctionCall(const ASR::FunctionCall_t &x) {
        if ( compiler_options.emit_debug_info ) debug_emit_loc(x);
        if( ASRUtils::is_intrinsic_optimization(x.m_name) ) {
            ASR::Function_t* routine = ASR::down_cast<ASR::Function_t>(
                        ASRUtils::symbol_get_past_external(x.m_name));
            if( generate_optimization_instructions(routine, x.m_args) ) {
                return ;
            }
        }
        if (x.m_value) {
            this->visit_expr_wrapper(x.m_value, true);
            return ;
        }

        // Generate runtime error if array arguments' shape doesn't match
        if (compiler_options.po.bounds_checking) {
            bounds_check_call(x);
        }

        std::vector<llvm::Value*> args;
        if( x.m_dt && ASR::is_a<ASR::StructInstanceMember_t>(*x.m_dt) &&
            ASR::is_a<ASR::Variable_t>(*ASRUtils::symbol_get_past_external(x.m_name)) &&
            ASR::is_a<ASR::FunctionType_t>(*ASRUtils::symbol_type(x.m_name)) ) {
            uint64_t ptr_loads_copy = ptr_loads;
            ptr_loads = 1;
            this->visit_expr(*x.m_dt);
            ptr_loads = ptr_loads_copy;
            llvm::Type* val_type = llvm_utils->get_type_from_ttype_t_util(
                x.m_dt, ASRUtils::extract_type(ASRUtils::expr_type(x.m_dt)), module.get());
            llvm::Value* callee = llvm_utils->CreateLoad2(val_type, tmp);

            args = convert_call_args(x, false);
            llvm::FunctionType* fntype = llvm_utils->get_function_type(
                *ASRUtils::get_function(x.m_name), module.get());
            tmp = builder->CreateCall(fntype, callee, args);
            return ;
        }

        const ASR::symbol_t *proc_sym = symbol_get_past_external(x.m_name);
        std::string proc_sym_name = "";
        bool is_deferred = false;
        bool is_nopass = false;
        if( ASR::is_a<ASR::StructMethodDeclaration_t>(*proc_sym) ) {
            ASR::StructMethodDeclaration_t* class_proc =
                ASR::down_cast<ASR::StructMethodDeclaration_t>(proc_sym);
            is_deferred = class_proc->m_is_deferred;
            if (compiler_options.new_classes) {
                is_deferred = ASRUtils::is_class_type(ASRUtils::extract_type(ASRUtils::expr_type(x.m_dt)));
            }
            proc_sym_name = class_proc->m_name;
            is_nopass = class_proc->m_is_nopass;
        }
        if( is_deferred ) {
            visit_RuntimePolymorphicFunctionCall(x, proc_sym_name);
            return ;
        }

        ASR::Function_t *s = nullptr;
        std::string self_argument = "";
        if (ASR::is_a<ASR::Function_t>(*proc_sym)) {
            s = ASR::down_cast<ASR::Function_t>(proc_sym);
        } else if (ASR::is_a<ASR::StructMethodDeclaration_t>(*proc_sym)) {
            ASR::StructMethodDeclaration_t *clss_proc = ASR::down_cast<
                ASR::StructMethodDeclaration_t>(proc_sym);
            s = ASR::down_cast<ASR::Function_t>(clss_proc->m_proc);
            if (clss_proc->m_self_argument) {
                self_argument = std::string(clss_proc->m_self_argument);
            }
            proc_sym = clss_proc->m_proc;
        } else if (ASR::is_a<ASR::Variable_t>(*proc_sym)) {
            ASR::Variable_t* proc_var = ASR::down_cast<ASR::Variable_t>(proc_sym);
            ASR::symbol_t *type_decl = proc_var->m_type_declaration;
            if (type_decl == nullptr) {
                throw CodeGenError("Procedure variable '" + std::string(proc_var->m_name)
                    + "' has no interface. Add explicit interface or ensure it is called somewhere.");
            }
            s = ASR::down_cast<ASR::Function_t>(
                ASRUtils::symbol_get_past_external(type_decl));
        } else {
            throw CodeGenError("FunctionCall: Symbol type not supported");
        }
        if( s == nullptr ) {
            s = ASR::down_cast<ASR::Function_t>(symbol_get_past_external(x.m_name));
        }
        bool is_method = false;
        llvm::Value* pass_arg = nullptr;
        if (x.m_dt && (!is_nopass)) {
            is_method = true;
            ASR::expr_t* dt_expr = x.m_dt;
            if (ASR::is_a<ASR::Cast_t>(*dt_expr)) {
                dt_expr = ASR::down_cast<ASR::Cast_t>(dt_expr)->m_arg;
            }
            if (ASR::is_a<ASR::Var_t>(*dt_expr)) {
                ASR::Variable_t *caller = EXPR2VAR(dt_expr);
                std::uint32_t h = get_hash((ASR::asr_t*)caller);
                // declared variable in the current scope
                llvm::Value* dt = llvm_symtab[h];
                // Function class type
                ASR::ttype_t* s_m_args0_type = ASRUtils::type_get_past_pointer(
                                                ASRUtils::expr_type(s->m_args[0]));
                // derived type declared type
                ASR::ttype_t* dt_type = ASRUtils::type_get_past_allocatable_pointer(caller->m_type);
                dt = convert_to_polymorphic_arg(dt_expr, dt, s->m_args[0], s_m_args0_type, dt_type);
                args.push_back(dt);
            } else if (ASR::is_a<ASR::StructInstanceMember_t>(*dt_expr)) {
                // Declared struct variable
                this->visit_expr(*dt_expr);
                llvm::Value* dt = tmp;
                ASR::ttype_t* caller_type = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(dt_expr));

                // Function's class type
                ASR::ttype_t *s_m_args0_type;
                ASR::expr_t *s_m_args0 = nullptr;
                if (self_argument.length() > 0) {
                    ASR::symbol_t *class_sym = s->m_symtab->resolve_symbol(self_argument);
                    ASR::Variable_t *var = ASR::down_cast<ASR::Variable_t>(class_sym);
                    s_m_args0 = ASRUtils::EXPR(ASR::make_Var_t(al, var->base.base.loc, &var->base));
                    s_m_args0_type = ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(var->m_type));
                    s_m_args0 = ASRUtils::EXPR(ASR::make_Var_t(al, var->base.base.loc, (ASR::symbol_t*) var));
                } else {
                    s_m_args0 = s->m_args[0];
                    s_m_args0_type = ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(
                        ASRUtils::expr_type(s->m_args[0])));
                }

                // Convert to polymorphic argument
                llvm::Value* dt_polymorphic = convert_to_polymorphic_arg(dt_expr, dt, s_m_args0, s_m_args0_type, caller_type);

                if (self_argument.length() == 0) {
                    args.push_back(dt_polymorphic);
                } else {
                    pass_arg = dt_polymorphic;
                }
            } else if(ASR::is_a<ASR::ArrayItem_t>(*dt_expr)) {
                this->visit_expr(*dt_expr);
                llvm::Value* dt = tmp;
                llvm::Value* dt_polymorphic = tmp;
                dt_polymorphic = convert_to_polymorphic_arg(dt_expr, dt, s->m_args[0], ASRUtils::expr_type(s->m_args[0]),
                                                ASRUtils::expr_type(dt_expr));
                args.push_back(dt_polymorphic);
            } else {
                throw CodeGenError("FunctionCall: StructType symbol type not supported");
            }
        }

        bool intrinsic_function = ASRUtils::is_intrinsic_function2(s);
        uint32_t h;
        ASR::FunctionType_t* s_func_type = ASR::down_cast<ASR::FunctionType_t>(s->m_function_signature);
        if (s_func_type->m_abi == ASR::abiType::Source && !intrinsic_function) {
            h = get_hash((ASR::asr_t*)proc_sym);
        } else if (s_func_type->m_abi == ASR::abiType::LFortranModule) {
            throw CodeGenError("Function LCompilers interfaces not implemented yet");
        } else if (s_func_type->m_abi == ASR::abiType::ExternalUndefined) {
            h = get_hash((ASR::asr_t*)proc_sym);
        } else if (s_func_type->m_abi == ASR::abiType::BindC) {
            h = get_hash((ASR::asr_t*)proc_sym);
        } else if (s_func_type->m_abi == ASR::abiType::Intrinsic || intrinsic_function) {
            std::string func_name = s->m_name;
            if( fname2arg_type.find(func_name) != fname2arg_type.end() ) {
                h = get_hash((ASR::asr_t*)proc_sym);
            } else {
                if (func_name == "len") {
                    throw LCompilersException("Unhandled");
                } else if (func_name == "command_argument_count") {
                    llvm::Function *fn = module->getFunction("_lfortran_get_argc");
                    if(!fn) {
                        llvm::FunctionType *function_type = llvm::FunctionType::get(
                            llvm::Type::getInt32Ty(context), {}, false);
                        fn = llvm::Function::Create(function_type,
                            llvm::Function::ExternalLinkage, "_lfortran_get_argc", module.get());
                    }
                    tmp = builder->CreateCall(fn, {});
                    return;
                } else if (func_name == "achar") {
                    // TODO: make achar just StringChr
                    this->visit_expr_wrapper(x.m_args[0].m_value, true);
                    tmp = lfortran_str_chr(tmp);
                    return;
                }
                if( ASRUtils::get_FunctionType(s)->m_deftype == ASR::deftypeType::Interface ) {
                    throw CodeGenError("Intrinsic '" + func_name + "' not implemented yet and compile time value is not available.");
                } else {
                    h = get_hash((ASR::asr_t*)proc_sym);
                }
            }
        } else {
            throw CodeGenError("ABI type not implemented yet.");
        }
        if (llvm_symtab_fn_arg.find(h) != llvm_symtab_fn_arg.end()) {
            // Check if this is a callback function
            llvm::Value* fn = llvm_symtab_fn_arg[h];
            if (llvm_symtab_fn.find(h) == llvm_symtab_fn.end()) {
                throw CodeGenError("The callback function not found in llvm_symtab_fn");
            }
            llvm::FunctionType* fntype = llvm_symtab_fn[h]->getFunctionType();
            std::string m_name = std::string(((ASR::Function_t*)(&(x.m_name->base)))->m_name);
            args = convert_call_args(x, is_method);
            tmp = builder->CreateCall(fntype, fn, args);
        } else if (ASRUtils::is_symbol_procedure_variable(ASRUtils::symbol_get_past_external(proc_sym)) && llvm_symtab.find(h) != llvm_symtab.end()) {
            // This is the case were a function pointer ( procedure variable ) is associated and used
            llvm::FunctionType* fntype = llvm_utils->get_function_type(*s, module.get());
            ASR::expr_t* proc_sym_expr = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, (ASR::symbol_t*) s));
            llvm::Type* fn_type = llvm_utils->get_type_from_ttype_t_util(proc_sym_expr,
                s->m_function_signature, module.get());
            llvm::Value* fn = llvm_symtab[h];
            fn = llvm_utils->CreateLoad2(fn_type, fn);
            args = convert_call_args(x, is_method);
            tmp = builder->CreateCall(fntype, fn, args);
        } else if (llvm_symtab_fn.find(h) == llvm_symtab_fn.end()) {
            throw CodeGenError("Function code not generated for '"
                + std::string(s->m_name) + "'");
        } else {
            llvm::Function *fn = llvm_symtab_fn[h];
            std::string m_name = std::string(((ASR::Function_t*)(&(x.m_name->base)))->m_name);
            std::vector<llvm::Value *> args2 = convert_call_args(x, is_method);
            args.insert(args.end(), args2.begin(), args2.end());
            if (pass_arg) {
                args.push_back(pass_arg);
            }
            ASR::ttype_t *return_var_type0 = EXPR2VAR(s->m_return_var)->m_type;
            if (ASRUtils::get_FunctionType(s)->m_abi == ASR::abiType::BindC) {
                if (is_a<ASR::Complex_t>(*return_var_type0)) {
                    int a_kind = down_cast<ASR::Complex_t>(return_var_type0)->m_kind;
                    if (a_kind == 8) {
                        if (compiler_options.platform == Platform::Windows) {
                            tmp = llvm_utils->CreateAlloca(complex_type_8, nullptr, "complex_ret_tmp");
                            args.insert(args.begin(), tmp);
                            builder->CreateCall(fn, args);
                            // Convert {double,double}* to {double,double}
                            tmp = llvm_utils->CreateLoad2(complex_type_8, tmp);
                        } else {
                            tmp = builder->CreateCall(fn, args);
                        }
                    } else {
                        tmp = builder->CreateCall(fn, args);
                    }
                } else {
                    tmp = builder->CreateCall(fn, args);
                }
            } else {
                tmp = CreateCallUtil(fn, args, return_var_type0);
            }
            // The convention we use is that any strings is a pointer to the underlying physicalType
            // Example of StringPhysicalTypes -> `string_descriptor*`, `i8*`
            if(ASRUtils::is_string_only(return_var_type0)){
                // Make sure to use `alloca` at the entry point.
                llvm::Value* string_ptr = llvm_utils->CreateAlloca(
                                            llvm_utils->get_StringType(return_var_type0),
                                            nullptr,
                                            "string_ret_const"
                                        );
                builder->CreateStore(tmp, string_ptr);
                tmp = string_ptr;
            }
        }
        // Convert complex return value from platform ABI to internal representation
        {
            ASR::ttype_t *return_var_type0 = EXPR2VAR(s->m_return_var)->m_type;
            if (is_a<ASR::Complex_t>(*return_var_type0)) {
                int a_kind = down_cast<ASR::Complex_t>(return_var_type0)->m_kind;
                if (a_kind == 4) {
                    if (compiler_options.platform == Platform::Windows) {
                        // tmp is i64, have to convert to {float, float}

                        // i64
                        llvm::Type* type_fx2 = llvm::Type::getInt64Ty(context);
                        // Convert i64 to i64*
                        llvm::AllocaInst *p_fx2 = llvm_utils->CreateAlloca(type_fx2, nullptr, "complex_ret_tmp");
                        builder->CreateStore(tmp, p_fx2);
                        // Convert i64* to {float,float}* using bitcast
                        tmp = builder->CreateBitCast(p_fx2, complex_type_4->getPointerTo());
                        // Convert {float,float}* to {float,float}
                        tmp = llvm_utils->CreateLoad2(complex_type_4, tmp);
                    } else if (compiler_options.platform == Platform::macOS_ARM) {
                        // pass - already {float, float}
                    } else {
                        // tmp is <2 x float>, convert to {float, float}
                        // <2 x float>
                        llvm::Type* type_fx2 = FIXED_VECTOR_TYPE::get(llvm::Type::getFloatTy(context), 2);
                        // Convert <2 x float> to <2 x float>*
                        llvm::AllocaInst *p_fx2 = llvm_utils->CreateAlloca(type_fx2, nullptr, "complex_ret_tmp");
                        builder->CreateStore(tmp, p_fx2);
                        // Convert <2 x float>* to {float,float}* using bitcast
                        tmp = builder->CreateBitCast(p_fx2, complex_type_4->getPointerTo());
                        // Convert {float,float}* to {float,float}
                        tmp = llvm_utils->CreateLoad2(complex_type_4, tmp);
                    }
                }
            }
        }
        if (ASRUtils::is_character(*x.m_type)) {
            strings_to_be_deallocated.push_back(al, tmp);
        }
    }

    void load_array_size_deep_copy(ASR::expr_t* x) {
        if (x != nullptr &&  ASR::is_a<ASR::Var_t>(*x)) {
            ASR::Var_t* x_var = ASR::down_cast<ASR::Var_t>(x);
            ASR::symbol_t* x_sym = ASRUtils::symbol_get_past_external(x_var->m_v);
            if (x_sym != nullptr && ASR::is_a<ASR::Variable_t>(*x_sym)) {
                ASR::Variable_t* x_sym_variable = ASR::down_cast<ASR::Variable_t>(x_sym);
                uint32_t x_sym_variable_h = get_hash((ASR::asr_t*)x_sym_variable);
                if (llvm_symtab_deep_copy.find({x_sym_variable_h, current_scope}) != llvm_symtab_deep_copy.end()) {
                    tmp = llvm_utils->CreateLoad2(llvm_utils->get_type_from_ttype_t_util(x, ASRUtils::expr_type(x), module.get()),
                        llvm_symtab_deep_copy[{x_sym_variable_h, current_scope}]);
                } else {
                    this->visit_expr_wrapper(x, true);
                }
            } else {
                this->visit_expr_wrapper(x, true);
            }
        } else if (x != nullptr) {
            this->visit_expr_wrapper(x, true);
        } else {
            throw CodeGenError("x is nullptr in load_array_size_deep_copy()");
        }
    }

    void visit_ArraySizeUtil(ASR::expr_t* m_v, ASR::ttype_t* m_type,
        ASR::expr_t* m_dim=nullptr, ASR::expr_t* m_value=nullptr) {
        if( m_value ) {
            visit_expr_wrapper(m_value, true);
            return ;
        }

        m_v = ASRUtils::get_expr_size_expr(m_v);
        LCOMPILERS_ASSERT(m_v);
        int output_kind = ASRUtils::extract_kind_from_ttype_t(m_type);
        int dim_kind = 4;
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 2 - // Sync: instead of 2 - , should this be ptr_loads_copy -
                    LLVM::is_llvm_pointer(*ASRUtils::expr_type(m_v));
        visit_expr_wrapper(m_v);
        ptr_loads = ptr_loads_copy;
        ASR::ttype_t* x_mv_type = ASRUtils::expr_type(m_v);
        LCOMPILERS_ASSERT(ASRUtils::is_array(x_mv_type));
        llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(m_v,
                ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(x_mv_type)), module.get());
        if (is_a<ASR::StructInstanceMember_t>(*m_v)) {
            tmp = llvm_utils->CreateLoad2(array_type->getPointerTo(), tmp);
        }
        llvm::Value* llvm_arg = tmp;

        llvm::Value* llvm_dim = nullptr;
        if( m_dim ) {
            visit_expr_wrapper(m_dim, true);
            dim_kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(m_dim));
            llvm_dim = tmp;
        }

        ASR::array_physical_typeType physical_type = ASRUtils::extract_physical_type(x_mv_type);
        if (physical_type == ASR::array_physical_typeType::StringArraySinglePointer) {
            if (ASRUtils::is_fixed_size_array(x_mv_type)) {
                physical_type = ASR::array_physical_typeType::FixedSizeArray;
            } else {
                physical_type = ASR::array_physical_typeType::DescriptorArray;
            }
        }
        switch( physical_type ) {
            case ASR::array_physical_typeType::AssumedRankArray:
            case ASR::array_physical_typeType::DescriptorArray: {
                tmp = arr_descr->get_array_size(array_type, llvm_arg, llvm_dim, output_kind, dim_kind);
                break;
            }
            case ASR::array_physical_typeType::PointerArray:
            case ASR::array_physical_typeType::SIMDArray:
            case ASR::array_physical_typeType::FixedSizeArray: {
                    llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(m_v,
                        ASRUtils::type_get_past_allocatable(
                            ASRUtils::type_get_past_pointer(m_type)), module.get());


                    ASR::dimension_t* m_dims = nullptr;
                    int n_dims = ASRUtils::extract_dimensions_from_ttype(x_mv_type, m_dims);
                    if( llvm_dim ) {
                    llvm::AllocaInst *target = llvm_utils->CreateAlloca(
                        target_type, nullptr, "array_size");
                    llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");
                    for( int i = 0; i < n_dims; i++ ) {
                        llvm::Function *fn = builder->GetInsertBlock()->getParent();

                        llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
                        llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

                        llvm::Value* cond = builder->CreateICmpEQ(llvm_dim,
                            llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, i + 1)));
                        builder->CreateCondBr(cond, thenBB, elseBB);
                        builder->SetInsertPoint(thenBB);
                        {
                            load_array_size_deep_copy(m_dims[i].m_length);

                            // Make dimension length and return size compatible.
                            if(ASRUtils::extract_kind_from_ttype_t(
                                ASRUtils::expr_type(m_dims[i].m_length)) > output_kind){
                                    tmp = builder->CreateTrunc(tmp, llvm::IntegerType::get(context, 8 * output_kind));
                            } else if (ASRUtils::extract_kind_from_ttype_t(
                                ASRUtils::expr_type(m_dims[i].m_length)) < output_kind){
                                tmp = builder->CreateSExt(tmp, llvm::IntegerType::get(context, 8 * output_kind));
                            }
                            builder->CreateStore(tmp, target);
                        }
                        builder->CreateBr(mergeBB);

                        start_new_block(elseBB);
                    }
                    start_new_block(mergeBB);
                    tmp = llvm_utils->CreateLoad2(target_type, target);
                } else {
                    if( physical_type == ASR::array_physical_typeType::FixedSizeArray ) {
                        int64_t size = ASRUtils::get_fixed_size_of_array(m_dims, n_dims);
                        tmp = llvm::ConstantInt::get(target_type, llvm::APInt(8 * output_kind, size));
                    } else {
                        llvm::Value* llvm_size = llvm::ConstantInt::get(target_type, llvm::APInt(8 * output_kind, 1));
                        int ptr_loads_copy = ptr_loads;
                        ptr_loads = 2;
                        for( int i = 0; i < n_dims; i++ ) {
                            load_array_size_deep_copy(m_dims[i].m_length);

                            // Make dimension length and return size compatible.
                            if(ASRUtils::extract_kind_from_ttype_t(
                                ASRUtils::expr_type(m_dims[i].m_length)) > output_kind){
                                    tmp = builder->CreateTrunc(tmp, llvm::IntegerType::get(context, 8 * output_kind));
                            } else if (ASRUtils::extract_kind_from_ttype_t(
                                ASRUtils::expr_type(m_dims[i].m_length)) < output_kind){
                                tmp = builder->CreateSExt(tmp, llvm::IntegerType::get(context, 8 * output_kind));
                            }

                            llvm_size = builder->CreateMul(tmp, llvm_size);
                        }
                        ptr_loads = ptr_loads_copy;
                        tmp = llvm_size;
                    }
                }
                break;
            }
            default: {
                LCOMPILERS_ASSERT(false);
            }
        }
    }

    void visit_ArraySize(const ASR::ArraySize_t& x) {
        visit_ArraySizeUtil(x.m_v, x.m_type, x.m_dim, x.m_value);
    }

    void visit_ArrayRank(const ASR::ArrayRank_t& x) {
        if( x.m_value ) {
            this->visit_expr_wrapper(x.m_value, true);
            return ;
        }
        ASR::expr_t* m_arg = x.m_v;
        this->visit_expr_wrapper(m_arg, false);
        llvm::Value *arg = tmp;
        llvm::Type* arr_type = llvm_utils->get_type_from_ttype_t_util(m_arg, ASRUtils::expr_type(m_arg), module.get());
        tmp = arr_descr->get_rank(arr_type, arg);
    }

    void visit_ArrayBound(const ASR::ArrayBound_t& x) {
        if (x.m_value) {
            this->visit_expr(*x.m_value);
            return;
        }
        ASR::expr_t* array_value = ASRUtils::expr_value(x.m_v);
        if( array_value && ASR::is_a<ASR::ArrayConstant_t>(*array_value) && ASRUtils::is_value_constant(x.m_dim) ) {
            int kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
            size_t bound_value = 0;
            ASR::dimension_t* m_dims = nullptr;
            ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(array_value), m_dims);
            int req_dim;
            ASRUtils::extract_value(x.m_dim, req_dim);
            req_dim--;

            size_t lbound = 1;
            if (m_dims[req_dim].m_start) {
                ASRUtils::extract_value(m_dims[req_dim].m_start, lbound);
            }
            if( x.m_bound == ASR::arrayboundType::LBound ) {
                bound_value = lbound;
            } else if( x.m_bound == ASR::arrayboundType::UBound ) {
                size_t length;
                ASRUtils::extract_value(m_dims[req_dim].m_length, length);
                bound_value = length + lbound - 1;
            } else {
                LCOMPILERS_ASSERT(false);
            }
            tmp = llvm::ConstantInt::get(context, llvm::APInt(kind * 8, bound_value));
            return ;
        }

        ASR::ttype_t* x_mv_type = ASRUtils::expr_type(x.m_v);
        llvm::Type* array_type = llvm_utils->get_type_from_ttype_t_util(x.m_v,
                ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(x_mv_type)), module.get());
        int64_t ptr_loads_copy = ptr_loads;
        ptr_loads = 2 - // Sync: instead of 2 - , should this be ptr_loads_copy -
                    (LLVM::is_llvm_pointer(*ASRUtils::expr_type(x.m_v)));
        visit_expr_wrapper(x.m_v);
        ptr_loads = ptr_loads_copy;
        if (is_a<ASR::StructInstanceMember_t>(*x.m_v)) {
            tmp = llvm_utils->CreateLoad2(array_type->getPointerTo(), tmp);
        }
        llvm::Value* llvm_arg1 = tmp;
        visit_expr_wrapper(x.m_dim, true);
        llvm::Value* dim_val = tmp;

        ASR::array_physical_typeType physical_type = ASRUtils::extract_physical_type(x_mv_type);
        switch( physical_type ) {
            case ASR::array_physical_typeType::DescriptorArray: {
                llvm::Value* dim_des_val = arr_descr->get_pointer_to_dimension_descriptor_array(array_type, llvm_arg1);
                llvm::Value* const_1 = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
                dim_val = builder->CreateSub(dim_val, const_1);
                llvm::Value* dim_struct = arr_descr->get_pointer_to_dimension_descriptor(dim_des_val, dim_val);
                llvm::Value* res = nullptr;
                if( x.m_bound == ASR::arrayboundType::LBound ) {
                    res = arr_descr->get_lower_bound(dim_struct);
                } else if( x.m_bound == ASR::arrayboundType::UBound ) {
                    res = arr_descr->get_upper_bound(dim_struct);
                }
                // Cast to match the declared return type of the ArrayBound node
                llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(x.m_v,
                    ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(x.m_type)), module.get());
                tmp = builder->CreateSExtOrTrunc(res, target_type);
                break;
            }
            case ASR::array_physical_typeType::FixedSizeArray:
            case ASR::array_physical_typeType::PointerArray:
            case ASR::array_physical_typeType::UnboundedPointerArray: {
                llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(x.m_v,
                    ASRUtils::type_get_past_allocatable(
                        ASRUtils::type_get_past_pointer(x.m_type)), module.get());
                llvm::AllocaInst *target = llvm_utils->CreateAlloca(
                    target_type, nullptr, "array_bound");
                llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");
                ASR::dimension_t* m_dims = nullptr;
                int n_dims = ASRUtils::extract_dimensions_from_ttype(x_mv_type, m_dims);
                for( int i = 0; i < n_dims; i++ ) {
                    llvm::Function *fn = builder->GetInsertBlock()->getParent();

                    llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
                    llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

                    llvm::Value* cond = builder->CreateICmpEQ(dim_val,
                        llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, i + 1)));
                    builder->CreateCondBr(cond, thenBB, elseBB);
                    builder->SetInsertPoint(thenBB);
                    {
                        if( x.m_bound == ASR::arrayboundType::LBound ) {
                            llvm::Value *lbound = nullptr;
                            if (m_dims[i].m_start) {
                                this->visit_expr_wrapper(m_dims[i].m_start, true);
                                lbound = tmp;
                            } else {
                                lbound = llvm::ConstantInt::get(target_type, 1);
                            }
                            builder->CreateStore(builder->CreateSExtOrTrunc(lbound, target_type), target);
                        } else if( x.m_bound == ASR::arrayboundType::UBound ) {
                            llvm::Value *lbound = nullptr, *length = nullptr;
                            if (m_dims[i].m_start) {
                                this->visit_expr_wrapper(m_dims[i].m_start, true);
                                lbound = tmp;
                            } else {
                                lbound = llvm::ConstantInt::get(target_type, 1);
                            }
                            if (m_dims[i].m_length) {
                                load_array_size_deep_copy(m_dims[i].m_length);
                                length = tmp;
                                unsigned target_bit_width = target_type->getIntegerBitWidth();
                                builder->CreateStore(
                                    builder->CreateSub(builder->CreateSExtOrTrunc(builder->CreateAdd(length, lbound), target_type),
                                          llvm::ConstantInt::get(context, llvm::APInt(target_bit_width, 1))),
                                    target);
                            } else {
                                // Assumed-size array: last dimension has no length
                                builder->CreateStore(builder->CreateSExtOrTrunc(lbound, target_type), target);
                            }
                        }
                    }
                    builder->CreateBr(mergeBB);

                    start_new_block(elseBB);
                }
                start_new_block(mergeBB);
                tmp = llvm_utils->CreateLoad2(target_type, target);
                break;
            }
            case ASR::array_physical_typeType::SIMDArray: {
                int kind = ASRUtils::extract_kind_from_ttype_t(x.m_type);
                unsigned bit_width = kind * 8;
                if( x.m_bound == ASR::arrayboundType::LBound ) {
                    tmp = llvm::ConstantInt::get(context, llvm::APInt(bit_width, 1));
                } else if( x.m_bound == ASR::arrayboundType::UBound ) {
                    int64_t size = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(x.m_v));
                    tmp = llvm::ConstantInt::get(context, llvm::APInt(bit_width, size));
                }
                break;
            }
            case ASR::array_physical_typeType::StringArraySinglePointer: {
                ASR::dimension_t* m_dims = nullptr;
                int n_dims = ASRUtils::extract_dimensions_from_ttype(x_mv_type, m_dims);
                if (ASRUtils::is_dimension_empty(m_dims, n_dims)) {
                    // treat it as DescriptorArray
                    llvm::Value* dim_des_val = arr_descr->get_pointer_to_dimension_descriptor_array(array_type, llvm_arg1);
                    llvm::Value* const_1 = llvm::ConstantInt::get(context, llvm::APInt(32, 1));
                    dim_val = builder->CreateSub(dim_val, const_1);
                    llvm::Value* dim_struct = arr_descr->get_pointer_to_dimension_descriptor(dim_des_val, dim_val);
                    llvm::Value* res = nullptr;
                    if( x.m_bound == ASR::arrayboundType::LBound ) {
                        res = arr_descr->get_lower_bound(dim_struct);
                    } else if( x.m_bound == ASR::arrayboundType::UBound ) {
                        res = arr_descr->get_upper_bound(dim_struct);
                    }
                    // Cast to match the declared return type of the ArrayBound node
                    llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(x.m_v,
                        ASRUtils::type_get_past_allocatable(
                            ASRUtils::type_get_past_pointer(x.m_type)), module.get());
                    tmp = builder->CreateSExtOrTrunc(res, target_type);
                    break;
                } else if (ASRUtils::is_fixed_size_array(x_mv_type)) {
                    llvm::Type* target_type = llvm_utils->get_type_from_ttype_t_util(x.m_v,
                        ASRUtils::type_get_past_allocatable(
                            ASRUtils::type_get_past_pointer(x.m_type)), module.get());
                    llvm::AllocaInst *target = llvm_utils->CreateAlloca(
                        target_type, nullptr, "array_bound");
                    llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(context, "ifcont");
                    ASR::dimension_t* m_dims = nullptr;
                    int n_dims = ASRUtils::extract_dimensions_from_ttype(x_mv_type, m_dims);
                    for( int i = 0; i < n_dims; i++ ) {
                        llvm::Function *fn = builder->GetInsertBlock()->getParent();

                        llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(context, "then", fn);
                        llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(context, "else");

                        llvm::Value* cond = builder->CreateICmpEQ(dim_val,
                            llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), llvm::APInt(32, i + 1)));
                        builder->CreateCondBr(cond, thenBB, elseBB);
                        builder->SetInsertPoint(thenBB);
                        {
                            if( x.m_bound == ASR::arrayboundType::LBound ) {
                                this->visit_expr_wrapper(m_dims[i].m_start, true);
                                builder->CreateStore(tmp, target);
                            } else if( x.m_bound == ASR::arrayboundType::UBound ) {
                                llvm::Value *lbound = nullptr, *length = nullptr;
                                this->visit_expr_wrapper(m_dims[i].m_start, true);
                                lbound = tmp;
                                load_array_size_deep_copy(m_dims[i].m_length);
                                length = tmp;
                                unsigned target_bit_width = target_type->getIntegerBitWidth();
                                builder->CreateStore(
                                    builder->CreateSub(builder->CreateSExtOrTrunc(builder->CreateAdd(length, lbound), target_type),
                                        llvm::ConstantInt::get(context, llvm::APInt(target_bit_width, 1))),
                                    target);
                            }
                        }
                        builder->CreateBr(mergeBB);

                        start_new_block(elseBB);
                    }
                    start_new_block(mergeBB);
                    tmp = llvm_utils->CreateLoad2(target_type, target);
                    break;
                } else {
                    LCOMPILERS_ASSERT(false);
                    break;
                }
            }
            default: {
                LCOMPILERS_ASSERT(false);
            }
        }
    }

    void visit_StringFormat(const ASR::StringFormat_t& x) {
        // TODO: Handle some things at compile time if possible:
        //ASR::expr_t* fmt_value = ASRUtils::expr_value(x.m_fmt);
        // if (fmt_value) ...
        if (x.m_kind == ASR::string_format_kindType::FormatFortran) {
            std::vector<llvm::Value *> args;
            // Push fmt string.
            if(x.m_fmt == nullptr){ // default formatting
                llvm::Type* int8Type = builder->getInt8Ty();
                llvm::PointerType* charPtrType = int8Type->getPointerTo();
                llvm::Constant* nullCharPtr = llvm::ConstantPointerNull::get(charPtrType);
                args.push_back(nullCharPtr);
                args.push_back(llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0));
            } else {
                llvm::Value* fmt_data, *fmt_len;
                std::tie(fmt_data, fmt_len) = get_string_data_and_length(x.m_fmt);
                args.push_back(fmt_data);
                args.push_back(fmt_len);
            }
            // Push Serialization;
            llvm::Value* serialization_info = SerializeExprTypes(x.m_args, x.n_args);
            args.push_back(serialization_info);

            // Create and Push a pointer to int64 to store the result size in
            llvm::Value *result_size_ptr = llvm_utils->CreateAlloca(*builder, llvm::Type::getInt64Ty(context));
            args.push_back(result_size_ptr);

            // Check unallocated arguments
            if (compiler_options.po.bounds_checking) {
                for (size_t i = 0; i < x.n_args; i++) {
                    ASR::ttype_t* arg_expr_type = ASRUtils::expr_type(x.m_args[i]);
                    if (ASRUtils::is_allocatable(arg_expr_type)) {
                        llvm_utils->generate_runtime_error(expr_is_unallocated(x.m_args[i]),
                                "Argument %d is unallocated.",
                                {LLVMUtils::RuntimeLabel("This is unallocated", {x.m_args[i]->base.loc})},
                                infile,
                                location_manager,
                                llvm::ConstantInt::get(llvm_utils->getIntType(4), llvm::APInt(32, i + 1)));
                    }
                }
            }

            //Push serialization of sizes and n_size
            size_t ArraySizesCnt = 0;
            for (size_t i=0; i<x.n_args; i++) {
                if(ASRUtils::is_array(ASRUtils::expr_type(x.m_args[i]))){
                    ASR::expr_t* ArraySizeExpr = ASRUtils::EXPR
                        (ASR::make_ArraySize_t(al, x.m_args[i]->base.loc, x.m_args[i],
                        nullptr, ASRUtils::TYPE(ASR::make_Integer_t(al, x.m_args[i]->base.loc, 8)),
                        ASRUtils::get_compile_time_array_size(al,
                            ASRUtils::expr_type(x.m_args[i])))) ;
                    visit_expr(*ArraySizeExpr);
                    args.push_back(tmp);
                    ArraySizesCnt++;
                }
            }

            args.insert(args.end()-ArraySizesCnt,
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(context),
                    ArraySizesCnt));
            // Push runtime-length of strings and n_length
            size_t string_lengths_cnt = 0;
            for(size_t i=0; i<x.n_args; i++) {
                // Only loop on string types.
                if(!ASRUtils::is_character(*
                    ASRUtils::extract_type(
                        expr_type(x.m_args[i])))){continue;}

                ASR::String_t* str_type =
                    ASR::down_cast<ASR::String_t>(
                        ASRUtils::extract_type(
                            expr_type(x.m_args[i])));
                int64_t len; // dummy to use below.
                if(ASRUtils::extract_value(str_type->m_len, len)){
                    // It's serialized at compile time (`S-len`).
                } else {
                    args.push_back(get_string_length(x.m_args[i]));
                    ++string_lengths_cnt;
                }
            }
            args.insert(args.end()- string_lengths_cnt - ArraySizesCnt,
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(context),
                    string_lengths_cnt));

            // This vector is used to keep track of all contiguous buffer copies created for arrays
            // which are allocated on heap, and need to be freed after the function call.
            std::vector<llvm::Value*> contiguous_copies_to_free;
            // Push the args.
            for (size_t i=0; i<x.n_args; i++) {
                // Push the args as raw pointers
                int64_t ptr_load_copy = ptr_loads;
                ptr_loads = (ASR::is_a<ASR::Var_t>(*x.m_args[i]) && !ASRUtils::is_character(*expr_type(x.m_args[i]))) ? 0 : 1;
                // Special Hanlding to pass appropriate pointer to the backend.
                if(ASRUtils::is_array(expr_type(x.m_args[i]))){ // Arrays need a cast to pointerToDataArray physicalType.
                    ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(
                        ASRUtils::type_get_past_allocatable_pointer(
                            ASRUtils::expr_type(x.m_args[i])));
                    //Copy only when we have DescriptorArray Type, where not referencing through pointer
                    //TODO: Check for non-unit strides, and create a copy only when having non-unit strides.
                    bool copy_needed = (arr->m_physical_type == ASR::array_physical_typeType::DescriptorArray) &&
                                        ASR::is_a<ASR::Var_t>(*x.m_args[i]);
                    if(copy_needed){
                        // For DescriptorArray, we need to create a contiguous copy
                        // because the descriptor may have non-unit strides (e.g., from array sections)
                        // and the string format runtime function expects contiguous arrays for inputs
                        ASR::ttype_t* source_array_type = ASRUtils::expr_type(x.m_args[i]);
                        // Visit the expression to get the descriptor
                        int64_t ptr_loads_copy2 = ptr_loads;
                        ptr_loads = 1 - !LLVM::is_llvm_pointer(*source_array_type);
                        visit_expr_wrapper(x.m_args[i]);
                        llvm::Value* source_desc = tmp;
                        llvm::Type* source_llvm_type = llvm_utils->get_type_from_ttype_t_util(
                            x.m_args[i], ASRUtils::type_get_past_allocatable_pointer(source_array_type), module.get());
                        ptr_loads = ptr_loads_copy2;
                        llvm::Type* elem_type = llvm_utils->get_type_from_ttype_t_util(
                            x.m_args[i], ASRUtils::extract_type(source_array_type), module.get());
                        int rank = ASRUtils::extract_n_dims_from_ttype(source_array_type);
                        // Create contiguous copy using the array descriptor utility
                        tmp = arr_descr->create_contiguous_copy_from_descriptor(
                            source_llvm_type, source_desc, elem_type, rank, module.get());
                        // Track this heap allocation to free after function call
                        contiguous_copies_to_free.push_back(tmp);
                    } else if(arr->m_physical_type != ASR::array_physical_typeType::PointerArray){
                        ASR::ttype_t* array_type = ASRUtils::TYPE(
                                                    ASR::make_Array_t(al, arr->base.base.loc,arr->m_type,
                                                    arr->m_dims, arr->n_dims,ASR::array_physical_typeType::FixedSizeArray));
                        ASR::expr_t* array_casted_to_pointer = ASRUtils::EXPR(
                                                                ASR::make_ArrayPhysicalCast_t(al, arr->base.base.loc,
                                                                x.m_args[i],arr->m_physical_type,
                                                                ASR::array_physical_typeType::PointerArray,
                                                                array_type, nullptr));
                        this->visit_expr(*array_casted_to_pointer);
                    } else {
                        this->visit_expr(*x.m_args[i]);
                    }
                } else if (ASRUtils::is_character(*expr_type(x.m_args[i])) &&
                    ASRUtils::get_string_type(expr_type(x.m_args[i]))->m_physical_type == ASR::CChar) {
                    visit_expr_load_wrapper(x.m_args[i], 0);
                    LCOMPILERS_ASSERT(llvm_utils->get_StringType(expr_type(x.m_args[i])) == llvm::Type::getInt8Ty(context))
                    LCOMPILERS_ASSERT(tmp->getType()->isPointerTy()); // atleast not `char`
                    llvm::Value* tmp_ptr = builder->CreateAlloca(llvm::Type::getInt8Ty(context)->getPointerTo()->getPointerTo());
                    builder->CreateStore(tmp, tmp_ptr);
                    tmp = tmp_ptr;
                } else {
                    ptr_loads = ptr_loads + LLVM::is_llvm_pointer(*expr_type(x.m_args[i]));
                    this->visit_expr_wrapper(x.m_args[i], true);
                }
                // Handling for polymorphic class variables in print statements with --new-classes
                if (compiler_options.new_classes &&
                    ASR::is_a<ASR::Var_t>(*x.m_args[i]) &&
                    ASRUtils::is_class_type(ASRUtils::extract_type(ASRUtils::expr_type(x.m_args[i])))) {

                    // Try to get struct symbol for this expression (returns nullptr if not applicable)
                    ASR::symbol_t* maybe_struct =
                        ASRUtils::symbol_get_past_external(
                            ASRUtils::get_struct_sym_from_struct_expr(x.m_args[i])
                        );

                    // If the argument is not a struct/class, skip this block (important for REPL)
                    if (maybe_struct != nullptr) {

                        ASR::Struct_t* struct_t = ASR::down_cast<ASR::Struct_t>(maybe_struct);

                        llvm::Type* polymorphic_struct_type = llvm_utils->getClassType(struct_t);
                        llvm::Type* actual_struct_type = llvm_utils->getStructType(struct_t, module.get(), true);

                        // GEP to the "data" field of the wrapper: wrapper = { typeid, data_ptr }
                        llvm::Value* data_ptr = llvm_utils->create_gep2(
                            polymorphic_struct_type, tmp, 1);

                        if (ASRUtils::is_unlimited_polymorphic_type(x.m_args[i])) {
                            // For class(*), load the void* from wrapper
                            tmp = llvm_utils->CreateLoad2(llvm_utils->i8_ptr, data_ptr);
                        } else {
                            // For a concrete CLASS(T), data_ptr is already the pointer we need
                            tmp = llvm_utils->CreateLoad2(actual_struct_type, data_ptr);
                        }
                    }
                }
                if(!tmp->getType()->isPointerTy() ||
                    ASR::is_a<ASR::PointerToCPtr_t>(*x.m_args[i])){
                    llvm::Value* tmp_ptr = builder->CreateAlloca(tmp->getType());
                    builder->CreateStore(tmp, tmp_ptr);
                    tmp = tmp_ptr;
                }
                args.push_back(tmp);
                ptr_loads = ptr_load_copy;
            }
            tmp = llvm_utils->string_format_fortran(args);
            // Free contiguous copies that were heap-allocated
            for (llvm::Value* copy_ptr : contiguous_copies_to_free) {
                llvm_utils->lfortran_free(copy_ptr);
            }

            // Load result size
            llvm::Value *result_size = llvm_utils->CreateLoad2(llvm::Type::getInt64Ty(context), result_size_ptr);

            tmp = llvm_utils->create_string_descriptor(tmp, result_size,"stringFormat_desc");
        } else {
            throw CodeGenError("Only FormatFortran string formatting implemented so far.");
        }
    }

    void visit_ArrayBroadcast(const ASR::ArrayBroadcast_t &x) {
        this->visit_expr_wrapper(x.m_array, true);
        llvm::Value *value = tmp;
        llvm::Type* ele_type = llvm_utils->get_el_type(
            x.m_array, ASRUtils::type_get_past_array(x.m_type), module.get());
        size_t n_eles = ASRUtils::get_fixed_size_of_array(x.m_type);
        llvm::Type* vec_type = FIXED_VECTOR_TYPE::get(ele_type, n_eles);
        llvm::AllocaInst *vec = llvm_utils->CreateAlloca(*builder, vec_type);
        for (size_t i=0; i < n_eles; i++) {
            llvm::Value* store_value = value;
            if (ASRUtils::is_logical(*ASRUtils::type_get_past_array(x.m_type)) &&
                store_value->getType()->isIntegerTy(1)) {
                store_value = builder->CreateZExt(store_value, llvm::Type::getInt8Ty(context));
            }
            builder->CreateStore(store_value, llvm_utils->create_gep2(vec_type, vec, i));
        }
        tmp = llvm_utils->CreateLoad2(vec_type, vec);
    }
};

/// Utility used by any llvm_util member function.
/// defined here to have access to ASRToLLVMVisitor member definition (specifically `visit_expr_wrapper()`, `tmp`).
llvm::Value* LLVMUtils::get_array_size(llvm::Value* array_ptr, llvm::Type* array_llvm_type, ASR::ttype_t* array_asr_type, ASRToLLVMVisitor *asr_to_llvm_visitor){
    const int RESULT_KIND = 8;
    auto const array_t = ASR::down_cast<ASR::Array_t>(array_asr_type);
    if(ASRUtils::is_fixed_size_array(array_asr_type)){
        const auto array_size = ASRUtils::get_fixed_size_of_array(array_asr_type);
        return llvm::ConstantInt::get(context, llvm::APInt(RESULT_KIND * 8, array_size));
    } else if(array_t->m_physical_type == ASR::DescriptorArray) {
        return arr_api->get_array_size(array_llvm_type, array_ptr, nullptr, RESULT_KIND);
    } else {
        llvm::Value* llvm_size = llvm::ConstantInt::get(context, llvm::APInt(8 * RESULT_KIND, 1));
        auto const n_dims = array_t->n_dims;
        auto const m_dims = array_t->m_dims;
        for( size_t i = 0; i < n_dims; i++ ) {
            asr_to_llvm_visitor->visit_expr_wrapper(m_dims[i].m_length, true);

            // Make dimension length and return size compatible.
            if(ASRUtils::extract_kind_from_ttype_t(
                ASRUtils::expr_type(m_dims[i].m_length)) > RESULT_KIND){
                    asr_to_llvm_visitor->tmp = builder->CreateTrunc(asr_to_llvm_visitor->tmp, llvm::IntegerType::get(context, 8 * RESULT_KIND));
            } else if (ASRUtils::extract_kind_from_ttype_t(
                ASRUtils::expr_type(m_dims[i].m_length)) < RESULT_KIND){
                asr_to_llvm_visitor->tmp = builder->CreateSExt(asr_to_llvm_visitor->tmp, llvm::IntegerType::get(context, 8 * RESULT_KIND));
            }
            llvm_size = builder->CreateMul(asr_to_llvm_visitor->tmp, llvm_size);
        }
        return llvm_size;
    }
}

Result<std::unique_ptr<LLVMModule>> asr_to_llvm(ASR::TranslationUnit_t &asr,
        diag::Diagnostics &diagnostics,
        llvm::LLVMContext &context, Allocator &al,
        LCompilers::PassManager& pass_manager,
        CompilerOptions &co, const std::string &run_fn, const std::string &/*global_underscore*/,
        const std::string &infile, LocationManager &lm)
{
    ASRToLLVMVisitor v(al, context, infile, co, diagnostics, lm);

    std::vector<int64_t> skip_optimization_func_instantiation;
    skip_optimization_func_instantiation.push_back(static_cast<int64_t>(
                    ASRUtils::IntrinsicElementalFunctions::FlipSign));
    skip_optimization_func_instantiation.push_back(static_cast<int64_t>(
                    ASRUtils::IntrinsicElementalFunctions::FMA));
    skip_optimization_func_instantiation.push_back(static_cast<int64_t>(
                    ASRUtils::IntrinsicElementalFunctions::SignFromValue));

    co.po.run_fun = run_fn;
    co.po.always_run = false;
    co.po.skip_optimization_func_instantiation = skip_optimization_func_instantiation;
    pass_manager.rtlib = co.rtlib;
    auto t1 = std::chrono::high_resolution_clock::now();
    pass_manager.apply_passes(al, &asr, co.po, diagnostics);
    auto t2 = std::chrono::high_resolution_clock::now();

    if (co.time_report) {
        int time_take_to_run_asr_passes = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();
        double time_in_milliseconds = (double) time_take_to_run_asr_passes / 1000.0;
        std::string message = "";
        if ( time_in_milliseconds >= 1.0 ) {
            message = "ASR -> ASR passes: " + std::to_string(time_take_to_run_asr_passes / 1000) + "." + std::to_string(time_take_to_run_asr_passes % 1000) + " ms";
        } else {
            message = "ASR -> ASR passes: " + std::to_string(time_in_milliseconds) + " ms";
        }
        co.po.vector_of_time_report.push_back(message);
    }

    // Uncomment for debugging the ASR after the transformation
    // std::cout << LCompilers::pickle(asr, true, false, false) << std::endl;

    t1 = std::chrono::high_resolution_clock::now();
    try {
        v.visit_asr((ASR::asr_t&)asr);
    } catch (const CodeGenError &e) {
        Error error;
        diagnostics.diagnostics.push_back(e.d);
        return error;
    } catch (const CodeGenAbort &) {
        LCOMPILERS_ASSERT(diagnostics.has_error())
        Error error;
        return error;
    }
    std::string msg;
    llvm::raw_string_ostream err(msg);
    if (llvm::verifyModule(*v.module, &err)) {
        std::string buf;
        llvm::raw_string_ostream os(buf);
        v.module->print(os, nullptr);
        std::cout << os.str();
        msg = "asr_to_llvm: module failed verification. Error:\n" + err.str();
        std::cout << msg << std::endl;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        diagnostics.diagnostics.push_back(diag::Diagnostic(msg,
            diag::Level::Error, diag::Stage::CodeGen));
        Error error;
        return error;
    };

    std::unique_ptr<LLVMModule> res = std::make_unique<LLVMModule>(std::move(v.module));
    t2 = std::chrono::high_resolution_clock::now();

    if (co.time_report) {
        int time_take_to_generate_llvm_ir = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();
        std::string message = "LLVM IR creation: " + std::to_string(time_take_to_generate_llvm_ir / 1000) + "." + std::to_string(time_take_to_generate_llvm_ir % 1000) + " ms";
        co.po.vector_of_time_report.push_back(message);
    }

    return res;
}

} // namespace LCompilers
