diff --git a/src/lfortran/semantics/ast_body_visitor.cpp b/src/lfortran/semantics/ast_body_visitor.cpp
index 805d5cd9d..c38114c7c 100644
--- a/src/lfortran/semantics/ast_body_visitor.cpp
+++ b/src/lfortran/semantics/ast_body_visitor.cpp
@@ -16,13 +16,14 @@
 #include <lfortran/utils.h>
 #include <libasr/pass/instantiate_template.h>
 
-namespace LCompilers::LFortran {
+namespace LCompilers::LFortran
+{
 
-class BodyVisitor : public CommonVisitor<BodyVisitor> {
+class BodyVisitor : public CommonVisitor<BodyVisitor>
+{
 private:
-
 public:
-    ASR::asr_t *asr;
+    ASR::asr_t* asr;
     bool from_block;
     std::set<std::string> labels;
     size_t starting_n_body = 0;
@@ -32,71 +33,87 @@ public:
     int pragma_nesting_level = 0;
     int pragma_nesting_level_2 = 0;
     bool openmp_collapse = false;
-    bool pragma_in_block=false;
-    bool do_in_pragma=false;
-    int nesting_lvl_inside_pragma=0;
-    int collapse_value=0;
+    bool pragma_in_block = false;
+    bool do_in_pragma = false;
+    int nesting_lvl_inside_pragma = 0;
+    int collapse_value = 0;
     Vec<ASR::do_loop_head_t> do_loop_heads_for_collapse;
     Vec<ASR::stmt_t*> do_loop_bodies_for_collapse;
-    AST::stmt_t **starting_m_body = nullptr;
+    AST::stmt_t** starting_m_body = nullptr;
     std::vector<ASR::symbol_t*> do_loop_variables;
-    std::map<ASR::asr_t*, std::pair<const AST::stmt_t*,int64_t>> print_statements;
-    std::vector<ASR::DoConcurrentLoop_t *> omp_constructs;
-    std::vector<ASR::stmt_t*> omp_region_body={};
-    bool is_first_section=false;
+    std::map<ASR::asr_t*, std::pair<const AST::stmt_t*, int64_t>> print_statements;
+    std::vector<ASR::DoConcurrentLoop_t*> omp_constructs;
+    std::vector<ASR::stmt_t*> omp_region_body = {};
+    bool is_first_section = false;
     int program_count = 0;
 
-    BodyVisitor(Allocator &al, ASR::asr_t *unit, diag::Diagnostics &diagnostics,
-        CompilerOptions &compiler_options,
-        std::map<uint64_t, std::map<std::string, ASR::ttype_t*>> &implicit_mapping,
+    BodyVisitor(
+        Allocator& al,
+        ASR::asr_t* unit,
+        diag::Diagnostics& diagnostics,
+        CompilerOptions& compiler_options,
+        std::map<uint64_t, std::map<std::string, ASR::ttype_t*>>& implicit_mapping,
         std::map<uint64_t, ASR::symbol_t*>& common_variables_hash,
         std::map<uint64_t, std::vector<std::string>>& external_procedures_mapping,
         std::map<uint64_t, std::vector<std::string>>& explicit_intrinsic_procedures_mapping,
-        std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>> &instantiate_types,
-        std::map<uint32_t, std::map<std::string, ASR::symbol_t*>> &instantiate_symbols,
-        std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>> &entry_functions,
-        std::map<std::string, std::vector<int>> &entry_function_arguments_mapping,
-        std::map<uint32_t, std::vector<ASR::stmt_t*>> &data_structure,
-        LCompilers::LocationManager &lm
-    ) : CommonVisitor(
-            al, nullptr, diagnostics, compiler_options, implicit_mapping,
-            common_variables_hash, external_procedures_mapping,
-            explicit_intrinsic_procedures_mapping, instantiate_types,
-            instantiate_symbols, entry_functions, entry_function_arguments_mapping,
-            data_structure, lm
-        ), asr{unit}, from_block{false} {}
-
-    void visit_Declaration(const AST::Declaration_t& x) {
-        if( from_block ) {
+        std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>>&
+            instantiate_types,
+        std::map<uint32_t, std::map<std::string, ASR::symbol_t*>>& instantiate_symbols,
+        std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>>& entry_functions,
+        std::map<std::string, std::vector<int>>& entry_function_arguments_mapping,
+        std::map<uint32_t, std::vector<ASR::stmt_t*>>& data_structure,
+        LCompilers::LocationManager& lm)
+        : CommonVisitor(al,
+                        nullptr,
+                        diagnostics,
+                        compiler_options,
+                        implicit_mapping,
+                        common_variables_hash,
+                        external_procedures_mapping,
+                        explicit_intrinsic_procedures_mapping,
+                        instantiate_types,
+                        instantiate_symbols,
+                        entry_functions,
+                        entry_function_arguments_mapping,
+                        data_structure,
+                        lm)
+        , asr{ unit }
+        , from_block{ false }
+    {
+    }
+
+    void visit_Declaration(const AST::Declaration_t& x)
+    {
+        if (from_block) {
             visit_DeclarationUtil(x);
         }
     }
 
-    void visit_Block(const AST::Block_t &x) {
+    void visit_Block(const AST::Block_t& x)
+    {
         all_loops_blocks_nesting++;
         from_block = true;
-        SymbolTable *parent_scope = current_scope;
+        SymbolTable* parent_scope = current_scope;
         current_scope = al.make_new<SymbolTable>(parent_scope);
         ASR::asr_t* block;
         std::string name;
         if (x.m_stmt_name) {
             name = std::string(x.m_stmt_name);
-            block = ASR::make_Block_t(al, x.base.base.loc,
-                current_scope, x.m_stmt_name, nullptr, 0);
+            block
+                = ASR::make_Block_t(al, x.base.base.loc, current_scope, x.m_stmt_name, nullptr, 0);
         } else {
             // TODO: Understand tests/block1.f90 to know if this is needed, otherwise
             // it might be possible to allow x.m_stmt_name to be nullptr
             name = parent_scope->get_unique_name("block");
-            block = ASR::make_Block_t(al, x.base.base.loc,
-                current_scope, s2c(al, name), nullptr, 0);
+            block
+                = ASR::make_Block_t(al, x.base.base.loc, current_scope, s2c(al, name), nullptr, 0);
         }
-        ASR::Block_t* block_t = ASR::down_cast<ASR::Block_t>(
-            ASR::down_cast<ASR::symbol_t>(block));
+        ASR::Block_t* block_t = ASR::down_cast<ASR::Block_t>(ASR::down_cast<ASR::symbol_t>(block));
 
-        for (size_t i=0; i<x.n_use; i++) {
+        for (size_t i = 0; i < x.n_use; i++) {
             visit_unit_decl1(*x.m_use[i]);
         }
-        for (size_t i=0; i<x.n_decl; i++) {
+        for (size_t i = 0; i < x.n_decl; i++) {
             visit_unit_decl2(*x.m_decl[i]);
         }
 
@@ -107,8 +124,7 @@ public:
         block_t->n_body = body.size();
         current_scope = parent_scope;
         current_scope->add_symbol(name, ASR::down_cast<ASR::symbol_t>(block));
-        tmp = ASR::make_BlockCall_t(al, x.base.base.loc,  -1,
-                                    ASR::down_cast<ASR::symbol_t>(block));
+        tmp = ASR::make_BlockCall_t(al, x.base.base.loc, -1, ASR::down_cast<ASR::symbol_t>(block));
         from_block = false;
         all_loops_blocks_nesting--;
     }
@@ -118,23 +134,24 @@ public:
     //   * ImplicitDeallocate
     //   * GoToTarget
     // The `body` Vec must already be reserved
-    void transform_stmts(Vec<ASR::stmt_t*> &body, size_t n_body, AST::stmt_t **m_body) {
+    void transform_stmts(Vec<ASR::stmt_t*>& body, size_t n_body, AST::stmt_t** m_body)
+    {
         tmp = nullptr;
         Vec<ASR::stmt_t*>* current_body_copy = current_body;
         current_body = &body;
-        for (size_t i=0; i<n_body; i++) {
+        for (size_t i = 0; i < n_body; i++) {
             // If there is a label, create a GoToTarget node first
             int64_t label = stmt_label(m_body[i]);
             if (label != 0) {
-                ASR::asr_t *l = ASR::make_GoToTarget_t(al, m_body[i]->base.loc, label,
-                                    s2c(al, std::to_string(label)));
+                ASR::asr_t* l = ASR::make_GoToTarget_t(
+                    al, m_body[i]->base.loc, label, s2c(al, std::to_string(label)));
                 body.push_back(al, ASR::down_cast<ASR::stmt_t>(l));
             }
             // Visit the statement
             LCOMPILERS_ASSERT(current_body != nullptr)
             try {
                 this->visit_stmt(*m_body[i]);
-            } catch (const SemanticAbort &a) {
+            } catch (const SemanticAbort& a) {
                 if (!compiler_options.continue_compilation) {
                     throw a;
                 } else {
@@ -142,7 +159,10 @@ public:
                     tmp_vec.clear();
                 }
             }
-            if((all_blocks_nesting ==0 || pragma_in_block) && !do_in_pragma && !omp_region_body.empty() && !(m_body[i]->type == AST::stmtType::Pragma && AST::down_cast<AST::Pragma_t>(m_body[i])->m_type == AST::OMPPragma)) {
+            if ((all_blocks_nesting == 0 || pragma_in_block) && !do_in_pragma
+                && !omp_region_body.empty()
+                && !(m_body[i]->type == AST::stmtType::Pragma
+                     && AST::down_cast<AST::Pragma_t>(m_body[i])->m_type == AST::OMPPragma)) {
                 ASR::stmt_t* tmp_stmt = ASRUtils::STMT(tmp);
                 omp_region_body.push_back(tmp_stmt);
             } else {
@@ -150,11 +170,13 @@ public:
                     ASR::stmt_t* tmp_stmt = ASRUtils::STMT(tmp);
                     if (tmp_stmt->type == ASR::stmtType::SubroutineCall) {
                         ASR::stmt_t* impl_decl = create_implicit_deallocate_subrout_call(tmp_stmt);
-                        if (impl_decl) body.push_back(al, impl_decl);
+                        if (impl_decl)
+                            body.push_back(al, impl_decl);
                     }
                     body.push_back(al, tmp_stmt);
                 } else if (!tmp_vec.empty()) {
-                    for (auto &x : tmp_vec) body.push_back(al, ASRUtils::STMT(x));
+                    for (auto& x : tmp_vec)
+                        body.push_back(al, ASRUtils::STMT(x));
                     tmp_vec.clear();
                 }
                 tmp = nullptr;
@@ -165,17 +187,18 @@ public:
         current_body = current_body_copy;
     }
 
-    void visit_TranslationUnit(const AST::TranslationUnit_t &x) {
+    void visit_TranslationUnit(const AST::TranslationUnit_t& x)
+    {
         program_count = 0;
-        ASR::TranslationUnit_t *unit = ASR::down_cast2<ASR::TranslationUnit_t>(asr);
+        ASR::TranslationUnit_t* unit = ASR::down_cast2<ASR::TranslationUnit_t>(asr);
         current_scope = unit->m_symtab;
         Vec<ASR::asr_t*> items;
         items.reserve(al, x.n_items);
-        for (size_t i=0; i<x.n_items; i++) {
+        for (size_t i = 0; i < x.n_items; i++) {
             tmp = nullptr;
             try {
                 visit_ast(*x.m_items[i]);
-            } catch (const SemanticAbort &a) {
+            } catch (const SemanticAbort& a) {
                 if (!compiler_options.continue_compilation) {
                     throw a;
                 } else {
@@ -186,7 +209,7 @@ public:
             if (tmp) {
                 items.push_back(al, tmp);
             } else if (!tmp_vec.empty()) {
-                for (auto &t: tmp_vec) {
+                for (auto& t : tmp_vec) {
                     items.push_back(al, t);
                 }
                 tmp_vec.clear();
@@ -197,60 +220,94 @@ public:
     }
 
     template <typename T>
-    void process_format_statement(ASR::asr_t *old_tmp, int &label, Allocator &al, std::map<int64_t, std::string> &format_statements) {
-        T *old_stmt = ASR::down_cast<T>(ASRUtils::STMT(old_tmp));
-        ASR::ttype_t *fmt_type = ASRUtils::TYPE(ASR::make_String_t(
-            al, old_stmt->base.base.loc, 1,
-            ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, old_stmt->base.base.loc, format_statements[label].size(),
+    void process_format_statement(ASR::asr_t* old_tmp,
+                                  int& label,
+                                  Allocator& al,
+                                  std::map<int64_t, std::string>& format_statements)
+    {
+        T* old_stmt = ASR::down_cast<T>(ASRUtils::STMT(old_tmp));
+        ASR::ttype_t* fmt_type = ASRUtils::TYPE(ASR::make_String_t(
+            al,
+            old_stmt->base.base.loc,
+            1,
+            ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                al,
+                old_stmt->base.base.loc,
+                format_statements[label].size(),
                 ASRUtils::TYPE(ASR::make_Integer_t(al, old_stmt->base.base.loc, 4)))),
-                ASR::string_length_kindType::ExpressionLength,
+            ASR::string_length_kindType::ExpressionLength,
             ASR::string_physical_typeType::DescriptorString));
-        ASR::expr_t *fmt_constant = ASRUtils::EXPR(ASR::make_StringConstant_t(
+        ASR::expr_t* fmt_constant = ASRUtils::EXPR(ASR::make_StringConstant_t(
             al, old_stmt->base.base.loc, s2c(al, format_statements[label]), fmt_type));
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Allocatable_t(al, old_stmt->base.base.loc,
-                ASRUtils::TYPE(ASR::make_String_t(
-                    al, old_stmt->base.base.loc, 1, nullptr,
-                    ASR::string_length_kindType::DeferredLength,
-                    ASR::string_physical_typeType::DescriptorString))));
-        ASR::expr_t *string_format = ASRUtils::EXPR(ASRUtils::make_StringFormat_t_util(al, old_stmt->base.base.loc,
-            fmt_constant, old_stmt->m_values, old_stmt->n_values, ASR::string_format_kindType::FormatFortran,
-            type, nullptr));
-        Vec<ASR::expr_t *> print_args;
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Allocatable_t(
+            al,
+            old_stmt->base.base.loc,
+            ASRUtils::TYPE(ASR::make_String_t(al,
+                                              old_stmt->base.base.loc,
+                                              1,
+                                              nullptr,
+                                              ASR::string_length_kindType::DeferredLength,
+                                              ASR::string_physical_typeType::DescriptorString))));
+        ASR::expr_t* string_format = ASRUtils::EXPR(
+            ASRUtils::make_StringFormat_t_util(al,
+                                               old_stmt->base.base.loc,
+                                               fmt_constant,
+                                               old_stmt->m_values,
+                                               old_stmt->n_values,
+                                               ASR::string_format_kindType::FormatFortran,
+                                               type,
+                                               nullptr));
+        Vec<ASR::expr_t*> print_args;
         print_args.reserve(al, 1);
         print_args.push_back(al, string_format);
         old_stmt->m_values = print_args.p;
         old_stmt->n_values = print_args.size();
     }
 
-    void handle_format() {
-        for(auto it = print_statements.begin(); it != print_statements.end(); it++) {
+    void handle_format()
+    {
+        for (auto it = print_statements.begin(); it != print_statements.end(); it++) {
             ASR::asr_t* old_tmp = it->first;
             const AST::stmt_t* x = it->second.first;
             int label = it->second.second;
             if (format_statements.find(label) == format_statements.end()) {
-                diag.semantic_error_label("The label " + std::to_string(label) + " does not point to any format statement",
-                 {x->base.loc},"Invalid label in this statement");
+                diag.semantic_error_label("The label " + std::to_string(label)
+                                              + " does not point to any format statement",
+                                          { x->base.loc },
+                                          "Invalid label in this statement");
             } else {
-                // To Do :: after refactoring write, change process_format_statement() to tackle stringformat instead.
+                // To Do :: after refactoring write, change process_format_statement() to tackle
+                // stringformat instead.
                 if (AST::is_a<AST::Print_t>(*x)) {
                     ASR::Print_t* print_stmt = ASR::down_cast2<ASR::Print_t>(old_tmp);
-                    if(ASR::is_a<ASR::StringFormat_t>(*print_stmt->m_text)){
-                        ASR::StringFormat_t* string_fmt_arg = ASR::down_cast<ASR::StringFormat_t>(
-                            print_stmt->m_text);
-                        ASR::ttype_t *fmt_type = ASRUtils::TYPE(ASR::make_String_t(
-                            al, print_stmt->base.base.loc, 1,
-                            ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, print_stmt->base.base.loc, format_statements[label].size(),
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, print_stmt->base.base.loc, 4)))),
-                            ASR::string_length_kindType::ExpressionLength,
-                            ASR::string_physical_typeType::DescriptorString));
-                        ASR::expr_t *fmt_constant = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                            al, print_stmt->base.base.loc, s2c(al, format_statements[label]), fmt_type));
+                    if (ASR::is_a<ASR::StringFormat_t>(*print_stmt->m_text)) {
+                        ASR::StringFormat_t* string_fmt_arg
+                            = ASR::down_cast<ASR::StringFormat_t>(print_stmt->m_text);
+                        ASR::ttype_t* fmt_type = ASRUtils::TYPE(
+                            ASR::make_String_t(al,
+                                               print_stmt->base.base.loc,
+                                               1,
+                                               ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                                   al,
+                                                   print_stmt->base.base.loc,
+                                                   format_statements[label].size(),
+                                                   ASRUtils::TYPE(ASR::make_Integer_t(
+                                                       al, print_stmt->base.base.loc, 4)))),
+                                               ASR::string_length_kindType::ExpressionLength,
+                                               ASR::string_physical_typeType::DescriptorString));
+                        ASR::expr_t* fmt_constant = ASRUtils::EXPR(
+                            ASR::make_StringConstant_t(al,
+                                                       print_stmt->base.base.loc,
+                                                       s2c(al, format_statements[label]),
+                                                       fmt_type));
                         string_fmt_arg->m_fmt = fmt_constant;
                     }
                 } else if (AST::is_a<AST::Write_t>(*x)) {
-                    process_format_statement<ASR::FileWrite_t>(old_tmp, label, al, format_statements);
+                    process_format_statement<ASR::FileWrite_t>(
+                        old_tmp, label, al, format_statements);
                 } else if (AST::is_a<AST::Read_t>(*x)) {
-                    process_format_statement<ASR::FileRead_t>(old_tmp, label, al, format_statements);
+                    process_format_statement<ASR::FileRead_t>(
+                        old_tmp, label, al, format_statements);
                 }
             }
         }
@@ -258,51 +315,50 @@ public:
         print_statements.clear();
     }
 
-    void visit_Open(const AST::Open_t& x) {
-        ASR::expr_t *a_newunit = nullptr, *a_filename = nullptr, *a_status = nullptr, *a_form = nullptr, 
-            *a_access = nullptr, *a_iostat = nullptr, *a_iomsg = nullptr, *a_action = nullptr, *a_delim = nullptr;
-        if( x.n_args > 1 ) {
-            diag.add(Diagnostic(
-                "Number of arguments cannot be more than 1 in Open statement.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+    void visit_Open(const AST::Open_t& x)
+    {
+        ASR::expr_t *a_newunit = nullptr, *a_filename = nullptr, *a_status = nullptr,
+                    *a_form = nullptr, *a_access = nullptr, *a_iostat = nullptr, *a_iomsg = nullptr,
+                    *a_action = nullptr, *a_delim = nullptr;
+        if (x.n_args > 1) {
+            diag.add(Diagnostic("Number of arguments cannot be more than 1 in Open statement.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        if( x.n_args == 1 ) {
+        if (x.n_args == 1) {
             this->visit_expr(*x.m_args[0]);
             a_newunit = ASRUtils::EXPR(tmp);
         }
-        for( std::uint32_t i = 0; i < x.n_kwargs; i++ ) {
+        for (std::uint32_t i = 0; i < x.n_kwargs; i++) {
             AST::keyword_t kwarg = x.m_kwargs[i];
             std::string m_arg_str(kwarg.m_arg);
             m_arg_str = to_lower(m_arg_str);
-            if( m_arg_str == std::string("newunit") ||
-                m_arg_str == std::string("unit") ) {
-                if( a_newunit != nullptr ) {
+            if (m_arg_str == std::string("newunit") || m_arg_str == std::string("unit")) {
+                if (a_newunit != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `unit` found, `unit` has already been specified via argument or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_newunit = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_newunit_type = ASRUtils::expr_type(a_newunit);
-                if( ( m_arg_str == std::string("newunit") &&
-                     !ASRUtils::is_variable(a_newunit) ) ||
-                    ( !ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_newunit_type))
-                    ) ) {
-                        diag.add(Diagnostic(
-                            "`newunit`/`unit` must be a mutable variable of type, Integer or IntegerPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                if ((m_arg_str == std::string("newunit") && !ASRUtils::is_variable(a_newunit))
+                    || (!ASR::is_a<ASR::Integer_t>(
+                        *ASRUtils::type_get_past_pointer(a_newunit_type)))) {
+                    diag.add(Diagnostic(
+                        "`newunit`/`unit` must be a mutable variable of type, Integer or IntegerPointer",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
 
-                if ( m_arg_str == std::string("newunit") ) {
+                if (m_arg_str == std::string("newunit")) {
                     Vec<AST::fnarg_t> args;
                     args.reserve(al, 0);
                     AST::fnarg_t arg;
@@ -313,519 +369,565 @@ public:
                     arg.m_end = kwarg.m_value;
                     args.push_back(al, arg);
                     AST::SubroutineCall_t* subrout_call = AST::down_cast2<AST::SubroutineCall_t>(
-                        AST::make_SubroutineCall_t(al, x.base.base.loc, 0, s2c(al, "newunit"), nullptr, 0, args.p, args.size(), nullptr, 0, nullptr, 0, nullptr));
+                        AST::make_SubroutineCall_t(al,
+                                                   x.base.base.loc,
+                                                   0,
+                                                   s2c(al, "newunit"),
+                                                   nullptr,
+                                                   0,
+                                                   args.p,
+                                                   args.size(),
+                                                   nullptr,
+                                                   0,
+                                                   nullptr,
+                                                   0,
+                                                   nullptr));
                     visit_SubroutineCall(*subrout_call);
                     tmp_vec.push_back(tmp);
                 }
-            } else if( m_arg_str == std::string("file") ) {
-                if( a_filename != nullptr ) {
+            } else if (m_arg_str == std::string("file")) {
+                if (a_filename != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `file` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_filename = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_filename_type = ASRUtils::expr_type(a_filename);
                 if (!ASRUtils::is_character(*a_filename_type)) {
-                        diag.add(Diagnostic(
-                            "`file` must be of type, String or StringPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                    diag.add(Diagnostic("`file` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
 
                 if (ASR::is_a<ASR::StringConstant_t>(*a_filename)) {
-                    std::string str = std::string(ASR::down_cast<ASR::StringConstant_t>(a_filename)->m_s);
+                    std::string str
+                        = std::string(ASR::down_cast<ASR::StringConstant_t>(a_filename)->m_s);
                     rtrim(str);
                     a_filename = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                                al, x.base.base.loc, s2c(al, str),
-                                ASRUtils::TYPE(ASR::make_String_t(
-                                    al, a_filename->base.loc, 1,
-                                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, a_filename->base.loc, str.length(),
-                                        ASRUtils::TYPE(ASR::make_Integer_t(al, a_filename->base.loc, 4)))),
-                                    ASR::string_length_kindType::ExpressionLength,
-                                    ASR::string_physical_typeType::DescriptorString))));
-                }
-            } else if( m_arg_str == std::string("status") ) {
-                if( a_status != nullptr ) {
+                        al,
+                        x.base.base.loc,
+                        s2c(al, str),
+                        ASRUtils::TYPE(ASR::make_String_t(
+                            al,
+                            a_filename->base.loc,
+                            1,
+                            ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                al,
+                                a_filename->base.loc,
+                                str.length(),
+                                ASRUtils::TYPE(ASR::make_Integer_t(al, a_filename->base.loc, 4)))),
+                            ASR::string_length_kindType::ExpressionLength,
+                            ASR::string_physical_typeType::DescriptorString))));
+                }
+            } else if (m_arg_str == std::string("status")) {
+                if (a_status != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `status` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_status = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_status_type = ASRUtils::expr_type(a_status);
                 if (!ASRUtils::is_character(*a_status_type)) {
-                        diag.add(Diagnostic(
-                            "`status` must be of type, String or StringPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                    diag.add(Diagnostic("`status` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
                 if (ASR::is_a<ASR::StringConstant_t>(*a_status)) {
-                    std::string str = std::string(ASR::down_cast<ASR::StringConstant_t>(a_status)->m_s);
+                    std::string str
+                        = std::string(ASR::down_cast<ASR::StringConstant_t>(a_status)->m_s);
                     rtrim(str);
                     a_status = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                                al, x.base.base.loc, s2c(al, str),
-                                ASRUtils::TYPE(ASR::make_String_t(
-                                    al, a_status->base.loc, 1,
-                                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, a_status->base.loc, str.length(),
-                                        ASRUtils::TYPE(ASR::make_Integer_t(al, a_status->base.loc, 4)))),
-                                    ASR::string_length_kindType::ExpressionLength,
-                                    ASR::string_physical_typeType::DescriptorString))));
-                }
-            } else if( m_arg_str == std::string("form") ) {
-                if ( a_form != nullptr ) {
+                        al,
+                        x.base.base.loc,
+                        s2c(al, str),
+                        ASRUtils::TYPE(ASR::make_String_t(
+                            al,
+                            a_status->base.loc,
+                            1,
+                            ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                al,
+                                a_status->base.loc,
+                                str.length(),
+                                ASRUtils::TYPE(ASR::make_Integer_t(al, a_status->base.loc, 4)))),
+                            ASR::string_length_kindType::ExpressionLength,
+                            ASR::string_physical_typeType::DescriptorString))));
+                }
+            } else if (m_arg_str == std::string("form")) {
+                if (a_form != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `form` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
-
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_form = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_form_type = ASRUtils::expr_type(a_form);
                 if (!ASRUtils::is_character(*a_form_type)) {
-                    diag.add(Diagnostic(
-                        "`form` must be of type, String or StringPointer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("`form` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 if (ASR::is_a<ASR::StringConstant_t>(*a_form)) {
-                    std::string str = std::string(ASR::down_cast<ASR::StringConstant_t>(a_form)->m_s);
+                    std::string str
+                        = std::string(ASR::down_cast<ASR::StringConstant_t>(a_form)->m_s);
                     rtrim(str);
                     a_form = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                                al, x.base.base.loc, s2c(al, str),
-                                ASRUtils::TYPE(ASR::make_String_t(
-                                    al, a_form->base.loc, 1,
-                                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, a_form->base.loc, str.length(),
-                                        ASRUtils::TYPE(ASR::make_Integer_t(al, a_form->base.loc, 4)))),
-                                    ASR::string_length_kindType::ExpressionLength,
-                                    ASR::string_physical_typeType::DescriptorString))));
-                }
-            } else if( m_arg_str == std::string("access") ) {  //TODO: Handle 'direct' as access argument
-                if ( a_access != nullptr ) {
+                        al,
+                        x.base.base.loc,
+                        s2c(al, str),
+                        ASRUtils::TYPE(ASR::make_String_t(
+                            al,
+                            a_form->base.loc,
+                            1,
+                            ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                al,
+                                a_form->base.loc,
+                                str.length(),
+                                ASRUtils::TYPE(ASR::make_Integer_t(al, a_form->base.loc, 4)))),
+                            ASR::string_length_kindType::ExpressionLength,
+                            ASR::string_physical_typeType::DescriptorString))));
+                }
+            } else if (m_arg_str
+                       == std::string("access")) {  // TODO: Handle 'direct' as access argument
+                if (a_access != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `access` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
-
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_access = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_access_type = ASRUtils::expr_type(a_access);
                 if (!ASRUtils::is_character(*a_access_type)) {
-                    diag.add(Diagnostic(
-                        "`access` must be of type, String or StringPointer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("`access` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("iostat") ) {
-                if ( a_iostat != nullptr ) {
+            } else if (m_arg_str == std::string("iostat")) {
+                if (a_iostat != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iostat` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iostat = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iostat_type = ASRUtils::expr_type(a_iostat);
                 if (!ASRUtils::is_variable(a_iostat)) {
-                    diag.add(Diagnostic(
-                        "Non-variable expression for `iostat`",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("Non-variable expression for `iostat`",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 if (!ASRUtils::is_integer(*a_iostat_type)) {
-                    diag.add(Diagnostic(
-                        "`iostat` must be of type, integer or integer*",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("`iostat` must be of type, integer or integer*",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else if (m_arg_str == std::string("iomsg")) {
-                if( a_iomsg != nullptr ) {
+                if (a_iomsg != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iomsg` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iomsg = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iomsg_type = ASRUtils::expr_type(a_iomsg);
                 if (!ASRUtils::is_variable(a_iomsg)) {
-                    diag.add(Diagnostic(
-                        "Non-variable expression for `iomsg`",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("Non-variable expression for `iomsg`",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                if (!ASR::is_a<ASR::String_t>(*ASRUtils::type_get_past_allocatable_pointer(a_iomsg_type))) {
-                    diag.add(Diagnostic(
-                        "`iomsg` must be of type, String",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                if (!ASR::is_a<ASR::String_t>(
+                        *ASRUtils::type_get_past_allocatable_pointer(a_iomsg_type))) {
+                    diag.add(Diagnostic("`iomsg` must be of type, String",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else if (m_arg_str == std::string("action")) {
                 if (a_action != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `action` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_action = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_action_type = ASRUtils::expr_type(a_action);
                 if (!ASRUtils::is_character(*a_action_type)) {
-                    diag.add(Diagnostic(
-                        "`action` must be of type, String or StringPointer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("`action` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else if (m_arg_str == std::string("delim")) {
                 if (a_delim != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `delim` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_delim = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_delim_type = ASRUtils::expr_type(a_delim);
                 if (!ASRUtils::is_character(*a_delim_type)) {
-                    diag.add(Diagnostic(
-                        "`delim` must be of type, String or StringPointer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("`delim` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else {
-                const std::unordered_set<std::string> unsupported_args {"err", "blank", "recl", "fileopt", "position", "pad"};
+                const std::unordered_set<std::string> unsupported_args{ "err",      "blank",
+                                                                        "recl",     "fileopt",
+                                                                        "position", "pad" };
                 if (unsupported_args.find(m_arg_str) == unsupported_args.end()) {
                     diag.add(diag::Diagnostic("Invalid argument `" + m_arg_str + "` supplied",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+                                              diag::Level::Error,
+                                              diag::Stage::Semantic,
+                                              { diag::Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 } else {
-                    diag.semantic_warning_label(
-                        "Argument `" + m_arg_str + "` isn't supported yet",
-                        {x.base.base.loc},
-                        "ignored for now"
-                    );
+                    diag.semantic_warning_label("Argument `" + m_arg_str + "` isn't supported yet",
+                                                { x.base.base.loc },
+                                                "ignored for now");
                 }
             }
         }
-        if( a_newunit == nullptr ) {
+        if (a_newunit == nullptr) {
             diag.add(Diagnostic(
                 "`newunit` or `unit` must be specified either in argument or keyword arguments.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        tmp = ASR::make_FileOpen_t(
-            al, x.base.base.loc, x.m_label, a_newunit, a_filename, a_status, a_form, a_access, a_iostat, a_iomsg, a_action, a_delim);
+        tmp = ASR::make_FileOpen_t(al,
+                                   x.base.base.loc,
+                                   x.m_label,
+                                   a_newunit,
+                                   a_filename,
+                                   a_status,
+                                   a_form,
+                                   a_access,
+                                   a_iostat,
+                                   a_iomsg,
+                                   a_action,
+                                   a_delim);
         tmp_vec.push_back(tmp);
         tmp = nullptr;
     }
 
-    void visit_Close(const AST::Close_t& x) {
+    void visit_Close(const AST::Close_t& x)
+    {
         ASR::expr_t *a_unit = nullptr, *a_iostat = nullptr, *a_iomsg = nullptr;
         ASR::expr_t *a_err = nullptr, *a_status = nullptr;
-        if( x.n_args > 1 ) {
-            diag.add(Diagnostic(
-                "Number of arguments cannot be more than 1 in Close statement.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (x.n_args > 1) {
+            diag.add(Diagnostic("Number of arguments cannot be more than 1 in Close statement.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        if( x.n_args == 1 ) {
+        if (x.n_args == 1) {
             this->visit_expr(*x.m_args[0]);
             a_unit = ASRUtils::EXPR(tmp);
         }
-        for( std::uint32_t i = 0; i < x.n_kwargs; i++ ) {
+        for (std::uint32_t i = 0; i < x.n_kwargs; i++) {
             AST::keyword_t kwarg = x.m_kwargs[i];
             std::string m_arg_str(kwarg.m_arg);
             m_arg_str = to_lower(m_arg_str);
-            if( m_arg_str == std::string("unit") ) {
-                if( a_unit != nullptr ) {
+            if (m_arg_str == std::string("unit")) {
+                if (a_unit != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `unit` found, `unit` has already been specified via argument or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_unit = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_newunit_type = ASRUtils::expr_type(a_unit);
                 if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_newunit_type))) {
-                        diag.add(Diagnostic(
-                            "`unit` must be of type, Integer or IntegerPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                    diag.add(Diagnostic("`unit` must be of type, Integer or IntegerPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("iostat") ) {
-                if( a_iostat != nullptr ) {
+            } else if (m_arg_str == std::string("iostat")) {
+                if (a_iostat != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iostat` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iostat = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iostat_type = ASRUtils::expr_type(a_iostat);
-                if( a_iostat->type != ASR::exprType::Var ||
-                    (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_iostat_type))) ) {
-                        diag.add(Diagnostic(
-                            "`iostat` must be a variable of type, Integer or IntegerPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                if (a_iostat->type != ASR::exprType::Var
+                    || (!ASR::is_a<ASR::Integer_t>(
+                        *ASRUtils::type_get_past_pointer(a_iostat_type)))) {
+                    diag.add(
+                        Diagnostic("`iostat` must be a variable of type, Integer or IntegerPointer",
+                                   Level::Error,
+                                   Stage::Semantic,
+                                   { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("iomsg") ) {
-                if( a_iomsg != nullptr ) {
+            } else if (m_arg_str == std::string("iomsg")) {
+                if (a_iomsg != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iomsg` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iomsg = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iomsg_type = ASRUtils::expr_type(a_iomsg);
-                if( a_iomsg->type != ASR::exprType::Var ||
-                    (!ASRUtils::is_character(*a_iomsg_type)) ) {
-                        diag.add(Diagnostic(
-                            "`iomsg` must be of type, String or StringPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
-                    }
-            } else if( m_arg_str == std::string("status") ) {
-                if( a_status != nullptr ) {
+                if (a_iomsg->type != ASR::exprType::Var
+                    || (!ASRUtils::is_character(*a_iomsg_type))) {
+                    diag.add(Diagnostic("`iomsg` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
+                }
+            } else if (m_arg_str == std::string("status")) {
+                if (a_status != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `status` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_status = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_status_type = ASRUtils::expr_type(a_status);
                 if (!ASRUtils::is_character(*a_status_type)) {
-                    diag.add(Diagnostic(
-                        "`status` must be of type, String or StringPointer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("`status` must be of type, String or StringPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("err") ) {
-                if( a_err != nullptr ) {
+            } else if (m_arg_str == std::string("err")) {
+                if (a_err != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `err` found, `err` has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                if( kwarg.m_value->type != AST::exprType::Num ) {
-                    diag.add(Diagnostic(
-                        "`err` must be a literal integer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                if (kwarg.m_value->type != AST::exprType::Num) {
+                    diag.add(Diagnostic("`err` must be a literal integer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_err = ASRUtils::EXPR(tmp);
             } else {
                 diag.add(diag::Diagnostic("Invalid argument `" + m_arg_str + "` supplied",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
-        if( a_unit == nullptr ) {
+        if (a_unit == nullptr) {
             diag.add(Diagnostic(
                 "`newunit` or `unit` must be specified either in argument or keyword arguments.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        tmp = ASR::make_FileClose_t(al, x.base.base.loc, x.m_label, a_unit, a_iostat, a_iomsg, a_err, a_status);
+        tmp = ASR::make_FileClose_t(
+            al, x.base.base.loc, x.m_label, a_unit, a_iostat, a_iomsg, a_err, a_status);
     }
 
-    void visit_Backspace(const AST::Backspace_t& x) {
+    void visit_Backspace(const AST::Backspace_t& x)
+    {
         ASR::expr_t *a_unit = nullptr, *a_iostat = nullptr;
-        ASR::expr_t *a_err = nullptr;
-        if( x.n_args > 1 ) {
-            diag.add(Diagnostic(
-                "Number of arguments cannot be more than 1 in Backspace statement.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        ASR::expr_t* a_err = nullptr;
+        if (x.n_args > 1) {
+            diag.add(Diagnostic("Number of arguments cannot be more than 1 in Backspace statement.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        if( x.n_args == 1 ) {
+        if (x.n_args == 1) {
             this->visit_expr(*x.m_args[0]);
             a_unit = ASRUtils::EXPR(tmp);
         }
-        for( std::uint32_t i = 0; i < x.n_kwargs; i++ ) {
+        for (std::uint32_t i = 0; i < x.n_kwargs; i++) {
             AST::keyword_t kwarg = x.m_kwargs[i];
             std::string m_arg_str(kwarg.m_arg);
             m_arg_str = to_lower(m_arg_str);
-            if( m_arg_str == std::string("unit") ) {
-                if( a_unit != nullptr ) {
+            if (m_arg_str == std::string("unit")) {
+                if (a_unit != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `unit` found, `unit` "
                         " has already been specified via argument or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_unit = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_newunit_type = ASRUtils::expr_type(a_unit);
                 if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_newunit_type))) {
-                        diag.add(Diagnostic(
-                            "`unit` must be of type, Integer or IntegerPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                    diag.add(Diagnostic("`unit` must be of type, Integer or IntegerPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("iostat") ) {
-                if( a_iostat != nullptr ) {
+            } else if (m_arg_str == std::string("iostat")) {
+                if (a_iostat != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iostat` found, unit has "
                         " already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iostat = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iostat_type = ASRUtils::expr_type(a_iostat);
-                if( a_iostat->type != ASR::exprType::Var ||
-                    (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_iostat_type))) ) {
-                        diag.add(Diagnostic(
-                            "`iostat` must be a variable of type, Integer "
-                            " or IntegerPointer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
-                        throw SemanticAbort();
+                if (a_iostat->type != ASR::exprType::Var
+                    || (!ASR::is_a<ASR::Integer_t>(
+                        *ASRUtils::type_get_past_pointer(a_iostat_type)))) {
+                    diag.add(Diagnostic("`iostat` must be a variable of type, Integer "
+                                        " or IntegerPointer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("err") ) {
-                if( a_err != nullptr ) {
+            } else if (m_arg_str == std::string("err")) {
+                if (a_err != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `err` found, `err` has "
                         " already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                if( kwarg.m_value->type != AST::exprType::Num ) {
-                    diag.add(Diagnostic(
-                        "`err` must be a literal integer",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                if (kwarg.m_value->type != AST::exprType::Num) {
+                    diag.add(Diagnostic("`err` must be a literal integer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_err = ASRUtils::EXPR(tmp);
             } else {
                 diag.add(diag::Diagnostic("Invalid argument `" + m_arg_str + "` supplied",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
-        if( a_unit == nullptr ) {
-            diag.add(Diagnostic(
-                "`unit` must be specified either in argument or keyword arguments.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (a_unit == nullptr) {
+            diag.add(Diagnostic("`unit` must be specified either in argument or keyword arguments.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         tmp = ASR::make_FileBackspace_t(al, x.base.base.loc, x.m_label, a_unit, a_iostat, a_err);
     }
 
-    void create_read_write_ASR_node(const AST::stmt_t& read_write_stmt, AST::stmtType _type) {
+    void create_read_write_ASR_node(const AST::stmt_t& read_write_stmt, AST::stmtType _type)
+    {
         int64_t m_label = -1;
-        AST::argstar_t* m_args = nullptr; size_t n_args = 0;
-        AST::kw_argstar_t* m_kwargs = nullptr; size_t n_kwargs = 0;
-        AST::expr_t** m_values = nullptr; size_t n_values = 0;
+        AST::argstar_t* m_args = nullptr;
+        size_t n_args = 0;
+        AST::kw_argstar_t* m_kwargs = nullptr;
+        size_t n_kwargs = 0;
+        AST::expr_t** m_values = nullptr;
+        size_t n_values = 0;
         const Location& loc = read_write_stmt.base.loc;
         AST::Write_t* w = nullptr;
         AST::Read_t* r = nullptr;
-        if( _type == AST::stmtType::Write ) {
-            w = (AST::Write_t*)(&read_write_stmt);
+        if (_type == AST::stmtType::Write) {
+            w = (AST::Write_t*) (&read_write_stmt);
             m_label = w->m_label;
-            m_args = w->m_args; n_args = w->n_args;
-            m_kwargs = w->m_kwargs; n_kwargs = w->n_kwargs;
-            m_values = w->m_values; n_values = w->n_values;
-        } else if( _type == AST::stmtType::Read ) {
-            r = (AST::Read_t*)(&read_write_stmt);
+            m_args = w->m_args;
+            n_args = w->n_args;
+            m_kwargs = w->m_kwargs;
+            n_kwargs = w->n_kwargs;
+            m_values = w->m_values;
+            n_values = w->n_values;
+        } else if (_type == AST::stmtType::Read) {
+            r = (AST::Read_t*) (&read_write_stmt);
             m_label = r->m_label;
-            m_args = r->m_args; n_args = r->n_args;
-            m_kwargs = r->m_kwargs; n_kwargs = r->n_kwargs;
-            m_values = r->m_values; n_values = r->n_values;
-        }
-
-        ASR::expr_t *a_unit, *a_fmt, *a_iomsg, *a_iostat, *a_size, *a_id, *a_separator, *a_end, *a_fmt_constant, *a_advance;
-        a_unit = a_fmt = a_iomsg = a_iostat = a_size = a_id = a_separator = a_end = a_fmt_constant = a_advance = nullptr;
-        ASR::stmt_t *overloaded_stmt = nullptr;
+            m_args = r->m_args;
+            n_args = r->n_args;
+            m_kwargs = r->m_kwargs;
+            n_kwargs = r->n_kwargs;
+            m_values = r->m_values;
+            n_values = r->n_values;
+        }
+
+        ASR::expr_t *a_unit, *a_fmt, *a_iomsg, *a_iostat, *a_size, *a_id, *a_separator, *a_end,
+            *a_fmt_constant, *a_advance;
+        a_unit = a_fmt = a_iomsg = a_iostat = a_size = a_id = a_separator = a_end = a_fmt_constant
+            = a_advance = nullptr;
+        ASR::stmt_t* overloaded_stmt = nullptr;
         std::string read_write = "";
         bool formatted = (n_args == 2);
         Vec<ASR::expr_t*> a_values_vec;
@@ -839,293 +941,309 @@ public:
             }
         }
 
-        if( n_args > 2 ) {
-            diag.add(Diagnostic(
-                "Number of arguments cannot be more than 2 in Read/Write statement.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+        if (n_args > 2) {
+            diag.add(
+                Diagnostic("Number of arguments cannot be more than 2 in Read/Write statement.",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { loc }) }));
             throw SemanticAbort();
         }
-        std::vector<ASR::expr_t**> args = {&a_unit, &a_fmt};
-        for( std::uint32_t i = 0; i < n_args; i++ ) {
-            if( m_args[i].m_value != nullptr ) {
+        std::vector<ASR::expr_t**> args = { &a_unit, &a_fmt };
+        for (std::uint32_t i = 0; i < n_args; i++) {
+            if (m_args[i].m_value != nullptr) {
                 this->visit_expr(*m_args[i].m_value);
                 *args[i] = ASRUtils::EXPR(tmp);
             }
         }
-        //check positional fmt argument (second arg)
+        // check positional fmt argument (second arg)
         if (a_fmt != nullptr) {
             ASR::ttype_t* fmt_type = ASRUtils::expr_type(a_fmt);
-            if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(fmt_type)) && ASR::is_a<ASR::Var_t>(*a_fmt)) {
+            if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(fmt_type))
+                && ASR::is_a<ASR::Var_t>(*a_fmt)) {
                 diag.add(Diagnostic(
                     "Assigned format (using integer variable as format specifier) is not supported. "
                     "Use character variables instead.",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         }
         std::vector<ASR::asr_t*> newline_for_advance;
-        for( std::uint32_t i = 0; i < n_kwargs; i++ ) {
+        for (std::uint32_t i = 0; i < n_kwargs; i++) {
             AST::kw_argstar_t kwarg = m_kwargs[i];
             std::string m_arg_str(kwarg.m_arg);
             m_arg_str = to_lower(m_arg_str);
-            if( m_arg_str == std::string("unit") ) {
-                if( a_unit != nullptr ) {
+            if (m_arg_str == std::string("unit")) {
+                if (a_unit != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `unit` found, `unit` has already been specified via argument or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (kwarg.m_value != nullptr) {
                     this->visit_expr(*kwarg.m_value);
                     a_unit = ASRUtils::EXPR(tmp);
                     ASR::ttype_t* a_unit_type = ASRUtils::expr_type(a_unit);
-                    if  (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_unit_type))) {
-                            diag.add(Diagnostic(
-                                "`unit` must be of type, Integer",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{loc})
-                                }));
-                            throw SemanticAbort();
+                    if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_unit_type))) {
+                        diag.add(Diagnostic("`unit` must be of type, Integer",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
+                        throw SemanticAbort();
                     }
                 }
-            } else if( m_arg_str == std::string("iostat") ) {
-                if( a_iostat != nullptr ) {
+            } else if (m_arg_str == std::string("iostat")) {
+                if (a_iostat != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iostat` found, unit has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iostat = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iostat_type = ASRUtils::expr_type(a_iostat);
                 if (!ASRUtils::is_variable(a_iostat)) {
-                    diag.add(Diagnostic(
-                        "Non-variable expression for `iostat`",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                    diag.add(Diagnostic("Non-variable expression for `iostat`",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (ASRUtils::is_array(a_iostat_type)) {
-                    diag.add(Diagnostic(
-                        "`iostat` must be scalar",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                    diag.add(Diagnostic("`iostat` must be scalar",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_iostat_type))) {
-                        diag.add(Diagnostic(
-                            "`iostat` must be of type, Integer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{loc})
-                            }));
-                        throw SemanticAbort();
+                    diag.add(Diagnostic("`iostat` must be of type, Integer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("iomsg") ) {
-                if( a_iomsg != nullptr ) {
+            } else if (m_arg_str == std::string("iomsg")) {
+                if (a_iomsg != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `iomsg` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_iomsg = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_iomsg_type = ASRUtils::expr_type(a_iomsg);
                 if (!ASRUtils::is_variable(a_iomsg)) {
-                    diag.add(Diagnostic(
-                        "Non-variable expression for `iomsg`",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                    diag.add(Diagnostic("Non-variable expression for `iomsg`",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (ASRUtils::is_array(a_iomsg_type)) {
-                    diag.add(Diagnostic(
-                        "`iomsg` must be scalar",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                    diag.add(Diagnostic("`iomsg` must be scalar",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (!ASR::is_a<ASR::String_t>(*ASRUtils::type_get_past_pointer(a_iomsg_type))) {
-                    diag.add(Diagnostic(
-                        "`iomsg` must be of type, String",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                    diag.add(Diagnostic("`iomsg` must be of type, String",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("size") ) {
-                if( a_size != nullptr ) {
+            } else if (m_arg_str == std::string("size")) {
+                if (a_size != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `size` found, `size` has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_size = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_size_type = ASRUtils::expr_type(a_size);
-                if( a_size->type != ASR::exprType::Var ||
-                    (!ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(a_size_type))) ) {
-                        diag.add(Diagnostic(
-                            "`size` must be of type, Integer",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{loc})
-                            }));
-                        throw SemanticAbort();
+                if (a_size->type != ASR::exprType::Var
+                    || (!ASR::is_a<ASR::Integer_t>(
+                        *ASRUtils::type_get_past_pointer(a_size_type)))) {
+                    diag.add(Diagnostic("`size` must be of type, Integer",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("id") ) {
-                if( a_id != nullptr ) {
+            } else if (m_arg_str == std::string("id")) {
+                if (a_id != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `id` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 a_id = ASRUtils::EXPR(tmp);
                 ASR::ttype_t* a_status_type = ASRUtils::expr_type(a_id);
                 if (!ASR::is_a<ASR::String_t>(*ASRUtils::type_get_past_pointer(a_status_type))) {
-                        diag.add(Diagnostic(
-                            "`status` must be of type String",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{loc})
-                            }));
-                        throw SemanticAbort();
+                    diag.add(Diagnostic("`status` must be of type String",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
+                    throw SemanticAbort();
                 }
-            } else if( m_arg_str == std::string("fmt")  ) {
-                if( a_fmt != nullptr ) {
+            } else if (m_arg_str == std::string("fmt")) {
+                if (a_fmt != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `fmt` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (kwarg.m_value != nullptr) {
                     tmp = nullptr;
                     this->visit_expr(*kwarg.m_value);
                     if (tmp == nullptr) {
-                        diag.add(Diagnostic(
-                            "?",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{loc})
-                            }));
+                        diag.add(
+                            Diagnostic("?", Level::Error, Stage::Semantic, { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                    a_fmt = ASRUtils::EXPR(tmp); 
+                    a_fmt = ASRUtils::EXPR(tmp);
                     // check that fmt is not integer
                     ASR::ttype_t* fmt_type = ASRUtils::expr_type(a_fmt);
-                    if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(fmt_type)) && ASR::is_a<ASR::Var_t>(*a_fmt)) {
+                    if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(fmt_type))
+                        && ASR::is_a<ASR::Var_t>(*a_fmt)) {
                         diag.add(Diagnostic(
                             "Assigned format (using integer variable as format specifier) is not supported. "
                             "Use character variables instead.",
-                            Level::Error, Stage::Semantic, {
-                                Label("", {loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
-            } else if( m_arg_str == std::string("advance") ) {
-                if( a_end != nullptr ) {
+            } else if (m_arg_str == std::string("advance")) {
+                if (a_end != nullptr) {
                     diag.add(Diagnostic(
                         R"""(Duplicate value of `advance` found, it has already been specified via arguments or keyword arguments)""",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 this->visit_expr(*kwarg.m_value);
                 ASR::expr_t* adv_val_expr = ASRUtils::EXPR(tmp);
                 a_advance = adv_val_expr;
-                ASR::ttype_t *str_type_len_0 = ASRUtils::TYPE(ASR::make_String_t(
-                    al, loc, 1,
-                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 0,
-                        ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                ASR::ttype_t* str_type_len_0 = ASRUtils::TYPE(ASR::make_String_t(
+                    al,
+                    loc,
+                    1,
+                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                        al, loc, 0, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
                     ASR::string_length_kindType::ExpressionLength,
                     ASR::string_physical_typeType::DescriptorString));
-                ASR::expr_t *empty = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                    al, loc, s2c(al, ""), str_type_len_0));
-                ASR::ttype_t *str_type_len_1 = ASRUtils::TYPE(ASR::make_String_t(
-                    al, loc, 1,
-                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1,
-                        ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
-                    ASR::string_length_kindType::ExpressionLength, 
+                ASR::expr_t* empty = ASRUtils::EXPR(
+                    ASR::make_StringConstant_t(al, loc, s2c(al, ""), str_type_len_0));
+                ASR::ttype_t* str_type_len_1 = ASRUtils::TYPE(ASR::make_String_t(
+                    al,
+                    loc,
+                    1,
+                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                        al, loc, 1, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                    ASR::string_length_kindType::ExpressionLength,
                     ASR::string_physical_typeType::DescriptorString));
-                ASR::expr_t *newline = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                    al, loc, s2c(al, "\n"), str_type_len_1));
+                ASR::expr_t* newline = ASRUtils::EXPR(
+                    ASR::make_StringConstant_t(al, loc, s2c(al, "\n"), str_type_len_1));
                 if (ASR::is_a<ASR::StringConstant_t>(*adv_val_expr)) {
-                    std::string adv_val = to_lower(ASR::down_cast<ASR::StringConstant_t>(adv_val_expr)->m_s);
+                    std::string adv_val
+                        = to_lower(ASR::down_cast<ASR::StringConstant_t>(adv_val_expr)->m_s);
                     if (adv_val == "yes") {
                         a_end = newline;
                     } else if (adv_val == "no") {
                         a_end = empty;
                     } else {
-                        diag.add(Diagnostic(
-                            "ADVANCE= specifier must have value = YES or NO",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{kwarg.loc})
-                            }));
+                        diag.add(Diagnostic("ADVANCE= specifier must have value = YES or NO",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { kwarg.loc }) }));
                         throw SemanticAbort();
                     }
                 } else {
-                    Vec<ASR::expr_t*> trim_arg; trim_arg.reserve(al, 1);
+                    Vec<ASR::expr_t*> trim_arg;
+                    trim_arg.reserve(al, 1);
                     trim_arg.push_back(al, a_advance);
-                    a_advance = ASRUtils::EXPR(ASR::make_IntrinsicElementalFunction_t(al, a_advance->base.loc,
+                    a_advance = ASRUtils::EXPR(ASR::make_IntrinsicElementalFunction_t(
+                        al,
+                        a_advance->base.loc,
                         static_cast<int64_t>(ASRUtils::IntrinsicElementalFunctions::StringTrim),
-                        trim_arg.p, trim_arg.n, 0, ASRUtils::expr_type(a_advance), nullptr));
-                    ASR::ttype_t *str_type_len_3 = ASRUtils::TYPE(ASR::make_String_t(
-                        al, loc, 1,
-                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 3,
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                        trim_arg.p,
+                        trim_arg.n,
+                        0,
+                        ASRUtils::expr_type(a_advance),
+                        nullptr));
+                    ASR::ttype_t* str_type_len_3 = ASRUtils::TYPE(ASR::make_String_t(
+                        al,
+                        loc,
+                        1,
+                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al, loc, 3, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
                         ASR::string_length_kindType::ExpressionLength,
                         ASR::string_physical_typeType::DescriptorString));
-                    ASR::expr_t *yes = ASRUtils::EXPR(ASR::make_StringConstant_t(
-                        al, loc, s2c(al, "yes"), str_type_len_3));
+                    ASR::expr_t* yes = ASRUtils::EXPR(
+                        ASR::make_StringConstant_t(al, loc, s2c(al, "yes"), str_type_len_3));
                     // TODO: Support case insensitive compare
-                    ASR::ttype_t *cmp_type = ASRUtils::TYPE(ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
-                    ASR::expr_t *test = ASRUtils::EXPR(ASR::make_StringCompare_t(al,
-                        loc, adv_val_expr, ASR::cmpopType::Eq, yes, cmp_type, nullptr));
+                    ASR::ttype_t* cmp_type = ASRUtils::TYPE(
+                        ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
+                    ASR::expr_t* test = ASRUtils::EXPR(ASR::make_StringCompare_t(
+                        al, loc, adv_val_expr, ASR::cmpopType::Eq, yes, cmp_type, nullptr));
                     Vec<ASR::stmt_t*> body;
                     body.reserve(al, 1);
-                    body.push_back(al, ASRUtils::STMT(
-                        ASR::make_FileWrite_t(al, loc, 0, a_unit,
-                        nullptr, nullptr, nullptr,
-                        nullptr, 0, nullptr, newline, nullptr, formatted)));
+                    body.push_back(al,
+                                   ASRUtils::STMT(ASR::make_FileWrite_t(al,
+                                                                        loc,
+                                                                        0,
+                                                                        a_unit,
+                                                                        nullptr,
+                                                                        nullptr,
+                                                                        nullptr,
+                                                                        nullptr,
+                                                                        0,
+                                                                        nullptr,
+                                                                        newline,
+                                                                        nullptr,
+                                                                        formatted)));
                     // TODO: Compare with "no" (case-insensitive) in else part
                     // Throw runtime error if advance expression does not match "no"
-                    newline_for_advance.push_back(ASR::make_If_t(al, loc, nullptr, test, body.p,
-                            body.size(), nullptr, 0));
+                    newline_for_advance.push_back(
+                        ASR::make_If_t(al, loc, nullptr, test, body.p, body.size(), nullptr, 0));
                     a_end = empty;
                 }
             }
         }
-        if( a_fmt == nullptr && a_end != nullptr ) {
+        if (a_fmt == nullptr && a_end != nullptr) {
             diag.add(Diagnostic(
                 R"""(List directed format(*) is not allowed with a ADVANCE= specifier)""",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         if (_type == AST::stmtType::Write && a_fmt == nullptr
-                && compiler_options.print_leading_space && formatted) {
+            && compiler_options.print_leading_space && formatted) {
             ASR::asr_t* file_write_asr_t = construct_leading_space(loc);
-            ASR::FileWrite_t* file_write = ASR::down_cast<ASR::FileWrite_t>(ASRUtils::STMT(file_write_asr_t));
+            ASR::FileWrite_t* file_write
+                = ASR::down_cast<ASR::FileWrite_t>(ASRUtils::STMT(file_write_asr_t));
             file_write->m_id = a_id;
             file_write->m_iomsg = a_iomsg;
             file_write->m_iostat = a_iostat;
@@ -1135,7 +1253,7 @@ public:
         } else if (_type == AST::stmtType::Write) {
             a_fmt_constant = a_fmt;
         }
-        for( std::uint32_t i = 0; i < n_values; i++ ) {
+        for (std::uint32_t i = 0; i < n_values; i++) {
             this->visit_expr(*m_values[i]);
             ASR::expr_t* expr = ASRUtils::EXPR(tmp);
             a_values_vec.push_back(al, expr);
@@ -1149,16 +1267,17 @@ public:
             overload_args.push_back(al, a_values_vec[0]);
             overload_args.push_back(al, a_unit);
             if (formatted) {
-                if (a_fmt) { // iotype
+                if (a_fmt) {  // iotype
                     overload_args.push_back(al, a_fmt);
                 } else {
-                    ASR::ttype_t* char_type = ASRUtils::TYPE(
-                        ASR::make_String_t(
-                            al, loc, 1,
-                            ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 12,
-                                ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
-                            ASR::string_length_kindType::ExpressionLength,
-                            ASR::string_physical_typeType::DescriptorString));
+                    ASR::ttype_t* char_type = ASRUtils::TYPE(ASR::make_String_t(
+                        al,
+                        loc,
+                        1,
+                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al, loc, 12, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                        ASR::string_length_kindType::ExpressionLength,
+                        ASR::string_physical_typeType::DescriptorString));
                     ASR::expr_t* list_directed = ASRUtils::EXPR(
                         ASR::make_StringConstant_t(al, loc, s2c(al, "LISTDIRECTED"), char_type));
                     overload_args.push_back(al, list_directed);
@@ -1173,25 +1292,40 @@ public:
                 dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1, int_type));
                 dim.m_length = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 0, int_type));
                 dims.push_back(al, dim);
-                ASR::ttype_t* arr_type = ASRUtils::TYPE(ASR::make_Array_t(al, loc, int_type, dims.p, dims.n,
-                    ASR::array_physical_typeType::FixedSizeArray));
+                ASR::ttype_t* arr_type = ASRUtils::TYPE(
+                    ASR::make_Array_t(al,
+                                      loc,
+                                      int_type,
+                                      dims.p,
+                                      dims.n,
+                                      ASR::array_physical_typeType::FixedSizeArray));
                 Vec<ASR::expr_t*> arr_args;
                 arr_args.reserve(al, 0);
-                overload_args.push_back(al, ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(
-                        al, loc, arr_args.p, arr_args.n, arr_type, ASR::arraystorageType::ColMajor)));
+                overload_args.push_back(al,
+                                        ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(
+                                            al,
+                                            loc,
+                                            arr_args.p,
+                                            arr_args.n,
+                                            arr_type,
+                                            ASR::arraystorageType::ColMajor)));
             }
             overload_args.push_back(al, a_iostat);
             overload_args.push_back(al, a_iomsg);
-            if (ASRUtils::use_overloaded_file_read_write(read_write, overload_args,
-                current_scope, asr, al, read_write_stmt.base.loc, current_function_dependencies,
-                current_module_dependencies,
-                [&](const std::string &msg, const Location &loc) {
-                    diag.add(Diagnostic(
-                        msg,
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
-                    throw SemanticAbort(); }) ) {
+            if (ASRUtils::use_overloaded_file_read_write(
+                    read_write,
+                    overload_args,
+                    current_scope,
+                    asr,
+                    al,
+                    read_write_stmt.base.loc,
+                    current_function_dependencies,
+                    current_module_dependencies,
+                    [&](const std::string& msg, const Location& loc) {
+                        diag.add(
+                            Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                        throw SemanticAbort();
+                    })) {
                 overloaded_stmt = ASRUtils::STMT(asr);
             }
         }
@@ -1200,55 +1334,123 @@ public:
             ASR::IntegerConstant_t* a_fmt_int = ASR::down_cast<ASR::IntegerConstant_t>(a_fmt);
             int64_t label = a_fmt_int->m_n;
             if (format_statements.find(label) == format_statements.end()) {
-                if( _type == AST::stmtType::Write ) {
-                    tmp = ASR::make_FileWrite_t(al, loc, m_label, a_unit,
-                        a_iomsg, a_iostat, a_id, a_values_vec.p,
-                        a_values_vec.size(), a_separator, a_end, nullptr, true);
-                    print_statements[tmp] = std::make_pair(&w->base,label);
-                } else if( _type == AST::stmtType::Read ) {
-                    tmp = ASR::make_FileRead_t(al, loc, m_label, a_unit, a_fmt, a_iomsg, a_iostat,
-                        a_advance, a_size, a_id, a_values_vec.p, a_values_vec.size(), nullptr, formatted);
-                    print_statements[tmp] = std::make_pair(&r->base,label);
+                if (_type == AST::stmtType::Write) {
+                    tmp = ASR::make_FileWrite_t(al,
+                                                loc,
+                                                m_label,
+                                                a_unit,
+                                                a_iomsg,
+                                                a_iostat,
+                                                a_id,
+                                                a_values_vec.p,
+                                                a_values_vec.size(),
+                                                a_separator,
+                                                a_end,
+                                                nullptr,
+                                                true);
+                    print_statements[tmp] = std::make_pair(&w->base, label);
+                } else if (_type == AST::stmtType::Read) {
+                    tmp = ASR::make_FileRead_t(al,
+                                               loc,
+                                               m_label,
+                                               a_unit,
+                                               a_fmt,
+                                               a_iomsg,
+                                               a_iostat,
+                                               a_advance,
+                                               a_size,
+                                               a_id,
+                                               a_values_vec.p,
+                                               a_values_vec.size(),
+                                               nullptr,
+                                               formatted);
+                    print_statements[tmp] = std::make_pair(&r->base, label);
                 }
                 return;
             }
             ASR::ttype_t* a_fmt_type = ASRUtils::TYPE(ASR::make_String_t(
-                al, a_fmt->base.loc, 1,
+                al,
+                a_fmt->base.loc,
+                1,
                 ASRUtils::EXPR(ASR::make_IntegerConstant_t(
-                    al, a_fmt->base.loc, format_statements[label].size(),
+                    al,
+                    a_fmt->base.loc,
+                    format_statements[label].size(),
                     ASRUtils::TYPE(ASR::make_Integer_t(al, a_fmt->base.loc, 4)))),
-                    ASR::string_length_kindType::ExpressionLength,
+                ASR::string_length_kindType::ExpressionLength,
                 ASR::string_physical_typeType::DescriptorString));
             a_fmt_constant = ASRUtils::EXPR(ASR::make_StringConstant_t(
                 al, a_fmt->base.loc, s2c(al, format_statements[label]), a_fmt_type));
         }
         // Don't use stringFormat with single character argument
-        if (!a_fmt
-            && _type == AST::stmtType::Write
-            && a_values_vec.size() == 1
-            && ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(a_values_vec[0]))){
-            tmp = ASR::make_FileWrite_t(al, loc, m_label, a_unit,
-            a_iomsg, a_iostat, a_id, a_values_vec.p,
-            a_values_vec.size(), a_separator, a_end, overloaded_stmt, formatted);
-        } else if ( _type == AST::stmtType::Write ) { // If not the previous case, Wrap everything in stringFormat.
+        if (!a_fmt && _type == AST::stmtType::Write && a_values_vec.size() == 1
+            && ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(a_values_vec[0]))) {
+            tmp = ASR::make_FileWrite_t(al,
+                                        loc,
+                                        m_label,
+                                        a_unit,
+                                        a_iomsg,
+                                        a_iostat,
+                                        a_id,
+                                        a_values_vec.p,
+                                        a_values_vec.size(),
+                                        a_separator,
+                                        a_end,
+                                        overloaded_stmt,
+                                        formatted);
+        } else if (_type == AST::stmtType::Write) {  // If not the previous case, Wrap everything in
+                                                     // stringFormat.
             if (formatted) {
-                ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Allocatable_t(al, loc,
-                    ASRUtils::TYPE(ASR::make_String_t(
-                        al, loc, 1, nullptr,
-                        ASR::string_length_kindType::DeferredLength,
-                        ASR::string_physical_typeType::DescriptorString))));
-                ASR::expr_t* string_format = ASRUtils::EXPR(ASRUtils::make_StringFormat_t_util(al, a_fmt? a_fmt->base.loc : read_write_stmt.base.loc,
-                    a_fmt_constant, a_values_vec.p, a_values_vec.size(), ASR::string_format_kindType::FormatFortran,
-                    type, nullptr));
+                ASR::ttype_t* type = ASRUtils::TYPE(
+                    ASR::make_Allocatable_t(al,
+                                            loc,
+                                            ASRUtils::TYPE(ASR::make_String_t(
+                                                al,
+                                                loc,
+                                                1,
+                                                nullptr,
+                                                ASR::string_length_kindType::DeferredLength,
+                                                ASR::string_physical_typeType::DescriptorString))));
+                ASR::expr_t* string_format = ASRUtils::EXPR(ASRUtils::make_StringFormat_t_util(
+                    al,
+                    a_fmt ? a_fmt->base.loc : read_write_stmt.base.loc,
+                    a_fmt_constant,
+                    a_values_vec.p,
+                    a_values_vec.size(),
+                    ASR::string_format_kindType::FormatFortran,
+                    type,
+                    nullptr));
                 a_values_vec.reserve(al, 1);
                 a_values_vec.push_back(al, string_format);
             }
-            tmp = ASR::make_FileWrite_t(al, loc, m_label, a_unit,
-                a_iomsg, a_iostat, a_id, a_values_vec.p,
-                a_values_vec.size(), a_separator, a_end, overloaded_stmt, formatted);
-        } else if( _type == AST::stmtType::Read ) {
-            tmp = ASR::make_FileRead_t(al, loc, m_label, a_unit, a_fmt, a_iomsg,
-               a_iostat, a_advance, a_size, a_id, a_values_vec.p, a_values_vec.size(), overloaded_stmt, formatted);
+            tmp = ASR::make_FileWrite_t(al,
+                                        loc,
+                                        m_label,
+                                        a_unit,
+                                        a_iomsg,
+                                        a_iostat,
+                                        a_id,
+                                        a_values_vec.p,
+                                        a_values_vec.size(),
+                                        a_separator,
+                                        a_end,
+                                        overloaded_stmt,
+                                        formatted);
+        } else if (_type == AST::stmtType::Read) {
+            tmp = ASR::make_FileRead_t(al,
+                                       loc,
+                                       m_label,
+                                       a_unit,
+                                       a_fmt,
+                                       a_iomsg,
+                                       a_iostat,
+                                       a_advance,
+                                       a_size,
+                                       a_id,
+                                       a_values_vec.p,
+                                       a_values_vec.size(),
+                                       overloaded_stmt,
+                                       formatted);
         }
 
         tmp_vec.push_back(tmp);
@@ -1256,50 +1458,57 @@ public:
         tmp = nullptr;
     }
 
-    void visit_Write(const AST::Write_t& x) {
+    void visit_Write(const AST::Write_t& x)
+    {
         create_read_write_ASR_node(x.base, x.class_type);
     }
 
-    void visit_Read(const AST::Read_t& x) {
+    void visit_Read(const AST::Read_t& x)
+    {
         create_read_write_ASR_node(x.base, x.class_type);
     }
 
     template <typename T>
-    void fill_args_for_rewind_inquire_flush(const T& x, const size_t max_args,
-        std::vector<ASR::expr_t*>& args, const size_t args_size,
-        std::map<std::string, size_t>& argname2idx, std::string& stmt_name) {
-        if( x.n_args + x.n_kwargs > max_args ) {
-            diag.add(Diagnostic(
-                "Incorrect number of arguments passed to " + stmt_name + "."
-                " It accepts a total of 3 arguments namely unit, iostat and err.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+    void fill_args_for_rewind_inquire_flush(const T& x,
+                                            const size_t max_args,
+                                            std::vector<ASR::expr_t*>& args,
+                                            const size_t args_size,
+                                            std::map<std::string, size_t>& argname2idx,
+                                            std::string& stmt_name)
+    {
+        if (x.n_args + x.n_kwargs > max_args) {
+            diag.add(
+                Diagnostic("Incorrect number of arguments passed to " + stmt_name
+                               + "."
+                                 " It accepts a total of 3 arguments namely unit, iostat and err.",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
-        for( size_t i = 0; i < args_size; i++ ) {
+        for (size_t i = 0; i < args_size; i++) {
             args.push_back(nullptr);
         }
-        for( size_t i = 0; i < x.n_args; i++ ) {
+        for (size_t i = 0; i < x.n_args; i++) {
             visit_expr(*x.m_args[i]);
             args[i] = ASRUtils::EXPR(tmp);
         }
 
-        for( size_t i = 0; i < x.n_kwargs; i++ ) {
-            if( x.m_kwargs[i].m_value ) {
+        for (size_t i = 0; i < x.n_kwargs; i++) {
+            if (x.m_kwargs[i].m_value) {
                 std::string m_arg_str = to_lower(std::string(x.m_kwargs[i].m_arg));
                 if (argname2idx.find(m_arg_str) == argname2idx.end()) {
                     diag.add(diag::Diagnostic("Invalid argument `" + m_arg_str + "` supplied",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+                                              diag::Level::Error,
+                                              diag::Stage::Semantic,
+                                              { diag::Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 } else if (args[argname2idx[m_arg_str]]) {
-                    diag.add(Diagnostic(
-                        m_arg_str + " has already been specified.",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic(m_arg_str + " has already been specified.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 visit_expr(*x.m_kwargs[i].m_value);
@@ -1308,8 +1517,10 @@ public:
         }
     }
 
-    void visit_Rewind(const AST::Rewind_t& x) {
-        std::map<std::string, size_t> argname2idx = {{"unit", 0}, {"iostat", 1}, {"err", 2 }};
+    void visit_Rewind(const AST::Rewind_t& x)
+    {
+        std::map<std::string, size_t> argname2idx
+            = { { "unit", 0 }, { "iostat", 1 }, { "err", 2 } };
         std::vector<ASR::expr_t*> args;
         std::string node_name = "Rewind";
         fill_args_for_rewind_inquire_flush(x, 3, args, 3, argname2idx, node_name);
@@ -1317,97 +1528,157 @@ public:
         tmp = ASR::make_FileRewind_t(al, x.base.base.loc, x.m_label, unit, iostat, err);
     }
 
-    void visit_Instantiate(const AST::Instantiate_t &x) {
-        ASR::symbol_t *sym = current_scope->resolve_symbol(x.m_name);
-        ASR::Template_t* temp = ASR::down_cast<ASR::Template_t>(ASRUtils::symbol_get_past_external(sym));
+    void visit_Instantiate(const AST::Instantiate_t& x)
+    {
+        ASR::symbol_t* sym = current_scope->resolve_symbol(x.m_name);
+        ASR::Template_t* temp
+            = ASR::down_cast<ASR::Template_t>(ASRUtils::symbol_get_past_external(sym));
 
-        std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>> type_subs = instantiate_types[x.base.base.loc.first];
-        std::map<std::string, ASR::symbol_t*> symbol_subs = instantiate_symbols[x.base.base.loc.first];
+        std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>> type_subs
+            = instantiate_types[x.base.base.loc.first];
+        std::map<std::string, ASR::symbol_t*> symbol_subs
+            = instantiate_symbols[x.base.base.loc.first];
 
         if (x.n_symbols == 0) {
-            for (auto const &sym_pair: temp->m_symtab->get_scope()) {
-                ASR::symbol_t *s = sym_pair.second;
+            for (auto const& sym_pair : temp->m_symtab->get_scope()) {
+                ASR::symbol_t* s = sym_pair.second;
                 std::string s_name = ASRUtils::symbol_name(s);
                 if (ASR::is_a<ASR::Function_t>(*s) && !ASRUtils::is_template_arg(sym, s_name)) {
-                    instantiate_body(al, type_subs, symbol_subs, current_scope->resolve_symbol(s_name), s);
+                    instantiate_body(
+                        al, type_subs, symbol_subs, current_scope->resolve_symbol(s_name), s);
                 }
             }
         } else {
-            for (size_t i = 0; i < x.n_symbols; i++){
+            for (size_t i = 0; i < x.n_symbols; i++) {
                 AST::UseSymbol_t* use_symbol = AST::down_cast<AST::UseSymbol_t>(x.m_symbols[i]);
-                ASR::symbol_t *s = temp->m_symtab->get_symbol(to_lower(use_symbol->m_remote_sym));
+                ASR::symbol_t* s = temp->m_symtab->get_symbol(to_lower(use_symbol->m_remote_sym));
                 std::string new_s_name = use_symbol->m_remote_sym;
                 if (use_symbol->m_local_rename) {
                     new_s_name = to_lower(use_symbol->m_local_rename);
                 }
-                instantiate_body(al, type_subs, symbol_subs, current_scope->resolve_symbol(new_s_name), s);
+                instantiate_body(
+                    al, type_subs, symbol_subs, current_scope->resolve_symbol(new_s_name), s);
             }
         }
-
     }
 
-    void visit_Inquire(const AST::Inquire_t& x) {
-        std::map<std::string, size_t> argname2idx = {
-            {"unit", 0}, {"file", 1}, {"iostat", 2}, {"err", 3},
-            {"exist", 4}, {"opened", 5}, {"number", 6}, {"named", 7},
-            {"name", 8}, {"access", 9}, {"sequential", 10}, {"direct", 11},
-            {"form", 12}, {"formatted", 13}, {"unformatted", 14}, {"recl", 15},
-            {"nextrec", 16}, {"blank", 17}, {"position", 18}, {"action", 19},
-            {"read", 20}, {"write", 21}, {"readwrite", 22}, {"delim", 23},
-            {"pad", 24}, {"flen", 25}, {"blocksize", 26}, {"convert", 27},
-            {"carriagecontrol", 28}, {"size", 29}, {"pos", 30}, {"iolength", 31}};
+    void visit_Inquire(const AST::Inquire_t& x)
+    {
+        std::map<std::string, size_t> argname2idx = { { "unit", 0 },
+                                                      { "file", 1 },
+                                                      { "iostat", 2 },
+                                                      { "err", 3 },
+                                                      { "exist", 4 },
+                                                      { "opened", 5 },
+                                                      { "number", 6 },
+                                                      { "named", 7 },
+                                                      { "name", 8 },
+                                                      { "access", 9 },
+                                                      { "sequential", 10 },
+                                                      { "direct", 11 },
+                                                      { "form", 12 },
+                                                      { "formatted", 13 },
+                                                      { "unformatted", 14 },
+                                                      { "recl", 15 },
+                                                      { "nextrec", 16 },
+                                                      { "blank", 17 },
+                                                      { "position", 18 },
+                                                      { "action", 19 },
+                                                      { "read", 20 },
+                                                      { "write", 21 },
+                                                      { "readwrite", 22 },
+                                                      { "delim", 23 },
+                                                      { "pad", 24 },
+                                                      { "flen", 25 },
+                                                      { "blocksize", 26 },
+                                                      { "convert", 27 },
+                                                      { "carriagecontrol", 28 },
+                                                      { "size", 29 },
+                                                      { "pos", 30 },
+                                                      { "iolength", 31 } };
         std::vector<ASR::expr_t*> args;
         std::string node_name = "Inquire";
         fill_args_for_rewind_inquire_flush(x, 31, args, 32, argname2idx, node_name);
         ASR::expr_t *unit = args[0], *file = args[1], *iostat = args[2], *err = args[3];
         ASR::expr_t *exist = args[4], *opened = args[5], *number = args[6], *named = args[7];
         ASR::expr_t *name = args[8], *access = args[9], *sequential = args[10], *direct = args[11];
-        ASR::expr_t *form = args[12], *formatted = args[13], *unformatted = args[14], *recl = args[15];
-        ASR::expr_t *nextrec = args[16], *blank = args[17], *position = args[18], *action = args[19];
+        ASR::expr_t *form = args[12], *formatted = args[13], *unformatted = args[14],
+                    *recl = args[15];
+        ASR::expr_t *nextrec = args[16], *blank = args[17], *position = args[18],
+                    *action = args[19];
         ASR::expr_t *read = args[20], *write = args[21], *readwrite = args[22], *delim = args[23];
         ASR::expr_t *pad = args[24], *flen = args[25], *blocksize = args[26], *convert = args[27];
-        ASR::expr_t *carriagecontrol = args[28], *size = args[29], *pos = args[30], *iolength = args[31];
+        ASR::expr_t *carriagecontrol = args[28], *size = args[29], *pos = args[30],
+                    *iolength = args[31];
         bool is_iolength_present = iolength != nullptr;
-        for( size_t i = 0; i < args.size() - 1; i++ ) {
-            if( is_iolength_present && args[i] ) {
-                diag.add(Diagnostic(
-                    "No argument should be specified when iolength is already present.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+        for (size_t i = 0; i < args.size() - 1; i++) {
+            if (is_iolength_present && args[i]) {
+                diag.add(
+                    Diagnostic("No argument should be specified when iolength is already present.",
+                               Level::Error,
+                               Stage::Semantic,
+                               { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
 
-        tmp = ASR::make_FileInquire_t(al, x.base.base.loc, x.m_label,
-                                  unit, file, iostat, err,
-                                  exist, opened, number, named,
-                                  name, access, sequential, direct,
-                                  form, formatted, unformatted, recl,
-                                  nextrec, blank, position, action,
-                                  read, write, readwrite, delim,
-                                  pad, flen, blocksize, convert,
-                                  carriagecontrol, size, pos, iolength);
+        tmp = ASR::make_FileInquire_t(al,
+                                      x.base.base.loc,
+                                      x.m_label,
+                                      unit,
+                                      file,
+                                      iostat,
+                                      err,
+                                      exist,
+                                      opened,
+                                      number,
+                                      named,
+                                      name,
+                                      access,
+                                      sequential,
+                                      direct,
+                                      form,
+                                      formatted,
+                                      unformatted,
+                                      recl,
+                                      nextrec,
+                                      blank,
+                                      position,
+                                      action,
+                                      read,
+                                      write,
+                                      readwrite,
+                                      delim,
+                                      pad,
+                                      flen,
+                                      blocksize,
+                                      convert,
+                                      carriagecontrol,
+                                      size,
+                                      pos,
+                                      iolength);
     }
 
-    void visit_Flush(const AST::Flush_t& x) {
-        std::map<std::string, size_t> argname2idx = {{"unit", 0}, {"err", 1}, {"iomsg", 2}, {"iostat", 3}};
+    void visit_Flush(const AST::Flush_t& x)
+    {
+        std::map<std::string, size_t> argname2idx
+            = { { "unit", 0 }, { "err", 1 }, { "iomsg", 2 }, { "iostat", 3 } };
         std::vector<ASR::expr_t*> args;
         std::string node_name = "Flush";
         fill_args_for_rewind_inquire_flush(x, 4, args, 4, argname2idx, node_name);
-        if( !args[0] ) {
-            diag.add(Diagnostic(
-                "unit must be present in flush statement arguments",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (!args[0]) {
+            diag.add(Diagnostic("unit must be present in flush statement arguments",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         ASR::expr_t *unit = args[0], *err = args[1], *iomsg = args[2], *iostat = args[3];
         tmp = ASR::make_Flush_t(al, x.base.base.loc, x.m_label, unit, err, iomsg, iostat);
     }
 
-    void visit_Associate(const AST::Associate_t& x) {
+    void visit_Associate(const AST::Associate_t& x)
+    {
         this->visit_expr(*(x.m_target));
         ASR::expr_t* target = ASRUtils::EXPR(tmp);
         ASR::ttype_t* target_type = ASRUtils::expr_type(target);
@@ -1417,25 +1688,26 @@ public:
         ASR::expr_t* value = ASRUtils::EXPR(tmp);
         ASR::ttype_t* value_type = ASRUtils::expr_type(value);
         bool is_target_pointer = ASRUtils::is_pointer(target_type);
-        if ( !is_target_pointer && !ASR::is_a<ASR::FunctionType_t>(*target_type) ) {
-            diag.add(Diagnostic(
-                "Only a pointer variable can be associated with another variable.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (!is_target_pointer && !ASR::is_a<ASR::FunctionType_t>(*target_type)) {
+            diag.add(Diagnostic("Only a pointer variable can be associated with another variable.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(target_type))
             && ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(value_type))) {
-            ASR::Struct_t* target_struct = ASR::down_cast<ASR::Struct_t>(
-                ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(target)));
+            ASR::Struct_t* target_struct
+                = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
+                    ASRUtils::get_struct_sym_from_struct_expr(target)));
             // Set value of `value_struct` to `target_struct` to
             // handle the case of a pointer null constant assignment.
             ASR::Struct_t* value_struct = target_struct;
 
             if (!ASR::is_a<ASR::PointerNullConstant_t>(*value)) {
-                value_struct = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(value)));
+                value_struct = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
+                    ASRUtils::get_struct_sym_from_struct_expr(value)));
             }
 
             if (ASRUtils::is_derived_type_similar(target_struct, value_struct)) {
@@ -1446,38 +1718,42 @@ public:
         }
     }
 
-    void visit_AssociateBlock(const AST::AssociateBlock_t& x) {
+    void visit_AssociateBlock(const AST::AssociateBlock_t& x)
+    {
         SymbolTable* new_scope = al.make_new<SymbolTable>(current_scope);
         std::string name = current_scope->get_unique_name("associate_block");
-        ASR::asr_t* associate_block = ASR::make_AssociateBlock_t(al, x.base.base.loc,
-                                        new_scope, s2c(al, name), nullptr, 0);
+        ASR::asr_t* associate_block
+            = ASR::make_AssociateBlock_t(al, x.base.base.loc, new_scope, s2c(al, name), nullptr, 0);
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
-        for( size_t i = 0; i < x.n_syms; i++ ) {
+        for (size_t i = 0; i < x.n_syms; i++) {
             this->visit_expr(*x.m_syms[i].m_initializer);
             ASR::expr_t* tmp_expr = ASRUtils::EXPR(tmp);
             ASR::ttype_t* tmp_type = ASRUtils::expr_type(tmp_expr);
             ASR::storage_typeType tmp_storage = ASR::storage_typeType::Default;
             bool create_associate_stmt = false;
 
-            if( ASR::is_a<ASR::Var_t>(*tmp_expr) ) {
+            if (ASR::is_a<ASR::Var_t>(*tmp_expr)) {
                 create_associate_stmt = true;
                 ASR::Variable_t* variable = ASRUtils::EXPR2VAR(tmp_expr);
                 tmp_storage = variable->m_storage;
                 tmp_type = variable->m_type;
             } else if (ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr)) {
                 create_associate_stmt = true;
-                ASR::StructInstanceMember_t* sim = ASR::down_cast<ASR::StructInstanceMember_t>(tmp_expr);
+                ASR::StructInstanceMember_t* sim
+                    = ASR::down_cast<ASR::StructInstanceMember_t>(tmp_expr);
                 tmp_type = sim->m_type;
-            } else if( ASR::is_a<ASR::ArraySection_t>(*tmp_expr) ) {
+            } else if (ASR::is_a<ASR::ArraySection_t>(*tmp_expr)) {
                 create_associate_stmt = true;
-                ASR::ArraySection_t* tmp_array_section = ASR::down_cast<ASR::ArraySection_t>(tmp_expr);
+                ASR::ArraySection_t* tmp_array_section
+                    = ASR::down_cast<ASR::ArraySection_t>(tmp_expr);
                 ASR::Variable_t* variable = ASRUtils::EXPR2VAR(tmp_array_section->m_v);
                 tmp_storage = variable->m_storage;
-                ASR::dimension_t *var_dims;
+                ASR::dimension_t* var_dims;
                 ASRUtils::extract_dimensions_from_ttype(variable->m_type, var_dims);
-                Vec<ASR::dimension_t> tmp_dims; tmp_dims.reserve(al, 1);
-                for ( size_t i = 0; i < tmp_array_section->n_args; i++ ) {
+                Vec<ASR::dimension_t> tmp_dims;
+                tmp_dims.reserve(al, 1);
+                for (size_t i = 0; i < tmp_array_section->n_args; i++) {
                     if (tmp_array_section->m_args[i].m_left) {
                         tmp_dims.push_back(al, var_dims[i]);
                     }
@@ -1487,31 +1763,53 @@ public:
                 create_associate_stmt = true;
             }
 
-            if ( create_associate_stmt && !ASR::is_a<ASR::Pointer_t>(*tmp_type) ) {
+            if (create_associate_stmt && !ASR::is_a<ASR::Pointer_t>(*tmp_type)) {
                 tmp_type = ASRUtils::duplicate_type_with_empty_dims(al, tmp_type);
-                tmp_type = ASRUtils::TYPE(ASR::make_Pointer_t(al, tmp_type->base.loc,
-                    ASRUtils::type_get_past_allocatable(tmp_type)));
+                tmp_type = ASRUtils::TYPE(ASR::make_Pointer_t(
+                    al, tmp_type->base.loc, ASRUtils::type_get_past_allocatable(tmp_type)));
             }
 
             std::string name = to_lower(x.m_syms[i].m_name);
-            char *name_c = s2c(al, name);
+            char* name_c = s2c(al, name);
             SetChar variable_dependencies_vec;
             variable_dependencies_vec.reserve(al, 1);
-            ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, tmp_type, nullptr, nullptr, name);
-            ASR::symbol_t* struct_sym = ASRUtils::import_struct_sym_as_external(al, x.base.base.loc, tmp_expr, current_scope);
-            ASR::asr_t *v = ASRUtils::make_Variable_t_util(al, x.base.base.loc, new_scope,
-                                                 name_c, variable_dependencies_vec.p, variable_dependencies_vec.size(),
-                                                 ASR::intentType::Local, nullptr, nullptr, tmp_storage, tmp_type, struct_sym,
-                                                 ASR::abiType::Source, ASR::accessType::Private, ASR::presenceType::Required,
-                                                 false);
+            ASRUtils::collect_variable_dependencies(
+                al, variable_dependencies_vec, tmp_type, nullptr, nullptr, name);
+            ASR::symbol_t* struct_sym = ASRUtils::import_struct_sym_as_external(
+                al, x.base.base.loc, tmp_expr, current_scope);
+            ASR::asr_t* v = ASRUtils::make_Variable_t_util(al,
+                                                           x.base.base.loc,
+                                                           new_scope,
+                                                           name_c,
+                                                           variable_dependencies_vec.p,
+                                                           variable_dependencies_vec.size(),
+                                                           ASR::intentType::Local,
+                                                           nullptr,
+                                                           nullptr,
+                                                           tmp_storage,
+                                                           tmp_type,
+                                                           struct_sym,
+                                                           ASR::abiType::Source,
+                                                           ASR::accessType::Private,
+                                                           ASR::presenceType::Required,
+                                                           false);
             new_scope->add_symbol(name, ASR::down_cast<ASR::symbol_t>(v));
-            ASR::expr_t* target_var = ASRUtils::EXPR(ASR::make_Var_t(al, v->loc, ASR::down_cast<ASR::symbol_t>(v)));
-            if( create_associate_stmt ) {
-                ASR::stmt_t* associate_stmt = ASRUtils::STMT(ASRUtils::make_Associate_t_util(al, tmp_expr->base.loc, target_var, tmp_expr));
+            ASR::expr_t* target_var
+                = ASRUtils::EXPR(ASR::make_Var_t(al, v->loc, ASR::down_cast<ASR::symbol_t>(v)));
+            if (create_associate_stmt) {
+                ASR::stmt_t* associate_stmt = ASRUtils::STMT(
+                    ASRUtils::make_Associate_t_util(al, tmp_expr->base.loc, target_var, tmp_expr));
                 body.push_back(al, associate_stmt);
             } else {
                 ASRUtils::make_ArrayBroadcast_t_util(al, tmp_expr->base.loc, target_var, tmp_expr);
-                ASR::stmt_t* assign_stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, tmp_expr->base.loc, target_var, tmp_expr, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+                ASR::stmt_t* assign_stmt = ASRUtils::STMT(
+                    ASRUtils::make_Assignment_t_util(al,
+                                                     tmp_expr->base.loc,
+                                                     target_var,
+                                                     tmp_expr,
+                                                     nullptr,
+                                                     compiler_options.po.realloc_lhs_arrays,
+                                                     false));
                 body.push_back(al, assign_stmt);
             }
         }
@@ -1519,100 +1817,107 @@ public:
         current_scope = new_scope;
         transform_stmts(body, x.n_body, x.m_body);
         current_scope = current_scope_copy;
-        ASR::AssociateBlock_t* associate_block_t = ASR::down_cast<ASR::AssociateBlock_t>(
-            ASR::down_cast<ASR::symbol_t>(associate_block));
+        ASR::AssociateBlock_t* associate_block_t
+            = ASR::down_cast<ASR::AssociateBlock_t>(ASR::down_cast<ASR::symbol_t>(associate_block));
         associate_block_t->m_body = body.p;
         associate_block_t->n_body = body.size();
         current_scope->add_symbol(name, ASR::down_cast<ASR::symbol_t>(associate_block));
-        tmp = ASR::make_AssociateBlockCall_t(al, x.base.base.loc, ASR::down_cast<ASR::symbol_t>(associate_block));
+        tmp = ASR::make_AssociateBlockCall_t(
+            al, x.base.base.loc, ASR::down_cast<ASR::symbol_t>(associate_block));
     }
 
-    void set_string_len_if_needed(const AST::Allocate_t& x, Vec<ASR::alloc_arg_t> &alloc_args_vec, bool cond, ASR::expr_t* expr) {
-            if (cond && ASRUtils::is_character(*ASRUtils::expr_type(expr))) {
-                ASR::expr_t* string_len = ASRUtils::EXPR(
-                    ASR::make_StringLen_t(al, x.base.base.loc, expr,
-                        ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc,
-                            compiler_options.po.default_integer_kind)),
-                        nullptr
-                    )
-                );
-                for (size_t i = 0; i < alloc_args_vec.size(); i++) {
-                    LCOMPILERS_ASSERT(
-                        ASRUtils::is_character(*ASRUtils::expr_type(alloc_args_vec[i].m_a)) ||
-                        ASRUtils::is_class_type(ASRUtils::extract_type(ASRUtils::expr_type(alloc_args_vec[i].m_a)))
-                    );
-                    alloc_args_vec.p[i].m_len_expr = string_len;
-                }
+    void set_string_len_if_needed(const AST::Allocate_t& x,
+                                  Vec<ASR::alloc_arg_t>& alloc_args_vec,
+                                  bool cond,
+                                  ASR::expr_t* expr)
+    {
+        if (cond && ASRUtils::is_character(*ASRUtils::expr_type(expr))) {
+            ASR::expr_t* string_len = ASRUtils::EXPR(ASR::make_StringLen_t(
+                al,
+                x.base.base.loc,
+                expr,
+                ASRUtils::TYPE(ASR::make_Integer_t(
+                    al, x.base.base.loc, compiler_options.po.default_integer_kind)),
+                nullptr));
+            for (size_t i = 0; i < alloc_args_vec.size(); i++) {
+                LCOMPILERS_ASSERT(
+                    ASRUtils::is_character(*ASRUtils::expr_type(alloc_args_vec[i].m_a))
+                    || ASRUtils::is_class_type(
+                        ASRUtils::extract_type(ASRUtils::expr_type(alloc_args_vec[i].m_a))));
+                alloc_args_vec.p[i].m_len_expr = string_len;
             }
         }
+    }
 
-    void visit_Allocate(const AST::Allocate_t& x) {
+    void visit_Allocate(const AST::Allocate_t& x)
+    {
         Vec<ASR::alloc_arg_t> alloc_args_vec;
         alloc_args_vec.reserve(al, x.n_args);
-        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-        ASR::expr_t* const_1 = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
-        for( size_t i = 0; i < x.n_args; i++ ) {
+        ASR::ttype_t* int_type = ASRUtils::TYPE(
+            ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+        ASR::expr_t* const_1
+            = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
+        for (size_t i = 0; i < x.n_args; i++) {
             ASR::alloc_arg_t new_arg;
             new_arg.m_len_expr = nullptr;
             new_arg.m_type = nullptr;
             new_arg.m_sym_subclass = nullptr;
             ASR::expr_t* tmp_stmt = nullptr;
             new_arg.loc = x.base.base.loc;
-            if( x.m_args[i].m_end && !x.m_args[i].m_start && !x.m_args[i].m_step ) {
+            if (x.m_args[i].m_end && !x.m_args[i].m_start && !x.m_args[i].m_step) {
                 this->visit_expr(*(x.m_args[i].m_end));
                 tmp_stmt = ASRUtils::EXPR(tmp);
 
                 if (ASR::is_a<ASR::StringItem_t>(*tmp_stmt)) {
                     diag.add(Diagnostic(
                         "Deferred-length CHARACTER variable must be allocated with a character length `character(..)`",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.m_args[i].m_end->base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.m_args[i].m_end->base.loc }) }));
                     throw SemanticAbort();
                 }
-            } else if( x.m_args[i].m_start && !x.m_args[i].m_end && x.m_args[i].m_step ) {
+            } else if (x.m_args[i].m_start && !x.m_args[i].m_end && x.m_args[i].m_step) {
                 this->visit_expr(*(x.m_args[i].m_step));
                 tmp_stmt = ASRUtils::EXPR(tmp);
-                if( AST::is_a<AST::FuncCallOrArray_t>(*x.m_args[i].m_start) ) {
-                    AST::FuncCallOrArray_t* func_call_t =
-                        AST::down_cast<AST::FuncCallOrArray_t>(x.m_args[i].m_start);
-                    if( to_lower(std::string(func_call_t->m_func)) == "character" ) {
-                        LCOMPILERS_ASSERT(func_call_t->n_args == 1 ||
-                                          func_call_t->n_keywords <= 2);
-                        if( func_call_t->m_args[0].m_end ) {
+                if (AST::is_a<AST::FuncCallOrArray_t>(*x.m_args[i].m_start)) {
+                    AST::FuncCallOrArray_t* func_call_t
+                        = AST::down_cast<AST::FuncCallOrArray_t>(x.m_args[i].m_start);
+                    if (to_lower(std::string(func_call_t->m_func)) == "character") {
+                        LCOMPILERS_ASSERT(func_call_t->n_args == 1 || func_call_t->n_keywords <= 2);
+                        if (func_call_t->m_args[0].m_end) {
                             visit_expr(*func_call_t->m_args[0].m_end);
                             new_arg.m_len_expr = ASRUtils::EXPR(tmp);
                         } else {
-                            for( size_t i = 0; i < func_call_t->n_keywords; i++ ) {
-                                if( to_lower(std::string(func_call_t->m_keywords[i].m_arg)) == "len" ) {
+                            for (size_t i = 0; i < func_call_t->n_keywords; i++) {
+                                if (to_lower(std::string(func_call_t->m_keywords[i].m_arg))
+                                    == "len") {
                                     visit_expr(*func_call_t->m_keywords[i].m_value);
                                     new_arg.m_len_expr = ASRUtils::EXPR(tmp);
                                 }
                             }
                         }
                     } else {
-                        diag.add(Diagnostic(
-                            "The type-spec: `" + std::string(func_call_t->m_func)
-                            + "` is not supported yet",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.m_args[i].m_start->base.loc})
-                            }));
+                        diag.add(Diagnostic("The type-spec: `" + std::string(func_call_t->m_func)
+                                                + "` is not supported yet",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.m_args[i].m_start->base.loc }) }));
                         throw SemanticAbort();
                     }
-                } else if( AST::is_a<AST::Name_t>(*x.m_args[i].m_start) ) {
+                } else if (AST::is_a<AST::Name_t>(*x.m_args[i].m_start)) {
                     AST::Name_t* name_t = AST::down_cast<AST::Name_t>(x.m_args[i].m_start);
-                    ASR::symbol_t *v = current_scope->resolve_symbol(to_lower(name_t->m_id));
+                    ASR::symbol_t* v = current_scope->resolve_symbol(to_lower(name_t->m_id));
                     if (v) {
-                        ASR::ttype_t* struct_t = ASRUtils::make_StructType_t_util(al, x.base.base.loc, v, true);
+                        ASR::ttype_t* struct_t
+                            = ASRUtils::make_StructType_t_util(al, x.base.base.loc, v, true);
                         new_arg.m_type = struct_t;
                         new_arg.m_sym_subclass = v;
                     } else {
-                        diag.add(Diagnostic(
-                            "`The type-spec: " + std::string(name_t->m_id)
-                            + "` is not supported yet",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.m_args[i].m_start->base.loc})
-                            }));
+                        diag.add(Diagnostic("`The type-spec: " + std::string(name_t->m_id)
+                                                + "` is not supported yet",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.m_args[i].m_start->base.loc }) }));
                         throw SemanticAbort();
                     }
                 } else {
@@ -1620,47 +1925,50 @@ public:
                 }
             }
             // Assume that tmp is an `ArraySection` or `ArrayItem`
-            if( ASR::is_a<ASR::ArraySection_t>(*tmp_stmt) ) {
+            if (ASR::is_a<ASR::ArraySection_t>(*tmp_stmt)) {
                 ASR::ArraySection_t* array_ref = ASR::down_cast<ASR::ArraySection_t>(tmp_stmt);
                 new_arg.m_a = array_ref->m_v;
                 Vec<ASR::dimension_t> dims_vec;
                 dims_vec.reserve(al, array_ref->n_args);
-                for( size_t j = 0; j < array_ref->n_args; j++ ) {
-                    ASR::dimension_t new_dim; new_dim.m_length = nullptr;
+                for (size_t j = 0; j < array_ref->n_args; j++) {
+                    ASR::dimension_t new_dim;
+                    new_dim.m_length = nullptr;
                     new_dim.m_start = nullptr;
                     new_dim.loc = array_ref->m_args[j].loc;
                     ASR::expr_t* m_left = array_ref->m_args[j].m_left;
-                    if( m_left != nullptr ) {
+                    if (m_left != nullptr) {
                         new_dim.m_start = m_left;
                     } else {
                         new_dim.m_start = const_1;
                     }
                     ASR::expr_t* m_right = array_ref->m_args[j].m_right;
-                    new_dim.m_length = ASRUtils::compute_length_from_start_end(al, new_dim.m_start, m_right);
+                    new_dim.m_length
+                        = ASRUtils::compute_length_from_start_end(al, new_dim.m_start, m_right);
                     dims_vec.push_back(al, new_dim);
                 }
                 new_arg.m_dims = dims_vec.p;
                 new_arg.n_dims = dims_vec.size();
                 alloc_args_vec.push_back(al, new_arg);
-            } else if( ASR::is_a<ASR::ArrayItem_t>(*tmp_stmt) ) {
+            } else if (ASR::is_a<ASR::ArrayItem_t>(*tmp_stmt)) {
                 ASR::ArrayItem_t* array_ref = ASR::down_cast<ASR::ArrayItem_t>(tmp_stmt);
                 new_arg.m_a = array_ref->m_v;
                 Vec<ASR::dimension_t> dims_vec;
                 dims_vec.reserve(al, array_ref->n_args);
-                for( size_t j = 0; j < array_ref->n_args; j++ ) {
-                    ASR::dimension_t new_dim; new_dim.m_length = nullptr;
+                for (size_t j = 0; j < array_ref->n_args; j++) {
+                    ASR::dimension_t new_dim;
+                    new_dim.m_length = nullptr;
                     new_dim.m_start = nullptr;
                     new_dim.loc = array_ref->m_args[j].loc;
                     new_dim.m_start = const_1;
-                    new_dim.m_length = ASRUtils::compute_length_from_start_end(al, new_dim.m_start,
-                                            array_ref->m_args[j].m_right);
+                    new_dim.m_length = ASRUtils::compute_length_from_start_end(
+                        al, new_dim.m_start, array_ref->m_args[j].m_right);
                     dims_vec.push_back(al, new_dim);
                 }
                 new_arg.m_dims = dims_vec.p;
                 new_arg.n_dims = dims_vec.size();
                 alloc_args_vec.push_back(al, new_arg);
-            } else if( ASR::is_a<ASR::Var_t>(*tmp_stmt) ||
-                       ASR::is_a<ASR::StructInstanceMember_t>(*tmp_stmt) ) {
+            } else if (ASR::is_a<ASR::Var_t>(*tmp_stmt)
+                       || ASR::is_a<ASR::StructInstanceMember_t>(*tmp_stmt)) {
                 new_arg.m_a = tmp_stmt;
                 new_arg.m_dims = nullptr;
                 new_arg.n_dims = 0;
@@ -1671,40 +1979,46 @@ public:
         bool cond = x.n_keywords == 0;
         bool stat_cond = false, errmsg_cond = false, source_cond = false, mold_cond = false;
         ASR::expr_t *stat = nullptr, *errmsg = nullptr, *source = nullptr, *mold = nullptr;
-        for ( size_t i=0; i<x.n_keywords; i++ ) {
+        for (size_t i = 0; i < x.n_keywords; i++) {
             stat_cond = !stat_cond && (to_lower(x.m_keywords[i].m_arg) == "stat");
             errmsg_cond = !errmsg_cond && (to_lower(x.m_keywords[i].m_arg) == "errmsg");
             source_cond = !source_cond && (to_lower(x.m_keywords[i].m_arg) == "source");
             mold_cond = !mold_cond && (to_lower(x.m_keywords[i].m_arg) == "mold");
             cond = cond || (stat_cond || errmsg_cond || source_cond || mold_cond);
-            if( stat_cond ) {
+            if (stat_cond) {
                 this->visit_expr(*(x.m_keywords[i].m_value));
                 stat = ASRUtils::EXPR(tmp);
-            } else if( errmsg_cond ) {
+            } else if (errmsg_cond) {
                 this->visit_expr(*(x.m_keywords[i].m_value));
                 errmsg = ASRUtils::EXPR(tmp);
-            } else if( source_cond ) {
+            } else if (source_cond) {
                 this->visit_expr(*(x.m_keywords[i].m_value));
                 source = ASRUtils::EXPR(tmp);
                 set_string_len_if_needed(x, alloc_args_vec, source_cond, source);
-            } else if ( mold_cond ) {
+            } else if (mold_cond) {
                 this->visit_expr(*(x.m_keywords[i].m_value));
                 mold = ASRUtils::EXPR(tmp);
                 set_string_len_if_needed(x, alloc_args_vec, mold_cond, mold);
             }
         }
 
-        if ( mold_cond && !source_cond) {
+        if (mold_cond && !source_cond) {
             Vec<ASR::alloc_arg_t> new_alloc_args_vec;
             new_alloc_args_vec.reserve(al, alloc_args_vec.size());
-            ASR::ttype_t* mold_type = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(mold));
+            ASR::ttype_t* mold_type
+                = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(mold));
             for (size_t i = 0; i < alloc_args_vec.size(); i++) {
-                if ( alloc_args_vec[i].n_dims == 0 ) {
-                    ASR::ttype_t* a_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(alloc_args_vec[i].m_a));
-                    if ( ASRUtils::check_equal_type(mold_type, a_type, mold, alloc_args_vec[i].m_a) ) {
+                if (alloc_args_vec[i].n_dims == 0) {
+                    ASR::ttype_t* a_type = ASRUtils::type_get_past_allocatable(
+                        ASRUtils::expr_type(alloc_args_vec[i].m_a));
+                    if (ASRUtils::check_equal_type(
+                            mold_type, a_type, mold, alloc_args_vec[i].m_a)) {
                         if (ASRUtils::is_array(mold_type)) {
-                            if (ASR::is_a<ASR::Array_t>(*mold_type) && ASR::down_cast<ASR::Array_t>(mold_type)->m_dims[0].m_length != nullptr) {
-                                ASR::Array_t* mold_array_type = ASR::down_cast<ASR::Array_t>(mold_type);
+                            if (ASR::is_a<ASR::Array_t>(*mold_type)
+                                && ASR::down_cast<ASR::Array_t>(mold_type)->m_dims[0].m_length
+                                       != nullptr) {
+                                ASR::Array_t* mold_array_type
+                                    = ASR::down_cast<ASR::Array_t>(mold_type);
                                 ASR::alloc_arg_t new_arg;
                                 new_arg.loc = alloc_args_vec[i].loc;
                                 new_arg.m_a = alloc_args_vec[i].m_a;
@@ -1716,15 +2030,23 @@ public:
                                 new_alloc_args_vec.push_back(al, new_arg);
                             } else {
                                 int n_dims = ASRUtils::extract_n_dims_from_ttype(mold_type);
-                                Vec<ASR::dimension_t> mold_dims_vec; mold_dims_vec.reserve(al, n_dims);
-                                ASR::ttype_t* integer_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
-                                for(int i=0; i<n_dims; i++) {
+                                Vec<ASR::dimension_t> mold_dims_vec;
+                                mold_dims_vec.reserve(al, n_dims);
+                                ASR::ttype_t* integer_type
+                                    = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
+                                for (int i = 0; i < n_dims; i++) {
                                     ASR::dimension_t dim;
                                     dim.loc = x.base.base.loc;
                                     dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
                                         al, x.base.base.loc, 1, integer_type));
                                     dim.m_length = ASRUtils::EXPR(ASR::make_ArraySize_t(
-                            al, x.base.base.loc, mold, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, i+1, integer_type)), integer_type, nullptr));
+                                        al,
+                                        x.base.base.loc,
+                                        mold,
+                                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                            al, x.base.base.loc, i + 1, integer_type)),
+                                        integer_type,
+                                        nullptr));
                                     mold_dims_vec.push_back(al, dim);
                                 }
                                 ASR::alloc_arg_t new_arg;
@@ -1737,7 +2059,7 @@ public:
                                 new_arg.n_dims = mold_dims_vec.size();
                                 new_alloc_args_vec.push_back(al, new_arg);
                             }
-                        } else if ( ASR::is_a<ASR::StructType_t>(*mold_type) ) {
+                        } else if (ASR::is_a<ASR::StructType_t>(*mold_type)) {
                             ASR::alloc_arg_t new_arg;
                             new_arg.loc = alloc_args_vec[i].loc;
                             new_arg.m_a = alloc_args_vec[i].m_a;
@@ -1748,18 +2070,19 @@ public:
                             new_arg.n_dims = 0;
                             new_alloc_args_vec.push_back(al, new_arg);
                         } else {
-                            diag.add(Diagnostic("The type of the argument is not supported yet for mold.",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{mold->base.loc})
-                                }));
+                            diag.add(Diagnostic(
+                                "The type of the argument is not supported yet for mold.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { mold->base.loc }) }));
                             throw SemanticAbort();
                         }
                     } else {
                         diag.add(Diagnostic(
                             "The type of the variable to be allocated does not match the type of the mold.",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 } else {
@@ -1769,205 +2092,230 @@ public:
             alloc_args_vec = new_alloc_args_vec;
         }
 
-        if( !cond ) {
-            diag.add(Diagnostic(
-                "`allocate` statement only "
-                "accepts four keyword arguments: "
-                "`stat`, `errmsg`, `source` and `mold`",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (!cond) {
+            diag.add(Diagnostic("`allocate` statement only "
+                                "accepts four keyword arguments: "
+                                "`stat`, `errmsg`, `source` and `mold`",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         // Perform all validation checks BEFORE creating any ASR nodes
         // to avoid creating malformed ASR when continuing compilation after errors
         if (source) {
-            for (size_t i = 0; i < alloc_args_vec.n ; i++) {
+            for (size_t i = 0; i < alloc_args_vec.n; i++) {
                 ASR::ttype_t* source_type = ASRUtils::expr_type(source);
                 ASR::ttype_t* var_type = ASRUtils::expr_type(alloc_args_vec.p[i].m_a);
 
                 ASR::dimension_t* source_m_dims = nullptr;
                 ASR::dimension_t* var_m_dims = alloc_args_vec.p[i].m_dims;
                 ASR::dimension_t* var_m_dims_decl = nullptr;
-                size_t source_n_dims = ASRUtils::extract_dimensions_from_ttype(source_type, source_m_dims);
+                size_t source_n_dims
+                    = ASRUtils::extract_dimensions_from_ttype(source_type, source_m_dims);
                 size_t var_n_dims = alloc_args_vec.p[i].n_dims;
-                size_t var_n_dims_decl = ASRUtils::extract_dimensions_from_ttype(var_type, var_m_dims_decl);
-
-                if (!ASRUtils::check_equal_type(source_type, var_type, source, alloc_args_vec.p[i].m_a)) {
-                    std::string source_type_str = ASRUtils::type_to_str_fortran_expr(source_type, source);
-                    std::string var_type_str = ASRUtils::type_to_str_fortran_expr(var_type, alloc_args_vec.p[i].m_a);
+                size_t var_n_dims_decl
+                    = ASRUtils::extract_dimensions_from_ttype(var_type, var_m_dims_decl);
+
+                if (!ASRUtils::check_equal_type(
+                        source_type, var_type, source, alloc_args_vec.p[i].m_a)) {
+                    std::string source_type_str
+                        = ASRUtils::type_to_str_fortran_expr(source_type, source);
+                    std::string var_type_str
+                        = ASRUtils::type_to_str_fortran_expr(var_type, alloc_args_vec.p[i].m_a);
                     diag.add(Diagnostic(
                         "Type mismatch: The `source` argument in `allocate` must have the same type as the allocated variable.\n"
-                        "Expected type: " + var_type_str + ", but got: " + source_type_str + ".",
-                        Level::Error, Stage::Semantic, {
-                            Label("incompatible types in `allocate` statement", {alloc_args_vec.p[i].m_a->base.loc, source->base.loc})
-                        }));
+                        "Expected type: "
+                            + var_type_str + ", but got: " + source_type_str + ".",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("incompatible types in `allocate` statement",
+                                { alloc_args_vec.p[i].m_a->base.loc, source->base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                if (source_n_dims != 0 && ((var_n_dims != 0 && var_n_dims != source_n_dims) || (var_n_dims == 0 && source_n_dims != var_n_dims_decl))) {
+                if (source_n_dims != 0
+                    && ((var_n_dims != 0 && var_n_dims != source_n_dims)
+                        || (var_n_dims == 0 && source_n_dims != var_n_dims_decl))) {
                     diag.add(Diagnostic(
                         "Dimension mismatch in `allocate` statement.",
-                        Level::Error, Stage::Semantic, {
-                            Label("mismatch in dimensions between allocated variable and `source`", {alloc_args_vec.p[i].m_a->base.loc, source->base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("mismatch in dimensions between allocated variable and `source`",
+                                { alloc_args_vec.p[i].m_a->base.loc, source->base.loc }) }));
                     throw SemanticAbort();
                 } else if (source_n_dims == 0 && (var_n_dims == 0 && var_n_dims_decl != 0)) {
                     diag.add(Diagnostic(
                         "Cannot allocate an array from a scalar source.",
-                        Level::Error, Stage::Semantic, {
-                            Label("allocated variable is an array, but `source` is a scalar",
-                                {alloc_args_vec.p[i].m_a->base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("allocated variable is an array, but `source` is a scalar",
+                                { alloc_args_vec.p[i].m_a->base.loc }) }));
                     throw SemanticAbort();
                 }
 
                 // Check individual dimension shapes
                 if (source_m_dims && var_m_dims) {
                     for (size_t j = 0; j < var_n_dims; j++) {
-                        int source_dim_shape = ASRUtils::extract_dim_value_int(source_m_dims[j].m_length);
+                        int source_dim_shape
+                            = ASRUtils::extract_dim_value_int(source_m_dims[j].m_length);
                         int var_dim_shape = ASRUtils::extract_dim_value_int(var_m_dims[j].m_length);
 
-                        if (source_dim_shape != -1 && var_dim_shape != -1 && source_dim_shape != var_dim_shape) {
+                        if (source_dim_shape != -1 && var_dim_shape != -1
+                            && source_dim_shape != var_dim_shape) {
                             diag.add(Diagnostic(
-                                        "Shape mismatch in `allocate` statement.",
-                                        Level::Error, Stage::Semantic, {
-                                            Label("shape mismatch in dimension " + std::to_string(j+1),
-                                                {alloc_args_vec.p[i].m_a->base.loc, source->base.loc})
-                                        }));
-                                    throw SemanticAbort();
+                                "Shape mismatch in `allocate` statement.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label(
+                                    "shape mismatch in dimension " + std::to_string(j + 1),
+                                    { alloc_args_vec.p[i].m_a->base.loc, source->base.loc }) }));
+                            throw SemanticAbort();
                         }
                     }
                 }
             }
         }
 
-        tmp = ASR::make_Allocate_t(al, x.base.base.loc,
-                                    alloc_args_vec.p, alloc_args_vec.size(),
-                                    stat, errmsg, source);
+        tmp = ASR::make_Allocate_t(
+            al, x.base.base.loc, alloc_args_vec.p, alloc_args_vec.size(), stat, errmsg, source);
 
         if (source) {
-            current_body->push_back(al, ASRUtils::STMT(ASR::make_Allocate_t(al, x.base.base.loc,
-                                        alloc_args_vec.p, alloc_args_vec.size(),
-                                        stat, errmsg, source)));
+            current_body->push_back(al,
+                                    ASRUtils::STMT(ASR::make_Allocate_t(al,
+                                                                        x.base.base.loc,
+                                                                        alloc_args_vec.p,
+                                                                        alloc_args_vec.size(),
+                                                                        stat,
+                                                                        errmsg,
+                                                                        source)));
             // Pushing assignment statements to source
-            for (size_t i = 0; i < alloc_args_vec.n ; i++) {
+            for (size_t i = 0; i < alloc_args_vec.n; i++) {
                 // Create assignment statement only for non-struct types
                 // All validation was already done above before creating the Allocate ASR node
-                if (!ASR::is_a<ASR::StructType_t>(*ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(alloc_args_vec[i].m_a)))) {
+                if (!ASR::is_a<ASR::StructType_t>(*ASRUtils::type_get_past_allocatable(
+                        ASRUtils::expr_type(alloc_args_vec[i].m_a)))) {
                     ASR::stmt_t* assign_stmt = ASRUtils::STMT(
-                        ASRUtils::make_Assignment_t_util(
-                            al, x.base.base.loc, alloc_args_vec[i].m_a, source, nullptr, compiler_options.po.realloc_lhs_arrays, false
-                        )
-                    );
+                        ASRUtils::make_Assignment_t_util(al,
+                                                         x.base.base.loc,
+                                                         alloc_args_vec[i].m_a,
+                                                         source,
+                                                         nullptr,
+                                                         compiler_options.po.realloc_lhs_arrays,
+                                                         false));
                     current_body->push_back(al, assign_stmt);
                 }
             }
             tmp = nullptr;
         } else {
-            for( size_t i = 0; i < x.n_args; i++ ) {
-                if(alloc_args_vec.p[i].m_a && ASRUtils::is_array(ASRUtils::expr_type(alloc_args_vec.p[i].m_a)) &&
-                    alloc_args_vec.p[i].n_dims == 0) {
-                    diag.add(Diagnostic(
-                        "Allocate for arrays should have dimensions specified, "
-                        "found only array variable with no dimensions",
-                        Level::Error, Stage::Semantic, {
-                            Label("Array specification required in allocate statement", {alloc_args_vec.p[i].m_a->base.loc})
-                        }));
+            for (size_t i = 0; i < x.n_args; i++) {
+                if (alloc_args_vec.p[i].m_a
+                    && ASRUtils::is_array(ASRUtils::expr_type(alloc_args_vec.p[i].m_a))
+                    && alloc_args_vec.p[i].n_dims == 0) {
+                    diag.add(
+                        Diagnostic("Allocate for arrays should have dimensions specified, "
+                                   "found only array variable with no dimensions",
+                                   Level::Error,
+                                   Stage::Semantic,
+                                   { Label("Array specification required in allocate statement",
+                                           { alloc_args_vec.p[i].m_a->base.loc }) }));
                     throw SemanticAbort();
                 }
             }
         }
     }
 
-    ASR::symbol_t* get_allocate_expr_sym(ASR::expr_t* v) {
+    ASR::symbol_t* get_allocate_expr_sym(ASR::expr_t* v)
+    {
         if (ASR::is_a<ASR::Var_t>(*v)) {
-            ASR::Var_t *var = ASR::down_cast<ASR::Var_t>(v);
+            ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(v);
             return var->m_v;
         }
         if (ASR::is_a<ASR::StructInstanceMember_t>(*v)) {
-            ASR::StructInstanceMember_t *sim = ASR::down_cast<ASR::StructInstanceMember_t>(v);
+            ASR::StructInstanceMember_t* sim = ASR::down_cast<ASR::StructInstanceMember_t>(v);
             return get_allocate_expr_sym(sim->m_v);
         }
         if (ASR::is_a<ASR::ArrayItem_t>(*v)) {
-            ASR::ArrayItem_t *arri = ASR::down_cast<ASR::ArrayItem_t>(v);
+            ASR::ArrayItem_t* arri = ASR::down_cast<ASR::ArrayItem_t>(v);
             return get_allocate_expr_sym(arri->m_v);
         }
         if (ASR::is_a<ASR::ArraySection_t>(*v)) {
-            ASR::ArraySection_t *arrs = ASR::down_cast<ASR::ArraySection_t>(v);
+            ASR::ArraySection_t* arrs = ASR::down_cast<ASR::ArraySection_t>(v);
             return get_allocate_expr_sym(arrs->m_v);
         }
         LCOMPILERS_ASSERT(false);
         return nullptr;
     }
 
-    inline void check_for_deallocation(ASR::symbol_t* tmp_sym, const Location& loc) {
+    inline void check_for_deallocation(ASR::symbol_t* tmp_sym, const Location& loc)
+    {
         tmp_sym = ASRUtils::symbol_get_past_external(tmp_sym);
-        if( !ASR::is_a<ASR::Variable_t>(*tmp_sym) ) {
-            diag.add(Diagnostic(
-                "Only an allocatable variable symbol "
-                "can be deallocated.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+        if (!ASR::is_a<ASR::Variable_t>(*tmp_sym)) {
+            diag.add(Diagnostic("Only an allocatable variable symbol "
+                                "can be deallocated.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
         ASR::Variable_t* tmp_v = ASR::down_cast<ASR::Variable_t>(tmp_sym);
-        if( ASR::is_a<ASR::Allocatable_t>(*tmp_v->m_type) &&
-            tmp_v->m_storage != ASR::storage_typeType::Save ) {
+        if (ASR::is_a<ASR::Allocatable_t>(*tmp_v->m_type)
+            && tmp_v->m_storage != ASR::storage_typeType::Save) {
             // If it is not allocatable, it can also be a pointer
-            if (ASR::is_a<ASR::Pointer_t>(*tmp_v->m_type) ||
-                ASR::is_a<ASR::Allocatable_t>(*tmp_v->m_type)) {
+            if (ASR::is_a<ASR::Pointer_t>(*tmp_v->m_type)
+                || ASR::is_a<ASR::Allocatable_t>(*tmp_v->m_type)) {
                 // OK
             } else {
-                diag.add(Diagnostic(
-                    "Only an allocatable or a pointer variable "
+                diag.add(Diagnostic("Only an allocatable or a pointer variable "
                                     "can be deallocated.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{loc})
-                    }));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         }
     }
 
-    void visit_Deallocate(const AST::Deallocate_t& x) {
+    void visit_Deallocate(const AST::Deallocate_t& x)
+    {
         Vec<ASR::expr_t*> arg_vec;
         arg_vec.reserve(al, x.n_args);
-        for( size_t i = 0; i < x.n_args; i++ ) {
+        for (size_t i = 0; i < x.n_args; i++) {
             this->visit_expr(*(x.m_args[i].m_end));
             ASR::expr_t* tmp_expr = ASRUtils::EXPR(tmp);
-            if( ASR::is_a<ASR::Var_t>(*tmp_expr) ) {
+            if (ASR::is_a<ASR::Var_t>(*tmp_expr)) {
                 const ASR::Var_t* tmp_var = ASR::down_cast<ASR::Var_t>(tmp_expr);
                 ASR::symbol_t* tmp_sym = tmp_var->m_v;
                 check_for_deallocation(tmp_sym, tmp_expr->base.loc);
-            } else if( ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr) ) {
-                const ASR::StructInstanceMember_t* tmp_struct_ref = ASR::down_cast<ASR::StructInstanceMember_t>(tmp_expr);
+            } else if (ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr)) {
+                const ASR::StructInstanceMember_t* tmp_struct_ref
+                    = ASR::down_cast<ASR::StructInstanceMember_t>(tmp_expr);
                 ASR::symbol_t* tmp_member = tmp_struct_ref->m_m;
                 check_for_deallocation(tmp_member, tmp_expr->base.loc);
             } else {
-                diag.add(Diagnostic(
-                    "Cannot deallocate variables in expression " +
-                    ASRUtils::type_to_str_python_expr(ASRUtils::expr_type((tmp_expr)), tmp_expr),
-                    Level::Error, Stage::Semantic, {
-                        Label("",{tmp_expr->base.loc})
-                    }));
+                diag.add(Diagnostic("Cannot deallocate variables in expression "
+                                        + ASRUtils::type_to_str_python_expr(
+                                            ASRUtils::expr_type((tmp_expr)), tmp_expr),
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { tmp_expr->base.loc }) }));
                 throw SemanticAbort();
             }
             arg_vec.push_back(al, tmp_expr);
         }
-        tmp = ASR::make_ExplicitDeallocate_t(al, x.base.base.loc,
-                                            arg_vec.p, arg_vec.size());
+        tmp = ASR::make_ExplicitDeallocate_t(al, x.base.base.loc, arg_vec.p, arg_vec.size());
     }
 
-    void visit_Return(const AST::Return_t& x) {
+    void visit_Return(const AST::Return_t& x)
+    {
         // TODO
         tmp = ASR::make_Return_t(al, x.base.base.loc);
     }
 
-    void visit_case_stmt(const AST::case_stmt_t& x) {
+    void visit_case_stmt(const AST::case_stmt_t& x)
+    {
         Vec<ASR::case_stmt_t*> case_stmts;
         case_stmts.reserve(al, 1);
         visit_case_stmt(x, case_stmts);
@@ -1978,52 +2326,59 @@ public:
         }
     }
 
-    void visit_case_stmt(const AST::case_stmt_t& x, Vec<ASR::case_stmt_t*>& case_stmts) {
-        AST::CaseStmt_t* Case_Stmt = (AST::CaseStmt_t*)(&(x.base));
+    void visit_case_stmt(const AST::case_stmt_t& x, Vec<ASR::case_stmt_t*>& case_stmts)
+    {
+        AST::CaseStmt_t* Case_Stmt = (AST::CaseStmt_t*) (&(x.base));
         std::vector<ASR::expr_t*> expr_accum;
-        auto emit_expr_group = [&](const Location &loc) {
-            if (expr_accum.empty()) return;
+        auto emit_expr_group = [&](const Location& loc) {
+            if (expr_accum.empty())
+                return;
             Vec<ASR::expr_t*> expr_vec;
             expr_vec.reserve(al, expr_accum.size());
-            for (ASR::expr_t* item: expr_accum) {
+            for (ASR::expr_t* item : expr_accum) {
                 expr_vec.push_back(al, item);
             }
             Vec<ASR::stmt_t*> case_body_vec;
             case_body_vec.reserve(al, Case_Stmt->n_body);
             transform_stmts(case_body_vec, Case_Stmt->n_body, Case_Stmt->m_body);
-            ASR::case_stmt_t *new_case = ASR::down_cast<ASR::case_stmt_t>(
-                ASR::make_CaseStmt_t(al, loc, expr_vec.p, expr_vec.size(),
-                                        case_body_vec.p, case_body_vec.size(), false));
+            ASR::case_stmt_t* new_case
+                = ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(al,
+                                                                        loc,
+                                                                        expr_vec.p,
+                                                                        expr_vec.size(),
+                                                                        case_body_vec.p,
+                                                                        case_body_vec.size(),
+                                                                        false));
             case_stmts.push_back(al, new_case);
             expr_accum.clear();
         };
 
-        for( std::uint32_t i = 0; i < Case_Stmt->n_test; i++ ) {
+        for (std::uint32_t i = 0; i < Case_Stmt->n_test; i++) {
             if (AST::is_a<AST::CaseCondExpr_t>(*(Case_Stmt->m_test[i]))) {
-                AST::CaseCondExpr_t *condexpr
+                AST::CaseCondExpr_t* condexpr
                     = AST::down_cast<AST::CaseCondExpr_t>(Case_Stmt->m_test[i]);
                 this->visit_expr(*condexpr->m_cond);
                 expr_accum.push_back(ASRUtils::EXPR(tmp));
                 continue;
             } else if (AST::is_a<AST::CaseCondRange_t>(*(Case_Stmt->m_test[i]))) {
                 emit_expr_group(x.base.loc);
-                AST::CaseCondRange_t *condrange
+                AST::CaseCondRange_t* condrange
                     = AST::down_cast<AST::CaseCondRange_t>(Case_Stmt->m_test[i]);
                 ASR::expr_t *m_start = nullptr, *m_end = nullptr;
-                if( condrange->m_start != nullptr ) {
+                if (condrange->m_start != nullptr) {
                     this->visit_expr(*(condrange->m_start));
                     m_start = ASRUtils::EXPR(tmp);
                 }
-                if( condrange->m_end != nullptr ) {
+                if (condrange->m_end != nullptr) {
                     this->visit_expr(*(condrange->m_end));
                     m_end = ASRUtils::EXPR(tmp);
                 }
                 Vec<ASR::stmt_t*> case_body_vec;
                 case_body_vec.reserve(al, Case_Stmt->n_body);
                 transform_stmts(case_body_vec, Case_Stmt->n_body, Case_Stmt->m_body);
-                ASR::case_stmt_t *new_case = ASR::down_cast<ASR::case_stmt_t>(
-                    ASR::make_CaseStmt_Range_t(al, x.base.loc, m_start, m_end,
-                                                case_body_vec.p, case_body_vec.size()));
+                ASR::case_stmt_t* new_case
+                    = ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_Range_t(
+                        al, x.base.loc, m_start, m_end, case_body_vec.p, case_body_vec.size()));
                 case_stmts.push_back(al, new_case);
                 continue;
             } else {
@@ -2033,43 +2388,49 @@ public:
         emit_expr_group(x.base.loc);
     }
 
-    void visit_Select(const AST::Select_t& x) {
+    void visit_Select(const AST::Select_t& x)
+    {
         this->visit_expr(*(x.m_test));
         ASR::expr_t* a_test = ASRUtils::EXPR(tmp);
         Vec<ASR::case_stmt_t*> a_body_vec;
         a_body_vec.reserve(al, x.n_body);
         Vec<ASR::stmt_t*> def_body;
         def_body.reserve(al, 1);
-        for( std::uint32_t i = 0; i < x.n_body; i++ ) {
-            AST::case_stmt_t *body = x.m_body[i];
+        for (std::uint32_t i = 0; i < x.n_body; i++) {
+            AST::case_stmt_t* body = x.m_body[i];
             if (AST::is_a<AST::CaseStmt_Default_t>(*body)) {
                 if (def_body.size() != 0) {
-                    diag.add(Diagnostic(
-                        "Default case present more than once",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("Default case present more than once",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                AST::CaseStmt_Default_t *d =
-                        AST::down_cast<AST::CaseStmt_Default_t>(body);
+                AST::CaseStmt_Default_t* d = AST::down_cast<AST::CaseStmt_Default_t>(body);
                 transform_stmts(def_body, d->n_body, d->m_body);
             } else {
                 visit_case_stmt(*body, a_body_vec);
             }
         }
 
-        tmp = ASR::make_Select_t(al, x.base.base.loc, x.m_stmt_name, a_test, a_body_vec.p,
-                           a_body_vec.size(), def_body.p, def_body.size(), false);
+        tmp = ASR::make_Select_t(al,
+                                 x.base.base.loc,
+                                 x.m_stmt_name,
+                                 a_test,
+                                 a_body_vec.p,
+                                 a_body_vec.size(),
+                                 def_body.p,
+                                 def_body.size(),
+                                 false);
     }
 
-    void visit_SelectRank(const AST::SelectRank_t& x) {
-        if ( !x.m_selector ) {
-            diag.add(Diagnostic(
-                "Selector expression is missing in select rank statement.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+    void visit_SelectRank(const AST::SelectRank_t& x)
+    {
+        if (!x.m_selector) {
+            diag.add(Diagnostic("Selector expression is missing in select rank statement.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         visit_expr(*x.m_selector);
@@ -2078,19 +2439,20 @@ public:
         if (ASR::is_a<ASR::Var_t>(*m_selector)) {
             ASR::Var_t* selector_var = ASR::down_cast<ASR::Var_t>(m_selector);
             if (ASR::is_a<ASR::Variable_t>(*selector_var->m_v)) {
-                ASR::Variable_t* selector_variable = ASR::down_cast<ASR::Variable_t>(selector_var->m_v);
+                ASR::Variable_t* selector_variable
+                    = ASR::down_cast<ASR::Variable_t>(selector_var->m_v);
                 array_var_name = selector_variable->m_name;
             }
         }
         ASR::ttype_t* selector_type = ASRUtils::expr_type(m_selector);
-        if( !ASR::is_a<ASR::Array_t>(*selector_type)) {
+        if (!ASR::is_a<ASR::Array_t>(*selector_type)) {
             // Throw error if selector is not an array
         }
         Vec<ASR::rank_stmt_t*> select_rank_body;
         Vec<ASR::stmt_t*> select_rank_default;
         select_rank_body.reserve(al, x.n_body);
         select_rank_default.reserve(al, 1);
-        for(size_t i=0; i<x.n_body; i++) {
+        for (size_t i = 0; i < x.n_body; i++) {
             SymbolTable* parent_scope = current_scope;
             current_scope = al.make_new<SymbolTable>(parent_scope);
             switch (x.m_body[i]->type) {
@@ -2099,30 +2461,42 @@ public:
                     AST::RankExpr_t* rank_expr = AST::down_cast<AST::RankExpr_t>(x.m_body[i]);
                     visit_expr(*rank_expr->m_value);
                     ASR::expr_t* rank_expr_value = ASRUtils::EXPR(tmp);
-                    if( !ASR::is_a<ASR::IntegerConstant_t>(*rank_expr_value) ) {
-                        diag.add(Diagnostic(
-                            "Rank expression must be an integer constant.",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{rank_expr->m_value->base.loc})
-                            }));
+                    if (!ASR::is_a<ASR::IntegerConstant_t>(*rank_expr_value)) {
+                        diag.add(Diagnostic("Rank expression must be an integer constant.",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { rank_expr->m_value->base.loc }) }));
                         throw SemanticAbort();
                     }
                     int rank = ASR::down_cast<ASR::IntegerConstant_t>(rank_expr_value)->m_n;
                     assumed_rank_arrays[array_var_name] = rank;
-                    Vec<ASR::stmt_t*> rank_body; rank_body.reserve(al, rank_expr->n_body);
+                    Vec<ASR::stmt_t*> rank_body;
+                    rank_body.reserve(al, rank_expr->n_body);
                     transform_stmts(rank_body, rank_expr->n_body, rank_expr->m_body);
                     std::string block_name = parent_scope->get_unique_name("~select_rank_block_");
-                    ASR::symbol_t* block_sym = ASR::down_cast<ASR::symbol_t>(ASR::make_Block_t(al, 
-                        rank_expr->base.base.loc, current_scope, s2c(al, block_name),
-                        nullptr, 0));
+                    ASR::symbol_t* block_sym
+                        = ASR::down_cast<ASR::symbol_t>(ASR::make_Block_t(al,
+                                                                          rank_expr->base.base.loc,
+                                                                          current_scope,
+                                                                          s2c(al, block_name),
+                                                                          nullptr,
+                                                                          0));
                     ASR::Block_t* block_t = ASR::down_cast<ASR::Block_t>(block_sym);
                     block_t->m_body = rank_body.p;
                     block_t->n_body = rank_body.size();
                     parent_scope->add_symbol(block_name, block_sym);
-                    Vec<ASR::stmt_t*> block_call_stmt; block_call_stmt.reserve(al, 1);
-                    block_call_stmt.push_back(al, ASRUtils::STMT(ASR::make_BlockCall_t(al, rank_expr->base.base.loc, -1, block_sym)));
-                    select_rank_body.push_back(al, ASR::down_cast<ASR::rank_stmt_t>(ASR::make_RankExpr_t(al, rank_expr->base.base.loc,
-                        rank_expr_value, block_call_stmt.p, block_call_stmt.size())));
+                    Vec<ASR::stmt_t*> block_call_stmt;
+                    block_call_stmt.reserve(al, 1);
+                    block_call_stmt.push_back(al,
+                                              ASRUtils::STMT(ASR::make_BlockCall_t(
+                                                  al, rank_expr->base.base.loc, -1, block_sym)));
+                    select_rank_body.push_back(al,
+                                               ASR::down_cast<ASR::rank_stmt_t>(
+                                                   ASR::make_RankExpr_t(al,
+                                                                        rank_expr->base.base.loc,
+                                                                        rank_expr_value,
+                                                                        block_call_stmt.p,
+                                                                        block_call_stmt.size())));
                     break;
                 }
 
@@ -2131,8 +2505,10 @@ public:
                     // TODO: throw error if more than one default case statement is present
                     SymbolTable* current_scope_copy = current_scope;
                     current_scope = parent_scope;
-                    AST::RankDefault_t* rank_default = AST::down_cast<AST::RankDefault_t>(x.m_body[i]);
-                    transform_stmts(select_rank_default, rank_default->n_body, rank_default->m_body);
+                    AST::RankDefault_t* rank_default
+                        = AST::down_cast<AST::RankDefault_t>(x.m_body[i]);
+                    transform_stmts(
+                        select_rank_default, rank_default->n_body, rank_default->m_body);
                     current_scope = current_scope_copy;
                     break;
                 }
@@ -2144,19 +2520,24 @@ public:
             current_scope = parent_scope;
         }
 
-        tmp = ASR::make_SelectRank_t(al, x.base.base.loc, m_selector, select_rank_body.p, 
-                    select_rank_body.size(), select_rank_default.p, select_rank_default.size());
+        tmp = ASR::make_SelectRank_t(al,
+                                     x.base.base.loc,
+                                     m_selector,
+                                     select_rank_body.p,
+                                     select_rank_body.size(),
+                                     select_rank_default.p,
+                                     select_rank_default.size());
     }
 
-    void visit_SelectType(const AST::SelectType_t& x) {
+    void visit_SelectType(const AST::SelectType_t& x)
+    {
         // TODO: We might need to re-order all ASR::TypeStmtName
         // before ASR::ClassStmt as per GFortran's semantics
-        if( !x.m_selector ) {
-            diag.add(Diagnostic(
-                "Selector expression is missing in select type statement.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (!x.m_selector) {
+            diag.add(Diagnostic("Selector expression is missing in select type statement.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         visit_expr(*x.m_selector);
@@ -2170,7 +2551,7 @@ public:
         ASR::symbol_t* select_variable_m_type_declaration = nullptr;
         char** selector_variable_dependencies = nullptr;
         size_t selector_variable_n_dependencies = 0;
-        if( ASR::is_a<ASR::Var_t>(*m_selector) ) {
+        if (ASR::is_a<ASR::Var_t>(*m_selector)) {
             ASR::symbol_t* selector_sym = ASR::down_cast<ASR::Var_t>(m_selector)->m_v;
             LCOMPILERS_ASSERT(ASR::is_a<ASR::Variable_t>(*selector_sym));
             selector_variable = ASR::down_cast<ASR::Variable_t>(selector_sym);
@@ -2178,56 +2559,80 @@ public:
             select_variable_m_type_declaration = selector_variable->m_type_declaration;
             selector_variable_dependencies = selector_variable->m_dependencies;
             selector_variable_n_dependencies = selector_variable->n_dependencies;
-        } else if( ASR::is_a<ASR::StructInstanceMember_t>(*m_selector) ) {
-            ASR::symbol_t* selector_sym = ASR::down_cast<ASR::StructInstanceMember_t>(m_selector)->m_m;
+        } else if (ASR::is_a<ASR::StructInstanceMember_t>(*m_selector)) {
+            ASR::symbol_t* selector_sym
+                = ASR::down_cast<ASR::StructInstanceMember_t>(m_selector)->m_m;
             LCOMPILERS_ASSERT(ASR::is_a<ASR::ExternalSymbol_t>(*selector_sym));
-            ASR::symbol_t* selector_ext = ASR::down_cast<ASR::ExternalSymbol_t>(selector_sym)->m_external;
+            ASR::symbol_t* selector_ext
+                = ASR::down_cast<ASR::ExternalSymbol_t>(selector_sym)->m_external;
             LCOMPILERS_ASSERT(ASR::is_a<ASR::Variable_t>(*selector_ext));
             selector_variable = ASR::down_cast<ASR::Variable_t>(selector_ext);
             selector_variable_type = selector_variable->m_type;
-            select_variable_m_type_declaration = ASRUtils::get_struct_sym_from_struct_expr(m_selector);
+            select_variable_m_type_declaration
+                = ASRUtils::get_struct_sym_from_struct_expr(m_selector);
             selector_variable_dependencies = selector_variable->m_dependencies;
             selector_variable_n_dependencies = selector_variable->n_dependencies;
         }
-        for( size_t i = 0; i < x.n_body; i++ ) {
+        for (size_t i = 0; i < x.n_body; i++) {
             SymbolTable* parent_scope = current_scope;
             current_scope = al.make_new<SymbolTable>(parent_scope);
             ASR::Variable_t* assoc_variable = nullptr;
             ASR::symbol_t* assoc_sym = nullptr;
-            if( x.m_assoc_name ) {
-                assoc_sym = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(
-                    al, x.base.base.loc, current_scope, x.m_assoc_name,
-                    nullptr, 0, ASR::intentType::Local, nullptr, nullptr,
-                    ASR::storage_typeType::Default, nullptr, nullptr, ASR::abiType::Source,
-                    ASR::accessType::Public, ASR::presenceType::Required, false));
+            if (x.m_assoc_name) {
+                assoc_sym = ASR::down_cast<ASR::symbol_t>(
+                    ASRUtils::make_Variable_t_util(al,
+                                                   x.base.base.loc,
+                                                   current_scope,
+                                                   x.m_assoc_name,
+                                                   nullptr,
+                                                   0,
+                                                   ASR::intentType::Local,
+                                                   nullptr,
+                                                   nullptr,
+                                                   ASR::storage_typeType::Default,
+                                                   nullptr,
+                                                   nullptr,
+                                                   ASR::abiType::Source,
+                                                   ASR::accessType::Public,
+                                                   ASR::presenceType::Required,
+                                                   false));
                 current_scope->add_symbol(std::string(x.m_assoc_name), assoc_sym);
                 assoc_variable = ASR::down_cast<ASR::Variable_t>(assoc_sym);
-            } else if( selector_variable ) {
+            } else if (selector_variable) {
                 assoc_variable = selector_variable;
             }
-            switch( x.m_body[i]->type ) {
+            switch (x.m_body[i]->type) {
                 case AST::type_stmtType::ClassStmt: {
                     AST::ClassStmt_t* class_stmt = AST::down_cast<AST::ClassStmt_t>(x.m_body[i]);
-                    ASR::symbol_t* sym = current_scope->resolve_symbol(to_lower(std::string(class_stmt->m_id)));
-                    if( assoc_variable ) {
+                    ASR::symbol_t* sym
+                        = current_scope->resolve_symbol(to_lower(std::string(class_stmt->m_id)));
+                    if (assoc_variable) {
                         ASR::ttype_t* selector_type = nullptr;
                         ASR::symbol_t* selector_m_type_declaration = nullptr;
                         ASR::symbol_t* sym_underlying = ASRUtils::symbol_get_past_external(sym);
-                        if( ASR::is_a<ASR::Struct_t>(*sym_underlying) ) {
-                            selector_type = ASRUtils::make_StructType_t_util(al, sym->base.loc, sym, !compiler_options.new_classes);
-                            selector_type = ASRUtils::make_Pointer_t_util(al, sym->base.loc, ASRUtils::extract_type(selector_type));
+                        if (ASR::is_a<ASR::Struct_t>(*sym_underlying)) {
+                            selector_type = ASRUtils::make_StructType_t_util(
+                                al, sym->base.loc, sym, !compiler_options.new_classes);
+                            selector_type = ASRUtils::make_Pointer_t_util(
+                                al, sym->base.loc, ASRUtils::extract_type(selector_type));
                             selector_m_type_declaration = sym;
                         } else {
                             diag.add(Diagnostic(
                                 "Only class and derived type in select type test expressions.",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{class_stmt->base.base.loc})
-                                }));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { class_stmt->base.base.loc }) }));
                             throw SemanticAbort();
                         }
                         SetChar assoc_deps;
                         assoc_deps.reserve(al, 1);
-                        ASRUtils::collect_variable_dependencies(al, assoc_deps, selector_type, nullptr, nullptr, ASRUtils::symbol_name(sym_underlying));
+                        ASRUtils::collect_variable_dependencies(
+                            al,
+                            assoc_deps,
+                            selector_type,
+                            nullptr,
+                            nullptr,
+                            ASRUtils::symbol_name(sym_underlying));
                         assoc_variable->m_dependencies = assoc_deps.p;
                         assoc_variable->n_dependencies = assoc_deps.size();
                         assoc_variable->m_type = selector_type;
@@ -2235,16 +2640,24 @@ public:
                     }
                     Vec<ASR::stmt_t*> class_stmt_body;
                     class_stmt_body.reserve(al, class_stmt->n_body);
-                    if( assoc_sym ) {
-                        class_stmt_body.push_back(al, ASRUtils::STMT(ASRUtils::make_Associate_t_util(al,
-                            class_stmt->base.base.loc, ASRUtils::EXPR(ASR::make_Var_t(al,
-                            class_stmt->base.base.loc, assoc_sym)), m_selector)) );
+                    if (assoc_sym) {
+                        class_stmt_body.push_back(
+                            al,
+                            ASRUtils::STMT(ASRUtils::make_Associate_t_util(
+                                al,
+                                class_stmt->base.base.loc,
+                                ASRUtils::EXPR(
+                                    ASR::make_Var_t(al, class_stmt->base.base.loc, assoc_sym)),
+                                m_selector)));
                     }
                     std::string block_name = parent_scope->get_unique_name("~select_type_block_");
-                    ASR::symbol_t* block_sym = ASR::down_cast<ASR::symbol_t>(ASR::make_Block_t(
-                                                    al, class_stmt->base.base.loc,
-                                                    current_scope, s2c(al, block_name),
-                                                    nullptr, 0));
+                    ASR::symbol_t* block_sym
+                        = ASR::down_cast<ASR::symbol_t>(ASR::make_Block_t(al,
+                                                                          class_stmt->base.base.loc,
+                                                                          current_scope,
+                                                                          s2c(al, block_name),
+                                                                          nullptr,
+                                                                          0));
                     transform_stmts(class_stmt_body, class_stmt->n_body, class_stmt->m_body);
                     ASR::Block_t* block_t_ = ASR::down_cast<ASR::Block_t>(block_sym);
                     block_t_->m_body = class_stmt_body.p;
@@ -2252,9 +2665,16 @@ public:
                     parent_scope->add_symbol(block_name, block_sym);
                     Vec<ASR::stmt_t*> block_call_stmt;
                     block_call_stmt.reserve(al, 1);
-                    block_call_stmt.push_back(al, ASRUtils::STMT(ASR::make_BlockCall_t(al, class_stmt->base.base.loc, -1, block_sym)));
-                    select_type_body.push_back(al, ASR::down_cast<ASR::type_stmt_t>(ASR::make_ClassStmt_t(al,
-                        class_stmt->base.base.loc, sym, block_call_stmt.p, block_call_stmt.size())));
+                    block_call_stmt.push_back(al,
+                                              ASRUtils::STMT(ASR::make_BlockCall_t(
+                                                  al, class_stmt->base.base.loc, -1, block_sym)));
+                    select_type_body.push_back(al,
+                                               ASR::down_cast<ASR::type_stmt_t>(
+                                                   ASR::make_ClassStmt_t(al,
+                                                                         class_stmt->base.base.loc,
+                                                                         sym,
+                                                                         block_call_stmt.p,
+                                                                         block_call_stmt.size())));
                     if (!compiler_options.new_classes || x.m_assoc_name == nullptr) {
                         assoc_variable->m_type = selector_variable_type;
                         assoc_variable->m_type_declaration = select_variable_m_type_declaration;
@@ -2262,27 +2682,37 @@ public:
                     break;
                 }
                 case AST::type_stmtType::TypeStmtName: {
-                    AST::TypeStmtName_t* type_stmt_name = AST::down_cast<AST::TypeStmtName_t>(x.m_body[i]);
-                    ASR::symbol_t* sym = current_scope->resolve_symbol(to_lower(std::string(type_stmt_name->m_name)));
-                    if( assoc_variable ) {
+                    AST::TypeStmtName_t* type_stmt_name
+                        = AST::down_cast<AST::TypeStmtName_t>(x.m_body[i]);
+                    ASR::symbol_t* sym = current_scope->resolve_symbol(
+                        to_lower(std::string(type_stmt_name->m_name)));
+                    if (assoc_variable) {
                         ASR::ttype_t* selector_type = nullptr;
                         ASR::symbol_t* selector_m_type_declaration = nullptr;
                         ASR::symbol_t* sym_underlying = ASRUtils::symbol_get_past_external(sym);
-                        if( ASR::is_a<ASR::Struct_t>(*sym_underlying) ) {
-                            selector_type = ASRUtils::make_StructType_t_util(al, sym->base.loc, sym, true);
-                            selector_type = ASRUtils::make_Pointer_t_util(al, sym->base.loc, ASRUtils::extract_type(selector_type));
+                        if (ASR::is_a<ASR::Struct_t>(*sym_underlying)) {
+                            selector_type
+                                = ASRUtils::make_StructType_t_util(al, sym->base.loc, sym, true);
+                            selector_type = ASRUtils::make_Pointer_t_util(
+                                al, sym->base.loc, ASRUtils::extract_type(selector_type));
                             selector_m_type_declaration = sym;
                         } else {
                             diag.add(Diagnostic(
                                 "Only class and derived type in select type test expressions.",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{type_stmt_name->base.base.loc})
-                                }));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { type_stmt_name->base.base.loc }) }));
                             throw SemanticAbort();
                         }
                         SetChar assoc_deps;
                         assoc_deps.reserve(al, 1);
-                        ASRUtils::collect_variable_dependencies(al, assoc_deps, selector_type, nullptr, nullptr, ASRUtils::symbol_name(sym_underlying));
+                        ASRUtils::collect_variable_dependencies(
+                            al,
+                            assoc_deps,
+                            selector_type,
+                            nullptr,
+                            nullptr,
+                            ASRUtils::symbol_name(sym_underlying));
                         assoc_variable->m_dependencies = assoc_deps.p;
                         assoc_variable->n_dependencies = assoc_deps.size();
                         assoc_variable->m_type = selector_type;
@@ -2290,26 +2720,44 @@ public:
                     }
                     Vec<ASR::stmt_t*> type_stmt_name_body;
                     type_stmt_name_body.reserve(al, type_stmt_name->n_body);
-                    if( assoc_sym ) {
-                        type_stmt_name_body.push_back(al, ASRUtils::STMT(ASRUtils::make_Associate_t_util(al,
-                            type_stmt_name->base.base.loc, ASRUtils::EXPR(ASR::make_Var_t(al,
-                            type_stmt_name->base.base.loc, assoc_sym)), m_selector)) );
+                    if (assoc_sym) {
+                        type_stmt_name_body.push_back(
+                            al,
+                            ASRUtils::STMT(ASRUtils::make_Associate_t_util(
+                                al,
+                                type_stmt_name->base.base.loc,
+                                ASRUtils::EXPR(
+                                    ASR::make_Var_t(al, type_stmt_name->base.base.loc, assoc_sym)),
+                                m_selector)));
                     }
                     std::string block_name = parent_scope->get_unique_name("~select_type_block_");
-                    ASR::symbol_t* block_sym = ASR::down_cast<ASR::symbol_t>(ASR::make_Block_t(
-                                                    al, type_stmt_name->base.base.loc,
-                                                    current_scope, s2c(al, block_name),
-                                                    nullptr, 0));
-                    transform_stmts(type_stmt_name_body, type_stmt_name->n_body, type_stmt_name->m_body);
+                    ASR::symbol_t* block_sym = ASR::down_cast<ASR::symbol_t>(
+                        ASR::make_Block_t(al,
+                                          type_stmt_name->base.base.loc,
+                                          current_scope,
+                                          s2c(al, block_name),
+                                          nullptr,
+                                          0));
+                    transform_stmts(
+                        type_stmt_name_body, type_stmt_name->n_body, type_stmt_name->m_body);
                     ASR::Block_t* block_t_ = ASR::down_cast<ASR::Block_t>(block_sym);
                     block_t_->m_body = type_stmt_name_body.p;
                     block_t_->n_body = type_stmt_name_body.size();
                     parent_scope->add_symbol(block_name, block_sym);
                     Vec<ASR::stmt_t*> block_call_stmt;
                     block_call_stmt.reserve(al, 1);
-                    block_call_stmt.push_back(al, ASRUtils::STMT(ASR::make_BlockCall_t(al, type_stmt_name->base.base.loc, -1, block_sym)));
-                    select_type_body.push_back(al, ASR::down_cast<ASR::type_stmt_t>(ASR::make_TypeStmtName_t(al,
-                        type_stmt_name->base.base.loc, sym, block_call_stmt.p, block_call_stmt.size())));
+                    block_call_stmt.push_back(
+                        al,
+                        ASRUtils::STMT(ASR::make_BlockCall_t(
+                            al, type_stmt_name->base.base.loc, -1, block_sym)));
+                    select_type_body.push_back(
+                        al,
+                        ASR::down_cast<ASR::type_stmt_t>(
+                            ASR::make_TypeStmtName_t(al,
+                                                     type_stmt_name->base.base.loc,
+                                                     sym,
+                                                     block_call_stmt.p,
+                                                     block_call_stmt.size())));
                     if (!compiler_options.new_classes || x.m_assoc_name == nullptr) {
                         assoc_variable->m_type = selector_variable_type;
                         assoc_variable->m_type_declaration = select_variable_m_type_declaration;
@@ -2317,22 +2765,28 @@ public:
                     break;
                 }
                 case AST::type_stmtType::TypeStmtType: {
-                    AST::TypeStmtType_t* type_stmt_type = AST::down_cast<AST::TypeStmtType_t>(x.m_body[i]);
+                    AST::TypeStmtType_t* type_stmt_type
+                        = AST::down_cast<AST::TypeStmtType_t>(x.m_body[i]);
                     ASR::ttype_t* selector_type = nullptr;
                     ASR::ttype_t* selector_variable_type = nullptr;
-                    if( assoc_variable ) {
+                    if (assoc_variable) {
                         Vec<ASR::dimension_t> m_dims;
                         m_dims.reserve(al, 1);
                         std::string assoc_variable_name = std::string(assoc_variable->m_name);
-                        ASR::symbol_t *type_declaration;
+                        ASR::symbol_t* type_declaration;
                         selector_type = determine_type(type_stmt_type->base.base.loc,
                                                        assoc_variable_name,
-                                                       type_stmt_type->m_vartype, false, false, m_dims,
+                                                       type_stmt_type->m_vartype,
+                                                       false,
+                                                       false,
+                                                       m_dims,
                                                        nullptr,
-                                                       type_declaration, ASR::abiType::Source);
+                                                       type_declaration,
+                                                       ASR::abiType::Source);
                         SetChar assoc_deps;
                         assoc_deps.reserve(al, 1);
-                        ASRUtils::collect_variable_dependencies(al, assoc_deps, selector_type, nullptr, nullptr, assoc_variable_name);
+                        ASRUtils::collect_variable_dependencies(
+                            al, assoc_deps, selector_type, nullptr, nullptr, assoc_variable_name);
                         assoc_variable->m_dependencies = assoc_deps.p;
                         assoc_variable->n_dependencies = assoc_deps.size();
                         assoc_variable->m_type = selector_type;
@@ -2340,26 +2794,44 @@ public:
                     }
                     Vec<ASR::stmt_t*> type_stmt_type_body;
                     type_stmt_type_body.reserve(al, type_stmt_type->n_body);
-                    if( assoc_sym ) {
-                        type_stmt_type_body.push_back(al, ASRUtils::STMT(ASRUtils::make_Associate_t_util(al,
-                            type_stmt_type->base.base.loc, ASRUtils::EXPR(ASR::make_Var_t(al,
-                            type_stmt_type->base.base.loc, assoc_sym)), m_selector)) );
+                    if (assoc_sym) {
+                        type_stmt_type_body.push_back(
+                            al,
+                            ASRUtils::STMT(ASRUtils::make_Associate_t_util(
+                                al,
+                                type_stmt_type->base.base.loc,
+                                ASRUtils::EXPR(
+                                    ASR::make_Var_t(al, type_stmt_type->base.base.loc, assoc_sym)),
+                                m_selector)));
                     }
                     std::string block_name = parent_scope->get_unique_name("~select_type_block_");
-                    ASR::symbol_t* block_sym = ASR::down_cast<ASR::symbol_t>(ASR::make_Block_t(
-                                                    al, type_stmt_type->base.base.loc,
-                                                    current_scope, s2c(al, block_name),
-                                                    nullptr, 0));
-                    transform_stmts(type_stmt_type_body, type_stmt_type->n_body, type_stmt_type->m_body);
+                    ASR::symbol_t* block_sym = ASR::down_cast<ASR::symbol_t>(
+                        ASR::make_Block_t(al,
+                                          type_stmt_type->base.base.loc,
+                                          current_scope,
+                                          s2c(al, block_name),
+                                          nullptr,
+                                          0));
+                    transform_stmts(
+                        type_stmt_type_body, type_stmt_type->n_body, type_stmt_type->m_body);
                     ASR::Block_t* block_t_ = ASR::down_cast<ASR::Block_t>(block_sym);
                     block_t_->m_body = type_stmt_type_body.p;
                     block_t_->n_body = type_stmt_type_body.size();
                     parent_scope->add_symbol(block_name, block_sym);
                     Vec<ASR::stmt_t*> block_call_stmt;
                     block_call_stmt.reserve(al, 1);
-                    block_call_stmt.push_back(al, ASRUtils::STMT(ASR::make_BlockCall_t(al, type_stmt_type->base.base.loc, -1, block_sym)));
-                    select_type_body.push_back(al, ASR::down_cast<ASR::type_stmt_t>(ASR::make_TypeStmtType_t(al,
-                        type_stmt_type->base.base.loc, selector_type, block_call_stmt.p, block_call_stmt.size())));
+                    block_call_stmt.push_back(
+                        al,
+                        ASRUtils::STMT(ASR::make_BlockCall_t(
+                            al, type_stmt_type->base.base.loc, -1, block_sym)));
+                    select_type_body.push_back(
+                        al,
+                        ASR::down_cast<ASR::type_stmt_t>(
+                            ASR::make_TypeStmtType_t(al,
+                                                     type_stmt_type->base.base.loc,
+                                                     selector_type,
+                                                     block_call_stmt.p,
+                                                     block_call_stmt.size())));
                     assoc_variable->m_type = selector_variable_type;
                     assoc_variable->m_type_declaration = select_variable_m_type_declaration;
                     break;
@@ -2367,17 +2839,19 @@ public:
                 case AST::type_stmtType::ClassDefault: {
                     SymbolTable* current_scope_copy = current_scope;
                     current_scope = parent_scope;
-                    AST::ClassDefault_t* class_default = AST::down_cast<AST::ClassDefault_t>(x.m_body[i]);
-                    transform_stmts(select_type_default, class_default->n_body, class_default->m_body);
+                    AST::ClassDefault_t* class_default
+                        = AST::down_cast<AST::ClassDefault_t>(x.m_body[i]);
+                    transform_stmts(
+                        select_type_default, class_default->n_body, class_default->m_body);
                     current_scope = current_scope_copy;
                     break;
                 }
                 default: {
-                    diag.add(Diagnostic(
-                        std::to_string(x.m_body[i]->type) + " statement not supported yet in select type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.m_body[i]->base.loc})
-                        }));
+                    diag.add(Diagnostic(std::to_string(x.m_body[i]->type)
+                                            + " statement not supported yet in select type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.m_body[i]->base.loc }) }));
                     throw SemanticAbort();
                 }
             }
@@ -2388,22 +2862,28 @@ public:
         selector_variable->m_dependencies = selector_variable_dependencies;
         selector_variable->n_dependencies = selector_variable_n_dependencies;
 
-        tmp = ASR::make_SelectType_t(al, x.base.base.loc, m_selector, x.m_assoc_name,
-                                     select_type_body.p, select_type_body.size(),
-                                     select_type_default.p, select_type_default.size());
+        tmp = ASR::make_SelectType_t(al,
+                                     x.base.base.loc,
+                                     m_selector,
+                                     x.m_assoc_name,
+                                     select_type_body.p,
+                                     select_type_body.size(),
+                                     select_type_default.p,
+                                     select_type_default.size());
     }
 
     template <typename T>
-    void visit_SubmoduleModuleCommon(const T& x) {
-        SymbolTable *old_scope = current_scope;
-        ASR::symbol_t *t = current_scope->get_symbol(to_lower(x.m_name));
-        ASR::Module_t *v = ASR::down_cast<ASR::Module_t>(t);
+    void visit_SubmoduleModuleCommon(const T& x)
+    {
+        SymbolTable* old_scope = current_scope;
+        ASR::symbol_t* t = current_scope->get_symbol(to_lower(x.m_name));
+        ASR::Module_t* v = ASR::down_cast<ASR::Module_t>(t);
         current_module_dependencies.clear(al);
         current_scope = v->m_symtab;
         current_module = v;
 
-        for (size_t i=0; i<x.n_decl; i++) {
-            if(x.m_decl[i]->type == AST::unit_decl2Type::Template){
+        for (size_t i = 0; i < x.n_decl; i++) {
+            if (x.m_decl[i]->type == AST::unit_decl2Type::Template) {
                 visit_unit_decl2(*x.m_decl[i]);
             }
         }
@@ -2411,25 +2891,25 @@ public:
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         auto& scope_data = data_structure[current_scope->counter];
-        if (scope_data.size()>0) {
-            for(auto it: scope_data) {
+        if (scope_data.size() > 0) {
+            for (auto it : scope_data) {
                 body.push_back(al, it);
             }
         }
         scope_data.clear();
 
         transform_stmts(body, x.n_body, x.m_body);
-        // We have to visit unit_decl_2 because in the example, the Template is directly inside the module and
-        // Template is a unit_decl_2
+        // We have to visit unit_decl_2 because in the example, the Template is directly inside the
+        // module and Template is a unit_decl_2
 
-        for (size_t i=0; i<x.n_contains; i++) {
+        for (size_t i = 0; i < x.n_contains; i++) {
             visit_program_unit(*x.m_contains[i]);
         }
 
-        if( current_module_dependencies.size() > 0 ) {
+        if (current_module_dependencies.size() > 0) {
             SetChar module_dependencies;
             module_dependencies.from_pointer_n_copy(al, v->m_dependencies, v->n_dependencies);
-            for( size_t i = 0; i < current_module_dependencies.size(); i++ ) {
+            for (size_t i = 0; i < current_module_dependencies.size(); i++) {
                 module_dependencies.push_back(al, current_module_dependencies[i]);
             }
             v->m_dependencies = module_dependencies.p;
@@ -2441,20 +2921,24 @@ public:
         tmp = nullptr;
     }
 
-    void visit_Submodule(const AST::Submodule_t &x) {
+    void visit_Submodule(const AST::Submodule_t& x)
+    {
         visit_SubmoduleModuleCommon(x);
     }
 
-    void visit_Module(const AST::Module_t &x) {
+    void visit_Module(const AST::Module_t& x)
+    {
         visit_SubmoduleModuleCommon(x);
     }
 
-    void visit_Use(const AST::Use_t& /* x */) {
+    void visit_Use(const AST::Use_t& /* x */)
+    {
         // handled in symbol table visitor
     }
-    void remove_common_variable_declarations(SymbolTable* current_scope) {
-        // iterate over all symbols in symbol table and check if any of them is present in common_variables_hash
-        // if yes, then remove it from scope
+    void remove_common_variable_declarations(SymbolTable* current_scope)
+    {
+        // iterate over all symbols in symbol table and check if any of them is present in
+        // common_variables_hash if yes, then remove it from scope
         std::map<std::string, ASR::symbol_t*> syms = current_scope->get_scope();
         for (auto it = syms.begin(); it != syms.end(); ++it) {
             if (ASR::is_a<ASR::Variable_t>(*(it->second))) {
@@ -2468,27 +2952,28 @@ public:
     }
 
 
-    void visit_Program(const AST::Program_t &x) {
+    void visit_Program(const AST::Program_t& x)
+    {
         program_count++;
         if (program_count >= 2) {
-        return;  // Just skip 
+            return;  // Just skip
         }
-        SymbolTable *old_scope = current_scope;
-        ASR::symbol_t *t = current_scope->get_symbol(to_lower(x.m_name));
-        ASR::Program_t *v = ASR::down_cast<ASR::Program_t>(t);
+        SymbolTable* old_scope = current_scope;
+        ASR::symbol_t* t = current_scope->get_symbol(to_lower(x.m_name));
+        ASR::Program_t* v = ASR::down_cast<ASR::Program_t>(t);
         current_scope = v->m_symtab;
         starting_m_body = x.m_body;
         starting_n_body = x.n_body;
 
-        for (size_t i=0; i<x.n_decl; i++) {
+        for (size_t i = 0; i < x.n_decl; i++) {
             visit_unit_decl2(*x.m_decl[i]);
         }
 
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         auto& scope_data_prog = data_structure[current_scope->counter];
-        if (scope_data_prog.size()>0) {
-            for(auto it: scope_data_prog) {
+        if (scope_data_prog.size() > 0) {
+            for (auto it : scope_data_prog) {
                 body.push_back(al, it);
             }
         }
@@ -2499,86 +2984,105 @@ public:
         v->m_body = body.p;
         v->n_body = body.size();
 
-        replace_ArrayItem_in_SubroutineCall(al, compiler_options.legacy_array_sections, current_scope);
+        replace_ArrayItem_in_SubroutineCall(
+            al, compiler_options.legacy_array_sections, current_scope);
 
-        for (size_t i=0; i<x.n_contains; i++) {
+        for (size_t i = 0; i < x.n_contains; i++) {
             visit_program_unit(*x.m_contains[i]);
         }
 
-        ASRUtils::update_call_args(al, current_scope, compiler_options.implicit_interface, changed_external_function_symbol);
+        ASRUtils::update_call_args(al,
+                                   current_scope,
+                                   compiler_options.implicit_interface,
+                                   changed_external_function_symbol);
 
         starting_m_body = nullptr;
-        starting_n_body =  0;
+        starting_n_body = 0;
         remove_common_variable_declarations(current_scope);
         current_scope = old_scope;
         tmp = nullptr;
     }
 
-    ASR::stmt_t* create_implicit_deallocate_subrout_call(ASR::stmt_t* x) {
+    ASR::stmt_t* create_implicit_deallocate_subrout_call(ASR::stmt_t* x)
+    {
         ASR::SubroutineCall_t* subrout_call = ASR::down_cast<ASR::SubroutineCall_t>(x);
         const ASR::symbol_t* subrout_sym = ASRUtils::symbol_get_past_external(subrout_call->m_name);
-        if( ! ASR::is_a<ASR::Function_t>(*subrout_sym)
-            || ASR::down_cast<ASR::Function_t>(subrout_sym)->m_return_var != nullptr ) {
+        if (!ASR::is_a<ASR::Function_t>(*subrout_sym)
+            || ASR::down_cast<ASR::Function_t>(subrout_sym)->m_return_var != nullptr) {
             return nullptr;
         }
         ASR::Function_t* subrout = ASR::down_cast<ASR::Function_t>(subrout_sym);
         Vec<ASR::expr_t*> del_syms;
         del_syms.reserve(al, 1);
-        for( size_t i = 0; i < subrout_call->n_args; i++ ) {
-            if( subrout_call->m_args[i].m_value &&
-                subrout_call->m_args[i].m_value->type == ASR::exprType::Var ) {
-                const ASR::Var_t* arg_var = ASR::down_cast<ASR::Var_t>(subrout_call->m_args[i].m_value);
+        for (size_t i = 0; i < subrout_call->n_args; i++) {
+            if (subrout_call->m_args[i].m_value
+                && subrout_call->m_args[i].m_value->type == ASR::exprType::Var) {
+                const ASR::Var_t* arg_var
+                    = ASR::down_cast<ASR::Var_t>(subrout_call->m_args[i].m_value);
                 const ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(arg_var->m_v);
-                if( sym->type == ASR::symbolType::Variable ) {
+                if (sym->type == ASR::symbolType::Variable) {
                     ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(sym);
                     const ASR::Var_t* orig_arg_var = ASR::down_cast<ASR::Var_t>(subrout->m_args[i]);
-                    const ASR::symbol_t* orig_sym = ASRUtils::symbol_get_past_external(orig_arg_var->m_v);
+                    const ASR::symbol_t* orig_sym
+                        = ASRUtils::symbol_get_past_external(orig_arg_var->m_v);
                     ASR::Variable_t* orig_var = ASR::down_cast<ASR::Variable_t>(orig_sym);
-                    if( ASR::is_a<ASR::Allocatable_t>(*var->m_type) &&
-                        ASR::is_a<ASR::Allocatable_t>(*orig_var->m_type) &&
-                        orig_var->m_intent == ASR::intentType::Out ) {
-                        del_syms.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, x->base.loc, arg_var->m_v)));
+                    if (ASR::is_a<ASR::Allocatable_t>(*var->m_type)
+                        && ASR::is_a<ASR::Allocatable_t>(*orig_var->m_type)
+                        && orig_var->m_intent == ASR::intentType::Out) {
+                        del_syms.push_back(
+                            al, ASRUtils::EXPR(ASR::make_Var_t(al, x->base.loc, arg_var->m_v)));
                     }
                     // Check struct-type members
                     if (ASR::is_a<ASR::StructType_t>(*ASRUtils::symbol_type(sym))
                         && !ASRUtils::is_class_type(ASRUtils::symbol_type(sym))
-                        && ASR::down_cast<ASR::Variable_t>(orig_sym)->m_intent == ASR::intentType::Out) {
+                        && ASR::down_cast<ASR::Variable_t>(orig_sym)->m_intent
+                               == ASR::intentType::Out) {
                         ASR::Struct_t* struct_type = ASR::down_cast<ASR::Struct_t>(
                             ASRUtils::symbol_get_past_external(var->m_type_declaration));
                         SymbolTable* sym_table_of_struct = struct_type->m_symtab;
-                        for(auto struct_member : sym_table_of_struct->get_scope()){
-                            if(ASR::is_a<ASR::Variable_t>(*struct_member.second) &&
-                                ASRUtils::is_allocatable(ASRUtils::symbol_type(struct_member.second))){
-                                del_syms.push_back(al, ASRUtils::EXPR(
-                                    ASRUtils::getStructInstanceMember_t(al,subrout_call->m_args[i].m_value->base.loc,
-                                    (ASR::asr_t*)subrout_call->m_args[i].m_value,
-                                    const_cast<ASR::symbol_t*>(sym), struct_member.second, current_scope)));
+                        for (auto struct_member : sym_table_of_struct->get_scope()) {
+                            if (ASR::is_a<ASR::Variable_t>(*struct_member.second)
+                                && ASRUtils::is_allocatable(
+                                    ASRUtils::symbol_type(struct_member.second))) {
+                                del_syms.push_back(
+                                    al,
+                                    ASRUtils::EXPR(ASRUtils::getStructInstanceMember_t(
+                                        al,
+                                        subrout_call->m_args[i].m_value->base.loc,
+                                        (ASR::asr_t*) subrout_call->m_args[i].m_value,
+                                        const_cast<ASR::symbol_t*>(sym),
+                                        struct_member.second,
+                                        current_scope)));
                             }
                         }
                     }
                 }
             }
         }
-        if( del_syms.size() == 0 ) {
+        if (del_syms.size() == 0) {
             return nullptr;
         }
-        return ASRUtils::STMT(ASR::make_ImplicitDeallocate_t(al, x->base.loc,
-                    del_syms.p, del_syms.size()));
+        return ASRUtils::STMT(
+            ASR::make_ImplicitDeallocate_t(al, x->base.loc, del_syms.p, del_syms.size()));
     }
 
-    void visit_Entry(const AST::Entry_t& /*x*/) {
+    void visit_Entry(const AST::Entry_t& /*x*/)
+    {
         tmp = nullptr;
     }
 
-    void add_subroutine_call(const Location& loc, std::string entry_function_name, std::string parent_function_name,
-                            int label, bool is_function = false) {
+    void add_subroutine_call(const Location& loc,
+                             std::string entry_function_name,
+                             std::string parent_function_name,
+                             int label,
+                             bool is_function = false)
+    {
         ASR::symbol_t* entry_function_sym = current_scope->resolve_symbol(entry_function_name);
         if (entry_function_sym == nullptr) {
-            diag.add(Diagnostic(
-                "Entry function '" + entry_function_name + "' not defined",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+            diag.add(Diagnostic("Entry function '" + entry_function_name + "' not defined",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         if (ASR::is_a<ASR::Variable_t>(*entry_function_sym)) {
@@ -2590,11 +3094,10 @@ public:
         std::string master_function_name = parent_function_name + "_main__lcompilers";
         ASR::symbol_t* master_function_sym = current_scope->resolve_symbol(master_function_name);
         if (master_function_sym == nullptr) {
-            diag.add(Diagnostic(
-                "Master function '" + master_function_name + "' not defined",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+            diag.add(Diagnostic("Master function '" + master_function_name + "' not defined",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         ASR::Function_t* master_function = ASR::down_cast<ASR::Function_t>(master_function_sym);
@@ -2602,12 +3105,14 @@ public:
         // iterate over argument mapping of entry function, keep only those arguments
         // which are present at vector<int> index, rest all are 0
         std::vector<int> indices = entry_function_arguments_mapping[entry_function_name];
-        Vec<ASR::call_arg_t> args; args.reserve(al, master_function->n_args);
+        Vec<ASR::call_arg_t> args;
+        args.reserve(al, master_function->n_args);
 
         for (size_t i = 0; i < master_function->n_args; i++) {
             ASR::expr_t* arg = nullptr;
             if (i == 0) {
-                ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
+                ASR::ttype_t* int_type = ASRUtils::TYPE(
+                    ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
                 arg = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, label, int_type));
             } else if (std::find(indices.begin(), indices.end(), i) != indices.end()) {
                 ASR::expr_t* master_function_arg = master_function->m_args[i];
@@ -2631,26 +3136,38 @@ public:
                 } else if (ASR::is_a<ASR::Logical_t>(*raw_type)) {
                     arg = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, loc, false, raw_type));
                 } else if (ASR::is_a<ASR::String_t>(*raw_type)) {
-                    ASR::ttype_t* character_type = ASRUtils::TYPE(ASR::make_String_t(al, loc, 1,
-                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 0,
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                    ASR::ttype_t* character_type = ASRUtils::TYPE(ASR::make_String_t(
+                        al,
+                        loc,
+                        1,
+                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al, loc, 0, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
                         ASR::string_length_kindType::ExpressionLength,
                         ASR::string_physical_typeType::DescriptorString));
-                    arg = ASRUtils::EXPR(ASR::make_StringConstant_t(al, loc, s2c(al, ""), character_type));
+                    arg = ASRUtils::EXPR(
+                        ASR::make_StringConstant_t(al, loc, s2c(al, ""), character_type));
                 } else {
-                    diag.add(Diagnostic(
-                        "Argument type not supported yet",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+                    diag.add(Diagnostic("Argument type not supported yet",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 if (ASRUtils::is_array(type)) {
-                    Vec<ASR::dimension_t> dims; dims.reserve(al, 1);
-                    ASR::dimension_t dim; dim.loc = loc; dim.m_start = nullptr; dim.m_length = nullptr;
+                    Vec<ASR::dimension_t> dims;
+                    dims.reserve(al, 1);
+                    ASR::dimension_t dim;
+                    dim.loc = loc;
+                    dim.m_start = nullptr;
+                    dim.m_length = nullptr;
                     dims.push_back(al, dim);
-                    ASR::ttype_t* arr_type = ASRUtils::TYPE(ASR::make_Array_t(al, type->base.loc,
-                                            raw_type, dims.p, dims.n, ASR::array_physical_typeType::DescriptorArray));
+                    ASR::ttype_t* arr_type = ASRUtils::TYPE(
+                        ASR::make_Array_t(al,
+                                          type->base.loc,
+                                          raw_type,
+                                          dims.p,
+                                          dims.n,
+                                          ASR::array_physical_typeType::DescriptorArray));
                     type = ASRUtils::TYPE(ASR::make_Pointer_t(al, type->base.loc, arr_type));
                     // create a variable of type: type
                     std::string sym_name = "";
@@ -2658,34 +3175,69 @@ public:
                         ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(master_function_arg);
                         sym_name = ASRUtils::symbol_name(var->m_v);
                     }
-                    ASR::asr_t* var_asr = ASRUtils::make_Variable_t_util(al, master_function_arg->base.loc,
-                                            entry_function->m_symtab, s2c(al,sym_name), nullptr, 0, ASR::intentType::Local,
-                                            nullptr, nullptr, ASR::storage_typeType::Default, type, ASRUtils::get_struct_sym_from_struct_expr(master_function_arg), ASR::abiType::Source,
-                                            ASR::accessType::Public, ASR::presenceType::Required, false);
+                    ASR::asr_t* var_asr = ASRUtils::make_Variable_t_util(
+                        al,
+                        master_function_arg->base.loc,
+                        entry_function->m_symtab,
+                        s2c(al, sym_name),
+                        nullptr,
+                        0,
+                        ASR::intentType::Local,
+                        nullptr,
+                        nullptr,
+                        ASR::storage_typeType::Default,
+                        type,
+                        ASRUtils::get_struct_sym_from_struct_expr(master_function_arg),
+                        ASR::abiType::Source,
+                        ASR::accessType::Public,
+                        ASR::presenceType::Required,
+                        false);
                     ASR::symbol_t* var_sym = ASR::down_cast<ASR::symbol_t>(var_asr);
                     entry_function->m_symtab->add_or_overwrite_symbol(sym_name, var_sym);
                     arg = ASRUtils::EXPR(ASR::make_Var_t(al, loc, var_sym));
                 }
             }
-            ASR::call_arg_t call_arg; call_arg.loc = loc; call_arg.m_value = arg; args.push_back(al, call_arg);
+            ASR::call_arg_t call_arg;
+            call_arg.loc = loc;
+            call_arg.m_value = arg;
+            args.push_back(al, call_arg);
         }
 
         ASR::stmt_t* stmt = nullptr;
         if (is_function) {
             // make an assignment to the return variable of entry function
             ASR::expr_t* lhs = entry_function->m_return_var;
-            ASR::expr_t* rhs = ASRUtils::EXPR(ASR::make_FunctionCall_t(al, loc, master_function_sym,
-                                master_function_sym, args.p, args.n, ASRUtils::expr_type(lhs), nullptr, nullptr));
-
-            stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, loc, lhs, rhs, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+            ASR::expr_t* rhs = ASRUtils::EXPR(ASR::make_FunctionCall_t(al,
+                                                                       loc,
+                                                                       master_function_sym,
+                                                                       master_function_sym,
+                                                                       args.p,
+                                                                       args.n,
+                                                                       ASRUtils::expr_type(lhs),
+                                                                       nullptr,
+                                                                       nullptr));
+
+            stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(
+                al, loc, lhs, rhs, nullptr, compiler_options.po.realloc_lhs_arrays, false));
 
         } else {
-            stmt = ASRUtils::STMT(ASRUtils::make_SubroutineCall_t_util(al,loc, master_function_sym,
-                                        master_function_sym, args.p, args.n, nullptr, nullptr, compiler_options.implicit_argument_casting, current_scope, current_function_dependencies));
+            stmt = ASRUtils::STMT(
+                ASRUtils::make_SubroutineCall_t_util(al,
+                                                     loc,
+                                                     master_function_sym,
+                                                     master_function_sym,
+                                                     args.p,
+                                                     args.n,
+                                                     nullptr,
+                                                     nullptr,
+                                                     compiler_options.implicit_argument_casting,
+                                                     current_scope,
+                                                     current_function_dependencies));
         }
         LCOMPILERS_ASSERT(stmt != nullptr);
 
-        Vec<ASR::stmt_t*> body; body.reserve(al, entry_function->n_body + 1);
+        Vec<ASR::stmt_t*> body;
+        body.reserve(al, entry_function->n_body + 1);
         for (size_t i = 0; i < entry_function->n_body; i++) {
             body.push_back(al, entry_function->m_body[i]);
         }
@@ -2696,23 +3248,30 @@ public:
 
         // add master function to dependencies of entry function
         SetChar entry_function_dependencies;
-        entry_function_dependencies.from_pointer_n_copy(al, entry_function->m_dependencies, entry_function->n_dependencies);
+        entry_function_dependencies.from_pointer_n_copy(
+            al, entry_function->m_dependencies, entry_function->n_dependencies);
         entry_function_dependencies.push_back(al, s2c(al, master_function_name));
         entry_function->m_dependencies = entry_function_dependencies.p;
         entry_function->n_dependencies = entry_function_dependencies.size();
     }
 
-    void visit_stmts_helper(std::vector<AST::stmt_t*> ast_stmt_vector, std::vector<ASR::stmt_t*> &stmt_vector,
-                            std::vector<ASR::asr_t*> &tmp_vec, std::string original_function_name, ASR::expr_t* return_var,
-                            std::vector<ASR::stmt_t*> &after_return_stmt_entry_function, bool is_last = false, bool is_main_function = false) {
+    void visit_stmts_helper(std::vector<AST::stmt_t*> ast_stmt_vector,
+                            std::vector<ASR::stmt_t*>& stmt_vector,
+                            std::vector<ASR::asr_t*>& tmp_vec,
+                            std::string original_function_name,
+                            ASR::expr_t* return_var,
+                            std::vector<ASR::stmt_t*>& after_return_stmt_entry_function,
+                            bool is_last = false,
+                            bool is_main_function = false)
+    {
         bool return_encountered = false;
         bool entry_encountered = false;
-        for (auto &ast_stmt: ast_stmt_vector) {
+        for (auto& ast_stmt : ast_stmt_vector) {
             bool is_pushed = false;
             int64_t label = stmt_label(ast_stmt);
             if (label != 0) {
-                ASR::asr_t *l = ASR::make_GoToTarget_t(al, ast_stmt->base.loc, label,
-                                    s2c(al, std::to_string(label)));
+                ASR::asr_t* l = ASR::make_GoToTarget_t(
+                    al, ast_stmt->base.loc, label, s2c(al, std::to_string(label)));
                 // body.push_back(al, ASR::down_cast<ASR::stmt_t>(l));
                 if (is_main_function && return_encountered && !entry_encountered) {
                     after_return_stmt_entry_function.push_back(ASRUtils::STMT(l));
@@ -2754,12 +3313,22 @@ public:
                     if (ASR::is_a<ASR::Var_t>(*target)) {
                         ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(target);
                         std::string var_name = ASRUtils::symbol_name(var->m_v);
-                        if (original_function_name == var_name || (entry_functions[original_function_name].find(var_name) != entry_functions[original_function_name].end())) {
+                        if (original_function_name == var_name
+                            || (entry_functions[original_function_name].find(var_name)
+                                != entry_functions[original_function_name].end())) {
                             // this is an assignment to entry function return variable
                             // make an assignment to return variable of master function
                             if (return_var != nullptr) {
-                                ASR::expr_t* lhs = return_var; ASR::expr_t* rhs = assignment->m_value;
-                                ASR::stmt_t* stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, tmp_stmt->base.loc, lhs, rhs, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+                                ASR::expr_t* lhs = return_var;
+                                ASR::expr_t* rhs = assignment->m_value;
+                                ASR::stmt_t* stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(
+                                    al,
+                                    tmp_stmt->base.loc,
+                                    lhs,
+                                    rhs,
+                                    nullptr,
+                                    compiler_options.po.realloc_lhs_arrays,
+                                    false));
                                 tmp_stmt = stmt;
                             }
                         }
@@ -2785,7 +3354,7 @@ public:
                     return_encountered = true;
                 }
             } else if (!tmp_vec.empty()) {
-                for(auto &x: tmp_vec) {
+                for (auto& x : tmp_vec) {
                     stmt_vector.push_back(ASRUtils::STMT(x));
                 }
                 tmp_vec.clear();
@@ -2795,13 +3364,17 @@ public:
     }
 
     template <typename T>
-    void populate_master_function(const T& x, const Location &loc, std::string master_function_name) {
+    void populate_master_function(const T& x, const Location& loc, std::string master_function_name)
+    {
         // populate master function
-        std::string original_function_name = master_function_name.substr(0, master_function_name.find("_main__lcompilers"));
+        std::string original_function_name
+            = master_function_name.substr(0, master_function_name.find("_main__lcompilers"));
         ASR::symbol_t* master_function_sym = current_scope->resolve_symbol(master_function_name);
         ASR::Function_t* master_function = ASR::down_cast<ASR::Function_t>(master_function_sym);
 
-        std::vector<ASR::asr_t*> tmp_vector; std::vector<ASR::stmt_t*> stmt_vector; std::vector<ASR::stmt_t*> after_return_stmt_entry_function;
+        std::vector<ASR::asr_t*> tmp_vector;
+        std::vector<ASR::stmt_t*> stmt_vector;
+        std::vector<ASR::stmt_t*> after_return_stmt_entry_function;
         SetChar current_function_dependencies_copy = current_function_dependencies;
         current_function_dependencies.clear(al);
 
@@ -2810,50 +3383,74 @@ public:
         ASR::symbol_t* left_sym = master_function->m_symtab->resolve_symbol("entry__lcompilers");
         LCOMPILERS_ASSERT(left_sym != nullptr);
         left = ASRUtils::EXPR(ASR::make_Var_t(al, loc, left_sym));
-        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
-        ASR::ttype_t* logical_type = ASRUtils::TYPE(ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
+        ASR::ttype_t* int_type = ASRUtils::TYPE(
+            ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
+        ASR::ttype_t* logical_type = ASRUtils::TYPE(
+            ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
         int num_entry_functions = entry_functions[original_function_name].size();
-        for(int i = 0; i < num_entry_functions + 1; i++) {
+        for (int i = 0; i < num_entry_functions + 1; i++) {
             ASR::stmt_t* if_stmt = nullptr;
-            ASR::expr_t* right = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, i+1, int_type));
-            ASR::expr_t* cmp = ASRUtils::EXPR(ASR::make_IntegerCompare_t(al, loc, left, ASR::cmpopType::Eq, right,
-                                logical_type, nullptr));
-
-            Vec<ASR::stmt_t*> if_body; if_body.reserve(al, 1);
-            ASR::stmt_t* go_to_label = ASRUtils::STMT(ASR::make_GoTo_t(al, loc, i+1, s2c(al, std::to_string(i+1))));
+            ASR::expr_t* right
+                = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, i + 1, int_type));
+            ASR::expr_t* cmp = ASRUtils::EXPR(ASR::make_IntegerCompare_t(
+                al, loc, left, ASR::cmpopType::Eq, right, logical_type, nullptr));
+
+            Vec<ASR::stmt_t*> if_body;
+            if_body.reserve(al, 1);
+            ASR::stmt_t* go_to_label
+                = ASRUtils::STMT(ASR::make_GoTo_t(al, loc, i + 1, s2c(al, std::to_string(i + 1))));
             if_body.push_back(al, go_to_label);
 
-            if_stmt = ASRUtils::STMT(ASR::make_If_t(al, loc, nullptr, cmp, if_body.p, if_body.size(), nullptr, 0));
+            if_stmt = ASRUtils::STMT(
+                ASR::make_If_t(al, loc, nullptr, cmp, if_body.p, if_body.size(), nullptr, 0));
             stmt_vector.push_back(if_stmt);
         }
 
         // handle subroutine
         int go_to_target = 1;
-        ASR::stmt_t* go_to_target_stmt = ASRUtils::STMT(ASR::make_GoToTarget_t(al, loc, go_to_target, s2c(al, std::to_string(go_to_target))));
-        stmt_vector.push_back(go_to_target_stmt); go_to_target++;
+        ASR::stmt_t* go_to_target_stmt = ASRUtils::STMT(
+            ASR::make_GoToTarget_t(al, loc, go_to_target, s2c(al, std::to_string(go_to_target))));
+        stmt_vector.push_back(go_to_target_stmt);
+        go_to_target++;
 
         std::vector<AST::stmt_t*> subroutine_stmt_vector;
         for (size_t i = 0; i < x.n_body; i++) {
             subroutine_stmt_vector.push_back(x.m_body[i]);
         }
-        Vec<ASR::stmt_t*> master_function_body; master_function_body.reserve(al, stmt_vector.size());
+        Vec<ASR::stmt_t*> master_function_body;
+        master_function_body.reserve(al, stmt_vector.size());
         current_body = &master_function_body;
         SymbolTable* old_scope = current_scope;
         current_scope = master_function->m_symtab;
-        visit_stmts_helper(subroutine_stmt_vector, stmt_vector, tmp_vector, original_function_name, master_function->m_return_var, after_return_stmt_entry_function, false, true);
+        visit_stmts_helper(subroutine_stmt_vector,
+                           stmt_vector,
+                           tmp_vector,
+                           original_function_name,
+                           master_function->m_return_var,
+                           after_return_stmt_entry_function,
+                           false,
+                           true);
 
         // handle entry functions
-        for (auto &it: entry_functions[original_function_name]) {
-            go_to_target_stmt = ASRUtils::STMT(ASR::make_GoToTarget_t(al, loc, go_to_target, s2c(al, std::to_string(go_to_target))));
-            stmt_vector.push_back(go_to_target_stmt); go_to_target++;
+        for (auto& it : entry_functions[original_function_name]) {
+            go_to_target_stmt = ASRUtils::STMT(ASR::make_GoToTarget_t(
+                al, loc, go_to_target, s2c(al, std::to_string(go_to_target))));
+            stmt_vector.push_back(go_to_target_stmt);
+            go_to_target++;
             // check if it is last entry function
             bool is_last = it.first == entry_functions[original_function_name].rbegin()->first;
-            visit_stmts_helper(it.second, stmt_vector, tmp_vector, original_function_name, master_function->m_return_var, after_return_stmt_entry_function, is_last);
-        }
-        for (auto &it: stmt_vector) {
+            visit_stmts_helper(it.second,
+                               stmt_vector,
+                               tmp_vector,
+                               original_function_name,
+                               master_function->m_return_var,
+                               after_return_stmt_entry_function,
+                               is_last);
+        }
+        for (auto& it : stmt_vector) {
             master_function_body.push_back(al, it);
         }
-        for (auto &it: after_return_stmt_entry_function) {
+        for (auto& it : after_return_stmt_entry_function) {
             master_function_body.push_back(al, it);
         }
 
@@ -2867,7 +3464,8 @@ public:
         current_scope = old_scope;
     }
 
-    void visit_Procedure(const AST::Procedure_t &x) {
+    void visit_Procedure(const AST::Procedure_t& x)
+    {
         SymbolTable* old_scope = current_scope;
         ASR::symbol_t* t = current_scope->get_symbol(to_lower(x.m_name));
         starting_m_body = x.m_body;
@@ -2879,8 +3477,8 @@ public:
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         auto& scope_data_sub = data_structure[current_scope->counter];
-        if (scope_data_sub.size()>0) {
-            for(auto it: scope_data_sub) {
+        if (scope_data_sub.size() > 0) {
+            for (auto it : scope_data_sub) {
                 body.push_back(al, it);
             }
         }
@@ -2891,7 +3489,7 @@ public:
         handle_format();
         SetChar func_deps;
         func_deps.from_pointer_n_copy(al, v->m_dependencies, v->n_dependencies);
-        for( auto& itr: current_function_dependencies ) {
+        for (auto& itr : current_function_dependencies) {
             func_deps.push_back(al, s2c(al, itr));
         }
         current_function_dependencies = current_function_dependencies_copy;
@@ -2907,15 +3505,16 @@ public:
         tmp = nullptr;
     }
 
-    void visit_Subroutine(const AST::Subroutine_t &x) {
-    // TODO: add SymbolTable::lookup_symbol(), which will automatically return
-    // an error
-    // TODO: add SymbolTable::get_symbol(), which will only check in Debug mode
-        SymbolTable *old_scope = current_scope;
-        ASR::symbol_t *t = current_scope->get_symbol(to_lower(x.m_name));
+    void visit_Subroutine(const AST::Subroutine_t& x)
+    {
+        // TODO: add SymbolTable::lookup_symbol(), which will automatically return
+        // an error
+        // TODO: add SymbolTable::get_symbol(), which will only check in Debug mode
+        SymbolTable* old_scope = current_scope;
+        ASR::symbol_t* t = current_scope->get_symbol(to_lower(x.m_name));
         starting_m_body = x.m_body;
         starting_n_body = x.n_body;
-        if( t->type == ASR::symbolType::GenericProcedure ) {
+        if (t->type == ASR::symbolType::GenericProcedure) {
             std::string subrout_name = to_lower(x.m_name) + "~genericprocedure";
             t = current_scope->get_symbol(subrout_name);
         }
@@ -2924,23 +3523,23 @@ public:
             t = ASRUtils::symbol_symtab(t)->get_symbol(to_lower(x.m_name));
         }
 
-        ASR::Function_t *v = ASR::down_cast<ASR::Function_t>(t);
+        ASR::Function_t* v = ASR::down_cast<ASR::Function_t>(t);
         current_scope = v->m_symtab;
-        for (size_t i=0; i<x.n_decl; i++) {
+        for (size_t i = 0; i < x.n_decl; i++) {
             is_Function = true;
-            if(x.m_decl[i]->type == AST::unit_decl2Type::Instantiate)
+            if (x.m_decl[i]->type == AST::unit_decl2Type::Instantiate)
                 visit_unit_decl2(*x.m_decl[i]);
             is_Function = false;
         }
         if (entry_functions.find(to_lower(v->m_name)) != entry_functions.end()) {
             /*
                 Subroutine is parent of entry function.
-                For all template functions, create a subroutine call to master function and add it to the body
-                of the subroutine.
+                For all template functions, create a subroutine call to master function and add it
+               to the body of the subroutine.
             */
             int label = 1;
             add_subroutine_call(x.base.base.loc, v->m_name, v->m_name, label++);
-            for (auto &it: entry_functions[v->m_name]) {
+            for (auto& it : entry_functions[v->m_name]) {
                 add_subroutine_call(x.base.base.loc, it.first, v->m_name, label++);
             }
             // populate master function
@@ -2957,8 +3556,8 @@ public:
         current_function_dependencies.clear(al);
         body.reserve(al, x.n_body);
         auto& scope_data_func = data_structure[current_scope->counter];
-        if (scope_data_func.size()>0) {
-            for(auto it: scope_data_func) {
+        if (scope_data_func.size() > 0) {
+            for (auto it : scope_data_func) {
                 body.push_back(al, it);
             }
         }
@@ -2967,7 +3566,7 @@ public:
         handle_format();
         SetChar func_deps;
         func_deps.from_pointer_n_copy(al, v->m_dependencies, v->n_dependencies);
-        for( auto& itr: current_function_dependencies ) {
+        for (auto& itr : current_function_dependencies) {
             func_deps.push_back(al, s2c(al, itr));
         }
         current_function_dependencies = current_function_dependencies_copy;
@@ -2976,13 +3575,17 @@ public:
         v->m_dependencies = func_deps.p;
         v->n_dependencies = func_deps.size();
 
-        replace_ArrayItem_in_SubroutineCall(al, compiler_options.legacy_array_sections, current_scope);
+        replace_ArrayItem_in_SubroutineCall(
+            al, compiler_options.legacy_array_sections, current_scope);
 
-        for (size_t i=0; i<x.n_contains; i++) {
+        for (size_t i = 0; i < x.n_contains; i++) {
             visit_program_unit(*x.m_contains[i]);
         }
 
-        ASRUtils::update_call_args(al, current_scope, compiler_options.implicit_interface, changed_external_function_symbol);
+        ASRUtils::update_call_args(al,
+                                   current_scope,
+                                   compiler_options.implicit_interface,
+                                   changed_external_function_symbol);
 
         starting_m_body = nullptr;
         starting_n_body = 0;
@@ -2991,12 +3594,13 @@ public:
         tmp = nullptr;
     }
 
-    void visit_Function(const AST::Function_t &x) {
+    void visit_Function(const AST::Function_t& x)
+    {
         starting_m_body = x.m_body;
         starting_n_body = x.n_body;
-        SymbolTable *old_scope = current_scope;
-        ASR::symbol_t *t = current_scope->get_symbol(to_lower(x.m_name));
-        if( t->type == ASR::symbolType::GenericProcedure ) {
+        SymbolTable* old_scope = current_scope;
+        ASR::symbol_t* t = current_scope->get_symbol(to_lower(x.m_name));
+        if (t->type == ASR::symbolType::GenericProcedure) {
             t = current_scope->get_symbol(to_lower(x.m_name) + "~genericprocedure");
         }
 
@@ -3004,17 +3608,17 @@ public:
             t = ASRUtils::symbol_symtab(t)->get_symbol(to_lower(x.m_name));
         }
 
-        ASR::Function_t *v = ASR::down_cast<ASR::Function_t>(t);
+        ASR::Function_t* v = ASR::down_cast<ASR::Function_t>(t);
         current_scope = v->m_symtab;
         if (entry_functions.find(to_lower(v->m_name)) != entry_functions.end()) {
             /*
                 Subroutine is parent of entry function.
-                For all template functions, create a subroutine call to master function and add it to the body
-                of the subroutine.
+                For all template functions, create a subroutine call to master function and add it
+               to the body of the subroutine.
             */
             int label = 1;
             add_subroutine_call(x.base.base.loc, v->m_name, v->m_name, label++, true);
-            for (auto &it: entry_functions[v->m_name]) {
+            for (auto& it : entry_functions[v->m_name]) {
                 add_subroutine_call(x.base.base.loc, it.first, v->m_name, label++, true);
             }
             // populate master function
@@ -3028,8 +3632,8 @@ public:
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         auto& scope_data_func2 = data_structure[current_scope->counter];
-        if (scope_data_func2.size()>0) {
-            for(auto it: scope_data_func2) {
+        if (scope_data_func2.size() > 0) {
+            for (auto it : scope_data_func2) {
                 body.push_back(al, it);
             }
         }
@@ -3040,7 +3644,7 @@ public:
         handle_format();
         SetChar func_deps;
         func_deps.from_pointer_n_copy(al, v->m_dependencies, v->n_dependencies);
-        for( auto& itr: current_function_dependencies ) {
+        for (auto& itr : current_function_dependencies) {
             func_deps.push_back(al, s2c(al, itr));
         }
         current_function_dependencies = current_function_dependencies_copy;
@@ -3049,20 +3653,24 @@ public:
         v->m_dependencies = func_deps.p;
         v->n_dependencies = func_deps.size();
 
-        replace_ArrayItem_in_SubroutineCall(al, compiler_options.legacy_array_sections, current_scope);
+        replace_ArrayItem_in_SubroutineCall(
+            al, compiler_options.legacy_array_sections, current_scope);
 
-        for (size_t i=0; i<x.n_contains; i++) {
+        for (size_t i = 0; i < x.n_contains; i++) {
             visit_program_unit(*x.m_contains[i]);
         }
 
-        for (size_t i=0; i<x.n_decl; i++) {
+        for (size_t i = 0; i < x.n_decl; i++) {
             is_Function = true;
-            if(x.m_decl[i]->type == AST::unit_decl2Type::Instantiate)
+            if (x.m_decl[i]->type == AST::unit_decl2Type::Instantiate)
                 visit_unit_decl2(*x.m_decl[i]);
             is_Function = false;
         }
 
-        ASRUtils::update_call_args(al, current_scope, compiler_options.implicit_interface, changed_external_function_symbol);
+        ASRUtils::update_call_args(al,
+                                   current_scope,
+                                   compiler_options.implicit_interface,
+                                   changed_external_function_symbol);
 
         starting_m_body = nullptr;
         starting_n_body = 0;
@@ -3071,33 +3679,47 @@ public:
         tmp = nullptr;
     }
 
-    void visit_Assign(const AST::Assign_t &x) {
-        std::string var_name = to_lower(std::string{x.m_variable});
-        ASR::symbol_t *sym = current_scope->resolve_symbol(var_name);
-        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+    void visit_Assign(const AST::Assign_t& x)
+    {
+        std::string var_name = to_lower(std::string{ x.m_variable });
+        ASR::symbol_t* sym = current_scope->resolve_symbol(var_name);
+        ASR::ttype_t* int_type = ASRUtils::TYPE(
+            ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
         if (!sym) {
             labels.insert(var_name);
             Str a_var_name_f;
             a_var_name_f.from_str(al, var_name);
             SetChar variable_dependencies_vec;
             variable_dependencies_vec.reserve(al, 1);
-            ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, int_type, nullptr, nullptr, var_name);
-            ASR::asr_t* a_variable = ASRUtils::make_Variable_t_util(al, x.base.base.loc, current_scope, a_var_name_f.c_str(al),
-                                                          variable_dependencies_vec.p, variable_dependencies_vec.size(),
-                                                          ASR::intentType::Local, nullptr, nullptr,
-                                                          ASR::storage_typeType::Default, int_type, nullptr,
-                                                          ASR::abiType::Source, ASR::Public, ASR::presenceType::Optional, false);
+            ASRUtils::collect_variable_dependencies(
+                al, variable_dependencies_vec, int_type, nullptr, nullptr, var_name);
+            ASR::asr_t* a_variable
+                = ASRUtils::make_Variable_t_util(al,
+                                                 x.base.base.loc,
+                                                 current_scope,
+                                                 a_var_name_f.c_str(al),
+                                                 variable_dependencies_vec.p,
+                                                 variable_dependencies_vec.size(),
+                                                 ASR::intentType::Local,
+                                                 nullptr,
+                                                 nullptr,
+                                                 ASR::storage_typeType::Default,
+                                                 int_type,
+                                                 nullptr,
+                                                 ASR::abiType::Source,
+                                                 ASR::Public,
+                                                 ASR::presenceType::Optional,
+                                                 false);
             current_scope->add_symbol(var_name, ASR::down_cast<ASR::symbol_t>(a_variable));
             sym = ASR::down_cast<ASR::symbol_t>(a_variable);
         } else {
             // symbol found but we need to have consistent types
             if (!ASR::is_a<ASR::Variable_t>(*sym)) {
-                diag.add(Diagnostic(
-                        "Assign target needs to be a variable.",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
-                    throw SemanticAbort();
+                diag.add(Diagnostic("Assign target needs to be a variable.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             }
 
             if (std::find(labels.begin(), labels.end(), var_name) == labels.end()) {
@@ -3111,9 +3733,17 @@ public:
 
         // ASSIGN XXX TO k -- XXX can only be integer for now.
         ASR::expr_t* target_var = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, sym));
-        ASR::expr_t* tmp_expr = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, x.m_assign_label, int_type));
+        ASR::expr_t* tmp_expr = ASRUtils::EXPR(
+            ASR::make_IntegerConstant_t(al, x.base.base.loc, x.m_assign_label, int_type));
         ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, target_var, tmp_expr);
-        tmp = (ASR::asr_t*)ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, x.base.base.loc, target_var, tmp_expr, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+        tmp = (ASR::asr_t*) ASRUtils::STMT(
+            ASRUtils::make_Assignment_t_util(al,
+                                             x.base.base.loc,
+                                             target_var,
+                                             tmp_expr,
+                                             nullptr,
+                                             compiler_options.po.realloc_lhs_arrays,
+                                             false));
     }
 
     /* Returns true if `x` is a statement function, false otherwise.
@@ -3126,19 +3756,21 @@ public:
     integer :: A(3, 5)
     A(i,j) = i*j
     */
-    bool is_statement_function( const AST::Assignment_t &x ) {
+    bool is_statement_function(const AST::Assignment_t& x)
+    {
         if (AST::is_a<AST::FuncCallOrArray_t>(*x.m_target)) {
-            // Look for the type of *x.m_target in symbol table, if it is integer, real, logical, or nullptr then it is a statement function
-            // unless it is being indexed as an array
-            AST::FuncCallOrArray_t *func_call_or_array = AST::down_cast<AST::FuncCallOrArray_t>(x.m_target);
+            // Look for the type of *x.m_target in symbol table, if it is integer, real, logical, or
+            // nullptr then it is a statement function unless it is being indexed as an array
+            AST::FuncCallOrArray_t* func_call_or_array
+                = AST::down_cast<AST::FuncCallOrArray_t>(x.m_target);
             if (func_call_or_array->n_member > 0) {
                 // This is part of a derived type, so it is not a statement function
                 return false;
             }
             std::string var_name = func_call_or_array->m_func;
             var_name = to_lower(var_name);
-            ASR::symbol_t *sym = current_scope->resolve_symbol(var_name);
-            if (sym==nullptr) {
+            ASR::symbol_t* sym = current_scope->resolve_symbol(var_name);
+            if (sym == nullptr) {
                 if (compiler_options.implicit_typing) {
                     return true;
                 } else {
@@ -3147,7 +3779,8 @@ public:
             } else {
                 if (ASR::is_a<ASR::Variable_t>(*sym)) {
                     auto v = ASR::down_cast<ASR::Variable_t>(sym);
-                    if (ASR::is_a<ASR::Integer_t>(*v->m_type) || ASR::is_a<ASR::Real_t>(*v->m_type) || ASR::is_a<ASR::Logical_t>(*v->m_type)
+                    if (ASR::is_a<ASR::Integer_t>(*v->m_type) || ASR::is_a<ASR::Real_t>(*v->m_type)
+                        || ASR::is_a<ASR::Logical_t>(*v->m_type)
                         || ASR::is_a<ASR::Complex_t>(*v->m_type)) {
                         if (ASRUtils::is_array(v->m_type)) {
                             return false;
@@ -3159,8 +3792,9 @@ public:
                                     no_array_sections = false;
                                     break;
                                 }
-                                if ( func_call_or_array->m_args[i].m_end != nullptr &&
-                                     AST::is_a<AST::Num_t>(*func_call_or_array->m_args[i].m_end) ) {
+                                if (func_call_or_array->m_args[i].m_end != nullptr
+                                    && AST::is_a<AST::Num_t>(
+                                        *func_call_or_array->m_args[i].m_end)) {
                                     constant_args = true;
                                     break;
                                 }
@@ -3186,30 +3820,30 @@ public:
         }
     }
 
-    void create_statement_function(const AST::Assignment_t &x) {
+    void create_statement_function(const AST::Assignment_t& x)
+    {
         current_function_dependencies.clear(al);
-        SymbolTable *parent_scope = current_scope;
+        SymbolTable* parent_scope = current_scope;
         current_scope = al.make_new<SymbolTable>(parent_scope);
 
-        //create a new function, and add it to the symbol table
+        // create a new function, and add it to the symbol table
         std::string var_name = to_lower(AST::down_cast<AST::FuncCallOrArray_t>(x.m_target)->m_func);
         auto v = AST::down_cast<AST::FuncCallOrArray_t>(x.m_target);
 
         Vec<ASR::expr_t*> args;
         args.reserve(al, v->n_args);
 
-        for (size_t i=0; i<v->n_args; i++) {
+        for (size_t i = 0; i < v->n_args; i++) {
             visit_expr(*(v->m_args[i]).m_end);
-            ASR::expr_t *end = ASRUtils::EXPR(tmp);
+            ASR::expr_t* end = ASRUtils::EXPR(tmp);
             ASR::Var_t* tmp_var;
             if (ASR::is_a<ASR::Var_t>(*end)) {
                 tmp_var = ASR::down_cast<ASR::Var_t>(end);
             } else {
-                diag.add(Diagnostic(
-                    "Statement function can only contain variables as arguments.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Statement function can only contain variables as arguments.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
 
@@ -3218,37 +3852,53 @@ public:
             arg_name = to_lower(arg_name);
             SetChar variable_dependencies_vec;
             variable_dependencies_vec.reserve(al, 1);
-            ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, ASRUtils::expr_type(end), nullptr, nullptr, arg_name);
-            ASR::asr_t *arg_var = ASRUtils::make_Variable_t_util(al, x.base.base.loc,
-                current_scope, s2c(al, arg_name),
-                variable_dependencies_vec.p, variable_dependencies_vec.size(),
-                ASRUtils::intent_in, nullptr, nullptr,
-                ASR::storage_typeType::Default, ASRUtils::expr_type(end), ASRUtils::get_struct_sym_from_struct_expr(end),
-                ASR::abiType::Source, ASR::Public, ASR::presenceType::Required,
-                false);
+            ASRUtils::collect_variable_dependencies(al,
+                                                    variable_dependencies_vec,
+                                                    ASRUtils::expr_type(end),
+                                                    nullptr,
+                                                    nullptr,
+                                                    arg_name);
+            ASR::asr_t* arg_var
+                = ASRUtils::make_Variable_t_util(al,
+                                                 x.base.base.loc,
+                                                 current_scope,
+                                                 s2c(al, arg_name),
+                                                 variable_dependencies_vec.p,
+                                                 variable_dependencies_vec.size(),
+                                                 ASRUtils::intent_in,
+                                                 nullptr,
+                                                 nullptr,
+                                                 ASR::storage_typeType::Default,
+                                                 ASRUtils::expr_type(end),
+                                                 ASRUtils::get_struct_sym_from_struct_expr(end),
+                                                 ASR::abiType::Source,
+                                                 ASR::Public,
+                                                 ASR::presenceType::Required,
+                                                 false);
             if (compiler_options.implicit_typing) {
-                current_scope->add_or_overwrite_symbol(arg_name, ASR::down_cast<ASR::symbol_t>(arg_var));
+                current_scope->add_or_overwrite_symbol(arg_name,
+                                                       ASR::down_cast<ASR::symbol_t>(arg_var));
             } else {
                 current_scope->add_symbol(arg_name, ASR::down_cast<ASR::symbol_t>(arg_var));
             }
-            args.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc,
-                current_scope->get_symbol(arg_name))));
+            args.push_back(al,
+                           ASRUtils::EXPR(ASR::make_Var_t(
+                               al, x.base.base.loc, current_scope->get_symbol(arg_name))));
         }
 
         // extract the type of var_name from symbol table
-        ASR::symbol_t *sym = current_scope->resolve_symbol(var_name);
-        ASR::ttype_t *type = nullptr;
+        ASR::symbol_t* sym = current_scope->resolve_symbol(var_name);
+        ASR::ttype_t* type = nullptr;
 
-        if (sym==nullptr) {
+        if (sym == nullptr) {
             if (compiler_options.implicit_typing) {
                 implicit_dictionary = implicit_mapping[get_hash(parent_scope->asr_owner)];
                 type = implicit_dictionary[std::string(1, to_lower(var_name)[0])];
             } else {
-                diag.add(Diagnostic(
-                    "Statement function needs to be declared.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Statement function needs to be declared.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         } else {
@@ -3259,54 +3909,88 @@ public:
         std::string return_var_name = var_name + "_return_var_name";
         SetChar variable_dependencies_vec;
         variable_dependencies_vec.reserve(al, 1);
-        ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type, nullptr, nullptr, return_var_name);
-        ASR::asr_t *return_var = ASRUtils::make_Variable_t_util(al, x.base.base.loc,
-            current_scope, s2c(al, return_var_name),
-            variable_dependencies_vec.p, variable_dependencies_vec.size(),
-            ASRUtils::intent_return_var, nullptr, nullptr,
-            ASR::storage_typeType::Default, type, sym,
-            ASR::abiType::Source, ASR::Public, ASR::presenceType::Required,
-            false);
+        ASRUtils::collect_variable_dependencies(
+            al, variable_dependencies_vec, type, nullptr, nullptr, return_var_name);
+        ASR::asr_t* return_var = ASRUtils::make_Variable_t_util(al,
+                                                                x.base.base.loc,
+                                                                current_scope,
+                                                                s2c(al, return_var_name),
+                                                                variable_dependencies_vec.p,
+                                                                variable_dependencies_vec.size(),
+                                                                ASRUtils::intent_return_var,
+                                                                nullptr,
+                                                                nullptr,
+                                                                ASR::storage_typeType::Default,
+                                                                type,
+                                                                sym,
+                                                                ASR::abiType::Source,
+                                                                ASR::Public,
+                                                                ASR::presenceType::Required,
+                                                                false);
         current_scope->add_symbol(return_var_name, ASR::down_cast<ASR::symbol_t>(return_var));
-        ASR::expr_t* to_return = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc,
-            ASR::down_cast<ASR::symbol_t>(return_var)));
-
-        tmp = ASRUtils::make_Function_t_util(
-            al, x.base.base.loc,
-            /* a_symtab */ current_scope,
-            /* a_name */ s2c(al, var_name),
-            /* m_dependency */ nullptr,
-            /* n_dependency */ 0,
-            /* a_args */ args.p,
-            /* n_args */ args.size(),
-            /* a_body */ nullptr,
-            /* n_body */ 0,
-            /* a_return_var */ to_return,
-            ASR::abiType::Source, ASR::accessType::Public, ASR::deftypeType::Implementation,
-            nullptr, false, false, false, false, false, nullptr, 0,
-            false, false, false);
+        ASR::expr_t* to_return = ASRUtils::EXPR(
+            ASR::make_Var_t(al, x.base.base.loc, ASR::down_cast<ASR::symbol_t>(return_var)));
+
+        tmp = ASRUtils::make_Function_t_util(al,
+                                             x.base.base.loc,
+                                             /* a_symtab */ current_scope,
+                                             /* a_name */ s2c(al, var_name),
+                                             /* m_dependency */ nullptr,
+                                             /* n_dependency */ 0,
+                                             /* a_args */ args.p,
+                                             /* n_args */ args.size(),
+                                             /* a_body */ nullptr,
+                                             /* n_body */ 0,
+                                             /* a_return_var */ to_return,
+                                             ASR::abiType::Source,
+                                             ASR::accessType::Public,
+                                             ASR::deftypeType::Implementation,
+                                             nullptr,
+                                             false,
+                                             false,
+                                             false,
+                                             false,
+                                             false,
+                                             nullptr,
+                                             0,
+                                             false,
+                                             false,
+                                             false);
         ASR::symbol_t* fn_sym = ASR::down_cast<ASR::symbol_t>(tmp);
         parent_scope->add_or_overwrite_symbol(var_name, fn_sym);
 
         Vec<ASR::stmt_t*> body;
         body.reserve(al, 1);
         this->visit_expr(*x.m_value);
-        ASR::expr_t *value = ASRUtils::EXPR(tmp);
-        ImplicitCastRules::set_converted_value(al, x.base.base.loc, &value,
-                                        ASRUtils::expr_type(value),ASRUtils::expr_type(to_return), diag);
-        if (!ASRUtils::check_equal_type(ASRUtils::expr_type(to_return),
-                                    ASRUtils::expr_type(value), to_return, value)) {
-            std::string ltype = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(to_return), to_return);
-            std::string rtype = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(value), value);
+        ASR::expr_t* value = ASRUtils::EXPR(tmp);
+        ImplicitCastRules::set_converted_value(al,
+                                               x.base.base.loc,
+                                               &value,
+                                               ASRUtils::expr_type(value),
+                                               ASRUtils::expr_type(to_return),
+                                               diag);
+        if (!ASRUtils::check_equal_type(
+                ASRUtils::expr_type(to_return), ASRUtils::expr_type(value), to_return, value)) {
+            std::string ltype
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(to_return), to_return);
+            std::string rtype
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(value), value);
             diag.semantic_error_label(
                 "Type mismatch in statement function, the types must be compatible",
-                {to_return->base.loc, value->base.loc},
-                "type mismatch (" + ltype + " and " + rtype + ")"
-            );
+                { to_return->base.loc, value->base.loc },
+                "type mismatch (" + ltype + " and " + rtype + ")");
             throw SemanticAbort();
         }
         ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, to_return, value);
-        body.push_back(al, ASR::down_cast<ASR::stmt_t>(ASRUtils::make_Assignment_t_util(al, x.base.base.loc, to_return, value, nullptr, compiler_options.po.realloc_lhs_arrays, false)));
+        body.push_back(al,
+                       ASR::down_cast<ASR::stmt_t>(
+                           ASRUtils::make_Assignment_t_util(al,
+                                                            x.base.base.loc,
+                                                            to_return,
+                                                            value,
+                                                            nullptr,
+                                                            compiler_options.po.realloc_lhs_arrays,
+                                                            false)));
 
         ASR::Function_t* fn = ASR::down_cast<ASR::Function_t>(fn_sym);
         fn->m_body = body.p;
@@ -3320,19 +4004,25 @@ public:
     /**
      * Checks compatibility between target and value arrays for assignment operations.
      *
-     * This function verifies that the target and value arrays are compatible for assignment by ensuring
+     * This function verifies that the target and value arrays are compatible for assignment by
+     * ensuring
      * - they have the same rank and
      * - (if applicable) dimensions.
      * and throws a semantic error if otherwise
      */
-    void check_ArrayAssignmentCompatibility(ASR::expr_t* target, ASR::expr_t* value, const AST::Assignment_t &x) {
-        ASR::ttype_t *target_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(target));
-        ASR::ttype_t *value_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(value));
+    void check_ArrayAssignmentCompatibility(ASR::expr_t* target,
+                                            ASR::expr_t* value,
+                                            const AST::Assignment_t& x)
+    {
+        ASR::ttype_t* target_type
+            = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(target));
+        ASR::ttype_t* value_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(value));
         // we don't want to check by "check_equal_type" because we want to allow
         // real :: x(4); x = [1, 2, 3, 4] to be a valid assignment (as RHS is "integer array")
         // TODO: the only reason to not do this check for "reshape" is because
         // incorrect 'n_dims' and 'shape' returned for "reshape" currently
-        if ( target_type != nullptr && value_type != nullptr && ASRUtils::is_array(target_type) && ASRUtils::is_array(value_type) ) {
+        if (target_type != nullptr && value_type != nullptr && ASRUtils::is_array(target_type)
+            && ASRUtils::is_array(value_type)) {
             ASR::dimension_t* target_dims = nullptr;
             ASR::dimension_t* value_dims = nullptr;
             size_t target_rank = ASRUtils::extract_dimensions_from_ttype(target_type, target_dims);
@@ -3340,41 +4030,40 @@ public:
             // ranks of LHS and RHS for an array assignment should
             // be same (including allocatable arrays)
             if (target_rank != value_rank) {
-                diag.add(Diagnostic(
-                    "Incompatible ranks " + std::to_string(target_rank) +
-                   " and " + std::to_string(value_rank) + " in assignment",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Incompatible ranks " + std::to_string(target_rank) + " and "
+                                        + std::to_string(value_rank) + " in assignment",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
-            } else if (ASRUtils::expr_type(target)->type == ASR::ttypeType::Array &&
-                       target_dims->m_length != nullptr &&
-                       !ASR::is_a<ASR::ArraySize_t>(*target_dims->m_length))
-            {
+            } else if (ASRUtils::expr_type(target)->type == ASR::ttypeType::Array
+                       && target_dims->m_length != nullptr
+                       && !ASR::is_a<ASR::ArraySize_t>(*target_dims->m_length)) {
                 // if in any of the dimension, arrays have different size
                 // raise an error
                 bool is_array_concat = false;
                 int flat_size = 0;
-                if( AST::is_a<AST::ArrayInitializer_t>(*x.m_value)){
-                     AST::ArrayInitializer_t *temp_array =
-                            AST::down_cast<AST::ArrayInitializer_t>(x.m_value);
-                    for(size_t i=0; i < temp_array->n_args; i++){
+                if (AST::is_a<AST::ArrayInitializer_t>(*x.m_value)) {
+                    AST::ArrayInitializer_t* temp_array
+                        = AST::down_cast<AST::ArrayInitializer_t>(x.m_value);
+                    for (size_t i = 0; i < temp_array->n_args; i++) {
                         this->visit_expr(*temp_array->m_args[i]);
-                        ASR::expr_t *temp = ASRUtils::EXPR(tmp);
-                        if( ASRUtils::expr_type(temp)->type == ASR::ttypeType::Array ) {
-                            flat_size += ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(temp));
+                        ASR::expr_t* temp = ASRUtils::EXPR(tmp);
+                        if (ASRUtils::expr_type(temp)->type == ASR::ttypeType::Array) {
+                            flat_size
+                                += ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(temp));
                             is_array_concat = true;
                         } else {
                             flat_size += 1;
                         }
                     }
                 }
-                if(!is_array_concat){
+                if (!is_array_concat) {
                     for (size_t i = 0; i < target_rank; i++) {
                         ASR::dimension_t dim_a = target_dims[i];
                         ASR::dimension_t dim_b = value_dims[i];
-                        int dim_a_int {-1};
-                        int dim_b_int {-1};
+                        int dim_a_int{ -1 };
+                        int dim_b_int{ -1 };
                         // 'm_length' isn't assigned for allocatable arrays
                         // let them be valid for now atleast
                         if (!(dim_a.m_length && dim_b.m_length)) {
@@ -3385,26 +4074,27 @@ public:
                         if (dim_a_int > 0 && dim_b_int > 0 && dim_a_int != dim_b_int) {
                             diag.add(diag::Diagnostic(
                                 "Different shape for array assignment on dimension "
-                                + std::to_string(i + 1) + "(" + std::to_string(dim_a_int)
-                                + " and " + std::to_string(dim_b_int) + ")",
-                                diag::Level::Error, diag::Stage::Semantic, {
-                                    diag::Label("", {x.base.base.loc})}));
+                                    + std::to_string(i + 1) + "(" + std::to_string(dim_a_int)
+                                    + " and " + std::to_string(dim_b_int) + ")",
+                                diag::Level::Error,
+                                diag::Stage::Semantic,
+                                { diag::Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
                 } else {
-                    //Case : C = [B, A] where B or A is Array
+                    // Case : C = [B, A] where B or A is Array
                     ASR::dimension_t dim_a = target_dims[0];
-                    int dim_a_int {-1};
+                    int dim_a_int{ -1 };
                     ASRUtils::extract_value(ASRUtils::expr_value(dim_a.m_length), dim_a_int);
                     if (dim_a_int > 0 && flat_size > 0 && dim_a_int != flat_size) {
-                        diag.add(Diagnostic(
-                            "Different shape for array assignment on "
-                            "dimension 1 (" + std::to_string(dim_a_int) + " and " +
-                            std::to_string(flat_size) + ")",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic("Different shape for array assignment on "
+                                            "dimension 1 ("
+                                                + std::to_string(dim_a_int) + " and "
+                                                + std::to_string(flat_size) + ")",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 }
@@ -3412,109 +4102,117 @@ public:
         }
     }
 
-    void visit_Assignment(const AST::Assignment_t &x) {
+    void visit_Assignment(const AST::Assignment_t& x)
+    {
         if (is_statement_function(x)) {
             create_statement_function(x);
             tmp = nullptr;
             return;
         }
         this->visit_expr(*x.m_target);
-        ASR::expr_t *target = ASRUtils::EXPR(tmp);
+        ASR::expr_t* target = ASRUtils::EXPR(tmp);
         if (auto* v = ASRUtils::extract_ExternalSymbol_Variable(target)) {
             if (v->m_is_protected) {
-                diag.add(Diagnostic(
-                    "Variable " + std::string(v->m_name) + " is PROTECTED and cannot appear in LHS of assignment",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {target->base.loc})
-                    }
-                ));
+                diag.add(Diagnostic("Variable " + std::string(v->m_name)
+                                        + " is PROTECTED and cannot appear in LHS of assignment",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { target->base.loc }) }));
                 throw SemanticAbort();
             }
         }
         // Handle Conversion from BOZ to Real Type for assign statements
         ASR::ttype_t* temp_current_variable_type_ = current_variable_type_;
-        if (AST::is_a<AST::BOZ_t>(*x.m_value)){
-            //For assigning Scalar Variable
-            if (ASR::is_a<ASR::Var_t>(*target)){
+        if (AST::is_a<AST::BOZ_t>(*x.m_value)) {
+            // For assigning Scalar Variable
+            if (ASR::is_a<ASR::Var_t>(*target)) {
                 ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(target);
                 ASR::symbol_t* sym = var->m_v;
-                if (ASR::is_a<ASR::Variable_t>(*sym)){
-                    ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym);
-                    if (ASR::is_a<ASR::Real_t>(*v->m_type)){
+                if (ASR::is_a<ASR::Variable_t>(*sym)) {
+                    ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(sym);
+                    if (ASR::is_a<ASR::Real_t>(*v->m_type)) {
                         current_variable_type_ = v->m_type;
                     }
                 }
             }
-            // For assigning Array Variable    
+            // For assigning Array Variable
             else if (ASR::is_a<ASR::ArrayItem_t>(*target)) {
-                ASR::ArrayItem_t *array_item = ASR::down_cast<ASR::ArrayItem_t>(target);
-                if (ASR::is_a<ASR::Real_t>(*array_item->m_type)){
+                ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(target);
+                if (ASR::is_a<ASR::Real_t>(*array_item->m_type)) {
                     current_variable_type_ = array_item->m_type;
                 }
             }
         }
         try {
             this->visit_expr(*x.m_value);
-        } catch (const SemanticAbort &e) {
-            if (!compiler_options.continue_compilation) throw e;
+        } catch (const SemanticAbort& e) {
+            if (!compiler_options.continue_compilation)
+                throw e;
         }
         current_variable_type_ = temp_current_variable_type_;
-        ASR::expr_t *value = ASRUtils::EXPR(tmp);
-        ASR::stmt_t *overloaded_stmt = nullptr;
+        ASR::expr_t* value = ASRUtils::EXPR(tmp);
+        ASR::stmt_t* overloaded_stmt = nullptr;
         if (ASR::is_a<ASR::Var_t>(*target)) {
-            ASR::Var_t *var = ASR::down_cast<ASR::Var_t>(target);
-            ASR::symbol_t *sym = var->m_v;
-            if (do_loop_variables.size() > 0 && std::find(do_loop_variables.begin(), do_loop_variables.end(), sym) != do_loop_variables.end()) {
-                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym);
+            ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(target);
+            ASR::symbol_t* sym = var->m_v;
+            if (do_loop_variables.size() > 0
+                && std::find(do_loop_variables.begin(), do_loop_variables.end(), sym)
+                       != do_loop_variables.end()) {
+                ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(sym);
                 std::string var_name = std::string(v->m_name);
-                diag.add(Diagnostic(
-                    "Assignment to loop variable `" + std::string(to_lower(var_name)) +"` is not allowed",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{target->base.loc})
-                    }));
+                diag.add(Diagnostic("Assignment to loop variable `"
+                                        + std::string(to_lower(var_name)) + "` is not allowed",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { target->base.loc }) }));
                 throw SemanticAbort();
             }
-            if (ASR::is_a<ASR::Variable_t>(*sym)){
-                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym);
+            if (ASR::is_a<ASR::Variable_t>(*sym)) {
+                ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(sym);
                 ASR::intentType intent = v->m_intent;
                 if (intent == ASR::intentType::In) {
-                    diag.add(Diagnostic(
-                        "Cannot assign to an intent(in) variable `" + std::string(v->m_name) + "`",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{target->base.loc})
-                        }));
+                    diag.add(Diagnostic("Cannot assign to an intent(in) variable `"
+                                            + std::string(v->m_name) + "`",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { target->base.loc }) }));
                     throw SemanticAbort();
                 }
                 if (v->m_storage == ASR::storage_typeType::Parameter) {
                     diag.add(diag::Diagnostic(
                         "Cannot assign to a constant variable",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                            diag::Label("assignment here", {x.base.base.loc}),
-                            diag::Label("declared as constant", {v->base.base.loc}, false),
+                        diag::Level::Error,
+                        diag::Stage::Semantic,
+                        {
+                            diag::Label("assignment here", { x.base.base.loc }),
+                            diag::Label("declared as constant", { v->base.base.loc }, false),
                         }));
-                    if (!compiler_options.continue_compilation) throw SemanticAbort();
+                    if (!compiler_options.continue_compilation)
+                        throw SemanticAbort();
                 }
             }
-            if (ASR::is_a<ASR::Function_t>(*sym)){
-                diag.add(Diagnostic(
-                    "Assignment to subroutine is not allowed",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{target->base.loc})
-                    }));
+            if (ASR::is_a<ASR::Function_t>(*sym)) {
+                diag.add(Diagnostic("Assignment to subroutine is not allowed",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { target->base.loc }) }));
                 throw SemanticAbort();
             }
         }
-        if( ASRUtils::use_overloaded_assignment(target, value,
-            current_scope, asr, al, x.base.base.loc, current_function_dependencies,
-            current_module_dependencies,
-            [&](const std::string &msg, const Location &loc) {
-                diag.add(Diagnostic(
-                    msg,
-                    Level::Error, Stage::Semantic, {
-                        Label("",{loc})
-                    }));
-                throw SemanticAbort();
-                }) ) {
+        if (ASRUtils::use_overloaded_assignment(
+                target,
+                value,
+                current_scope,
+                asr,
+                al,
+                x.base.base.loc,
+                current_function_dependencies,
+                current_module_dependencies,
+                [&](const std::string& msg, const Location& loc) {
+                    diag.add(
+                        Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                    throw SemanticAbort();
+                })) {
             overloaded_stmt = ASRUtils::STMT(asr);
         }
         if (ASR::is_a<ASR::Cast_t>(*target)) {
@@ -3528,17 +4226,17 @@ public:
                 target = cast->m_arg;
                 ASR::expr_t* y = value;
                 const Location& loc = x.base.base.loc;
-                ASR::expr_t *val = target;
+                ASR::expr_t* val = target;
 
-                ASR::ttype_t *real_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc,
-                    ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(val))));
-                ASR::expr_t *im = ASRUtils::EXPR(ASR::make_ComplexIm_t(al, loc,
-                    val, real_type, nullptr));
+                ASR::ttype_t* real_type = ASRUtils::TYPE(ASR::make_Real_t(
+                    al, loc, ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(val))));
+                ASR::expr_t* im
+                    = ASRUtils::EXPR(ASR::make_ComplexIm_t(al, loc, val, real_type, nullptr));
                 ASR::expr_t* cmplx = ASRUtils::EXPR(ASR::make_ComplexConstructor_t(
                     al, loc, y, im, ASRUtils::expr_type(target), nullptr));
                 value = cmplx;
             }
-        } else if ( ASR::is_a<ASR::ComplexRe_t>(*target) ) {
+        } else if (ASR::is_a<ASR::ComplexRe_t>(*target)) {
             ASR::ComplexRe_t* re = ASR::down_cast<ASR::ComplexRe_t>(target);
             /*
                 Case: x % re = y
@@ -3548,16 +4246,16 @@ public:
             target = re->m_arg;
             ASR::expr_t* y = value;
             const Location& loc = x.base.base.loc;
-            ASR::expr_t *val = target;
+            ASR::expr_t* val = target;
 
-            ASR::ttype_t *real_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc,
-                ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(val))));
-            ASR::expr_t *im = ASRUtils::EXPR(ASR::make_ComplexIm_t(al, loc,
-                val, real_type, nullptr));
+            ASR::ttype_t* real_type = ASRUtils::TYPE(ASR::make_Real_t(
+                al, loc, ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(val))));
+            ASR::expr_t* im
+                = ASRUtils::EXPR(ASR::make_ComplexIm_t(al, loc, val, real_type, nullptr));
             ASR::expr_t* cmplx = ASRUtils::EXPR(ASR::make_ComplexConstructor_t(
                 al, loc, y, im, ASRUtils::expr_type(target), nullptr));
             value = cmplx;
-        } else if ( ASR::is_a<ASR::ComplexIm_t>(*target) ) {
+        } else if (ASR::is_a<ASR::ComplexIm_t>(*target)) {
             ASR::ComplexIm_t* im = ASR::down_cast<ASR::ComplexIm_t>(target);
             /*
                 Case: x % im = y
@@ -3567,181 +4265,269 @@ public:
             target = im->m_arg;
             ASR::expr_t* y = value;
             const Location& loc = x.base.base.loc;
-            ASR::expr_t* re = ASRUtils::EXPR(ASR::make_Cast_t(al, loc, target,
-                ASR::cast_kindType::ComplexToReal, ASRUtils::expr_type(y), nullptr));
-            ASR::expr_t* cmplx = ASRUtils::EXPR(ASR::make_ComplexConstructor_t(al,
-                loc, re, y, ASRUtils::expr_type(target), nullptr));
+            ASR::expr_t* re = ASRUtils::EXPR(ASR::make_Cast_t(al,
+                                                              loc,
+                                                              target,
+                                                              ASR::cast_kindType::ComplexToReal,
+                                                              ASRUtils::expr_type(y),
+                                                              nullptr));
+            ASR::expr_t* cmplx = ASRUtils::EXPR(ASR::make_ComplexConstructor_t(
+                al, loc, re, y, ASRUtils::expr_type(target), nullptr));
             value = cmplx;
         }
-        if( target->type != ASR::exprType::Var &&
-            target->type != ASR::exprType::ArrayItem &&
-            target->type != ASR::exprType::ArraySection &&
-            target->type != ASR::exprType::StringSection &&
-            target->type != ASR::exprType::StringItem &&
-            target->type != ASR::exprType::StructInstanceMember &&
-            target->type != ASR::exprType::UnionInstanceMember &&
-            target->type != ASR::exprType::ComplexRe &&
-            target->type != ASR::exprType::ComplexIm
-        )
-        {
-            diag.add(Diagnostic(
-                "The LHS of assignment can only be a variable or an array reference",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (target->type != ASR::exprType::Var && target->type != ASR::exprType::ArrayItem
+            && target->type != ASR::exprType::ArraySection
+            && target->type != ASR::exprType::StringSection
+            && target->type != ASR::exprType::StringItem
+            && target->type != ASR::exprType::StructInstanceMember
+            && target->type != ASR::exprType::UnionInstanceMember
+            && target->type != ASR::exprType::ComplexRe
+            && target->type != ASR::exprType::ComplexIm) {
+            diag.add(
+                Diagnostic("The LHS of assignment can only be a variable or an array reference",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
-        ASR::ttype_t *target_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(target));
-        ASR::ttype_t *value_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(value));
-        if (target->type == ASR::exprType::Var && !ASRUtils::is_array(target_type) &&
-            value->type == ASR::exprType::ArrayConstant ) {
-            diag.add(Diagnostic(
-                "ArrayInitalizer expressions can only be assigned array references",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        ASR::ttype_t* target_type
+            = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(target));
+        ASR::ttype_t* value_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(value));
+        if (target->type == ASR::exprType::Var && !ASRUtils::is_array(target_type)
+            && value->type == ASR::exprType::ArrayConstant) {
+            diag.add(Diagnostic("ArrayInitalizer expressions can only be assigned array references",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
+
+        // === SHAPE MISMATCH CHECK (Fix for issue #9100) ===
+        {
+            ASR::ttype_t* lhs_type = ASRUtils::expr_type(target);
+            ASR::ttype_t* rhs_type = ASRUtils::expr_type(value);
+
+            if (ASRUtils::is_array(lhs_type) && ASRUtils::is_array(rhs_type)) {
+                ASR::dimension_t* lhs_dims = nullptr;
+                ASR::dimension_t* rhs_dims = nullptr;
+
+                size_t lhs_rank = ASRUtils::extract_dimensions_from_ttype(
+                    ASRUtils::expr_type(target), lhs_dims);
+                size_t rhs_rank
+                    = ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(value), rhs_dims);
+
+                bool mismatch = false;
+
+                // Different rank
+                if (lhs_rank != rhs_rank) {
+                    mismatch = true;
+                } else {
+                    // Compare lengths for each dimension
+                    for (size_t i = 0; i < lhs_rank; i++) {
+                        std::string lhs_dim = ASRUtils::extract_dim_value(lhs_dims[i].m_length);
+                        std::string rhs_dim = ASRUtils::extract_dim_value(rhs_dims[i].m_length);
+
+                        // Only flag mismatch when both sides are known (not ":") and differ.
+                        if (lhs_dim != ":" && rhs_dim != ":" && lhs_dim != rhs_dim) {
+                            mismatch = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (mismatch) {
+                    diag.semantic_error_label(
+                        "Different shape for array assignment", { target->base.loc }, "");
+                    throw SemanticAbort();
+                }
+            }
+        }
+
         check_ArrayAssignmentCompatibility(target, value, x);
 
-        if( overloaded_stmt == nullptr ) {
-            if ((target->type == ASR::exprType::Var ||
-                target->type == ASR::exprType::ArrayItem ||
-                target->type == ASR::exprType::ArraySection ||
-                target->type == ASR::exprType::StructInstanceMember ||
-                target->type == ASR::exprType::UnionInstanceMember) &&
-                !ASRUtils::check_equal_type(target_type, value_type, target, value)) {
+        if (overloaded_stmt == nullptr) {
+            if ((target->type == ASR::exprType::Var || target->type == ASR::exprType::ArrayItem
+                 || target->type == ASR::exprType::ArraySection
+                 || target->type == ASR::exprType::StructInstanceMember
+                 || target->type == ASR::exprType::UnionInstanceMember)
+                && !ASRUtils::check_equal_type(target_type, value_type, target, value)) {
                 if (value->type == ASR::exprType::ArrayConstant) {
-                    ASR::ArrayConstant_t *ac = ASR::down_cast<ASR::ArrayConstant_t>(value);
+                    ASR::ArrayConstant_t* ac = ASR::down_cast<ASR::ArrayConstant_t>(value);
                     int size = ASRUtils::get_fixed_size_of_array(ac->m_type);
-                    Vec<ASR::expr_t*> args; args.reserve(al, size);
+                    Vec<ASR::expr_t*> args;
+                    args.reserve(al, size);
                     for (size_t i = 0; i < (size_t) size; i++) {
                         ASR::expr_t* arg = ASRUtils::fetch_ArrayConstant_value(al, ac, i);
-                        ImplicitCastRules::set_converted_value(al, x.base.base.loc, &arg,
-                                                ASRUtils::expr_type(arg),
-                                                ASRUtils::type_get_past_allocatable(target_type), diag);
+                        ImplicitCastRules::set_converted_value(
+                            al,
+                            x.base.base.loc,
+                            &arg,
+                            ASRUtils::expr_type(arg),
+                            ASRUtils::type_get_past_allocatable(target_type),
+                            diag);
                         // ASRUtils::set_ArrayConstant_value(ac, arg, i);
                         args.push_back(al, arg);
                     }
-                    ac = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al, ac->base.base.loc,
-                            args.p, args.n, ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(target_type)), ac->m_storage_format))));
+                    ac = ASR::down_cast<ASR::ArrayConstant_t>(
+                        ASRUtils::expr_value(ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(
+                            al,
+                            ac->base.base.loc,
+                            args.p,
+                            args.n,
+                            ASRUtils::type_get_past_allocatable(
+                                ASRUtils::type_get_past_pointer(target_type)),
+                            ac->m_storage_format))));
                     value = ASRUtils::EXPR((ASR::asr_t*) ac);
                     LCOMPILERS_ASSERT(ASRUtils::is_array(ac->m_type));
-                    if( ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_pointer(
-                            ASRUtils::type_get_past_allocatable(ac->m_type))) ) {
-                        ASR::Array_t* array_t = ASR::down_cast<ASR::Array_t>(
-                            ASRUtils::type_get_past_pointer(
+                    if (ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_pointer(
+                            ASRUtils::type_get_past_allocatable(ac->m_type)))) {
+                        ASR::Array_t* array_t
+                            = ASR::down_cast<ASR::Array_t>(ASRUtils::type_get_past_pointer(
                                 ASRUtils::type_get_past_allocatable(ac->m_type)));
-                        array_t->m_type = ASRUtils::expr_type(ASRUtils::fetch_ArrayConstant_value(al, ac, 0));
+                        array_t->m_type
+                            = ASRUtils::expr_type(ASRUtils::fetch_ArrayConstant_value(al, ac, 0));
                     }
                 } else {
-                    if (ASR::is_a<ASR::IntrinsicElementalFunction_t>(*value) &&
-                          ASR::down_cast<ASR::IntrinsicElementalFunction_t>(value)->m_intrinsic_id == static_cast<int64_t>(ASRUtils::IntrinsicElementalFunctions::Maskl) &&
-                            ASRUtils::extract_kind_from_ttype_t(target_type) == 8) {
+                    if (ASR::is_a<ASR::IntrinsicElementalFunction_t>(*value)
+                        && ASR::down_cast<ASR::IntrinsicElementalFunction_t>(value)->m_intrinsic_id
+                               == static_cast<int64_t>(ASRUtils::IntrinsicElementalFunctions::Maskl)
+                        && ASRUtils::extract_kind_from_ttype_t(target_type) == 8) {
                         // Do return_type = kind(8)
-                        ASR::ttype_t* int_64 = ASRUtils::TYPE(ASR::make_Integer_t(al, value->base.loc, 8));
-                        ASR::IntrinsicElementalFunction_t* int_func = ASR::down_cast<ASR::IntrinsicElementalFunction_t>(value);
-                        value = ASRUtils::EXPR(ASR::make_IntrinsicElementalFunction_t(al, value->base.loc, int_func->m_intrinsic_id,
-                            int_func->m_args, int_func->n_args, int_func->m_overload_id, int_64, int_func->m_value));
+                        ASR::ttype_t* int_64
+                            = ASRUtils::TYPE(ASR::make_Integer_t(al, value->base.loc, 8));
+                        ASR::IntrinsicElementalFunction_t* int_func
+                            = ASR::down_cast<ASR::IntrinsicElementalFunction_t>(value);
+                        value = ASRUtils::EXPR(
+                            ASR::make_IntrinsicElementalFunction_t(al,
+                                                                   value->base.loc,
+                                                                   int_func->m_intrinsic_id,
+                                                                   int_func->m_args,
+                                                                   int_func->n_args,
+                                                                   int_func->m_overload_id,
+                                                                   int_64,
+                                                                   int_func->m_value));
                     } else {
-                    if (ASR::is_a<ASR::ArrayReshape_t>(*value)) {
-                        ASR::ArrayReshape_t* array_reshape = ASR::down_cast<ASR::ArrayReshape_t>(value);
-                        if (ASR::is_a<ASR::ArrayConstructor_t>(*array_reshape->m_array) && ASR::is_a<ASR::ImpliedDoLoop_t>(**ASR::down_cast<ASR::ArrayConstructor_t>(array_reshape->m_array)->m_args)) {
-                            ASR::Array_t* array_reshape_array_type = ASR::down_cast<ASR::Array_t>(array_reshape->m_type);
-                            Vec<ASR::dimension_t> array_reshape_dims;
-                            array_reshape_dims.reserve(al, array_reshape_array_type->n_dims);
-                            for (size_t i=0;i<array_reshape_array_type->n_dims;i++) {
-                                array_reshape_dims.push_back(al, array_reshape_array_type->m_dims[i]);
+                        if (ASR::is_a<ASR::ArrayReshape_t>(*value)) {
+                            ASR::ArrayReshape_t* array_reshape
+                                = ASR::down_cast<ASR::ArrayReshape_t>(value);
+                            if (ASR::is_a<ASR::ArrayConstructor_t>(*array_reshape->m_array)
+                                && ASR::is_a<ASR::ImpliedDoLoop_t>(
+                                    **ASR::down_cast<ASR::ArrayConstructor_t>(
+                                          array_reshape->m_array)
+                                          ->m_args)) {
+                                ASR::Array_t* array_reshape_array_type
+                                    = ASR::down_cast<ASR::Array_t>(array_reshape->m_type);
+                                Vec<ASR::dimension_t> array_reshape_dims;
+                                array_reshape_dims.reserve(al, array_reshape_array_type->n_dims);
+                                for (size_t i = 0; i < array_reshape_array_type->n_dims; i++) {
+                                    array_reshape_dims.push_back(
+                                        al, array_reshape_array_type->m_dims[i]);
+                                }
+                                array_reshape->m_type = ASRUtils::duplicate_type(
+                                    al,
+                                    array_reshape->m_type,
+                                    &array_reshape_dims,
+                                    ASR::array_physical_typeType::DescriptorArray,
+                                    true);
                             }
-                            array_reshape->m_type = ASRUtils::duplicate_type(al, array_reshape->m_type, &array_reshape_dims, ASR::array_physical_typeType::DescriptorArray,true);
                         }
-                    }
-                    ImplicitCastRules::set_converted_value(al, x.base.base.loc, &value,
-                                        value_type, target_type, diag);
+                        ImplicitCastRules::set_converted_value(
+                            al, x.base.base.loc, &value, value_type, target_type, diag);
                     }
                 }
             }
-            std::string ltype = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(target), target);
-            std::string rtype = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(value), value);
-            if (!ASRUtils::check_equal_type(ASRUtils::expr_type(target),
-                                        ASRUtils::expr_type(value), target, value)) {
-                if(value->type == ASR::exprType::ArrayConstant) {
-                    ASR::ArrayConstant_t *ac = ASR::down_cast<ASR::ArrayConstant_t>(value);
-                    for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(ac->m_type); i++) {
+            std::string ltype
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(target), target);
+            std::string rtype
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(value), value);
+            if (!ASRUtils::check_equal_type(
+                    ASRUtils::expr_type(target), ASRUtils::expr_type(value), target, value)) {
+                if (value->type == ASR::exprType::ArrayConstant) {
+                    ASR::ArrayConstant_t* ac = ASR::down_cast<ASR::ArrayConstant_t>(value);
+                    for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(ac->m_type);
+                         i++) {
                         ASR::expr_t* arr_const_val = ASRUtils::fetch_ArrayConstant_value(al, ac, i);
-                        if(!ASRUtils::check_equal_type(ASRUtils::expr_type(arr_const_val), ASRUtils::expr_type(target), arr_const_val, target)) {
+                        if (!ASRUtils::check_equal_type(ASRUtils::expr_type(arr_const_val),
+                                                        ASRUtils::expr_type(target),
+                                                        arr_const_val,
+                                                        target)) {
                             diag.semantic_error_label(
                                 "Type mismatch in assignment, the types must be compatible",
-                                {target->base.loc, value->base.loc},
-                                "type mismatch (" + ltype + " and " + rtype + ")"
-                            );
+                                { target->base.loc, value->base.loc },
+                                "type mismatch (" + ltype + " and " + rtype + ")");
                             throw SemanticAbort();
                         }
                     }
                     LCOMPILERS_ASSERT(ASRUtils::is_array(ac->m_type));
-                    if(!ASRUtils::check_equal_type(ac->m_type, ASRUtils::expr_type(target), value, target)) {
+                    if (!ASRUtils::check_equal_type(
+                            ac->m_type, ASRUtils::expr_type(target), value, target)) {
                         diag.semantic_error_label(
                             "Type mismatch in assignment, the types must be compatible",
-                            {target->base.loc, value->base.loc},
-                            "type mismatch (" + ltype + " and " + rtype + ")"
-                        );
+                            { target->base.loc, value->base.loc },
+                            "type mismatch (" + ltype + " and " + rtype + ")");
                         throw SemanticAbort();
                     }
-                } else if(value->type == ASR::exprType::ArrayConstructor) {
-                    ASR::ArrayConstructor_t *ac = ASR::down_cast<ASR::ArrayConstructor_t>(value);
+                } else if (value->type == ASR::exprType::ArrayConstructor) {
+                    ASR::ArrayConstructor_t* ac = ASR::down_cast<ASR::ArrayConstructor_t>(value);
                     for (size_t i = 0; i < ac->n_args; i++) {
-                        if(!ASRUtils::check_equal_type(ASRUtils::expr_type(ac->m_args[i]), ASRUtils::expr_type(target), ac->m_args[i], target)) {
+                        if (!ASRUtils::check_equal_type(ASRUtils::expr_type(ac->m_args[i]),
+                                                        ASRUtils::expr_type(target),
+                                                        ac->m_args[i],
+                                                        target)) {
                             diag.semantic_error_label(
                                 "Type mismatch in assignment, the types must be compatible",
-                                {target->base.loc, value->base.loc},
-                                "type mismatch (" + ltype + " and " + rtype + ")"
-                            );
+                                { target->base.loc, value->base.loc },
+                                "type mismatch (" + ltype + " and " + rtype + ")");
                             throw SemanticAbort();
                         }
                     }
                     LCOMPILERS_ASSERT(ASRUtils::is_array(ac->m_type));
-                    if(!ASRUtils::check_equal_type(ac->m_type, ASRUtils::expr_type(target), value, target)) {
+                    if (!ASRUtils::check_equal_type(
+                            ac->m_type, ASRUtils::expr_type(target), value, target)) {
                         diag.semantic_error_label(
                             "Type mismatch in assignment, the types must be compatible",
-                            {target->base.loc, value->base.loc},
-                            "type mismatch (" + ltype + " and " + rtype + ")"
-                        );
+                            { target->base.loc, value->base.loc },
+                            "type mismatch (" + ltype + " and " + rtype + ")");
                         throw SemanticAbort();
                     }
                 } else {
-                        diag.semantic_error_label(
-                            "Type mismatch in assignment, the types must be compatible",
-                            {target->base.loc, value->base.loc},
-                            "type mismatch (" + ltype + " and " + rtype + ")"
-                        );
-                        throw SemanticAbort();
-                }
-            }
-            if (ASRUtils::is_array(ASRUtils::expr_type(value)) &&
-                !ASRUtils::is_array(ASRUtils::expr_type(target))) {
                     diag.semantic_error_label(
                         "Type mismatch in assignment, the types must be compatible",
-                        {target->base.loc, value->base.loc},
-                        "type mismatch (" + ltype + " and " + rtype + ")"
-                    );
+                        { target->base.loc, value->base.loc },
+                        "type mismatch (" + ltype + " and " + rtype + ")");
                     throw SemanticAbort();
+                }
+            }
+            if (ASRUtils::is_array(ASRUtils::expr_type(value))
+                && !ASRUtils::is_array(ASRUtils::expr_type(target))) {
+                diag.semantic_error_label(
+                    "Type mismatch in assignment, the types must be compatible",
+                    { target->base.loc, value->base.loc },
+                    "type mismatch (" + ltype + " and " + rtype + ")");
+                throw SemanticAbort();
             }
         }
 
         ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, target, value);
 
-        tmp = ASRUtils::make_Assignment_t_util(al, x.base.base.loc, target, value,
-                            overloaded_stmt, compiler_options.po.realloc_lhs_arrays, false);
+        tmp = ASRUtils::make_Assignment_t_util(al,
+                                               x.base.base.loc,
+                                               target,
+                                               value,
+                                               overloaded_stmt,
+                                               compiler_options.po.realloc_lhs_arrays,
+                                               false);
     }
 
-    ASR::asr_t* create_CFPointer(const AST::SubroutineCall_t& x) {
+    ASR::asr_t* create_CFPointer(const AST::SubroutineCall_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"cptr", "fptr", "shape"};
+        std::vector<std::string> kwarg_names = { "cptr", "fptr", "shape" };
         handle_intrinsic_node_args<AST::SubroutineCall_t>(
             x, args, kwarg_names, 2, 3, std::string("c_f_ptr"));
         ASR::expr_t *cptr = args[0], *fptr = args[1], *shape = args[2];
-        if( shape && ASR::is_a<ASR::ArrayConstant_t>(*shape) ) {
+        if (shape && ASR::is_a<ASR::ArrayConstant_t>(*shape)) {
             ASR::ttype_t* array_constant_type = ASRUtils::expr_type(shape);
             ASR::Array_t* array_t = ASR::down_cast<ASR::Array_t>(array_constant_type);
             array_t->m_physical_type = ASR::array_physical_typeType::PointerArray;
@@ -3749,154 +4535,185 @@ public:
         ASR::ttype_t* fptr_type = ASRUtils::expr_type(fptr);
         bool is_fptr_array = ASRUtils::is_array(fptr_type);
         bool is_ptr = ASR::is_a<ASR::Pointer_t>(*fptr_type);
-        if( !is_ptr ) {
-            diag.add(Diagnostic(
-                "fptr is not a pointer.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{fptr->base.loc})
-                }));
+        if (!is_ptr) {
+            diag.add(Diagnostic("fptr is not a pointer.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { fptr->base.loc }) }));
             throw SemanticAbort();
         }
-        if(!is_fptr_array && shape) {
-            diag.add(diag::Diagnostic(
-                                "shape argument specified in c_f_pointer "
-                                "even though fptr is not an array.",
-                                diag::Level::Error, diag::Stage::Semantic, {
-                                    diag::Label("", {shape->base.loc})}));
+        if (!is_fptr_array && shape) {
+            diag.add(diag::Diagnostic("shape argument specified in c_f_pointer "
+                                      "even though fptr is not an array.",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { shape->base.loc }) }));
             throw SemanticAbort();
         }
-        if(is_fptr_array && !shape) {
-            diag.add(Diagnostic(
-                "shape argument not specified in c_f_pointer "
-                "even though fptr is an array.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{shape->base.loc})
-                }));
+        if (is_fptr_array && !shape) {
+            diag.add(Diagnostic("shape argument not specified in c_f_pointer "
+                                "even though fptr is an array.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { shape->base.loc }) }));
             throw SemanticAbort();
         }
         ASR::dimension_t* shape_dims;
         ASR::expr_t* lower_bounds = nullptr;
-        if( shape ) {
-            int shape_rank = ASRUtils::extract_dimensions_from_ttype(
-                                ASRUtils::expr_type(shape),
-                                shape_dims);
-            if( shape_rank != 1 ) {
-                diag.add(diag::Diagnostic(
-                                "shape array passed to c_f_pointer "
-                                "must be of rank 1 but given rank is " +
-                                std::to_string(shape_rank),
-                                diag::Level::Error, diag::Stage::Semantic, {
-                                    diag::Label("", {shape->base.loc})}));
-            throw SemanticAbort();
+        if (shape) {
+            int shape_rank
+                = ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(shape), shape_dims);
+            if (shape_rank != 1) {
+                diag.add(diag::Diagnostic("shape array passed to c_f_pointer "
+                                          "must be of rank 1 but given rank is "
+                                              + std::to_string(shape_rank),
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { shape->base.loc }) }));
+                throw SemanticAbort();
             }
 
             ASR::dimension_t* target_dims;
             int target_n_dims = ASRUtils::extract_dimensions_from_ttype(fptr_type, target_dims);
-            if( target_n_dims > 0 ) {
+            if (target_n_dims > 0) {
                 Vec<ASR::expr_t*> lbs;
                 lbs.reserve(al, target_n_dims);
                 bool success = true;
-                for( int i = 0; i < target_n_dims; i++ ) {
-                    if( target_dims->m_length == nullptr ) {
+                for (int i = 0; i < target_n_dims; i++) {
+                    if (target_dims->m_length == nullptr) {
                         success = false;
                         break;
                     }
-                    lbs.push_back(al, ASRUtils::EXPR(ASR::make_IntegerConstant_t(
-                        al, x.base.base.loc, 1, ASRUtils::TYPE(
-                            ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind)))));
-                }
-                if( success ) {
+                    lbs.push_back(
+                        al,
+                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al,
+                            x.base.base.loc,
+                            1,
+                            ASRUtils::TYPE(ASR::make_Integer_t(
+                                al, x.base.base.loc, compiler_options.po.default_integer_kind)))));
+                }
+                if (success) {
                     Vec<ASR::dimension_t> dims;
                     dims.reserve(al, 1);
-                    ASR::dimension_t dim;  dim.m_length = nullptr; dim.m_start = nullptr;
+                    ASR::dimension_t dim;
+                    dim.m_length = nullptr;
+                    dim.m_start = nullptr;
                     dim.loc = x.base.base.loc;
                     dim.m_length = make_ConstantWithKind(make_IntegerConstant_t,
-                        make_Integer_t, target_n_dims, compiler_options.po.default_integer_kind, dim.loc);
+                                                         make_Integer_t,
+                                                         target_n_dims,
+                                                         compiler_options.po.default_integer_kind,
+                                                         dim.loc);
                     dim.m_start = make_ConstantWithKind(make_IntegerConstant_t,
-                        make_Integer_t, 0, compiler_options.po.default_integer_kind, dim.loc);
+                                                        make_Integer_t,
+                                                        0,
+                                                        compiler_options.po.default_integer_kind,
+                                                        dim.loc);
                     dims.push_back(al, dim);
-                    ASR::ttype_t* type = ASRUtils::make_Array_t_util(al, dim.loc,
-                        ASRUtils::expr_type(lbs[0]), dims.p, dims.size(), ASR::abiType::Source,
-                        false, ASR::array_physical_typeType::PointerArray, true);
-                    lower_bounds = ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al,
-                        x.base.base.loc, lbs.p, lbs.size(), type,
-                        ASR::arraystorageType::RowMajor));
+                    ASR::ttype_t* type
+                        = ASRUtils::make_Array_t_util(al,
+                                                      dim.loc,
+                                                      ASRUtils::expr_type(lbs[0]),
+                                                      dims.p,
+                                                      dims.size(),
+                                                      ASR::abiType::Source,
+                                                      false,
+                                                      ASR::array_physical_typeType::PointerArray,
+                                                      true);
+                    lower_bounds = ASRUtils::EXPR(
+                        ASRUtils::make_ArrayConstructor_t_util(al,
+                                                               x.base.base.loc,
+                                                               lbs.p,
+                                                               lbs.size(),
+                                                               type,
+                                                               ASR::arraystorageType::RowMajor));
                 }
             }
         }
         return ASR::make_CPtrToPointer_t(al, x.base.base.loc, cptr, fptr, shape, lower_bounds);
     }
 
-    ASR::asr_t* intrinsic_subroutine_as_node(const AST::SubroutineCall_t &x, std::string var_name) {
+    ASR::asr_t* intrinsic_subroutine_as_node(const AST::SubroutineCall_t& x, std::string var_name)
+    {
         if (is_intrinsic_registry_subroutine(var_name)) {
-            if ( ASRUtils::IntrinsicImpureSubroutineRegistry::is_intrinsic_subroutine(var_name)) {
+            if (ASRUtils::IntrinsicImpureSubroutineRegistry::is_intrinsic_subroutine(var_name)) {
                 IntrinsicSignature signature = get_intrinsic_signature(var_name);
                 Vec<ASR::expr_t*> args;
                 bool signature_matched = false;
-                signature_matched = handle_intrinsic_node_args(
-                    x, args, signature.kwarg_names,
-                    signature.positional_args, signature.max_args,
-                    var_name, true);
-
-                if( !signature_matched ) {
-                    diag.add(Diagnostic(
-                        "No matching signature found for intrinsic " + var_name,
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                signature_matched = handle_intrinsic_node_args(x,
+                                                               args,
+                                                               signature.kwarg_names,
+                                                               signature.positional_args,
+                                                               signature.max_args,
+                                                               var_name,
+                                                               true);
+
+                if (!signature_matched) {
+                    diag.add(Diagnostic("No matching signature found for intrinsic " + var_name,
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                if( ASRUtils::IntrinsicImpureSubroutineRegistry::is_intrinsic_subroutine(var_name) ) {
+                if (ASRUtils::IntrinsicImpureSubroutineRegistry::is_intrinsic_subroutine(
+                        var_name)) {
                     fill_optional_kind_arg(var_name, args);
 
-                    ASRUtils::create_intrinsic_subroutine create_func =
-                        ASRUtils::IntrinsicImpureSubroutineRegistry::get_create_subroutine(var_name);
+                    ASRUtils::create_intrinsic_subroutine create_func
+                        = ASRUtils::IntrinsicImpureSubroutineRegistry::get_create_subroutine(
+                            var_name);
                     tmp = create_func(al, x.base.base.loc, args, diag);
                     return tmp;
                 }
             }
         } else if (startswith(var_name, "_lfortran_")) {
             // LFortran specific intrinsics
-            
+
             IntrinsicSignature signature = get_intrinsic_signature(var_name);
             Vec<ASR::expr_t*> args;
             bool signature_matched = false;
-            signature_matched = handle_intrinsic_node_args(
-                x, args, signature.kwarg_names,
-                signature.positional_args, signature.max_args,
-                var_name, true);
-
-            if( !signature_matched ) {
-                diag.add(Diagnostic(
-                    "No matching signature found for intrinsic " + var_name,
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+            signature_matched = handle_intrinsic_node_args(x,
+                                                           args,
+                                                           signature.kwarg_names,
+                                                           signature.positional_args,
+                                                           signature.max_args,
+                                                           var_name,
+                                                           true);
+
+            if (!signature_matched) {
+                diag.add(Diagnostic("No matching signature found for intrinsic " + var_name,
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
 
             if (var_name == "_lfortran_list_append") {
                 if (!ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-                    diag.add(Diagnostic(
-                        "First argument of " + var_name + " must be of list type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("First argument of " + var_name + " must be of list type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                ASR::List_t *list_type = ASR::down_cast<ASR::List_t>(ASRUtils::expr_type(args[0]));
-                ASR::ttype_t *arg_type = ASRUtils::expr_type(args[1]);
-                ASR::ttype_t *contained_type = ASRUtils::get_contained_type((ASR::ttype_t *)list_type);
+                ASR::List_t* list_type = ASR::down_cast<ASR::List_t>(ASRUtils::expr_type(args[0]));
+                ASR::ttype_t* arg_type = ASRUtils::expr_type(args[1]);
+                ASR::ttype_t* contained_type
+                    = ASRUtils::get_contained_type((ASR::ttype_t*) list_type);
                 if (!ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-                    std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
-                    std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
-                    diag.add(Diagnostic(
-                        "Type mismatch in " + var_name + ", the types must be compatible",
-                        Level::Error, Stage::Semantic, {
-                            Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                        }));
+                    std::string contained_type_str
+                        = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+                    std::string arg_type_str
+                        = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
+                    diag.add(Diagnostic("Type mismatch in " + var_name
+                                            + ", the types must be compatible",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("Types mismatch (found '" + arg_type_str
+                                                    + "', expected '" + contained_type_str + "')",
+                                                { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
@@ -3904,171 +4721,209 @@ public:
 
             } else if (var_name == "_lfortran_list_insert") {
                 if (!ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-                    diag.add(Diagnostic(
-                        "First argument of " + var_name + " must be of list type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("First argument of " + var_name + " must be of list type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                
-                ASR::ttype_t *contained_type = ASRUtils::get_contained_type(ASRUtils::expr_type(args[0]));
 
-                if (!ASRUtils::check_equal_type(contained_type, ASRUtils::expr_type(args[2]), nullptr, nullptr)) {
-                    std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
-                    std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[2]), nullptr);
-                    diag.add(Diagnostic(
-                        "Type mismatch in " + var_name + ", the types must be compatible",
-                        Level::Error, Stage::Semantic, {
-                            Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                        }));
+                ASR::ttype_t* contained_type
+                    = ASRUtils::get_contained_type(ASRUtils::expr_type(args[0]));
+
+                if (!ASRUtils::check_equal_type(
+                        contained_type, ASRUtils::expr_type(args[2]), nullptr, nullptr)) {
+                    std::string contained_type_str
+                        = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+                    std::string arg_type_str
+                        = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[2]), nullptr);
+                    diag.add(Diagnostic("Type mismatch in " + var_name
+                                            + ", the types must be compatible",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("Types mismatch (found '" + arg_type_str
+                                                    + "', expected '" + contained_type_str + "')",
+                                                { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                
+
                 if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(args[1]))) {
-                    std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
-                    diag.add(Diagnostic("Index of a list must be an integer not '" + arg_type_str + "'",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                    std::string arg_type_str
+                        = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
+                    diag.add(
+                        Diagnostic("Index of a list must be an integer not '" + arg_type_str + "'",
+                                   Level::Error,
+                                   Stage::Semantic,
+                                   { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
-                } 
+                }
 
                 return ASR::make_ListInsert_t(al, x.base.base.loc, args[0], args[1], args[2]);
             } else if (var_name == "_lfortran_list_remove") {
                 if (!ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-                    diag.add(Diagnostic(
-                        "First argument of " + var_name + " must be of list type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("First argument of " + var_name + " must be of list type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                
-                ASR::ttype_t *contained_type = ASRUtils::get_contained_type(ASRUtils::expr_type(args[0]));
 
-                if (!ASRUtils::check_equal_type(contained_type, ASRUtils::expr_type(args[1]), nullptr, nullptr)) {
-                    std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
-                    std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[2]), nullptr);
-                    diag.add(Diagnostic(
-                        "Type mismatch in " + var_name + ", the types must be compatible",
-                        Level::Error, Stage::Semantic, {
-                            Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                        }));
+                ASR::ttype_t* contained_type
+                    = ASRUtils::get_contained_type(ASRUtils::expr_type(args[0]));
+
+                if (!ASRUtils::check_equal_type(
+                        contained_type, ASRUtils::expr_type(args[1]), nullptr, nullptr)) {
+                    std::string contained_type_str
+                        = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+                    std::string arg_type_str
+                        = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[2]), nullptr);
+                    diag.add(Diagnostic("Type mismatch in " + var_name
+                                            + ", the types must be compatible",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("Types mismatch (found '" + arg_type_str
+                                                    + "', expected '" + contained_type_str + "')",
+                                                { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
                 return ASR::make_ListRemove_t(al, x.base.base.loc, args[0], args[1]);
             } else if (var_name == "_lfortran_list_reverse") {
                 if (!ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-                    diag.add(Diagnostic(
-                        "First argument of " + var_name + " must be of list type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("First argument of " + var_name + " must be of list type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                ASRUtils::create_intrinsic_function create_function =
-                    ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("list.reverse");
+                ASRUtils::create_intrinsic_function create_function
+                    = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(
+                        "list.reverse");
                 return create_function(al, x.base.base.loc, args, diag);
             } else if (var_name == "_lfortran_set_add") {
                 if (!ASR::is_a<ASR::Set_t>(*ASRUtils::expr_type(args[0]))) {
-                    diag.add(Diagnostic(
-                        "First argument of " + var_name + " must be of set type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("First argument of " + var_name + " must be of set type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                ASR::Set_t *set_type = ASR::down_cast<ASR::Set_t>(ASRUtils::expr_type(args[0]));
-                ASR::ttype_t *arg_type = ASRUtils::expr_type(args[1]);
-                ASR::ttype_t *contained_type = ASRUtils::get_contained_type((ASR::ttype_t *)set_type);
+                ASR::Set_t* set_type = ASR::down_cast<ASR::Set_t>(ASRUtils::expr_type(args[0]));
+                ASR::ttype_t* arg_type = ASRUtils::expr_type(args[1]);
+                ASR::ttype_t* contained_type
+                    = ASRUtils::get_contained_type((ASR::ttype_t*) set_type);
                 if (!ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-                    std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
-                    std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
-                    diag.add(Diagnostic(
-                        "Type mismatch in " + var_name + ", the types must be compatible",
-                        Level::Error, Stage::Semantic, {
-                            Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                        }));
+                    std::string contained_type_str
+                        = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+                    std::string arg_type_str
+                        = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
+                    diag.add(Diagnostic("Type mismatch in " + var_name
+                                            + ", the types must be compatible",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("Types mismatch (found '" + arg_type_str
+                                                    + "', expected '" + contained_type_str + "')",
+                                                { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                ASRUtils::create_intrinsic_function create_function =
-                    ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("set.add");
+                ASRUtils::create_intrinsic_function create_function
+                    = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("set.add");
                 return create_function(al, x.base.base.loc, args, diag);
             } else if (var_name == "_lfortran_set_item") {
                 if (ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-                    ASR::List_t *list_type = ASR::down_cast<ASR::List_t>(ASRUtils::expr_type(args[0]));
-                    ASR::ttype_t *index_type = ASRUtils::expr_type(args[1]);
-                    ASR::ttype_t *arg_type = ASRUtils::expr_type(args[2]);
-                    ASR::ttype_t *contained_type = ASRUtils::get_contained_type((ASR::ttype_t *)list_type);
+                    ASR::List_t* list_type
+                        = ASR::down_cast<ASR::List_t>(ASRUtils::expr_type(args[0]));
+                    ASR::ttype_t* index_type = ASRUtils::expr_type(args[1]);
+                    ASR::ttype_t* arg_type = ASRUtils::expr_type(args[2]);
+                    ASR::ttype_t* contained_type
+                        = ASRUtils::get_contained_type((ASR::ttype_t*) list_type);
 
                     if (!ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-                        std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
-                        std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
+                        std::string contained_type_str
+                            = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+                        std::string arg_type_str
+                            = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
                         diag.add(Diagnostic(
                             "Type mismatch in " + var_name + ", the types must be compatible",
-                            Level::Error, Stage::Semantic, {
-                                Label("Types mismatch (found '" + 
-                            arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                        + contained_type_str + "')",
+                                    { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
 
                     if (!ASR::is_a<ASR::Integer_t>(*index_type)) {
-                        std::string index_type_str = ASRUtils::type_to_str_fortran_expr(index_type, nullptr);
-                        diag.add(Diagnostic("Index of a list must be an integer not '" + index_type_str + "'",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                        std::string index_type_str
+                            = ASRUtils::type_to_str_fortran_expr(index_type, nullptr);
+                        diag.add(Diagnostic("Index of a list must be an integer not '"
+                                                + index_type_str + "'",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
 
-                    return ASRUtils::make_Assignment_t_util(al, x.base.base.loc, 
-                                        ASRUtils::EXPR(ASR::make_ListItem_t(al, x.base.base.loc, args[0], args[1],
-                                                             contained_type, nullptr)), 
-                                                            args[2], nullptr, false, false);
+                    return ASRUtils::make_Assignment_t_util(
+                        al,
+                        x.base.base.loc,
+                        ASRUtils::EXPR(ASR::make_ListItem_t(
+                            al, x.base.base.loc, args[0], args[1], contained_type, nullptr)),
+                        args[2],
+                        nullptr,
+                        false,
+                        false);
                 } else if (ASR::is_a<ASR::Dict_t>(*ASRUtils::expr_type(args[0]))) {
-                    ASR::Dict_t *dict_type = ASR::down_cast<ASR::Dict_t>(ASRUtils::expr_type(args[0]));
-                    ASR::ttype_t *key_type = ASRUtils::expr_type(args[1]);
-                    ASR::ttype_t *value_type = ASRUtils::expr_type(args[2]);
+                    ASR::Dict_t* dict_type
+                        = ASR::down_cast<ASR::Dict_t>(ASRUtils::expr_type(args[0]));
+                    ASR::ttype_t* key_type = ASRUtils::expr_type(args[1]);
+                    ASR::ttype_t* value_type = ASRUtils::expr_type(args[2]);
 
-                    ASR::ttype_t *dict_key_type = dict_type->m_key_type;
-                    ASR::ttype_t *dict_value_type = dict_type->m_value_type;
+                    ASR::ttype_t* dict_key_type = dict_type->m_key_type;
+                    ASR::ttype_t* dict_value_type = dict_type->m_value_type;
                     if (!ASRUtils::check_equal_type(dict_key_type, key_type, nullptr, nullptr)) {
-                        std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(dict_key_type, nullptr);
-                        std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(key_type, nullptr);
+                        std::string contained_type_str
+                            = ASRUtils::type_to_str_fortran_expr(dict_key_type, nullptr);
+                        std::string arg_type_str
+                            = ASRUtils::type_to_str_fortran_expr(key_type, nullptr);
                         diag.add(Diagnostic(
                             "Type mismatch in " + var_name + ", the key types must be compatible",
-                            Level::Error, Stage::Semantic, {
-                                Label("Types mismatch (found '" + 
-                            arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                        + contained_type_str + "')",
+                                    { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
 
-                    if (!ASRUtils::check_equal_type(dict_value_type, value_type, nullptr, nullptr)) {
-                        std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(dict_value_type, nullptr);
-                        std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(value_type, nullptr);
+                    if (!ASRUtils::check_equal_type(
+                            dict_value_type, value_type, nullptr, nullptr)) {
+                        std::string contained_type_str
+                            = ASRUtils::type_to_str_fortran_expr(dict_value_type, nullptr);
+                        std::string arg_type_str
+                            = ASRUtils::type_to_str_fortran_expr(value_type, nullptr);
                         diag.add(Diagnostic(
                             "Type mismatch in " + var_name + ", the value types must be compatible",
-                            Level::Error, Stage::Semantic, {
-                                Label("Types mismatch (found '" + 
-                            arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                        + contained_type_str + "')",
+                                    { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
 
                     return ASR::make_DictInsert_t(al, x.base.base.loc, args[0], args[1], args[2]);
                 } else {
-                    std::string type_string = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
-                    diag.add(Diagnostic(
-                        "First argument of type '"  + type_string + "' has not been implemented for " + var_name + " yet",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    std::string type_string
+                        = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
+                    diag.add(Diagnostic("First argument of type '" + type_string
+                                            + "' has not been implemented for " + var_name + " yet",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 return nullptr;
@@ -4077,16 +4932,17 @@ public:
                     return ASR::make_ListClear_t(al, x.base.base.loc, args[0]);
                 } /*else if (ASR::is_a<ASR::Dict_t>(*ASRUtils::expr_type(args[0]))) {
                     return ASR::make_DictClear_t(al, x.base.base.loc, args[0]);
-                } else if (ASR::is_a<ASR::Set_t>(*ASRUtils::expr_type(args[0]))) { TODO: Set, Dict Clear is not implemented
-                    return ASR::make_SetClear_t(al, x.base.base.loc, args[0]);
-                } */ 
+                } else if (ASR::is_a<ASR::Set_t>(*ASRUtils::expr_type(args[0]))) { TODO: Set, Dict
+                Clear is not implemented return ASR::make_SetClear_t(al, x.base.base.loc, args[0]);
+                } */
                 else {
-                    std::string type_string = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
-                    diag.add(Diagnostic(
-                        "First argument of type '"  + type_string + "' has not been implemented for " + var_name + " yet",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    std::string type_string
+                        = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
+                    diag.add(Diagnostic("First argument of type '" + type_string
+                                            + "' has not been implemented for " + var_name + " yet",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 return nullptr;
@@ -4098,7 +4954,8 @@ public:
     /*
         Function to convert 'FLUSH' subroutine call to 'FLUSH' ASR node
     */
-    void flush_subroutine_to_flush_statement(const AST::SubroutineCall_t &x) {
+    void flush_subroutine_to_flush_statement(const AST::SubroutineCall_t& x)
+    {
         LCOMPILERS_ASSERT(to_lower(x.m_name) == "flush")
 
         // for FLUSH subroutine call, the only argument 'unit' is optional
@@ -4113,57 +4970,41 @@ public:
             // when 'FLUSH' intrinsic is called with no argument,
             // then all open units need to be 'FLUSH'ed
             ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
-            ASR::expr_t* one = ASRUtils::EXPR(
-                ASR::make_IntegerConstant_t(
-                    al, x.base.base.loc, 1, int_type
-                )
-            );
-            ASR::expr_t* minus_one = ASRUtils::EXPR(
-                ASR::make_IntegerConstant_t(
-                    al, x.base.base.loc, -1, int_type
-                )
-            );
+            ASR::expr_t* one
+                = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
+            ASR::expr_t* minus_one
+                = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, -1, int_type));
             // we assign an integer -1 unit to that
             unit_flush = ASRUtils::EXPR(
-                ASR::make_IntegerUnaryMinus_t(
-                    al, x.base.base.loc, one, int_type, minus_one
-                )
-            );
+                ASR::make_IntegerUnaryMinus_t(al, x.base.base.loc, one, int_type, minus_one));
         } else {
-            diag.add(Diagnostic(
-                "Expected 0 or 1 arguments, got " + std::to_string(x.n_args + x.n_keywords) +
-                " arguments instead.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                })
-            );
+            diag.add(Diagnostic("Expected 0 or 1 arguments, got "
+                                    + std::to_string(x.n_args + x.n_keywords)
+                                    + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        tmp = ASR::make_Flush_t(
-            al, x.base.base.loc, 0, unit_flush, nullptr,
-            nullptr, nullptr
-        );
+        tmp = ASR::make_Flush_t(al, x.base.base.loc, 0, unit_flush, nullptr, nullptr, nullptr);
         // encourage users to use `FLUSH` statement instead,
         // as 'FLUSH' subroutine call isn't in Fortran standard
-        diag.semantic_warning_label(
-            "The 'flush' intrinsic function is an LFortran extension",
-            {x.base.base.loc},
-            "help: use the 'flush' statement instead"
-        );
+        diag.semantic_warning_label("The 'flush' intrinsic function is an LFortran extension",
+                                    { x.base.base.loc },
+                                    "help: use the 'flush' statement instead");
     }
 
     /*
         visit passed args, and visit kwargs and sets "nopass" only for GenericProcedure
     */
-    void process_call_args_and_kwargs(
-        const AST::SubroutineCall_t &x,
-        Vec<ASR::call_arg_t>& args,
-        ASR::symbol_t* original_sym,
-        diag::Diagnostics& diag,
-        ASR::expr_t* v_expr,
-        Allocator& al,
-        bool& nopass
-    ) {
+    void process_call_args_and_kwargs(const AST::SubroutineCall_t& x,
+                                      Vec<ASR::call_arg_t>& args,
+                                      ASR::symbol_t* original_sym,
+                                      diag::Diagnostics& diag,
+                                      ASR::expr_t* v_expr,
+                                      Allocator& al,
+                                      bool& nopass)
+    {
         visit_expr_list(x.m_args, x.n_args, args);
         ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(original_sym);
 
@@ -4177,44 +5018,58 @@ public:
             if (ASR::is_a<ASR::Function_t>(*f2)) {
                 ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f2);
                 diag::Diagnostics diags;
-                visit_kwargs(args, x.m_keywords, x.n_keywords,
-                             f->m_args, f->n_args, x.base.base.loc, f,
-                             diags, x.n_member);
+                visit_kwargs(args,
+                             x.m_keywords,
+                             x.n_keywords,
+                             f->m_args,
+                             f->n_args,
+                             x.base.base.loc,
+                             f,
+                             diags,
+                             x.n_member);
                 if (diags.has_error()) {
-                    diag.diagnostics.insert(diag.diagnostics.end(),
-                                            diags.diagnostics.begin(), diags.diagnostics.end());
+                    diag.diagnostics.insert(
+                        diag.diagnostics.end(), diags.diagnostics.begin(), diags.diagnostics.end());
                     throw SemanticAbort();
                 }
             } else if (ASR::is_a<ASR::StructMethodDeclaration_t>(*f2)) {
-                ASR::StructMethodDeclaration_t* f3 = ASR::down_cast<ASR::StructMethodDeclaration_t>(f2);
+                ASR::StructMethodDeclaration_t* f3
+                    = ASR::down_cast<ASR::StructMethodDeclaration_t>(f2);
                 ASR::symbol_t* f4 = f3->m_proc;
                 bool is_nopass = f3->m_is_nopass;
                 if (!ASR::is_a<ASR::Function_t>(*f4)) {
-                    diag.add(Diagnostic(
-                        std::string(f3->m_proc_name) + " is not a subroutine.",
-                        Level::Error, Stage::Semantic, {
-                            Label("", {x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic(std::string(f3->m_proc_name) + " is not a subroutine.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f4);
                 diag::Diagnostics diags;
-                visit_kwargs(args, x.m_keywords, x.n_keywords,
-                             f->m_args, f->n_args, x.base.base.loc, f,
-                             diags, x.n_member, is_nopass);
+                visit_kwargs(args,
+                             x.m_keywords,
+                             x.n_keywords,
+                             f->m_args,
+                             f->n_args,
+                             x.base.base.loc,
+                             f,
+                             diags,
+                             x.n_member,
+                             is_nopass);
                 if (diags.has_error()) {
-                    diag.diagnostics.insert(diag.diagnostics.end(),
-                                            diags.diagnostics.begin(), diags.diagnostics.end());
+                    diag.diagnostics.insert(
+                        diag.diagnostics.end(), diags.diagnostics.begin(), diags.diagnostics.end());
                     throw SemanticAbort();
                 }
             } else if (ASR::is_a<ASR::GenericProcedure_t>(*f2)) {
                 // pass, this is handled below
             } else {
                 diag.add(Diagnostic(
-                    "Keyword arguments are not implemented for generic subroutines yet, symbol type: " + std::to_string(f2->type),
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})
-                    }));
+                    "Keyword arguments are not implemented for generic subroutines yet, symbol type: "
+                        + std::to_string(f2->type),
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
@@ -4228,17 +5083,18 @@ public:
             for (size_t i = 0; i < f3->n_procs && !function_found; i++) {
                 ASR::symbol_t* f4 = ASRUtils::symbol_get_past_external(f3->m_procs[i]);
                 if (ASR::is_a<ASR::StructMethodDeclaration_t>(*f4)) {
-                    ASR::StructMethodDeclaration_t* f5 = ASR::down_cast<ASR::StructMethodDeclaration_t>(f4);
+                    ASR::StructMethodDeclaration_t* f5
+                        = ASR::down_cast<ASR::StructMethodDeclaration_t>(f4);
                     f4 = f5->m_proc;
                     is_nopass = f5->m_is_nopass;
                     is_class_procedure = true;
                 }
                 if (!ASR::is_a<ASR::Function_t>(*f4)) {
-                    diag.add(Diagnostic(
-                        std::string(ASRUtils::symbol_name(f4)) + " is not a function/subroutine.",
-                        Level::Error, Stage::Semantic, {
-                            Label("", {x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic(std::string(ASRUtils::symbol_name(f4))
+                                            + " is not a function/subroutine.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
@@ -4247,9 +5103,16 @@ public:
                     diag::Diagnostics diags;
                     Vec<ASR::call_arg_t> args_;
                     args_.from_pointer_n_copy(al, args.p, args.size());
-                    visit_kwargs(args_, x.m_keywords, x.n_keywords,
-                                 f->m_args, f->n_args, x.base.base.loc, f,
-                                 diags, x.n_member, is_nopass);
+                    visit_kwargs(args_,
+                                 x.m_keywords,
+                                 x.n_keywords,
+                                 f->m_args,
+                                 f->n_args,
+                                 x.base.base.loc,
+                                 f,
+                                 diags,
+                                 x.n_member,
+                                 is_nopass);
                     if (is_class_procedure && !is_nopass) {
                         ASR::call_arg_t this_arg;
                         this_arg.loc = x.m_member[0].loc;
@@ -4257,15 +5120,19 @@ public:
                         args_.push_front(al, this_arg);
                     }
                     if (!diags.has_error()) {
-                        if (static_cast<size_t>(ASRUtils::select_generic_procedure(args_, *f3, x.base.base.loc,
-                            [&](const std::string& msg, const Location& loc) {
-                                diag.add(Diagnostic(
-                                    msg,
-                                    Level::Error, Stage::Semantic, {
-                                        Label("", {loc})
-                                    }));
-                                throw SemanticAbort();
-                            }, false)) == i) {
+                        if (static_cast<size_t>(ASRUtils::select_generic_procedure(
+                                args_,
+                                *f3,
+                                x.base.base.loc,
+                                [&](const std::string& msg, const Location& loc) {
+                                    diag.add(Diagnostic(msg,
+                                                        Level::Error,
+                                                        Stage::Semantic,
+                                                        { Label("", { loc }) }));
+                                    throw SemanticAbort();
+                                },
+                                false))
+                            == i) {
                             function_found = true;
                             args.n = 0;
                             if (is_class_procedure && !is_nopass) {
@@ -4278,41 +5145,49 @@ public:
                 }
             }
             if (!function_found && x.n_keywords > 0) {
-                diag.add(Diagnostic(
-                    "No matching function found for the call to generic procedure, " + std::string(f3->m_name),
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("No matching function found for the call to generic procedure, "
+                                        + std::string(f3->m_name),
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             nopass = is_nopass;
         }
     }
 
-    void visit_SubroutineCall(const AST::SubroutineCall_t &x) {
+    void visit_SubroutineCall(const AST::SubroutineCall_t& x)
+    {
         std::string sub_name = to_lower(x.m_name);
         ASR::asr_t* intrinsic_subroutine = intrinsic_subroutine_as_node(x, sub_name);
-        if( intrinsic_subroutine ) {
+        if (intrinsic_subroutine) {
             tmp = intrinsic_subroutine;
             return;
         }
         if (x.n_temp_args > 0) {
-            ASR::symbol_t *owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
-            sub_name = handle_templated(x.m_name, ASR::is_a<ASR::Template_t>(*ASRUtils::get_asr_owner(owner_sym)),
-                x.m_temp_args, x.n_temp_args, x.base.base.loc);
+            ASR::symbol_t* owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
+            sub_name
+                = handle_templated(x.m_name,
+                                   ASR::is_a<ASR::Template_t>(*ASRUtils::get_asr_owner(owner_sym)),
+                                   x.m_temp_args,
+                                   x.n_temp_args,
+                                   x.base.base.loc);
         }
         SymbolTable* scope = current_scope;
-        ASR::symbol_t *original_sym;
-        ASR::expr_t *v_expr = nullptr;
+        ASR::symbol_t* original_sym;
+        ASR::expr_t* v_expr = nullptr;
         bool is_external = check_is_external(sub_name);
         bool sub_contain_entry_function = entry_functions.find(sub_name) != entry_functions.end();
         if (!is_external && sub_contain_entry_function) {
             // there can be a chance that scope is new scope of master entry function
-            // Then check if it is external procedure by checking all the external_procedures_mapping
+            // Then check if it is external procedure by checking all the
+            // external_procedures_mapping
 
-            for(auto it: external_procedures_mapping) {
+            for (auto it : external_procedures_mapping) {
                 std::vector<std::string> external_procedures_copy = it.second;
-                if (std::find(external_procedures_copy.begin(), external_procedures_copy.end(), sub_name) != external_procedures_copy.end()) {
+                if (std::find(
+                        external_procedures_copy.begin(), external_procedures_copy.end(), sub_name)
+                    != external_procedures_copy.end()) {
                     is_external = true;
                     break;
                 }
@@ -4322,30 +5197,32 @@ public:
         // If this is a type bound procedure (in a class) it won't be in the
         // main symbol table. Need to check n_member.
         if (x.n_member >= 1) {
-            visit_NameUtil(x.m_member, x.n_member - 1,
-                x.m_member[x.n_member - 1].m_name, x.base.base.loc);
+            visit_NameUtil(
+                x.m_member, x.n_member - 1, x.m_member[x.n_member - 1].m_name, x.base.base.loc);
             v_expr = ASRUtils::EXPR(tmp);
-            original_sym = resolve_deriv_type_proc(x.base.base.loc, sub_name,
-                            to_lower(x.m_member[x.n_member - 1].m_name), v_expr,
-                            ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)), scope);
-            original_sym = ASRUtils::import_class_procedure(al, x.base.base.loc,
-                original_sym, current_scope);
+            original_sym = resolve_deriv_type_proc(
+                x.base.base.loc,
+                sub_name,
+                to_lower(x.m_member[x.n_member - 1].m_name),
+                v_expr,
+                ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)),
+                scope);
+            original_sym = ASRUtils::import_class_procedure(
+                al, x.base.base.loc, original_sym, current_scope);
         } else {
             original_sym = current_scope->resolve_symbol(sub_name);
         }
         if (!original_sym || (original_sym && is_external)) {
             if (to_lower(sub_name) == "exit") {
-                diag.semantic_warning_label(
-                    "Routine `" + sub_name + "` is a non-standard function",
-                    {x.base.base.loc},
-                    ""
-                );
+                diag.semantic_warning_label("Routine `" + sub_name + "` is a non-standard function",
+                                            { x.base.base.loc },
+                                            "");
                 ASR::expr_t* arg = nullptr;
-                if ( x.n_args >= 1 ) {
+                if (x.n_args >= 1) {
                     visit_expr(*x.m_args[0].m_end);
                     arg = ASRUtils::EXPR(tmp);
                 }
-                tmp = ASR::make_Stop_t( al, x.base.base.loc, arg );
+                tmp = ASR::make_Stop_t(al, x.base.base.loc, arg);
                 return;
             }
             if (to_lower(sub_name) == "flush") {
@@ -4359,11 +5236,14 @@ public:
                 ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, 8));
                 create_implicit_interface_function(x, sub_name, false, type);
                 original_sym = current_scope->resolve_symbol(sub_name);
-                LCOMPILERS_ASSERT(original_sym!=nullptr);
+                LCOMPILERS_ASSERT(original_sym != nullptr);
             }
-            // check if external sym is updated, or: say if signature of external_sym and original_sym are different
-            if (original_sym && external_sym && is_external && ASRUtils::is_external_sym_changed(original_sym, external_sym)) {
-                changed_external_function_symbol[ASRUtils::symbol_name(original_sym)] = original_sym;
+            // check if external sym is updated, or: say if signature of external_sym and
+            // original_sym are different
+            if (original_sym && external_sym && is_external
+                && ASRUtils::is_external_sym_changed(original_sym, external_sym)) {
+                changed_external_function_symbol[ASRUtils::symbol_name(original_sym)]
+                    = original_sym;
             }
             // remove from external_procedures_mapping
             if (original_sym && is_external) {
@@ -4373,7 +5253,7 @@ public:
             // Update arguments if the symbol belonged to a function
             ASR::symbol_t* asr_owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
             if (ASR::is_a<ASR::Function_t>(*asr_owner_sym)) {
-                ASR::Function_t *current_function = ASR::down_cast<ASR::Function_t>(asr_owner_sym);
+                ASR::Function_t* current_function = ASR::down_cast<ASR::Function_t>(asr_owner_sym);
                 for (size_t i = 0; i < current_function->n_args; i++) {
                     if (ASR::is_a<ASR::Var_t>(*current_function->m_args[i])) {
                         ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(current_function->m_args[i]);
@@ -4384,13 +5264,13 @@ public:
                 }
             }
         }
-        ASR::symbol_t *sym = ASRUtils::symbol_get_past_external(original_sym);
-        ASR::Function_t *f = nullptr;
+        ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(original_sym);
+        ASR::Function_t* f = nullptr;
         if (ASR::is_a<ASR::Function_t>(*sym)) {
             f = ASR::down_cast<ASR::Function_t>(sym);
             if (ASRUtils::is_intrinsic_procedure(f)) {
-                if (intrinsic_module_procedures_as_asr_nodes.find(sub_name) !=
-                    intrinsic_module_procedures_as_asr_nodes.end()) {
+                if (intrinsic_module_procedures_as_asr_nodes.find(sub_name)
+                    != intrinsic_module_procedures_as_asr_nodes.end()) {
                     if (sub_name == "c_f_pointer") {
                         tmp = create_CFPointer(x);
                     } else {
@@ -4405,24 +5285,24 @@ public:
         bool nopass = false;
         process_call_args_and_kwargs(x, args, original_sym, diag, v_expr, al, nopass);
 
-        // checking for intent mismatch   
-        if (f) { 
+        // checking for intent mismatch
+        if (f) {
             ASRUtils::check_simple_intent_mismatch<SemanticAbort>(this->diag, f, args);
         }
 
-        ASR::symbol_t *final_sym=nullptr;
+        ASR::symbol_t* final_sym = nullptr;
         switch (original_sym->type) {
-            case (ASR::symbolType::Function) : {
+            case (ASR::symbolType::Function): {
                 final_sym = original_sym;
                 original_sym = nullptr;
                 legacy_array_sections_helper(final_sym, args, x.base.base.loc);
                 break;
             }
-            case (ASR::symbolType::GenericProcedure) : {
-                ASR::GenericProcedure_t *p = ASR::down_cast<ASR::GenericProcedure_t>(original_sym);
+            case (ASR::symbolType::GenericProcedure): {
+                ASR::GenericProcedure_t* p = ASR::down_cast<ASR::GenericProcedure_t>(original_sym);
                 ASR::symbol_t* original_sym_owner = ASRUtils::get_asr_owner(original_sym);
                 Vec<ASR::call_arg_t> args_with_mdt;
-                if( x.n_member >= 1 ) {
+                if (x.n_member >= 1) {
                     // we append "this/self" (i.e. ClassObject) as first argument
                     // only when nopass is not used in the associated subroutine
                     if (!nopass) {
@@ -4436,151 +5316,186 @@ public:
                         // size as `n_args`
                         args_with_mdt.reserve(al, x.n_args);
                     }
-                    for( size_t i = 0; i < args.size(); i++ ) {
+                    for (size_t i = 0; i < args.size(); i++) {
                         args_with_mdt.push_back(al, args[i]);
                     }
                 }
-                if( !ASR::is_a<ASR::Module_t>(*original_sym_owner) &&
-                    !ASR::is_a<ASR::Program_t>(*original_sym_owner) ) {
+                if (!ASR::is_a<ASR::Module_t>(*original_sym_owner)
+                    && !ASR::is_a<ASR::Program_t>(*original_sym_owner)) {
                     std::string s_name = "1_" + std::string(p->m_name);
                     std::string original_sym_owner_name = ASRUtils::symbol_name(original_sym_owner);
-                    if( current_scope->resolve_symbol(original_sym_owner_name) == nullptr ) {
+                    if (current_scope->resolve_symbol(original_sym_owner_name) == nullptr) {
                         std::string original_sym_owner_name_ = "1_" + original_sym_owner_name;
-                        if( current_scope->resolve_symbol(original_sym_owner_name) == nullptr ) {
+                        if (current_scope->resolve_symbol(original_sym_owner_name) == nullptr) {
                             ASR::symbol_t* module_ = ASRUtils::get_asr_owner(original_sym_owner);
                             LCOMPILERS_ASSERT(ASR::is_a<ASR::Module_t>(*module_));
-                            original_sym_owner = ASR::down_cast<ASR::symbol_t>(ASR::make_ExternalSymbol_t(al,
-                                                    x.base.base.loc, current_scope, s2c(al, original_sym_owner_name_),
-                                                    original_sym_owner, ASRUtils::symbol_name(module_), nullptr, 0,
-                                                    s2c(al, original_sym_owner_name), ASR::accessType::Private));
-                            current_scope->add_or_overwrite_symbol(original_sym_owner_name_, original_sym_owner);
+                            original_sym_owner = ASR::down_cast<ASR::symbol_t>(
+                                ASR::make_ExternalSymbol_t(al,
+                                                           x.base.base.loc,
+                                                           current_scope,
+                                                           s2c(al, original_sym_owner_name_),
+                                                           original_sym_owner,
+                                                           ASRUtils::symbol_name(module_),
+                                                           nullptr,
+                                                           0,
+                                                           s2c(al, original_sym_owner_name),
+                                                           ASR::accessType::Private));
+                            current_scope->add_or_overwrite_symbol(original_sym_owner_name_,
+                                                                   original_sym_owner);
                             original_sym_owner_name = original_sym_owner_name_;
                         }
                     }
-                    original_sym = ASR::down_cast<ASR::symbol_t>(ASR::make_ExternalSymbol_t(al,
-                        p->base.base.loc, current_scope, s2c(al, s_name), original_sym,
-                        s2c(al, original_sym_owner_name), nullptr, 0, p->m_name, ASR::accessType::Private));
+                    original_sym = ASR::down_cast<ASR::symbol_t>(
+                        ASR::make_ExternalSymbol_t(al,
+                                                   p->base.base.loc,
+                                                   current_scope,
+                                                   s2c(al, s_name),
+                                                   original_sym,
+                                                   s2c(al, original_sym_owner_name),
+                                                   nullptr,
+                                                   0,
+                                                   p->m_name,
+                                                   ASR::accessType::Private));
                     current_scope->add_or_overwrite_symbol(s_name, original_sym);
                 }
 
-                // If GenericProcedure resolves to a parent struct symbol, resolve the procedure names again with the original struct symbol
-                if (v_expr &&
-                    x.n_member >= 1 &&
-                    ASR::is_a<ASR::StructType_t>(*ASRUtils::expr_type(v_expr)) && !ASRUtils::is_class_type(ASRUtils::expr_type(v_expr)) &&
-                    (ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(v_expr)))) !=
-                        ASRUtils::get_asr_owner(ASRUtils::symbol_get_past_external(original_sym))) {
+                // If GenericProcedure resolves to a parent struct symbol, resolve the procedure
+                // names again with the original struct symbol
+                if (v_expr && x.n_member >= 1
+                    && ASR::is_a<ASR::StructType_t>(*ASRUtils::expr_type(v_expr))
+                    && !ASRUtils::is_class_type(ASRUtils::expr_type(v_expr))
+                    && (ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(
+                           ASRUtils::get_struct_sym_from_struct_expr(v_expr))))
+                           != ASRUtils::get_asr_owner(
+                               ASRUtils::symbol_get_past_external(original_sym))) {
                     for (size_t i = 0; i < p->n_procs; i++) {
-                        final_sym = resolve_deriv_type_proc(x.base.base.loc, ASRUtils::symbol_name(p->m_procs[i]),
-                                        to_lower(x.m_member[x.n_member - 1].m_name), v_expr,
-                                        ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)), scope);
-                        final_sym = ASRUtils::import_class_procedure(al, x.base.base.loc,
-                            final_sym, current_scope);
-                        ASR::StructMethodDeclaration_t* cp = ASR::down_cast<ASR::StructMethodDeclaration_t>(ASRUtils::symbol_get_past_external(final_sym));
+                        final_sym = resolve_deriv_type_proc(
+                            x.base.base.loc,
+                            ASRUtils::symbol_name(p->m_procs[i]),
+                            to_lower(x.m_member[x.n_member - 1].m_name),
+                            v_expr,
+                            ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)),
+                            scope);
+                        final_sym = ASRUtils::import_class_procedure(
+                            al, x.base.base.loc, final_sym, current_scope);
+                        ASR::StructMethodDeclaration_t* cp
+                            = ASR::down_cast<ASR::StructMethodDeclaration_t>(
+                                ASRUtils::symbol_get_past_external(final_sym));
                         Location l = x.base.base.loc;
                         // TODO: Add error message here
-                        if (ASRUtils::select_func_subrout(cp->m_proc, args_with_mdt, l,
-                            [&](const std::string &msg, const Location &loc) {
-                                diag.add(Diagnostic(
-                                    msg,
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{loc})
-                                    }));
-                                throw SemanticAbort();
+                        if (ASRUtils::select_func_subrout(
+                                cp->m_proc,
+                                args_with_mdt,
+                                l,
+                                [&](const std::string& msg, const Location& loc) {
+                                    diag.add(Diagnostic(msg,
+                                                        Level::Error,
+                                                        Stage::Semantic,
+                                                        { Label("", { loc }) }));
+                                    throw SemanticAbort();
                                 })) {
-                                    break;
-                                }
+                            break;
+                        }
                     }
                     break;
                 }
 
                 int idx;
-                if( x.n_member >= 1 ) {
-                    idx = ASRUtils::select_generic_procedure(args_with_mdt, *p, x.base.base.loc,
-                            [&](const std::string &msg, const Location &loc) {
-                                diag.add(Diagnostic(
-                                    msg,
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{loc})
-                                    }));
-                                throw SemanticAbort();
-                                });
+                if (x.n_member >= 1) {
+                    idx = ASRUtils::select_generic_procedure(
+                        args_with_mdt,
+                        *p,
+                        x.base.base.loc,
+                        [&](const std::string& msg, const Location& loc) {
+                            diag.add(Diagnostic(
+                                msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                            throw SemanticAbort();
+                        });
                 } else {
-                    idx = ASRUtils::select_generic_procedure(args, *p, x.base.base.loc,
-                            [&](const std::string &msg, const Location &loc) {
-                                diag.add(Diagnostic(
-                                    msg,
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{loc})
-                                    }));
-                                throw SemanticAbort();
-                                });
+                    idx = ASRUtils::select_generic_procedure(
+                        args,
+                        *p,
+                        x.base.base.loc,
+                        [&](const std::string& msg, const Location& loc) {
+                            diag.add(Diagnostic(
+                                msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                            throw SemanticAbort();
+                        });
                 }
                 ASR::symbol_t* func_sym = p->m_procs[idx];
 
-                // Case: GenericProcedure is present in abstract class and called from derived class object
+                // Case: GenericProcedure is present in abstract class and called from derived class
+                // object
                 if (x.n_member >= 1) {
-                    func_sym = resolve_deriv_type_proc(x.base.base.loc, ASRUtils::symbol_name(func_sym),
-                                    to_lower(x.m_member[x.n_member - 1].m_name), v_expr,
-                                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)), scope);
+                    func_sym = resolve_deriv_type_proc(
+                        x.base.base.loc,
+                        ASRUtils::symbol_name(func_sym),
+                        to_lower(x.m_member[x.n_member - 1].m_name),
+                        v_expr,
+                        ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)),
+                        scope);
                 }
                 // Create ExternalSymbol for procedures in different modules.
-                if( ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(func_sym)) ) {
-                    f = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(func_sym));
+                if (ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(func_sym))) {
+                    f = ASR::down_cast<ASR::Function_t>(
+                        ASRUtils::symbol_get_past_external(func_sym));
                 }
-                final_sym = ASRUtils::import_class_procedure(al, x.base.base.loc,
-                    func_sym, current_scope);
+                final_sym = ASRUtils::import_class_procedure(
+                    al, x.base.base.loc, func_sym, current_scope);
                 break;
             }
-            case (ASR::symbolType::StructMethodDeclaration) : {
+            case (ASR::symbolType::StructMethodDeclaration): {
                 final_sym = original_sym;
                 original_sym = nullptr;
                 break;
             }
-            case (ASR::symbolType::ExternalSymbol) : {
-                ASR::ExternalSymbol_t *p = ASR::down_cast<ASR::ExternalSymbol_t>(original_sym);
+            case (ASR::symbolType::ExternalSymbol): {
+                ASR::ExternalSymbol_t* p = ASR::down_cast<ASR::ExternalSymbol_t>(original_sym);
                 final_sym = p->m_external;
                 // Enforced by verify(), but we ensure anyway that
                 // ExternalSymbols are not chained:
                 LCOMPILERS_ASSERT(!ASR::is_a<ASR::ExternalSymbol_t>(*final_sym))
                 if (ASR::is_a<ASR::GenericProcedure_t>(*final_sym)) {
-                    ASR::GenericProcedure_t *g = ASR::down_cast<ASR::GenericProcedure_t>(final_sym);
-                    int idx = ASRUtils::select_generic_procedure(args, *g, x.base.base.loc,
-                                [&](const std::string &msg, const Location &loc) {
-                                    diag.add(Diagnostic(
-                                        msg,
-                                        Level::Error, Stage::Semantic, {
-                                            Label("",{loc})
-                                        }));
-                                    throw SemanticAbort();
-                                    });
+                    ASR::GenericProcedure_t* g = ASR::down_cast<ASR::GenericProcedure_t>(final_sym);
+                    int idx = ASRUtils::select_generic_procedure(
+                        args,
+                        *g,
+                        x.base.base.loc,
+                        [&](const std::string& msg, const Location& loc) {
+                            diag.add(Diagnostic(
+                                msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                            throw SemanticAbort();
+                        });
                     // FIXME
                     // Create ExternalSymbol for the final subroutine here
                     final_sym = ASRUtils::symbol_get_past_external(g->m_procs[idx]);
                     if (!ASR::is_a<ASR::Function_t>(*final_sym)) {
-                        diag.add(Diagnostic(
-                            "ExternalSymbol must point to a Subroutine",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic("ExternalSymbol must point to a Subroutine",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                     f = ASR::down_cast<ASR::Function_t>(final_sym);
                     // We mangle the new ExternalSymbol's local name as:
                     //   generic_procedure_local_name @
                     //     specific_procedure_remote_name
-                    std::string local_sym = std::string(to_lower(p->m_name)) + "@"
-                        + ASRUtils::symbol_name(final_sym);
+                    std::string local_sym
+                        = std::string(to_lower(p->m_name)) + "@" + ASRUtils::symbol_name(final_sym);
                     if (current_scope->get_symbol(local_sym) == nullptr) {
                         Str name;
                         name.from_str(al, local_sym);
-                        char *cname = name.c_str(al);
-                        ASR::asr_t *sub = ASR::make_ExternalSymbol_t(
-                            al, p->base.base.loc,
+                        char* cname = name.c_str(al);
+                        ASR::asr_t* sub = ASR::make_ExternalSymbol_t(
+                            al,
+                            p->base.base.loc,
                             /* a_symtab */ current_scope,
                             /* a_name */ cname,
                             final_sym,
                             ASRUtils::symbol_name(ASRUtils::get_asr_owner(final_sym)),
-                            nullptr, 0, ASRUtils::symbol_name(final_sym),
+                            nullptr,
+                            0,
+                            ASRUtils::symbol_name(final_sym),
                             ASR::accessType::Private);
                         final_sym = ASR::down_cast<ASR::symbol_t>(sub);
                         current_scope->add_symbol(local_sym, final_sym);
@@ -4588,17 +5503,18 @@ public:
                         final_sym = current_scope->get_symbol(local_sym);
                     }
                 } else if (ASR::is_a<ASR::StructMethodDeclaration_t>(*final_sym)) {
-                    ASR::StructMethodDeclaration_t* class_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(final_sym);
+                    ASR::StructMethodDeclaration_t* class_proc
+                        = ASR::down_cast<ASR::StructMethodDeclaration_t>(final_sym);
                     nopass = class_proc->m_is_nopass;
                     final_sym = original_sym;
                     original_sym = nullptr;
                     ASR::symbol_t* f4 = class_proc->m_proc;
                     if (!ASR::is_a<ASR::Function_t>(*f4)) {
-                        diag.add(Diagnostic(
-                            std::string(class_proc->m_proc_name) + " is not a subroutine.",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic(std::string(class_proc->m_proc_name)
+                                                + " is not a subroutine.",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                     f = ASR::down_cast<ASR::Function_t>(f4);
@@ -4607,24 +5523,22 @@ public:
                     final_sym = original_sym;
                     original_sym = nullptr;
                 } else {
-                    if (!ASR::is_a<ASR::Function_t>(*final_sym) &&
-                        !ASR::is_a<ASR::StructMethodDeclaration_t>(*final_sym)) {
-                        diag.add(Diagnostic(
-                            "ExternalSymbol must point to a Subroutine",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                    if (!ASR::is_a<ASR::Function_t>(*final_sym)
+                        && !ASR::is_a<ASR::StructMethodDeclaration_t>(*final_sym)) {
+                        diag.add(Diagnostic("ExternalSymbol must point to a Subroutine",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
-                    final_sym=original_sym;
+                    final_sym = original_sym;
                     original_sym = nullptr;
                 }
                 break;
             }
-            case (ASR::symbolType::Variable) : {
-                if (compiler_options.implicit_interface &&
-                    !ASRUtils::is_symbol_procedure_variable(original_sym)
-                ) {
+            case (ASR::symbolType::Variable): {
+                if (compiler_options.implicit_interface
+                    && !ASRUtils::is_symbol_procedure_variable(original_sym)) {
                     // In case of implicit_interface, we redefine the symbol
                     // from a Variable to Function. Example:
                     //
@@ -4639,7 +5553,7 @@ public:
                     current_scope->erase_symbol(sub_name);
                     create_implicit_interface_function(x, sub_name, false, old_type);
                     original_sym = current_scope->resolve_symbol(sub_name);
-                    LCOMPILERS_ASSERT(original_sym!=nullptr);
+                    LCOMPILERS_ASSERT(original_sym != nullptr);
 
                     // One issue to solve is if `sub_name` is an argument of
                     // the current function, such as in:
@@ -4658,20 +5572,19 @@ public:
                     // We simply redo function arguments based on the updated
                     // symbol table:
                     LCOMPILERS_ASSERT(current_scope->asr_owner != nullptr)
-                    ASR::Function_t *current_function = ASR::down_cast2
-                        <ASR::Function_t>(current_scope->asr_owner);
+                    ASR::Function_t* current_function
+                        = ASR::down_cast2<ASR::Function_t>(current_scope->asr_owner);
                     redo_function_argument(*current_function, sub_name);
                 }
                 final_sym = original_sym;
                 original_sym = nullptr;
                 break;
             }
-            default : {
-                diag.add(Diagnostic(
-                    "Symbol type not supported",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+            default: {
+                diag.add(Diagnostic("Symbol type not supported",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
@@ -4682,14 +5595,14 @@ public:
         }
         ASRUtils::insert_module_dependency(final_sym, al, current_module_dependencies);
         if (f) {
-            const int offset { (v_expr == nullptr || nopass) ? 0 : 1 };
+            const int offset{ (v_expr == nullptr || nopass) ? 0 : 1 };
             if (args.size() + offset > f->n_args) {
-                const Location args_loc { ASRUtils::get_vec_loc(args) };
-                diag.add(diag::Diagnostic(
-                    "More actual than formal arguments in procedure call",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {args_loc})}));
-                    throw SemanticAbort();
+                const Location args_loc{ ASRUtils::get_vec_loc(args) };
+                diag.add(diag::Diagnostic("More actual than formal arguments in procedure call",
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { args_loc }) }));
+                throw SemanticAbort();
             }
 
             // Validate required arguments are provided
@@ -4702,23 +5615,22 @@ public:
                     if (v->m_presence != ASR::presenceType::Optional) {
                         if (i >= args.size()) {
                             if (args.empty()) {
-                                diag.add(diag::Diagnostic(
-                                    "Required argument `" + std::string(v->m_name) +
-                                    "` is missing in function call",
-                                    diag::Level::Error, diag::Stage::Semantic, {
-                                        diag::Label("", {x.base.base.loc})
-                                    }));
+                                diag.add(
+                                    diag::Diagnostic("Required argument `" + std::string(v->m_name)
+                                                         + "` is missing in function call",
+                                                     diag::Level::Error,
+                                                     diag::Stage::Semantic,
+                                                     { diag::Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
 
-                            const Location args_loc { ASRUtils::get_vec_loc(args) };
-                            diag.add(diag::Diagnostic(
-                                "Required argument `" + std::string(v->m_name) +
-                                "` at position " + std::to_string(i + 1) +
-                                " is missing in function call",
-                                diag::Level::Error, diag::Stage::Semantic, {
-                                    diag::Label("", {args_loc})
-                                }));
+                            const Location args_loc{ ASRUtils::get_vec_loc(args) };
+                            diag.add(diag::Diagnostic("Required argument `" + std::string(v->m_name)
+                                                          + "` at position " + std::to_string(i + 1)
+                                                          + " is missing in function call",
+                                                      diag::Level::Error,
+                                                      diag::Stage::Semantic,
+                                                      { diag::Label("", { args_loc }) }));
                             throw SemanticAbort();
                         }
                     }
@@ -4726,23 +5638,31 @@ public:
                         ASR::expr_t* passed_arg = args[i].m_value;
                         ASR::ttype_t* passed_type = ASRUtils::expr_type(passed_arg);
                         ASR::ttype_t* param_type = v->m_type;
-                        // Skip type checking for implicit argument_casting, 
+                        // Skip type checking for implicit argument_casting,
                         // polymorphic types (class), function types, and intrinsics
-                        bool skip_check = compiler_options.implicit_argument_casting ||
-                                            ASRUtils::is_class_type(ASRUtils::type_get_past_array(passed_type)) ||
-                                            ASRUtils::is_class_type(ASRUtils::type_get_past_array(param_type)) ||
-                                            ASR::is_a<ASR::FunctionType_t>(*ASRUtils::type_get_past_array(passed_type)) ||
-                                            ASR::is_a<ASR::FunctionType_t>(*ASRUtils::type_get_past_array(param_type));
+                        bool skip_check
+                            = compiler_options.implicit_argument_casting
+                              || ASRUtils::is_class_type(ASRUtils::type_get_past_array(passed_type))
+                              || ASRUtils::is_class_type(ASRUtils::type_get_past_array(param_type))
+                              || ASR::is_a<ASR::FunctionType_t>(
+                                  *ASRUtils::type_get_past_array(passed_type))
+                              || ASR::is_a<ASR::FunctionType_t>(
+                                  *ASRUtils::type_get_past_array(param_type));
                         // Check if types are equal
-                        if (!skip_check && !ASRUtils::check_equal_type(passed_type, param_type, passed_arg, f->m_args[i+offset])) {
-                            std::string passed_type_str = ASRUtils::type_to_str_fortran_expr(passed_type, nullptr);
-                            std::string param_type_str = ASRUtils::type_to_str_fortran_expr(param_type, nullptr);
+                        if (!skip_check
+                            && !ASRUtils::check_equal_type(
+                                passed_type, param_type, passed_arg, f->m_args[i + offset])) {
+                            std::string passed_type_str
+                                = ASRUtils::type_to_str_fortran_expr(passed_type, nullptr);
+                            std::string param_type_str
+                                = ASRUtils::type_to_str_fortran_expr(param_type, nullptr);
                             diag.add(diag::Diagnostic(
-                                "Type mismatch in argument `" + std::string(v->m_name) +
-                                "`: expected `" + param_type_str + "` but got `" +passed_type_str + "`",
-                                diag::Level::Error, diag::Stage::Semantic, {
-                                        diag::Label("", {passed_arg->base.loc})
-                                }));
+                                "Type mismatch in argument `" + std::string(v->m_name)
+                                    + "`: expected `" + param_type_str + "` but got `"
+                                    + passed_type_str + "`",
+                                diag::Level::Error,
+                                diag::Stage::Semantic,
+                                { diag::Label("", { passed_arg->base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
@@ -4752,8 +5672,17 @@ public:
             ASRUtils::set_absent_optional_arguments_to_null(args, f, al, v_expr, nopass);
         }
         ASR::stmt_t* cast_stmt = nullptr;
-        tmp = ASRUtils::make_SubroutineCall_t_util(al, x.base.base.loc,
-                final_sym, original_sym, args.p, args.size(), v_expr, &cast_stmt, compiler_options.implicit_argument_casting, current_scope, current_function_dependencies);
+        tmp = ASRUtils::make_SubroutineCall_t_util(al,
+                                                   x.base.base.loc,
+                                                   final_sym,
+                                                   original_sym,
+                                                   args.p,
+                                                   args.size(),
+                                                   v_expr,
+                                                   &cast_stmt,
+                                                   compiler_options.implicit_argument_casting,
+                                                   current_scope,
+                                                   current_function_dependencies);
 
         if (cast_stmt != nullptr) {
             current_body->push_back(al, cast_stmt);
@@ -4762,12 +5691,13 @@ public:
 
     // Changes argument `sub_name` to the new symbol from the current symbol
     // table of the function `x`.
-    void redo_function_argument(ASR::Function_t &x, const std::string &sub_name) {
-        for (size_t i=0; i<x.n_args; i++) {
-            ASR::symbol_t *sym = ASR::down_cast<ASR::Var_t>(x.m_args[i])->m_v;
+    void redo_function_argument(ASR::Function_t& x, const std::string& sub_name)
+    {
+        for (size_t i = 0; i < x.n_args; i++) {
+            ASR::symbol_t* sym = ASR::down_cast<ASR::Var_t>(x.m_args[i])->m_v;
             std::string arg_s = ASRUtils::symbol_name(sym);
             if (arg_s == sub_name) {
-                ASR::symbol_t *var = x.m_symtab->get_symbol(arg_s);
+                ASR::symbol_t* var = x.m_symtab->get_symbol(arg_s);
                 x.m_args[i] = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, var));
                 return;
             }
@@ -4775,72 +5705,91 @@ public:
         throw LCompilersException("Argument not found");
     }
 
-    ASR::asr_t* construct_leading_space(const Location &loc) {
-        ASR::ttype_t *str_type_len_0 = ASRUtils::TYPE(ASR::make_String_t(
-            al, loc, 1,
-            ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 0,
-                ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
-            ASR::string_length_kindType::ExpressionLength,
-            ASR::string_physical_typeType::DescriptorString));
-        ASR::expr_t *empty_string = ASRUtils::EXPR(ASR::make_StringConstant_t(
-            al, loc, s2c(al, ""), str_type_len_0));
-        ASR::ttype_t *str_type_len_1 = ASRUtils::TYPE(ASR::make_String_t(
-            al, loc, 1,
-            ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1,
-                ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
-            ASR::string_length_kindType::ExpressionLength,
-            ASR::string_physical_typeType::DescriptorString));
-        ASR::expr_t *space = ASRUtils::EXPR(ASR::make_StringConstant_t(
-            al, loc, s2c(al, " "), str_type_len_1));
+    ASR::asr_t* construct_leading_space(const Location& loc)
+    {
+        ASR::ttype_t* str_type_len_0 = ASRUtils::TYPE(
+            ASR::make_String_t(al,
+                               loc,
+                               1,
+                               ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                   al, loc, 0, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                               ASR::string_length_kindType::ExpressionLength,
+                               ASR::string_physical_typeType::DescriptorString));
+        ASR::expr_t* empty_string
+            = ASRUtils::EXPR(ASR::make_StringConstant_t(al, loc, s2c(al, ""), str_type_len_0));
+        ASR::ttype_t* str_type_len_1 = ASRUtils::TYPE(
+            ASR::make_String_t(al,
+                               loc,
+                               1,
+                               ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                   al, loc, 1, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
+                               ASR::string_length_kindType::ExpressionLength,
+                               ASR::string_physical_typeType::DescriptorString));
+        ASR::expr_t* space
+            = ASRUtils::EXPR(ASR::make_StringConstant_t(al, loc, s2c(al, " "), str_type_len_1));
         Vec<ASR::expr_t*> args;
         args.reserve(al, 1);
         args.push_back(al, space);
-        return ASR::make_FileWrite_t(al, loc, 0, nullptr, nullptr,
-            nullptr, nullptr, args.p, args.size(), nullptr, empty_string, nullptr, true);
+        return ASR::make_FileWrite_t(al,
+                                     loc,
+                                     0,
+                                     nullptr,
+                                     nullptr,
+                                     nullptr,
+                                     nullptr,
+                                     args.p,
+                                     args.size(),
+                                     nullptr,
+                                     empty_string,
+                                     nullptr,
+                                     true);
     }
 
-    void visit_Print(const AST::Print_t &x) {
+    void visit_Print(const AST::Print_t& x)
+    {
         Vec<ASR::expr_t*> body;
         body.reserve(al, x.n_values);
-        ASR::expr_t *fmt=nullptr;
+        ASR::expr_t* fmt = nullptr;
         if (x.m_fmt != nullptr) {
             this->visit_expr(*x.m_fmt);
             fmt = ASRUtils::EXPR(tmp);
-            //check if fmt is integer variable
+            // check if fmt is integer variable
             ASR::ttype_t* fmt_type = ASRUtils::expr_type(fmt);
-            if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(fmt_type)) &&
-                ASR::is_a<ASR::Var_t>(*fmt)) {
+            if (ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(fmt_type))
+                && ASR::is_a<ASR::Var_t>(*fmt)) {
                 diag.add(Diagnostic(
                     "Assigned format (using integer variable as format specifier) is not supported. "
                     "Use character variables instead.",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         } else {
             if (compiler_options.print_leading_space) {
-                current_body->push_back(al, ASRUtils::STMT(construct_leading_space(x.base.base.loc)));
+                current_body->push_back(al,
+                                        ASRUtils::STMT(construct_leading_space(x.base.base.loc)));
             }
         }
 
-        for (size_t i=0; i<x.n_values; i++) {
+        for (size_t i = 0; i < x.n_values; i++) {
             this->visit_expr(*x.m_values[i]);
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
             if (ASRUtils::is_assumed_rank_array(ASRUtils::expr_type(expr))) {
                 ASR::Var_t* v = ASR::down_cast<ASR::Var_t>(expr);
-                ASR::Variable_t *var = ASR::down_cast<ASR::Variable_t>(v->m_v);
+                ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(v->m_v);
                 std::string var_name = var->m_name;
                 if (assumed_rank_arrays.find(var_name) == assumed_rank_arrays.end()) {
                     diag.add(diag::Diagnostic(
                         "Assumed-rank arrays are not supported in print statements",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                            diag::Label("", {expr->base.loc})
-                        }));
+                        diag::Level::Error,
+                        diag::Stage::Semantic,
+                        { diag::Label("", { expr->base.loc }) }));
                     throw SemanticAbort();
                 } else {
                     int rank = assumed_rank_arrays[var_name];
-                    Vec<ASR::dimension_t> dims; dims.reserve(al, rank);
+                    Vec<ASR::dimension_t> dims;
+                    dims.reserve(al, rank);
                     for (int r = 0; r < rank; r++) {
                         ASR::dimension_t dim;
                         dim.loc = x.base.base.loc;
@@ -4848,68 +5797,120 @@ public:
                         dim.m_length = nullptr;
                         dims.push_back(al, dim);
                     }
-                    ASR::ttype_t* elem_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(expr));
-                    ASR::ttype_t* desc_type = ASRUtils::make_Array_t_util(al, x.base.base.loc,
-                        elem_type, dims.p, dims.size(), ASR::abiType::Source, false,
-                        ASR::array_physical_typeType::DescriptorArray, false, false, true
-                    );
+                    ASR::ttype_t* elem_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(expr));
+                    ASR::ttype_t* desc_type
+                        = ASRUtils::make_Array_t_util(al,
+                                                      x.base.base.loc,
+                                                      elem_type,
+                                                      dims.p,
+                                                      dims.size(),
+                                                      ASR::abiType::Source,
+                                                      false,
+                                                      ASR::array_physical_typeType::DescriptorArray,
+                                                      false,
+                                                      false,
+                                                      true);
                     ASR::asr_t* array_cast = ASRUtils::make_ArrayPhysicalCast_t_util(
-                        al, expr->base.loc, expr, ASR::array_physical_typeType::AssumedRankArray,
-                        ASR::array_physical_typeType::DescriptorArray, desc_type, nullptr
-                    );
+                        al,
+                        expr->base.loc,
+                        expr,
+                        ASR::array_physical_typeType::AssumedRankArray,
+                        ASR::array_physical_typeType::DescriptorArray,
+                        desc_type,
+                        nullptr);
                     expr = ASRUtils::EXPR(array_cast);
                 }
             }
             body.push_back(al, expr);
         }
         if (fmt && ASR::is_a<ASR::IntegerConstant_t>(*fmt)) {
-            ASR::IntegerConstant_t *f = ASR::down_cast<ASR::IntegerConstant_t>(fmt);
+            ASR::IntegerConstant_t* f = ASR::down_cast<ASR::IntegerConstant_t>(fmt);
             int64_t label = f->m_n;
             if (format_statements.find(label) == format_statements.end()) {
-                ASR::ttype_t *char_type = ASRUtils::TYPE(ASR::make_Allocatable_t(al, x.base.base.loc,
-                    ASRUtils::TYPE(ASR::make_String_t(
-                        al, x.base.base.loc, 1, nullptr,
-                        ASR::string_length_kindType::DeferredLength,
-                        ASR::string_physical_typeType::DescriptorString))));
-                tmp =  ASR::make_Print_t(al, x.base.base.loc,
-                    ASRUtils::EXPR(ASR::make_StringFormat_t(al, x.base.base.loc, nullptr, body.p, body.size(),
-                    ASR::string_format_kindType::FormatFortran, char_type, nullptr)));
-                print_statements[tmp] = std::make_pair(&x.base,label);
+                ASR::ttype_t* char_type = ASRUtils::TYPE(
+                    ASR::make_Allocatable_t(al,
+                                            x.base.base.loc,
+                                            ASRUtils::TYPE(ASR::make_String_t(
+                                                al,
+                                                x.base.base.loc,
+                                                1,
+                                                nullptr,
+                                                ASR::string_length_kindType::DeferredLength,
+                                                ASR::string_physical_typeType::DescriptorString))));
+                tmp = ASR::make_Print_t(al,
+                                        x.base.base.loc,
+                                        ASRUtils::EXPR(ASR::make_StringFormat_t(
+                                            al,
+                                            x.base.base.loc,
+                                            nullptr,
+                                            body.p,
+                                            body.size(),
+                                            ASR::string_format_kindType::FormatFortran,
+                                            char_type,
+                                            nullptr)));
+                print_statements[tmp] = std::make_pair(&x.base, label);
                 return;
             }
-            ASR::ttype_t *fmt_type = ASRUtils::TYPE(ASR::make_String_t(
-                al, fmt->base.loc, 1,
-                ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, fmt->base.loc,
-                    format_statements[label].size(),
-                    ASRUtils::TYPE(ASR::make_Integer_t(al, fmt->base.loc, 4)))),
-                ASR::string_length_kindType::ExpressionLength,
-                ASR::string_physical_typeType::DescriptorString));
-            ASR::expr_t *fmt_constant = ASRUtils::EXPR(ASR::make_StringConstant_t(
+            ASR::ttype_t* fmt_type = ASRUtils::TYPE(
+                ASR::make_String_t(al,
+                                   fmt->base.loc,
+                                   1,
+                                   ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                       al,
+                                       fmt->base.loc,
+                                       format_statements[label].size(),
+                                       ASRUtils::TYPE(ASR::make_Integer_t(al, fmt->base.loc, 4)))),
+                                   ASR::string_length_kindType::ExpressionLength,
+                                   ASR::string_physical_typeType::DescriptorString));
+            ASR::expr_t* fmt_constant = ASRUtils::EXPR(ASR::make_StringConstant_t(
                 al, fmt->base.loc, s2c(al, format_statements[label]), fmt_type));
-            ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Allocatable_t(al, x.base.base.loc,
-                ASRUtils::TYPE(ASR::make_String_t(
-                    al, x.base.base.loc, 1, nullptr,
-                    ASR::string_length_kindType::DeferredLength,
-                    ASR::string_physical_typeType::DescriptorString))));
-            ASR::expr_t* string_format = ASRUtils::EXPR(ASRUtils::make_StringFormat_t_util(al, fmt->base.loc,
-                fmt_constant, body.p, body.size(), ASR::string_format_kindType::FormatFortran,
-                type, nullptr));
+            ASR::ttype_t* type = ASRUtils::TYPE(
+                ASR::make_Allocatable_t(al,
+                                        x.base.base.loc,
+                                        ASRUtils::TYPE(ASR::make_String_t(
+                                            al,
+                                            x.base.base.loc,
+                                            1,
+                                            nullptr,
+                                            ASR::string_length_kindType::DeferredLength,
+                                            ASR::string_physical_typeType::DescriptorString))));
+            ASR::expr_t* string_format = ASRUtils::EXPR(
+                ASRUtils::make_StringFormat_t_util(al,
+                                                   fmt->base.loc,
+                                                   fmt_constant,
+                                                   body.p,
+                                                   body.size(),
+                                                   ASR::string_format_kindType::FormatFortran,
+                                                   type,
+                                                   nullptr));
 
 
             tmp = ASR::make_Print_t(al, x.base.base.loc, string_format);
         } else if (!fmt && body.size() == 1
-                        && ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(body[0]))
-                        && !ASR::is_a<ASR::ImpliedDoLoop_t>(*body[0])) {
+                   && ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(body[0]))
+                   && !ASR::is_a<ASR::ImpliedDoLoop_t>(*body[0])) {
             tmp = ASR::make_Print_t(al, x.base.base.loc, body[0]);
         } else {
-            ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Allocatable_t(al, x.base.base.loc,
-                ASRUtils::TYPE(ASR::make_String_t(
-                    al, x.base.base.loc, 1, nullptr,
-                    ASR::string_length_kindType::DeferredLength,
-                    ASR::string_physical_typeType::DescriptorString))));
-            ASR::expr_t* string_format = ASRUtils::EXPR(ASRUtils::make_StringFormat_t_util(al, fmt?fmt->base.loc:x.base.base.loc,
-                fmt, body.p, body.size(), ASR::string_format_kindType::FormatFortran,
-                type, nullptr));
+            ASR::ttype_t* type = ASRUtils::TYPE(
+                ASR::make_Allocatable_t(al,
+                                        x.base.base.loc,
+                                        ASRUtils::TYPE(ASR::make_String_t(
+                                            al,
+                                            x.base.base.loc,
+                                            1,
+                                            nullptr,
+                                            ASR::string_length_kindType::DeferredLength,
+                                            ASR::string_physical_typeType::DescriptorString))));
+            ASR::expr_t* string_format = ASRUtils::EXPR(
+                ASRUtils::make_StringFormat_t_util(al,
+                                                   fmt ? fmt->base.loc : x.base.base.loc,
+                                                   fmt,
+                                                   body.p,
+                                                   body.size(),
+                                                   ASR::string_format_kindType::FormatFortran,
+                                                   type,
+                                                   nullptr));
 
             Vec<ASR::expr_t*> print_args;
             print_args.reserve(al, 1);
@@ -4919,108 +5920,128 @@ public:
         }
     }
 
-    void visit_If(const AST::If_t &x) {
+    void visit_If(const AST::If_t& x)
+    {
         all_blocks_nesting++;
         visit_expr(*x.m_test);
-        ASR::expr_t *test = ASRUtils::EXPR(tmp);
-        ASR::ttype_t *test_type = ASRUtils::type_get_past_pointer(ASRUtils::expr_type(test));
+        ASR::expr_t* test = ASRUtils::EXPR(tmp);
+        ASR::ttype_t* test_type = ASRUtils::type_get_past_pointer(ASRUtils::expr_type(test));
         if (!ASR::is_a<ASR::Logical_t>(*test_type)) {
-            diag.add(diag::Diagnostic("Expected logical expression in if statement, but recieved " +
-                ASRUtils::type_to_str_fortran_expr(test_type, test) + " instead",
-                diag::Level::Error, diag::Stage::Semantic, {
-                diag::Label(ASRUtils::type_to_str_fortran_expr(test_type, test) + " expression, expected logical", {test->base.loc})}));
+            diag.add(diag::Diagnostic(
+                "Expected logical expression in if statement, but recieved "
+                    + ASRUtils::type_to_str_fortran_expr(test_type, test) + " instead",
+                diag::Level::Error,
+                diag::Stage::Semantic,
+                { diag::Label(ASRUtils::type_to_str_fortran_expr(test_type, test)
+                                  + " expression, expected logical",
+                              { test->base.loc }) }));
             throw SemanticAbort();
         }
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
-        if(pragma_in_block) {
+        if (pragma_in_block) {
             nesting_lvl_inside_pragma++;
-            do_in_pragma=true;
+            do_in_pragma = true;
         }
         transform_stmts(body, x.n_body, x.m_body);
-        if(pragma_in_block) {
+        if (pragma_in_block) {
             nesting_lvl_inside_pragma--;
         }
-        if(nesting_lvl_inside_pragma==0) {
-            do_in_pragma=false;
+        if (nesting_lvl_inside_pragma == 0) {
+            do_in_pragma = false;
         }
         Vec<ASR::stmt_t*> orelse;
         orelse.reserve(al, x.n_orelse);
         transform_stmts(orelse, x.n_orelse, x.m_orelse);
-        tmp = ASR::make_If_t(al, x.base.base.loc, x.m_stmt_name, test, body.p,
-                body.size(), orelse.p, orelse.size());
+        tmp = ASR::make_If_t(
+            al, x.base.base.loc, x.m_stmt_name, test, body.p, body.size(), orelse.p, orelse.size());
         all_blocks_nesting--;
     }
 
-    void visit_IfArithmetic(const AST::IfArithmetic_t &x) {
+    void visit_IfArithmetic(const AST::IfArithmetic_t& x)
+    {
         visit_expr(*x.m_test);
-        ASR::expr_t *test_int = ASRUtils::EXPR(tmp);
-        ASR::ttype_t *test_int_type = ASRUtils::expr_type(test_int);
-        bool is_int  = ASR::is_a<ASR::Integer_t>(*test_int_type);
+        ASR::expr_t* test_int = ASRUtils::EXPR(tmp);
+        ASR::ttype_t* test_int_type = ASRUtils::expr_type(test_int);
+        bool is_int = ASR::is_a<ASR::Integer_t>(*test_int_type);
         bool is_real = ASR::is_a<ASR::Real_t>(*test_int_type);
         if (!is_int && !is_real) {
-            diag.add(diag::Diagnostic(
-                "Arithmetic if (x) requires an integer or real for `x`",
-                diag::Level::Error, diag::Stage::Semantic, {
-                    diag::Label("", {test_int->base.loc})}));
+            diag.add(diag::Diagnostic("Arithmetic if (x) requires an integer or real for `x`",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { test_int->base.loc }) }));
             throw SemanticAbort();
         }
         ASR::expr_t *test_lt, *test_gt;
         int kind = ASRUtils::extract_kind_from_ttype_t(test_int_type);
         if (is_int) {
-            ASR::ttype_t *type0 = ASRUtils::TYPE(
-                ASR::make_Integer_t(al, x.base.base.loc, kind));
-            ASR::expr_t *right = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al,
-                x.base.base.loc, 0, type0));
-            ASR::ttype_t *type = ASRUtils::TYPE(
+            ASR::ttype_t* type0 = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind));
+            ASR::expr_t* right
+                = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 0, type0));
+            ASR::ttype_t* type = ASRUtils::TYPE(
                 ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-            ASR::expr_t *value = nullptr;
-            test_lt = ASRUtils::EXPR(ASR::make_IntegerCompare_t(al, test_int->base.loc,
-                test_int, ASR::cmpopType::Lt, right, type, value));
-            test_gt = ASRUtils::EXPR(ASR::make_IntegerCompare_t(al, test_int->base.loc,
-                test_int, ASR::cmpopType::Gt, right, type, value));
+            ASR::expr_t* value = nullptr;
+            test_lt = ASRUtils::EXPR(ASR::make_IntegerCompare_t(
+                al, test_int->base.loc, test_int, ASR::cmpopType::Lt, right, type, value));
+            test_gt = ASRUtils::EXPR(ASR::make_IntegerCompare_t(
+                al, test_int->base.loc, test_int, ASR::cmpopType::Gt, right, type, value));
         } else {
-            ASR::ttype_t *type0 = ASRUtils::TYPE(
-                ASR::make_Real_t(al, x.base.base.loc, kind));
-            ASR::expr_t *right = ASRUtils::EXPR(ASR::make_RealConstant_t(al,
-                x.base.base.loc, 0, type0));
-            ASR::ttype_t *type = ASRUtils::TYPE(
+            ASR::ttype_t* type0 = ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, kind));
+            ASR::expr_t* right
+                = ASRUtils::EXPR(ASR::make_RealConstant_t(al, x.base.base.loc, 0, type0));
+            ASR::ttype_t* type = ASRUtils::TYPE(
                 ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-            ASR::expr_t *value = nullptr;
-            test_lt = ASRUtils::EXPR(ASR::make_RealCompare_t(al, test_int->base.loc,
-                test_int, ASR::cmpopType::Lt, right, type, value));
-            test_gt = ASRUtils::EXPR(ASR::make_RealCompare_t(al, test_int->base.loc,
-                test_int, ASR::cmpopType::Gt, right, type, value));
+            ASR::expr_t* value = nullptr;
+            test_lt = ASRUtils::EXPR(ASR::make_RealCompare_t(
+                al, test_int->base.loc, test_int, ASR::cmpopType::Lt, right, type, value));
+            test_gt = ASRUtils::EXPR(ASR::make_RealCompare_t(
+                al, test_int->base.loc, test_int, ASR::cmpopType::Gt, right, type, value));
         }
         Vec<ASR::stmt_t*> body;
         body.reserve(al, 1);
-        body.push_back(al, ASRUtils::STMT(
-            ASR::make_GoTo_t(al, x.base.base.loc, x.m_lt_label,
-                s2c(al, std::to_string(x.m_lt_label)))));
+        body.push_back(
+            al,
+            ASRUtils::STMT(ASR::make_GoTo_t(
+                al, x.base.base.loc, x.m_lt_label, s2c(al, std::to_string(x.m_lt_label)))));
         Vec<ASR::stmt_t*> orelse;
         orelse.reserve(al, 1);
 
         Vec<ASR::stmt_t*> body_gt;
         body_gt.reserve(al, 1);
-        body_gt.push_back(al, ASRUtils::STMT(
-            ASR::make_GoTo_t(al, x.base.base.loc, x.m_gt_label,
-                s2c(al, std::to_string(x.m_gt_label)))));
+        body_gt.push_back(
+            al,
+            ASRUtils::STMT(ASR::make_GoTo_t(
+                al, x.base.base.loc, x.m_gt_label, s2c(al, std::to_string(x.m_gt_label)))));
         Vec<ASR::stmt_t*> orelse_gt;
         orelse_gt.reserve(al, 1);
-        orelse_gt.push_back(al, ASRUtils::STMT(
-            ASR::make_GoTo_t(al, x.base.base.loc, x.m_eq_label,
-                s2c(al, std::to_string(x.m_eq_label)))));
-
-        orelse.push_back(al, ASRUtils::STMT(
-            ASR::make_If_t(al, x.base.base.loc, x.m_stmt_name, test_gt, body_gt.p,
-                body_gt.size(), orelse_gt.p, orelse_gt.size())));
-        tmp = ASR::make_If_t(al, x.base.base.loc, x.m_stmt_name, test_lt, body.p,
-                body.size(), orelse.p, orelse.size());
+        orelse_gt.push_back(
+            al,
+            ASRUtils::STMT(ASR::make_GoTo_t(
+                al, x.base.base.loc, x.m_eq_label, s2c(al, std::to_string(x.m_eq_label)))));
+
+        orelse.push_back(al,
+                         ASRUtils::STMT(ASR::make_If_t(al,
+                                                       x.base.base.loc,
+                                                       x.m_stmt_name,
+                                                       test_gt,
+                                                       body_gt.p,
+                                                       body_gt.size(),
+                                                       orelse_gt.p,
+                                                       orelse_gt.size())));
+        tmp = ASR::make_If_t(al,
+                             x.base.base.loc,
+                             x.m_stmt_name,
+                             test_lt,
+                             body.p,
+                             body.size(),
+                             orelse.p,
+                             orelse.size());
     }
 
-    void visit_Where(const AST::Where_t &x) {
+    void visit_Where(const AST::Where_t& x)
+    {
         visit_expr(*x.m_test);
-        ASR::expr_t *test = ASRUtils::EXPR(tmp);
+        ASR::expr_t* test = ASRUtils::EXPR(tmp);
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         transform_stmts(body, x.n_body, x.m_body);
@@ -5031,63 +6052,72 @@ public:
             if (ASR::is_a<ASR::Logical_t>(*ASRUtils::extract_type(ASRUtils::expr_type(test)))) {
                 // verify that `test` is *not* the ttype of an expression as we then
                 // are sure that it is a single standalone logical array
-                if  (!ASR::is_a<ASR::IntegerCompare_t>(*test)
+                if (!ASR::is_a<ASR::IntegerCompare_t>(*test)
                     && !ASR::is_a<ASR::RealCompare_t>(*test)
                     && !ASR::is_a<ASR::LogicalBinOp_t>(*test)) {
-                        // Rewrite into a form "X == true" as a workaround
-                        // until https://github.com/lfortran/lfortran/issues/4330 is fixed
-                        ASR::expr_t* logical_true = ASRUtils::EXPR(
-                                                        ASR::make_LogicalConstant_t(al, x.base.base.loc, true,
-                                                        ASRUtils::TYPE(ASR::make_Logical_t(al, x.base.base.loc, 4))));
-                        test = ASRUtils::EXPR(ASR::make_LogicalBinOp_t(al, x.base.base.loc, test,
-                                    ASR::logicalbinopType::Eqv, logical_true, ASRUtils::expr_type(test), nullptr));
+                    // Rewrite into a form "X == true" as a workaround
+                    // until https://github.com/lfortran/lfortran/issues/4330 is fixed
+                    ASR::expr_t* logical_true = ASRUtils::EXPR(ASR::make_LogicalConstant_t(
+                        al,
+                        x.base.base.loc,
+                        true,
+                        ASRUtils::TYPE(ASR::make_Logical_t(al, x.base.base.loc, 4))));
+                    test = ASRUtils::EXPR(ASR::make_LogicalBinOp_t(al,
+                                                                   x.base.base.loc,
+                                                                   test,
+                                                                   ASR::logicalbinopType::Eqv,
+                                                                   logical_true,
+                                                                   ASRUtils::expr_type(test),
+                                                                   nullptr));
                 }
             } else {
-                diag.add(Diagnostic(
-                    "the first array argument to `where` must be of type logical",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{test->base.loc})
-                    }));
+                diag.add(Diagnostic("the first array argument to `where` must be of type logical",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { test->base.loc }) }));
                 throw SemanticAbort();
             }
         } else {
-            diag.add(Diagnostic(
-                "the argument to `where` must be an array",
-                Level::Error, Stage::Semantic, {
-                    Label("",{test->base.loc})
-                }));
+            diag.add(Diagnostic("the argument to `where` must be an array",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { test->base.loc }) }));
             throw SemanticAbort();
         }
-        tmp = ASR::make_Where_t(al, x.base.base.loc, test, body.p, body.size(), orelse.p, orelse.size());
+        tmp = ASR::make_Where_t(
+            al, x.base.base.loc, test, body.p, body.size(), orelse.p, orelse.size());
     }
 
-    void visit_WhileLoop(const AST::WhileLoop_t &x) {
+    void visit_WhileLoop(const AST::WhileLoop_t& x)
+    {
         all_loops_blocks_nesting += 1;
         visit_expr(*x.m_test);
-        ASR::expr_t *test = ASRUtils::EXPR(tmp);
+        ASR::expr_t* test = ASRUtils::EXPR(tmp);
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         transform_stmts(body, x.n_body, x.m_body);
-        tmp = ASR::make_WhileLoop_t(al, x.base.base.loc, x.m_stmt_name, test, body.p,
-                body.size(), nullptr, 0);
+        tmp = ASR::make_WhileLoop_t(
+            al, x.base.base.loc, x.m_stmt_name, test, body.p, body.size(), nullptr, 0);
         all_loops_blocks_nesting -= 1;
     }
 
-    #define cast_as_loop_var(conv_candidate) \
-        ASR::ttype_t *des_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(var)); \
-        ASR::ttype_t *src_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(*conv_candidate)); \
-        ImplicitCastRules::set_converted_value(al, x.base.base.loc, conv_candidate, src_type, des_type, diag);
+#define cast_as_loop_var(conv_candidate)                                                           \
+    ASR::ttype_t* des_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(var));        \
+    ASR::ttype_t* src_type                                                                         \
+        = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(*conv_candidate));               \
+    ImplicitCastRules::set_converted_value(                                                        \
+        al, x.base.base.loc, conv_candidate, src_type, des_type, diag);
 
-    void visit_DoLoop(const AST::DoLoop_t &x) {
+    void visit_DoLoop(const AST::DoLoop_t& x)
+    {
         char* loop_name = x.m_stmt_name;
         if (loop_name) {
             std::string loop_name_str = to_lower(loop_name);
             if (current_scope->get_symbol(loop_name_str) != nullptr) {
-                diag.add(Diagnostic(
-                    "DO loop label '" + loop_name_str + "' already defined",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("DO loop label '" + loop_name_str + "' already defined",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
@@ -5098,7 +6128,8 @@ public:
         ASR::ttype_t* type = nullptr;
         var = start = end = nullptr;
         if (x.m_var) {
-            var = replace_with_common_block_variables(ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(x.m_var))));
+            var = replace_with_common_block_variables(
+                ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(x.m_var))));
         }
         if (x.m_start) {
             visit_expr(*x.m_start);
@@ -5106,10 +6137,7 @@ public:
             type = ASRUtils::expr_type(start);
             if (!ASR::is_a<ASR::Integer_t>(*type)) {
                 diag.semantic_warning_label(
-                    "Start expression in DO loop must be integer",
-                    {start->base.loc},
-                    ""
-                );
+                    "Start expression in DO loop must be integer", { start->base.loc }, "");
             }
             cast_as_loop_var(&start);
         }
@@ -5119,10 +6147,7 @@ public:
             type = ASRUtils::expr_type(end);
             if (!ASR::is_a<ASR::Integer_t>(*type)) {
                 diag.semantic_warning_label(
-                    "End expression in DO loop must be integer",
-                    {end->base.loc},
-                    ""
-                );
+                    "End expression in DO loop must be integer", { end->base.loc }, "");
             }
             cast_as_loop_var(&end);
         }
@@ -5135,11 +6160,10 @@ public:
             if (ASR::is_a<ASR::IntegerConstant_t>(*increment)) {
                 ASR::IntegerConstant_t* inc = ASR::down_cast<ASR::IntegerConstant_t>(increment);
                 if (inc->m_n == 0) {
-                    diag.add(Diagnostic(
-                        "Step expression (Increment) in DO loop cannot be zero",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{increment->base.loc})
-                        }));
+                    diag.add(Diagnostic("Step expression (Increment) in DO loop cannot be zero",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { increment->base.loc }) }));
                     throw SemanticAbort();
                 }
             } else {
@@ -5147,9 +6171,8 @@ public:
                 if (!ASR::is_a<ASR::Integer_t>(*type)) {
                     diag.semantic_warning_label(
                         "Step expression (increment) in DO loop must be integer",
-                        {increment->base.loc},
-                        ""
-                    );
+                        { increment->base.loc },
+                        "");
                 }
             }
             cast_as_loop_var(&increment);
@@ -5166,16 +6189,16 @@ public:
         }
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
-        if(pragma_in_block) {
+        if (pragma_in_block) {
             nesting_lvl_inside_pragma++;
-            do_in_pragma=true;
+            do_in_pragma = true;
         }
         transform_stmts(body, x.n_body, x.m_body);
-        if(pragma_in_block) {
+        if (pragma_in_block) {
             nesting_lvl_inside_pragma--;
         }
-        if(nesting_lvl_inside_pragma==0) {
-            do_in_pragma=false;
+        if (nesting_lvl_inside_pragma == 0) {
+            do_in_pragma = false;
         }
         ASR::do_loop_head_t head;
         head.m_v = var;
@@ -5184,59 +6207,58 @@ public:
         head.m_increment = increment;
         if (head.m_v != nullptr) {
             head.loc = head.m_v->base.loc;
-            tmp = ASR::make_DoLoop_t(al, x.base.base.loc, x.m_stmt_name,
-                head, body.p, body.size(), nullptr, 0);
+            tmp = ASR::make_DoLoop_t(
+                al, x.base.base.loc, x.m_stmt_name, head, body.p, body.size(), nullptr, 0);
             if (do_loop_variables.size() > 0) {
                 do_loop_variables.pop_back();
             }
         } else {
-            ASR::ttype_t* cond_type
-                = ASRUtils::TYPE(ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-            ASR::expr_t* cond = ASRUtils::EXPR(
-                ASR::make_LogicalConstant_t(al, x.base.base.loc, true, cond_type));
-            tmp = ASR::make_WhileLoop_t(al, x.base.base.loc, x.m_stmt_name, cond, body.p, body.size(), nullptr, 0);
+            ASR::ttype_t* cond_type = ASRUtils::TYPE(
+                ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+            ASR::expr_t* cond
+                = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, x.base.base.loc, true, cond_type));
+            tmp = ASR::make_WhileLoop_t(
+                al, x.base.base.loc, x.m_stmt_name, cond, body.p, body.size(), nullptr, 0);
         }
         loop_nesting -= 1;
         all_loops_blocks_nesting -= 1;
         all_blocks_nesting--;
     }
 
-    void visit_DoConcurrentLoop(const AST::DoConcurrentLoop_t &x) {
+    void visit_DoConcurrentLoop(const AST::DoConcurrentLoop_t& x)
+    {
         all_loops_blocks_nesting += 1;
         Vec<ASR::do_loop_head_t> heads;  // Create a vector of loop heads
-        heads.reserve(al,x.n_control);
-        for(size_t i=0;i<x.n_control;i++) {
-            AST::ConcurrentControl_t &h = *(AST::ConcurrentControl_t*) x.m_control[i];
-            if (! h.m_var) {
-                diag.add(Diagnostic(
-                    "Do loop: loop variable is required for now",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+        heads.reserve(al, x.n_control);
+        for (size_t i = 0; i < x.n_control; i++) {
+            AST::ConcurrentControl_t& h = *(AST::ConcurrentControl_t*) x.m_control[i];
+            if (!h.m_var) {
+                diag.add(Diagnostic("Do loop: loop variable is required for now",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-            if (! h.m_start) {
-                diag.add(Diagnostic(
-                    "Do loop: start condition required for now",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+            if (!h.m_start) {
+                diag.add(Diagnostic("Do loop: start condition required for now",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-            if (! h.m_end) {
-                diag.add(Diagnostic(
-                    "Do loop: end condition required for now",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+            if (!h.m_end) {
+                diag.add(Diagnostic("Do loop: end condition required for now",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-            ASR::expr_t *var = ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(h.m_var)));
+            ASR::expr_t* var = ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(h.m_var)));
             visit_expr(*h.m_start);
-            ASR::expr_t *start = ASRUtils::EXPR(tmp);
+            ASR::expr_t* start = ASRUtils::EXPR(tmp);
             visit_expr(*h.m_end);
-            ASR::expr_t *end = ASRUtils::EXPR(tmp);
-            ASR::expr_t *increment;
+            ASR::expr_t* end = ASRUtils::EXPR(tmp);
+            ASR::expr_t* increment;
             if (h.m_increment) {
                 visit_expr(*h.m_increment);
                 increment = ASRUtils::EXPR(tmp);
@@ -5254,108 +6276,133 @@ public:
         Vec<ASR::stmt_t*> body;
         body.reserve(al, x.n_body);
         transform_stmts(body, x.n_body, x.m_body);
-        Vec<ASR::reduction_expr_t> reductions; reductions.reserve(al, 1);
-        Vec<ASR::expr_t*> shared_expr; shared_expr.reserve(al, 1);
-        Vec<ASR::expr_t*> local_expr; local_expr.reserve(al, 1);
-        for (size_t i = 0; i < x.n_locality; i++ ) {
-            AST::concurrent_locality_t *locality = x.m_locality[i];
-            if ( locality->type == AST::concurrent_localityType::ConcurrentReduce ) {
-                AST::ConcurrentReduce_t *reduce = AST::down_cast<AST::ConcurrentReduce_t>(locality);
+        Vec<ASR::reduction_expr_t> reductions;
+        reductions.reserve(al, 1);
+        Vec<ASR::expr_t*> shared_expr;
+        shared_expr.reserve(al, 1);
+        Vec<ASR::expr_t*> local_expr;
+        local_expr.reserve(al, 1);
+        for (size_t i = 0; i < x.n_locality; i++) {
+            AST::concurrent_locality_t* locality = x.m_locality[i];
+            if (locality->type == AST::concurrent_localityType::ConcurrentReduce) {
+                AST::ConcurrentReduce_t* reduce = AST::down_cast<AST::ConcurrentReduce_t>(locality);
                 AST::reduce_opType op = reduce->m_op;
-                for ( size_t j = 0; j < reduce->n_vars; j++ ) {
-                    ASR::reduction_expr_t red; red.loc = x.base.base.loc;
-                    if ( op == AST::reduce_opType::ReduceAdd ) {
+                for (size_t j = 0; j < reduce->n_vars; j++) {
+                    ASR::reduction_expr_t red;
+                    red.loc = x.base.base.loc;
+                    if (op == AST::reduce_opType::ReduceAdd) {
                         red.m_op = ASR::reduction_opType::ReduceAdd;
-                    } else if ( op == AST::reduce_opType::ReduceMAX ) {
+                    } else if (op == AST::reduce_opType::ReduceMAX) {
                         red.m_op = ASR::reduction_opType::ReduceMAX;
-                    } else if ( op == AST::reduce_opType::ReduceMIN ) {
+                    } else if (op == AST::reduce_opType::ReduceMIN) {
                         red.m_op = ASR::reduction_opType::ReduceMIN;
-                    } else if ( op == AST::reduce_opType::ReduceMul ) {
+                    } else if (op == AST::reduce_opType::ReduceMul) {
                         red.m_op = ASR::reduction_opType::ReduceMul;
                     } else {
-                        diag.add(Diagnostic(
-                            "Unknown reduction operation",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic("Unknown reduction operation",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
-                    red.m_arg = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, current_scope->resolve_symbol(to_lower(reduce->m_vars[j]))));
+                    red.m_arg = ASRUtils::EXPR(ASR::make_Var_t(
+                        al,
+                        x.base.base.loc,
+                        current_scope->resolve_symbol(to_lower(reduce->m_vars[j]))));
                     reductions.push_back(al, red);
                 }
-            } else if ( locality->type == AST::concurrent_localityType::ConcurrentShared ) {
-                AST::ConcurrentShared_t *shared = AST::down_cast<AST::ConcurrentShared_t>(locality);
-                for ( size_t j = 0; j < shared->n_vars; j++ ) {
-                    shared_expr.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, current_scope->resolve_symbol(to_lower(shared->m_vars[j])))));
-                }
-            } else if ( locality->type == AST::concurrent_localityType::ConcurrentLocal ) {
-                AST::ConcurrentLocal_t *private_ = AST::down_cast<AST::ConcurrentLocal_t>(locality);
-                for ( size_t j = 0; j < private_->n_vars; j++ ) {
+            } else if (locality->type == AST::concurrent_localityType::ConcurrentShared) {
+                AST::ConcurrentShared_t* shared = AST::down_cast<AST::ConcurrentShared_t>(locality);
+                for (size_t j = 0; j < shared->n_vars; j++) {
+                    shared_expr.push_back(
+                        al,
+                        ASRUtils::EXPR(ASR::make_Var_t(
+                            al,
+                            x.base.base.loc,
+                            current_scope->resolve_symbol(to_lower(shared->m_vars[j])))));
+                }
+            } else if (locality->type == AST::concurrent_localityType::ConcurrentLocal) {
+                AST::ConcurrentLocal_t* private_ = AST::down_cast<AST::ConcurrentLocal_t>(locality);
+                for (size_t j = 0; j < private_->n_vars; j++) {
                     // check if loop variable is part of local expr
-                    for(size_t k=0;k<x.n_control;k++) {
-                        AST::ConcurrentControl_t &h = *(AST::ConcurrentControl_t*) x.m_control[k];
-                        ASR::expr_t *var = ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(h.m_var)));
-                        if (current_scope->resolve_symbol(to_lower(private_->m_vars[j])) == ASR::down_cast<ASR::Var_t>(var)->m_v ) {
-                            diag.add(Diagnostic(
-                                "Do concurrent loop variable `" + std::string(private_->m_vars[j]) + "` cannot be part of local expression",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{private_->base.base.loc})
-                                }));
+                    for (size_t k = 0; k < x.n_control; k++) {
+                        AST::ConcurrentControl_t& h = *(AST::ConcurrentControl_t*) x.m_control[k];
+                        ASR::expr_t* var
+                            = ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(h.m_var)));
+                        if (current_scope->resolve_symbol(to_lower(private_->m_vars[j]))
+                            == ASR::down_cast<ASR::Var_t>(var)->m_v) {
+                            diag.add(Diagnostic("Do concurrent loop variable `"
+                                                    + std::string(private_->m_vars[j])
+                                                    + "` cannot be part of local expression",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { private_->base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
-                    local_expr.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, current_scope->resolve_symbol(to_lower(private_->m_vars[j])))));
-                }
-            }
-        }
-        tmp = ASR::make_DoConcurrentLoop_t(al, x.base.base.loc, heads.p, heads.n, shared_expr.p, shared_expr.n, local_expr.p, local_expr.n, reductions.p, reductions.n, body.p,
-                body.size());
+                    local_expr.push_back(
+                        al,
+                        ASRUtils::EXPR(ASR::make_Var_t(
+                            al,
+                            x.base.base.loc,
+                            current_scope->resolve_symbol(to_lower(private_->m_vars[j])))));
+                }
+            }
+        }
+        tmp = ASR::make_DoConcurrentLoop_t(al,
+                                           x.base.base.loc,
+                                           heads.p,
+                                           heads.n,
+                                           shared_expr.p,
+                                           shared_expr.n,
+                                           local_expr.p,
+                                           local_expr.n,
+                                           reductions.p,
+                                           reductions.n,
+                                           body.p,
+                                           body.size());
         all_loops_blocks_nesting -= 1;
     }
 
-    void visit_ForAllSingle(const AST::ForAllSingle_t &x) {
+    void visit_ForAllSingle(const AST::ForAllSingle_t& x)
+    {
         all_loops_blocks_nesting += 1;
         if (x.n_control != 1) {
-            diag.add(Diagnostic(
-                "Forall statement: exactly one control statement is required for now",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+            diag.add(
+                Diagnostic("Forall statement: exactly one control statement is required for now",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        AST::ConcurrentControl_t &h = *(AST::ConcurrentControl_t*) x.m_control[0];
-        if (! h.m_var) {
-            diag.add(Diagnostic(
-                "Forall statement: loop variable is required",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        AST::ConcurrentControl_t& h = *(AST::ConcurrentControl_t*) x.m_control[0];
+        if (!h.m_var) {
+            diag.add(Diagnostic("Forall statement: loop variable is required",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        if (! h.m_start) {
-            diag.add(Diagnostic(
-                "Forall statement: start condition is required",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (!h.m_start) {
+            diag.add(Diagnostic("Forall statement: start condition is required",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        if (! h.m_end) {
-            diag.add(Diagnostic(
-                "Forall statement: end condition is required",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (!h.m_end) {
+            diag.add(Diagnostic("Forall statement: end condition is required",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        ASR::expr_t *var = ASRUtils::EXPR(
-            resolve_variable(x.base.base.loc, to_lower(h.m_var))
-        );
+        ASR::expr_t* var = ASRUtils::EXPR(resolve_variable(x.base.base.loc, to_lower(h.m_var)));
         visit_expr(*h.m_start);
-        ASR::expr_t *start = ASRUtils::EXPR(tmp);
+        ASR::expr_t* start = ASRUtils::EXPR(tmp);
         visit_expr(*h.m_end);
-        ASR::expr_t *end = ASRUtils::EXPR(tmp);
-        ASR::expr_t *increment;
+        ASR::expr_t* end = ASRUtils::EXPR(tmp);
+        ASR::expr_t* increment;
         if (h.m_increment) {
             visit_expr(*h.m_increment);
             increment = ASRUtils::EXPR(tmp);
@@ -5365,7 +6412,7 @@ public:
 
         ASR::stmt_t* assign_stmt;
         this->visit_stmt(*x.m_assign);
-        LCOMPILERS_ASSERT(tmp) // TODO Handle constant array
+        LCOMPILERS_ASSERT(tmp)  // TODO Handle constant array
         assign_stmt = ASRUtils::STMT(tmp);
         ASR::do_loop_head_t head;
         head.m_v = var;
@@ -5377,7 +6424,8 @@ public:
         all_loops_blocks_nesting -= 1;
     }
 
-    void visit_Exit(const AST::Exit_t &x) {
+    void visit_Exit(const AST::Exit_t& x)
+    {
         if (all_loops_blocks_nesting == 0) {
             diag.add(Diagnostic("`exit` statements cannot be outside of loops or blocks",
                                 Level::Error,
@@ -5388,25 +6436,28 @@ public:
         tmp = ASR::make_Exit_t(al, x.base.base.loc, x.m_stmt_name);
     }
 
-    void visit_Cycle(const AST::Cycle_t &x) {
+    void visit_Cycle(const AST::Cycle_t& x)
+    {
         tmp = ASR::make_Cycle_t(al, x.base.base.loc, x.m_stmt_name);
     }
 
-    void visit_Continue(const AST::Continue_t &/*x*/) {
+    void visit_Continue(const AST::Continue_t& /*x*/)
+    {
         // TODO: add a check here that we are inside a While loop
         // Nothing to generate, we return a null pointer
         tmp = nullptr;
     }
 
-    void visit_GoTo(const AST::GoTo_t &x) {
+    void visit_GoTo(const AST::GoTo_t& x)
+    {
         if (x.m_goto_label) {
             if (AST::is_a<AST::Num_t>(*x.m_goto_label)) {
                 int goto_label = AST::down_cast<AST::Num_t>(x.m_goto_label)->m_n;
-                tmp = ASR::make_GoTo_t(al, x.base.base.loc, goto_label,
-                        s2c(al, std::to_string(goto_label)));
+                tmp = ASR::make_GoTo_t(
+                    al, x.base.base.loc, goto_label, s2c(al, std::to_string(goto_label)));
             } else {
                 this->visit_expr(*x.m_goto_label);
-                ASR::expr_t *goto_label = ASRUtils::EXPR(tmp);
+                ASR::expr_t* goto_label = ASRUtils::EXPR(tmp);
 
                 // n_labels GOTO
                 Vec<ASR::case_stmt_t*> a_body_vec;
@@ -5417,35 +6468,50 @@ public:
                 def_body.reserve(al, 1);
                 for (size_t i = 0; i < x.n_labels; ++i) {
                     if (!AST::is_a<AST::Num_t>(*x.m_labels[i])) {
-                        diag.add(Diagnostic(
-                            "Only integer labels are supported in GOTO.",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic("Only integer labels are supported in GOTO.",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     } else {
-                        auto l = AST::down_cast<AST::Num_t>(x.m_labels[i]); // l->m_n gets the target -> if l->m_n == (i+1) ...
+                        auto l = AST::down_cast<AST::Num_t>(
+                            x.m_labels[i]);  // l->m_n gets the target -> if l->m_n == (i+1) ...
                         Vec<ASR::stmt_t*> body;
                         body.reserve(al, 1);
-                        body.push_back(al, ASRUtils::STMT(ASR::make_GoTo_t(al, x.base.base.loc, l->m_n, s2c(al, std::to_string(l->m_n)))));
+                        body.push_back(
+                            al,
+                            ASRUtils::STMT(ASR::make_GoTo_t(
+                                al, x.base.base.loc, l->m_n, s2c(al, std::to_string(l->m_n)))));
                         Vec<ASR::expr_t*> comparator_one;
                         comparator_one.reserve(al, 1);
-                        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-                        comparator_one.push_back(al, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, i+1, int_type)));
-                        a_body_vec.push_back(al, ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(al, x.base.base.loc, comparator_one.p, 1, body.p, 1, false)));
+                        ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(
+                            al, x.base.base.loc, compiler_options.po.default_integer_kind));
+                        comparator_one.push_back(al,
+                                                 ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                                     al, x.base.base.loc, i + 1, int_type)));
+                        a_body_vec.push_back(
+                            al,
+                            ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(
+                                al, x.base.base.loc, comparator_one.p, 1, body.p, 1, false)));
                     }
                 }
-                tmp = ASR::make_Select_t(al, x.base.base.loc, nullptr, goto_label, a_body_vec.p,
-                           a_body_vec.size(), def_body.p, def_body.size(), false);
+                tmp = ASR::make_Select_t(al,
+                                         x.base.base.loc,
+                                         nullptr,
+                                         goto_label,
+                                         a_body_vec.p,
+                                         a_body_vec.size(),
+                                         def_body.p,
+                                         def_body.size(),
+                                         false);
             }
         } else if (x.m_int_var) {
-            std::string label{x.m_int_var};
+            std::string label{ x.m_int_var };
             if (std::find(labels.begin(), labels.end(), label) == labels.end()) {
-                diag.add(Diagnostic(
-                    "Cannot GOTO unknown label",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Cannot GOTO unknown label",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             auto sym = current_scope->resolve_symbol(label);
@@ -5461,11 +6527,10 @@ public:
                 }
             } else {
                 // cannot perform expected behavior
-                diag.add(Diagnostic(
-                    "Cannot compute GOTO.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Cannot compute GOTO.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
 
@@ -5476,63 +6541,88 @@ public:
             Vec<ASR::stmt_t*> def_body;
             def_body.reserve(al, 1);
 
-            auto is_integer = [] (const std::string & s) {
-                    return !s.empty() && std::all_of(s.begin(), s.end(), [](char c) {
-                        return ::isdigit(c) || c == ' ';
-                    });
+            auto is_integer = [](const std::string& s) {
+                return !s.empty() && std::all_of(s.begin(), s.end(), [](char c) {
+                    return ::isdigit(c) || c == ' ';
+                });
             };
 
-            // if there are no labels to iterate over, iterate over _all_ labels available in current scope
+            // if there are no labels to iterate over, iterate over _all_ labels available in
+            // current scope
             if (!x.n_labels) {
-                for (const auto &label : labels) {
-                    if (!is_integer(label)) continue;
+                for (const auto& label : labels) {
+                    if (!is_integer(label))
+                        continue;
                     int32_t num = std::stoi(label);
                     Vec<ASR::stmt_t*> body;
                     body.reserve(al, 1);
-                    body.push_back(al, ASRUtils::STMT(ASR::make_GoTo_t(al, x.base.base.loc, num, s2c(al, std::to_string(num)))));
+                    body.push_back(al,
+                                   ASRUtils::STMT(ASR::make_GoTo_t(
+                                       al, x.base.base.loc, num, s2c(al, std::to_string(num)))));
                     Vec<ASR::expr_t*> comparator_one;
                     comparator_one.reserve(al, 1);
-                    ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-                    comparator_one.push_back(al, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, num, int_type)));
-                    a_body_vec.push_back(al, ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(al, x.base.base.loc, comparator_one.p, 1, body.p, 1, false)));
+                    ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(
+                        al, x.base.base.loc, compiler_options.po.default_integer_kind));
+                    comparator_one.push_back(al,
+                                             ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                                 al, x.base.base.loc, num, int_type)));
+                    a_body_vec.push_back(
+                        al,
+                        ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(
+                            al, x.base.base.loc, comparator_one.p, 1, body.p, 1, false)));
                 }
             } else {
                 for (size_t i = 0; i < x.n_labels; ++i) {
                     if (!AST::is_a<AST::Num_t>(*x.m_labels[i])) {
-                        diag.add(Diagnostic(
-                            "Only integer labels are supported in GOTO.",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic("Only integer labels are supported in GOTO.",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     } else {
                         auto l = AST::down_cast<AST::Num_t>(x.m_labels[i]);
                         Vec<ASR::stmt_t*> body;
                         body.reserve(al, 1);
-                        body.push_back(al, ASRUtils::STMT(ASR::make_GoTo_t(al, x.base.base.loc, l->m_n, s2c(al, std::to_string(l->m_n)))));
+                        body.push_back(
+                            al,
+                            ASRUtils::STMT(ASR::make_GoTo_t(
+                                al, x.base.base.loc, l->m_n, s2c(al, std::to_string(l->m_n)))));
                         Vec<ASR::expr_t*> comparator_one;
                         comparator_one.reserve(al, 1);
-                        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-                        comparator_one.push_back(al, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, l->m_n, int_type)));
-                        a_body_vec.push_back(al, ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(al, x.base.base.loc, comparator_one.p, 1, body.p, 1, false)));
+                        ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(
+                            al, x.base.base.loc, compiler_options.po.default_integer_kind));
+                        comparator_one.push_back(al,
+                                                 ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                                     al, x.base.base.loc, l->m_n, int_type)));
+                        a_body_vec.push_back(
+                            al,
+                            ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(
+                                al, x.base.base.loc, comparator_one.p, 1, body.p, 1, false)));
                     }
                 }
             }
             ASR::expr_t* var_expr = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, sym));
-            tmp = ASR::make_Select_t(al, x.base.base.loc, nullptr, var_expr, a_body_vec.p,
-                           a_body_vec.size(), def_body.p, def_body.size(), false);
+            tmp = ASR::make_Select_t(al,
+                                     x.base.base.loc,
+                                     nullptr,
+                                     var_expr,
+                                     a_body_vec.p,
+                                     a_body_vec.size(),
+                                     def_body.p,
+                                     def_body.size(),
+                                     false);
         } else {
-            diag.add(Diagnostic(
-                "There must be a target to GOTO.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+            diag.add(Diagnostic("There must be a target to GOTO.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
-    void visit_Stop(const AST::Stop_t &x) {
-        ASR::expr_t *code;
+    void visit_Stop(const AST::Stop_t& x)
+    {
+        ASR::expr_t* code;
         if (x.m_code) {
             visit_expr(*x.m_code);
             code = ASRUtils::EXPR(tmp);
@@ -5542,8 +6632,9 @@ public:
         tmp = ASR::make_Stop_t(al, x.base.base.loc, code);
     }
 
-    void visit_ErrorStop(const AST::ErrorStop_t &x) {
-        ASR::expr_t *code;
+    void visit_ErrorStop(const AST::ErrorStop_t& x)
+    {
+        ASR::expr_t* code;
         if (x.m_code) {
             visit_expr(*x.m_code);
             code = ASRUtils::EXPR(tmp);
@@ -5553,59 +6644,64 @@ public:
         tmp = ASR::make_ErrorStop_t(al, x.base.base.loc, code);
     }
 
-    void visit_Nullify(const AST::Nullify_t &x) {
+    void visit_Nullify(const AST::Nullify_t& x)
+    {
         Vec<ASR::expr_t*> arg_vec;
         arg_vec.reserve(al, x.n_args);
-        for( size_t i = 0; i < x.n_args; i++ ) {
+        for (size_t i = 0; i < x.n_args; i++) {
             this->visit_expr(*(x.m_args[i]));
             ASR::expr_t* tmp_expr = ASRUtils::EXPR(tmp);
-            if (ASRUtils::is_pointer(ASRUtils::expr_type(tmp_expr)) || ASR::is_a<ASR::FunctionType_t>(*ASRUtils::expr_type(tmp_expr))) {
-                if(ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr) || ASR::is_a<ASR::Var_t>(*tmp_expr)) {
+            if (ASRUtils::is_pointer(ASRUtils::expr_type(tmp_expr))
+                || ASR::is_a<ASR::FunctionType_t>(*ASRUtils::expr_type(tmp_expr))) {
+                if (ASR::is_a<ASR::StructInstanceMember_t>(*tmp_expr)
+                    || ASR::is_a<ASR::Var_t>(*tmp_expr)) {
                     arg_vec.push_back(al, tmp_expr);
-                }
-                else {
+                } else {
                     diag.add(Diagnostic(
-                    "Pointer must be of Variable type or StructInstanceMember type in order to get nullified.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{tmp_expr->base.loc})
-                    }));
-                throw SemanticAbort();
+                        "Pointer must be of Variable type or StructInstanceMember type in order to get nullified.",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { tmp_expr->base.loc }) }));
+                    throw SemanticAbort();
                 }
             } else {
-                diag.add(Diagnostic(
-                    "Only a pointer variable symbol "
-                    "can be nullified.",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{tmp_expr->base.loc})
-                    }));
+                diag.add(Diagnostic("Only a pointer variable symbol "
+                                    "can be nullified.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { tmp_expr->base.loc }) }));
                 throw SemanticAbort();
             }
         }
         tmp = ASR::make_Nullify_t(al, x.base.base.loc, arg_vec.p, arg_vec.size());
     }
 
-    void visit_Requirement(const AST::Requirement_t /*&x*/) {
-
+    void visit_Requirement(const AST::Requirement_t /*&x*/)
+    {
     }
 
-    void visit_Require(const AST::Require_t /*&x*/) {
-
+    void visit_Require(const AST::Require_t /*&x*/)
+    {
     }
 
-    void collect_omp_body(ASR::omp_region_typeType region_type) {
+    void collect_omp_body(ASR::omp_region_typeType region_type)
+    {
         if (omp_region_body.size() > 0) {
             Vec<ASR::stmt_t*> last_pragma_body;
-            last_pragma_body.reserve(al,0);
-            //Collect till we encounter required OMPRegion of region_type
-            while(!omp_region_body.empty() && !(omp_region_body.back()->type == ASR::stmtType::OMPRegion && (ASR::down_cast<ASR::OMPRegion_t>(omp_region_body.back())->m_region == region_type))) {
+            last_pragma_body.reserve(al, 0);
+            // Collect till we encounter required OMPRegion of region_type
+            while (!omp_region_body.empty()
+                   && !(omp_region_body.back()->type == ASR::stmtType::OMPRegion
+                        && (ASR::down_cast<ASR::OMPRegion_t>(omp_region_body.back())->m_region
+                            == region_type))) {
                 last_pragma_body.push_back(al, omp_region_body.back());
                 omp_region_body.pop_back();
             }
             // Reverse the vector of body to maintain the order
             Vec<ASR::stmt_t*> tmp_body;
             tmp_body.reserve(al, 0);
-            for(size_t i=0; i<last_pragma_body.size(); i++) {
-                tmp_body.push_back(al, last_pragma_body[last_pragma_body.size()-i-1]);
+            for (size_t i = 0; i < last_pragma_body.size(); i++) {
+                tmp_body.push_back(al, last_pragma_body[last_pragma_body.size() - i - 1]);
             }
             ASR::OMPRegion_t* omp_region = ASR::down_cast<ASR::OMPRegion_t>(omp_region_body.back());
             omp_region->m_body = tmp_body.p;
@@ -5613,7 +6709,8 @@ public:
         }
     }
 
-    Vec<ASR::omp_clause_t*> get_clauses(const AST::Pragma_t &x) {
+    Vec<ASR::omp_clause_t*> get_clauses(const AST::Pragma_t& x)
+    {
         Location loc = x.base.base.loc;
         Vec<ASR::omp_clause_t*> clauses;
         clauses.reserve(al, x.n_clauses);
@@ -5621,34 +6718,38 @@ public:
         for (size_t i = 0; i < x.n_clauses; i++) {
             std::string clause = AST::down_cast<AST::String_t>(x.m_clauses[i])->m_s;
             std::string clause_name = clause.substr(0, clause.find('('));
-            if (clause_name == "private" || clause_name == "reduction" || clause_name == "shared" || clause_name == "firstprivate" || clause_name == "collapse" || clause_name == "num_teams" || clause_name == "thread_limit" || clause_name == "schedule" || clause_name == "num_threads" || clause_name == "map" || clause_name == "device") {
-                std::string list = clause.substr(clause.find('(') + 1, clause.size() - clause_name.size() - 2);
+            if (clause_name == "private" || clause_name == "reduction" || clause_name == "shared"
+                || clause_name == "firstprivate" || clause_name == "collapse"
+                || clause_name == "num_teams" || clause_name == "thread_limit"
+                || clause_name == "schedule" || clause_name == "num_threads" || clause_name == "map"
+                || clause_name == "device") {
+                std::string list
+                    = clause.substr(clause.find('(') + 1, clause.size() - clause_name.size() - 2);
                 Vec<ASR::expr_t*> vars;
                 vars.reserve(al, 1);
                 ASR::reduction_opType op = ASR::reduction_opType::ReduceAdd;
                 ASR::map_typeType map_type = ASR::map_typeType::To;
                 if (clause_name == "reduction") {
                     std::string reduction_op = list.substr(0, list.find(':'));
-                    if ( reduction_op == "+" ) {
+                    if (reduction_op == "+") {
                         op = ASR::reduction_opType::ReduceAdd;
-                    } else if ( reduction_op == "-" ) {
+                    } else if (reduction_op == "-") {
                         op = ASR::reduction_opType::ReduceSub;
-                    } else if ( reduction_op == "*" ) {
+                    } else if (reduction_op == "*") {
                         op = ASR::reduction_opType::ReduceMul;
-                    } else if ( reduction_op == "max" ) {
+                    } else if (reduction_op == "max") {
                         op = ASR::reduction_opType::ReduceMAX;
-                    } else if ( reduction_op == "min" ) {
+                    } else if (reduction_op == "min") {
                         op = ASR::reduction_opType::ReduceMIN;
                     } else {
-                        diag.add(Diagnostic(
-                            "The reduction operator "+ reduction_op
-                            +" is not supported yet",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{loc})
-                            }));
+                        diag.add(Diagnostic("The reduction operator " + reduction_op
+                                                + " is not supported yet",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                        list = list.substr(list.find(':')+1);
+                    list = list.substr(list.find(':') + 1);
                 } else if (clause_name == "map") {
                     std::string map_str = list.substr(0, list.find(':'));
                     if (map_str == "to") {
@@ -5658,29 +6759,75 @@ public:
                     } else if (map_str == "tofrom") {
                         map_type = ASR::map_typeType::ToFrom;
                     } else {
-                        diag.add(Diagnostic("The map type `" + map_str + "` is not supported", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("The map type `" + map_str + "` is not supported",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                    list = list.substr(list.find(':')+1);
+                    list = list.substr(list.find(':') + 1);
                 } else if (clause_name == "collapse") {
-                    int collapse_value = std::stoi(list.erase(0, list.find_first_not_of(" "))); // Get the value of N
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPCollapse_t(al, loc, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, collapse_value, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
+                    int collapse_value = std::stoi(
+                        list.erase(0, list.find_first_not_of(" ")));  // Get the value of N
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPCollapse_t(
+                                          al,
+                                          loc,
+                                          ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                              al,
+                                              loc,
+                                              collapse_value,
+                                              ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
                     continue;
                 } else if (clause_name == "num_threads") {
-                    int num_threads = std::stoi(list.erase(0, list.find_first_not_of(" "))); // Get the value of N
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPNumThreads_t(al, loc, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, num_threads, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
+                    int num_threads = std::stoi(
+                        list.erase(0, list.find_first_not_of(" ")));  // Get the value of N
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPNumThreads_t(
+                                          al,
+                                          loc,
+                                          ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                              al,
+                                              loc,
+                                              num_threads,
+                                              ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
                     continue;
                 } else if (clause_name == "thread_limit") {
-                    int thread_limit = std::stoi(list.erase(0, list.find_first_not_of(" "))); // Get the value of N
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPThreadLimit_t(al, loc, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, thread_limit, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
+                    int thread_limit = std::stoi(
+                        list.erase(0, list.find_first_not_of(" ")));  // Get the value of N
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPThreadLimit_t(
+                                          al,
+                                          loc,
+                                          ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                              al,
+                                              loc,
+                                              thread_limit,
+                                              ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
                     continue;
                 } else if (clause_name == "num_teams") {
-                    int num_teams = std::stoi(list.erase(0, list.find_first_not_of(" "))); // Get the value of N
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPNumTeams_t(al, loc, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, num_teams, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
+                    int num_teams = std::stoi(
+                        list.erase(0, list.find_first_not_of(" ")));  // Get the value of N
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPNumTeams_t(
+                                          al,
+                                          loc,
+                                          ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                              al,
+                                              loc,
+                                              num_teams,
+                                              ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
                     continue;
                 } else if (clause_name == "device") {
-                    int dev = std::stoi(list.erase(0, list.find_first_not_of(" "))); // Get the value of N
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPDevice_t(al, loc, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, dev, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
+                    int dev = std::stoi(
+                        list.erase(0, list.find_first_not_of(" ")));  // Get the value of N
+                    clauses.push_back(
+                        al,
+                        ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPDevice_t(
+                            al,
+                            loc,
+                            ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                al, loc, dev, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
                     continue;
                 } else if (clause_name == "schedule") {
                     ASR::schedule_typeType schedule_type;
@@ -5695,47 +6842,71 @@ public:
                     } else if (LCompilers::startswith(list, "runtime")) {
                         schedule_type = ASR::schedule_typeType::Runtime;
                     } else {
-                        diag.add(Diagnostic("The schedule type `" + list + "` is not supported", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("The schedule type `" + list + "` is not supported",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                     int chunk_size = 0;
-                    if(list.find(',') != std::string::npos) {
-                        list = list.substr(list.find(',')+1);
+                    if (list.find(',') != std::string::npos) {
+                        list = list.substr(list.find(',') + 1);
                         chunk_size = std::stoi(list.erase(0, list.find_first_not_of(" ")));
                     }
-                    if(chunk_size == 0) {
-                        clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                        ASR::make_OMPSchedule_t(al, loc, schedule_type, nullptr)));
+                    if (chunk_size == 0) {
+                        clauses.push_back(al,
+                                          ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPSchedule_t(
+                                              al, loc, schedule_type, nullptr)));
                     } else {
-                        clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                            ASR::make_OMPSchedule_t(al, loc, schedule_type, ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, chunk_size, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
+                        clauses.push_back(
+                            al,
+                            ASR::down_cast<ASR::omp_clause_t>(ASR::make_OMPSchedule_t(
+                                al,
+                                loc,
+                                schedule_type,
+                                ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                    al,
+                                    loc,
+                                    chunk_size,
+                                    ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))))));
                     }
                     continue;
                 }
-                for (auto &s : LCompilers::string_split(list, ",", false)) {
+                for (auto& s : LCompilers::string_split(list, ",", false)) {
                     s.erase(0, s.find_first_not_of(" "));
                     bool is_array_section = false;
                     std::string section;
-                    if(s[s.size()-1] == ')') {
+                    if (s[s.size() - 1] == ')') {
                         size_t pos = s.find('(');
-                        if(pos != s.size() - 1) {
+                        if (pos != s.size() - 1) {
                             section = s.substr(pos + 1, s.size() - 2);
                             s = s.substr(0, pos);
                             is_array_section = true;
                         } else {
-                            diag.add(Diagnostic("The clause variable `" + s + "` is not declared or not a variable", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                            diag.add(Diagnostic("The clause variable `" + s
+                                                    + "` is not declared or not a variable",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { loc }) }));
                             throw SemanticAbort();
                         }
                     }
-                    ASR::symbol_t *sym = current_scope->get_symbol(s);
+                    ASR::symbol_t* sym = current_scope->get_symbol(s);
                     if (!sym || !ASR::is_a<ASR::Variable_t>(*sym)) {
-                        diag.add(Diagnostic("The clause variable `" + s + "` is not declared or not a variable", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("The clause variable `" + s
+                                                + "` is not declared or not a variable",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                    if(is_array_section) {
-                        ASR::Variable_t *var = ASR::down_cast<ASR::Variable_t>(sym);
+                    if (is_array_section) {
+                        ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(sym);
                         if (!ASRUtils::is_array(var->m_type)) {
-                            diag.add(Diagnostic("The clause variable `" + s + "` is not an array", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                            diag.add(Diagnostic("The clause variable `" + s + "` is not an array",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { loc }) }));
                             throw SemanticAbort();
                         } else {
                             Vec<ASR::array_index_t> args;
@@ -5749,39 +6920,56 @@ public:
                             idx.m_right = b.i32(stoi(end));
                             idx.m_step = b.i32(1);
                             args.push_back(al, idx);
-                            vars.push_back(al, ASRUtils::EXPR(ASR::make_ArraySection_t(al, loc, ASRUtils::EXPR(ASR::make_Var_t(al, loc, sym)),
-                                args.p, args.n, ASRUtils::type_get_past_allocatable(var->m_type), nullptr)));
+                            vars.push_back(al,
+                                           ASRUtils::EXPR(ASR::make_ArraySection_t(
+                                               al,
+                                               loc,
+                                               ASRUtils::EXPR(ASR::make_Var_t(al, loc, sym)),
+                                               args.p,
+                                               args.n,
+                                               ASRUtils::type_get_past_allocatable(var->m_type),
+                                               nullptr)));
                         }
                     } else {
                         vars.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, loc, sym)));
                     }
                 }
                 if (clause_name == "private") {
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                        ASR::make_OMPPrivate_t(al, loc, vars.p, vars.n)));
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(
+                                          ASR::make_OMPPrivate_t(al, loc, vars.p, vars.n)));
                 } else if (clause_name == "shared") {
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                        ASR::make_OMPShared_t(al, loc, vars.p, vars.n)));
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(
+                                          ASR::make_OMPShared_t(al, loc, vars.p, vars.n)));
                 } else if (clause_name == "firstprivate") {
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                        ASR::make_OMPFirstPrivate_t(al, loc, vars.p, vars.n)));
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(
+                                          ASR::make_OMPFirstPrivate_t(al, loc, vars.p, vars.n)));
                 } else if (clause_name == "map") {
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                        ASR::make_OMPMap_t(al, loc, map_type, vars.p, vars.n)));
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(
+                                          ASR::make_OMPMap_t(al, loc, map_type, vars.p, vars.n)));
                 } else {
-                    clauses.push_back(al, ASR::down_cast<ASR::omp_clause_t>(
-                        ASR::make_OMPReduction_t(al, loc, op, vars.p, vars.n)));
+                    clauses.push_back(al,
+                                      ASR::down_cast<ASR::omp_clause_t>(
+                                          ASR::make_OMPReduction_t(al, loc, op, vars.p, vars.n)));
                 }
             } else {
-                diag.add(Diagnostic("The clause " + clause_name + " is not supported for parallel sections", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                diag.add(Diagnostic("The clause " + clause_name
+                                        + " is not supported for parallel sections",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         }
         return clauses;
     }
 
-    void visit_Pragma(const AST::Pragma_t &x) {
-        if ( !compiler_options.openmp ) {
+    void visit_Pragma(const AST::Pragma_t& x)
+    {
+        if (!compiler_options.openmp) {
             return;
         }
         Location loc = x.base.base.loc;
@@ -5792,13 +6980,15 @@ public:
                     // Collect the body of the previous section
                     pragma_nesting_level_2--;
                     collect_omp_body(ASR::omp_region_typeType::Section);
-                    // Now collect stmts of all Sections inside the parallel sections and add it in body of ParallelSections OMPRegion_t
+                    // Now collect stmts of all Sections inside the parallel sections and add it in
+                    // body of ParallelSections OMPRegion_t
                     collect_omp_body(ASR::omp_region_typeType::ParallelSections);
                 } else if (LCompilers::startswith(x.m_construct_name, "sections")) {
                     // Collect the body of the previous section
                     pragma_nesting_level_2--;
                     collect_omp_body(ASR::omp_region_typeType::Section);
-                    // Now collect stmts of all Sections inside the parallel sections and add it in body of ParallelSections OMPRegion_t
+                    // Now collect stmts of all Sections inside the parallel sections and add it in
+                    // body of ParallelSections OMPRegion_t
                     collect_omp_body(ASR::omp_region_typeType::Sections);
                 } else if (LCompilers::startswith(x.m_construct_name, "single")) {
                     collect_omp_body(ASR::omp_region_typeType::Single);
@@ -5812,7 +7002,7 @@ public:
                     collect_omp_body(ASR::omp_region_typeType::ParallelDo);
                 } else if (LCompilers::startswith(x.m_construct_name, "parallel")) {
                     collect_omp_body(ASR::omp_region_typeType::Parallel);
-                } else if(LCompilers::startswith(x.m_construct_name, "do")) {
+                } else if (LCompilers::startswith(x.m_construct_name, "do")) {
                     collect_omp_body(ASR::omp_region_typeType::Do);
                 } else if (LCompilers::startswith(x.m_construct_name, "critical")) {
                     collect_omp_body(ASR::omp_region_typeType::Critical);
@@ -5829,15 +7019,17 @@ public:
                 } else if (LCompilers::startswith(x.m_construct_name, "target")) {
                     collect_omp_body(ASR::omp_region_typeType::Target);
                 }
-                pragma_in_block=false;
-                if((pragma_nesting_level_2 == 0 && omp_region_body.size()==1) || all_blocks_nesting>0) {
-                    tmp=(ASR::asr_t*)(ASR::down_cast<ASR::OMPRegion_t>(omp_region_body.back()));
+                pragma_in_block = false;
+                if ((pragma_nesting_level_2 == 0 && omp_region_body.size() == 1)
+                    || all_blocks_nesting > 0) {
+                    tmp = (ASR::asr_t*) (ASR::down_cast<ASR::OMPRegion_t>(omp_region_body.back()));
                     omp_region_body.pop_back();
                 }
                 return;
             }
 
-            if(all_blocks_nesting>0) pragma_in_block=true;
+            if (all_blocks_nesting > 0)
+                pragma_in_block = true;
             if (to_lower(x.m_construct_name) == "parallel") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
@@ -5845,36 +7037,54 @@ public:
 
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Parallel, clauses.p, clauses.n, body.p, body.n)));
-            } else if ( to_lower(x.m_construct_name) == "do" ) {
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Parallel,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
+            } else if (to_lower(x.m_construct_name) == "do") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
-                
+
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Do, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(ASRUtils::STMT(ASR::make_OMPRegion_t(
+                    al, loc, ASR::omp_region_typeType::Do, clauses.p, clauses.n, body.p, body.n)));
             } else if (to_lower(x.m_construct_name) == "parallel do") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
-                
+
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::ParallelDo, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::ParallelDo,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "sections") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 is_first_section = true;
-                
+
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Sections, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Sections,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "parallel sections") {
                 pragma_nesting_level_2++;
                 is_first_section = true;
@@ -5885,11 +7095,17 @@ public:
 
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::ParallelSections, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::ParallelSections,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "section") {
                 pragma_nesting_level_2++;
-                if(!is_first_section){
+                if (!is_first_section) {
                     // Collect body of previous section and put it in its OMPRegion
                     pragma_nesting_level_2--;
                     collect_omp_body(ASR::omp_region_typeType::Section);
@@ -5898,106 +7114,177 @@ public:
                 }
                 // Add OMPRegion of Current Section
                 ASR::asr_t* section = ASR::make_OMPRegion_t(
-                    al, x.base.base.loc, ASR::omp_region_typeType::Section,
-                    nullptr, 0, nullptr, 0);
+                    al, x.base.base.loc, ASR::omp_region_typeType::Section, nullptr, 0, nullptr, 0);
                 omp_region_body.push_back(ASRUtils::STMT(section));
-            } else if(to_lower(x.m_construct_name) == "single") {
+            } else if (to_lower(x.m_construct_name) == "single") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Single, clauses.p, clauses.n, body.p, body.n)));
-            
-            } else if(to_lower(x.m_construct_name) == "master") {
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Single,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
+
+            } else if (to_lower(x.m_construct_name) == "master") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Master, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Master,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "task") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Task, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Task,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "critical") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Critical, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Critical,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "barrier") {
                 // pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Barrier, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Barrier,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "taskwait") {
                 // pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Taskwait, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Taskwait,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "taskloop") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Taskloop, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Taskloop,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "teams") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Teams, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Teams,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "distribute") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Distribute, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Distribute,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "teams distribute") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::TeamsDistribute, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::TeamsDistribute,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "atomic") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Atomic, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Atomic,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "target") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
                 clauses = get_clauses(x);
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
-                omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::Target, clauses.p, clauses.n, body.p, body.n)));
+                omp_region_body.push_back(
+                    ASRUtils::STMT(ASR::make_OMPRegion_t(al,
+                                                         loc,
+                                                         ASR::omp_region_typeType::Target,
+                                                         clauses.p,
+                                                         clauses.n,
+                                                         body.p,
+                                                         body.n)));
             } else if (to_lower(x.m_construct_name) == "distribute parallel do") {
                 pragma_nesting_level_2++;
                 Vec<ASR::omp_clause_t*> clauses;
@@ -6005,78 +7292,93 @@ public:
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, 0);
                 omp_region_body.push_back(ASRUtils::STMT(
-                    ASR::make_OMPRegion_t(al, loc, ASR::omp_region_typeType::DistributeParallelDo, clauses.p, clauses.n, body.p, body.n)));
-            }else {
-                diag.add(Diagnostic(
-                    "The construct "+ std::string(x.m_construct_name)
-                    +" is not supported yet",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{loc})
-                    }));
+                    ASR::make_OMPRegion_t(al,
+                                          loc,
+                                          ASR::omp_region_typeType::DistributeParallelDo,
+                                          clauses.p,
+                                          clauses.n,
+                                          body.p,
+                                          body.n)));
+            } else {
+                diag.add(Diagnostic("The construct " + std::string(x.m_construct_name)
+                                        + " is not supported yet",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         } else {
-            diag.add(Diagnostic(
-                "The pragma type is not supported yet",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+            diag.add(Diagnostic("The pragma type is not supported yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
     }
 
-    void visit_Template(const AST::Template_t &x){
+    void visit_Template(const AST::Template_t& x)
+    {
         is_template = true;
 
         SymbolTable* old_scope = current_scope;
         ASR::symbol_t* t = current_scope->get_symbol(to_lower(x.m_name));
         ASR::Template_t* v = ASR::down_cast<ASR::Template_t>(t);
         current_scope = v->m_symtab;
-        for (size_t i=0; i<x.n_decl; i++) {
+        for (size_t i = 0; i < x.n_decl; i++) {
             this->visit_unit_decl2(*x.m_decl[i]);
         }
-        for (size_t i=0; i<x.n_contains; i++) {
+        for (size_t i = 0; i < x.n_contains; i++) {
             this->visit_program_unit(*x.m_contains[i]);
         }
         current_scope = old_scope;
 
         is_template = false;
     }
-
 };
 
-Result<ASR::TranslationUnit_t*> body_visitor(Allocator &al,
-        AST::TranslationUnit_t &ast,
-        diag::Diagnostics &diagnostics,
-        ASR::asr_t *unit,
-        CompilerOptions &compiler_options,
-        std::map<uint64_t, std::map<std::string, ASR::ttype_t*>>& implicit_mapping,
-        std::map<uint64_t, ASR::symbol_t*>& common_variables_hash,
-        std::map<uint64_t, std::vector<std::string>>& external_procedures_mapping,
-        std::map<uint64_t, std::vector<std::string>>& explicit_intrinsic_procedures_mapping,
-        std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>> &instantiate_types,
-        std::map<uint32_t, std::map<std::string, ASR::symbol_t*>> &instantiate_symbols,
-        std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>> &entry_functions,
-        std::map<std::string, std::vector<int>> &entry_function_arguments_mapping,
-        std::map<uint32_t, std::vector<ASR::stmt_t*>> &data_structure,
-        LCompilers::LocationManager &lm)
+Result<ASR::TranslationUnit_t*>
+body_visitor(
+    Allocator& al,
+    AST::TranslationUnit_t& ast,
+    diag::Diagnostics& diagnostics,
+    ASR::asr_t* unit,
+    CompilerOptions& compiler_options,
+    std::map<uint64_t, std::map<std::string, ASR::ttype_t*>>& implicit_mapping,
+    std::map<uint64_t, ASR::symbol_t*>& common_variables_hash,
+    std::map<uint64_t, std::vector<std::string>>& external_procedures_mapping,
+    std::map<uint64_t, std::vector<std::string>>& explicit_intrinsic_procedures_mapping,
+    std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>>&
+        instantiate_types,
+    std::map<uint32_t, std::map<std::string, ASR::symbol_t*>>& instantiate_symbols,
+    std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>>& entry_functions,
+    std::map<std::string, std::vector<int>>& entry_function_arguments_mapping,
+    std::map<uint32_t, std::vector<ASR::stmt_t*>>& data_structure,
+    LCompilers::LocationManager& lm)
 {
-    BodyVisitor b(al, unit, diagnostics, compiler_options, implicit_mapping,
-        common_variables_hash, external_procedures_mapping,
-        explicit_intrinsic_procedures_mapping,
-        instantiate_types, instantiate_symbols, entry_functions,
-        entry_function_arguments_mapping, data_structure, lm
-    );
+    BodyVisitor b(al,
+                  unit,
+                  diagnostics,
+                  compiler_options,
+                  implicit_mapping,
+                  common_variables_hash,
+                  external_procedures_mapping,
+                  explicit_intrinsic_procedures_mapping,
+                  instantiate_types,
+                  instantiate_symbols,
+                  entry_functions,
+                  entry_function_arguments_mapping,
+                  data_structure,
+                  lm);
     try {
         b.is_body_visitor = true;
         b.visit_TranslationUnit(ast);
         b.is_body_visitor = false;
-    } catch (const SemanticAbort &) {
+    } catch (const SemanticAbort&) {
         Error error;
         return error;
     }
-    ASR::TranslationUnit_t *tu = ASR::down_cast2<ASR::TranslationUnit_t>(unit);
+    ASR::TranslationUnit_t* tu = ASR::down_cast2<ASR::TranslationUnit_t>(unit);
     return tu;
 }
 
-} // namespace LCompilers::LFortran
+}  // namespace LCompilers::LFortran
diff --git a/src/lfortran/semantics/ast_common_visitor.h b/src/lfortran/semantics/ast_common_visitor.h
index f00db0c0a..86b578dea 100644
--- a/src/lfortran/semantics/ast_common_visitor.h
+++ b/src/lfortran/semantics/ast_common_visitor.h
@@ -19,83 +19,89 @@
 #include <map>
 #include <limits>
 
+using LCompilers::diag::Diagnostic;
+using LCompilers::diag::Label;
 using LCompilers::diag::Level;
 using LCompilers::diag::Stage;
-using LCompilers::diag::Label;
-using LCompilers::diag::Diagnostic;
 
-namespace LCompilers::LFortran {
+namespace LCompilers::LFortran
+{
 
 static std::map<std::string, std::vector<ASR::Variable_t*>> vars_with_deferred_struct_declaration;
 static std::map<std::string, int> assumed_rank_arrays;
 
 template <typename T>
-void extract_bind(T &x, ASR::abiType &abi_type, char *&bindc_name, diag::Diagnostics &diag) {
+void
+extract_bind(T& x, ASR::abiType& abi_type, char*& bindc_name, diag::Diagnostics& diag)
+{
     if (x.m_bind) {
-        AST::Bind_t *bind = AST::down_cast<AST::Bind_t>(x.m_bind);
+        AST::Bind_t* bind = AST::down_cast<AST::Bind_t>(x.m_bind);
         if (bind->n_args == 1) {
             if (AST::is_a<AST::Name_t>(*bind->m_args[0])) {
-                AST::Name_t *name = AST::down_cast<AST::Name_t>(
-                    bind->m_args[0]);
+                AST::Name_t* name = AST::down_cast<AST::Name_t>(bind->m_args[0]);
                 if (to_lower(std::string(name->m_id)) == "c") {
-                    abi_type=ASR::abiType::BindC;
+                    abi_type = ASR::abiType::BindC;
                 } else if (to_lower(std::string(name->m_id)) == "js") {
-                    abi_type=ASR::abiType::BindJS;
+                    abi_type = ASR::abiType::BindJS;
                 } else {
-                    diag.add(diag::Diagnostic(
-                        "Unsupported language in bind()",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                            diag::Label("", {x.base.base.loc})}));
+                    diag.add(diag::Diagnostic("Unsupported language in bind()",
+                                              diag::Level::Error,
+                                              diag::Stage::Semantic,
+                                              { diag::Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else {
-                    diag.add(diag::Diagnostic(
-                        "Language name must be specified in bind() as plain text",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                            diag::Label("", {x.base.base.loc})}));
-                    throw SemanticAbort();
+                diag.add(diag::Diagnostic("Language name must be specified in bind() as plain text",
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             }
         } else {
-            diag.add(diag::Diagnostic(
-                "At least one argument needed in bind()",
-                diag::Level::Error, diag::Stage::Semantic, {
-                    diag::Label("", {x.base.base.loc})}));
+            diag.add(diag::Diagnostic("At least one argument needed in bind()",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         if (bind->n_kwargs == 1) {
-            char *arg = bind->m_kwargs[0].m_arg;
-            AST::expr_t *value = bind->m_kwargs[0].m_value;
+            char* arg = bind->m_kwargs[0].m_arg;
+            AST::expr_t* value = bind->m_kwargs[0].m_value;
             if (to_lower(std::string(arg)) == "name") {
                 if (AST::is_a<AST::String_t>(*value)) {
-                    AST::String_t *name = AST::down_cast<AST::String_t>(value);
+                    AST::String_t* name = AST::down_cast<AST::String_t>(value);
                     bindc_name = name->m_s;
                 } else {
                     diag.add(diag::Diagnostic(
                         "The value of the 'name' keyword argument in bind(c) must be a string",
-                        diag::Level::Error, diag::Stage::Semantic, {
-                            diag::Label("", {x.base.base.loc})}));
+                        diag::Level::Error,
+                        diag::Stage::Semantic,
+                        { diag::Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else {
-                diag.add(diag::Diagnostic(
-                    "Unsupported keyword argument in bind()",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+                diag.add(diag::Diagnostic("Unsupported keyword argument in bind()",
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
     }
 }
 
-uint64_t static inline get_hash(ASR::asr_t *node)
+uint64_t static inline get_hash(ASR::asr_t* node)
 {
-    return (uint64_t)node;
+    return (uint64_t) node;
 }
 
-#define LFORTRAN_STMT_LABEL_TYPE(x) \
-        case AST::stmtType::x: { return AST::down_cast<AST::x##_t>(f)->m_label; }
+#define LFORTRAN_STMT_LABEL_TYPE(x)                                                                \
+    case AST::stmtType::x: {                                                                       \
+        return AST::down_cast<AST::x##_t>(f)->m_label;                                             \
+    }
 
-static inline int64_t stmt_label(AST::stmt_t *f)
+static inline int64_t
+stmt_label(AST::stmt_t* f)
 {
     switch (f->type) {
         LFORTRAN_STMT_LABEL_TYPE(Allocate)
@@ -149,7 +155,8 @@ static inline int64_t stmt_label(AST::stmt_t *f)
         LFORTRAN_STMT_LABEL_TYPE(SelectType)
         LFORTRAN_STMT_LABEL_TYPE(Where)
         LFORTRAN_STMT_LABEL_TYPE(WhileLoop)
-        default : throw LCompilersException("Unhandled type in stmt_label");
+        default:
+            throw LCompilersException("Unhandled type in stmt_label");
     }
 }
 
@@ -158,13 +165,19 @@ struct IntrinsicSignature {
     int positional_args, max_args;
 
     IntrinsicSignature(std::vector<std::string> kwarg_names_ = {},
-        int positional_args_ = 0, int max_args_ = 0): kwarg_names(kwarg_names_),
-        positional_args(positional_args_), max_args(max_args_) {}
+                       int positional_args_ = 0,
+                       int max_args_ = 0)
+        : kwarg_names(kwarg_names_)
+        , positional_args(positional_args_)
+        , max_args(max_args_)
+    {
+    }
 };
 
-class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValuesVisitor> {
-    public:
-    Allocator &al;
+class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValuesVisitor>
+{
+public:
+    Allocator& al;
     std::vector<ASR::symbol_t*>& loop_vars;
     std::vector<int>& loop_indices;
     ASR::expr_t* value;
@@ -172,51 +185,66 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
     diag::Diagnostics& diag;
     const std::map<ASRUtils::IntrinsicElementalFunctions, size_t> name2signature_varargs = {
         // max0 can accept any arbitrary number of arguments 2<=x<=100
-        {ASRUtils::IntrinsicElementalFunctions::Max, 100},
+        { ASRUtils::IntrinsicElementalFunctions::Max, 100 },
         // min0 can accept any arbitrary number of arguments 2<=x<=100
-        {ASRUtils::IntrinsicElementalFunctions::Min, 100},
-        {ASRUtils::IntrinsicElementalFunctions::Aint, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Nint, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Anint, 2},
-        {ASRUtils::IntrinsicElementalFunctions::StringContainsSet, 4},
-        {ASRUtils::IntrinsicElementalFunctions::StringFindSet, 4},
-        {ASRUtils::IntrinsicElementalFunctions::SubstrIndex, 4},
-        {ASRUtils::IntrinsicElementalFunctions::Floor, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Ceiling, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Maskr, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Maskl, 2},
-        {ASRUtils::IntrinsicElementalFunctions::SelectedRealKind, 3},
-        {ASRUtils::IntrinsicElementalFunctions::Ishftc, 3},
-        {ASRUtils::IntrinsicElementalFunctions::Ichar, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Char, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Achar, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Logical, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Real, 2},
-        {ASRUtils::IntrinsicElementalFunctions::StorageSize, 2},
-        {ASRUtils::IntrinsicElementalFunctions::OutOfRange, 3},
-        {ASRUtils::IntrinsicElementalFunctions::StringLenTrim, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Int, 2},
-        {ASRUtils::IntrinsicElementalFunctions::Cmplx, 3},
+        { ASRUtils::IntrinsicElementalFunctions::Min, 100 },
+        { ASRUtils::IntrinsicElementalFunctions::Aint, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Nint, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Anint, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::StringContainsSet, 4 },
+        { ASRUtils::IntrinsicElementalFunctions::StringFindSet, 4 },
+        { ASRUtils::IntrinsicElementalFunctions::SubstrIndex, 4 },
+        { ASRUtils::IntrinsicElementalFunctions::Floor, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Ceiling, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Maskr, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Maskl, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::SelectedRealKind, 3 },
+        { ASRUtils::IntrinsicElementalFunctions::Ishftc, 3 },
+        { ASRUtils::IntrinsicElementalFunctions::Ichar, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Char, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Achar, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Logical, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Real, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::StorageSize, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::OutOfRange, 3 },
+        { ASRUtils::IntrinsicElementalFunctions::StringLenTrim, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Int, 2 },
+        { ASRUtils::IntrinsicElementalFunctions::Cmplx, 3 },
     };
 
-    ImpliedDoLoopValuesVisitor(Allocator& al, std::vector<ASR::symbol_t*>& loop_vars, std::vector<int>& loop_indices, ASR::expr_t* value_,
-        ASR::ttype_t* type, diag::Diagnostics& diag) :
-        al(al), loop_vars(loop_vars), loop_indices(loop_indices), value(value_), type(type), diag(diag) {}
+    ImpliedDoLoopValuesVisitor(Allocator& al,
+                               std::vector<ASR::symbol_t*>& loop_vars,
+                               std::vector<int>& loop_indices,
+                               ASR::expr_t* value_,
+                               ASR::ttype_t* type,
+                               diag::Diagnostics& diag)
+        : al(al)
+        , loop_vars(loop_vars)
+        , loop_indices(loop_indices)
+        , value(value_)
+        , type(type)
+        , diag(diag)
+    {
+    }
 
-    void visit_Var(const ASR::Var_t &x) {
-        int loop_var_index = std::find(loop_vars.begin(), loop_vars.end(), x.m_v) - loop_vars.begin();
+    void visit_Var(const ASR::Var_t& x)
+    {
+        int loop_var_index
+            = std::find(loop_vars.begin(), loop_vars.end(), x.m_v) - loop_vars.begin();
         // check if loop_var_index is valid
         if (loop_var_index >= (int) loop_vars.size()) {
             // this is compiletime value
-            ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(
-                                        ASRUtils::symbol_get_past_external(x.m_v));
+            ASR::Variable_t* var
+                = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(x.m_v));
             this->visit_expr(*var->m_value);
         } else {
-            value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, loop_indices[loop_var_index], ASRUtils::symbol_type(x.m_v)));
+            value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                al, x.base.base.loc, loop_indices[loop_var_index], ASRUtils::symbol_type(x.m_v)));
         }
     }
 
-    void visit_ArrayItem(const ASR::ArrayItem_t &x) {
+    void visit_ArrayItem(const ASR::ArrayItem_t& x)
+    {
         std::vector<int64_t> indices;
         for (size_t k = 0; k < x.n_args; k++) {
             this->visit_expr(*x.m_args[k].m_right);
@@ -237,20 +265,22 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
             this->value = nullptr;
             return;
         }
-    
+
         ASR::ttype_t* array_type = arr_const->m_type;
         ASR::ttype_t* el_type = ASRUtils::type_get_past_array(array_type);
         if (ASR::is_a<ASR::Integer_t>(*el_type)) {
             int kind = ASR::down_cast<ASR::Integer_t>(el_type)->m_kind;
             if (kind == 4) {
-                int32_t* data = (int32_t*)arr_const->m_data;
+                int32_t* data = (int32_t*) arr_const->m_data;
                 int32_t val = data[idx0];
-                this->value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, arr_const->base.base.loc, val, el_type));
+                this->value = ASRUtils::EXPR(
+                    ASR::make_IntegerConstant_t(al, arr_const->base.base.loc, val, el_type));
                 return;
             } else if (kind == 8) {
-                int64_t* data = (int64_t*)arr_const->m_data;
+                int64_t* data = (int64_t*) arr_const->m_data;
                 int64_t val = data[idx0];
-                this->value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, arr_const->base.base.loc, val, el_type));
+                this->value = ASRUtils::EXPR(
+                    ASR::make_IntegerConstant_t(al, arr_const->base.base.loc, val, el_type));
                 return;
             } else {
                 this->value = nullptr;
@@ -259,14 +289,16 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
         } else if (ASR::is_a<ASR::Real_t>(*el_type)) {
             int kind = ASR::down_cast<ASR::Real_t>(el_type)->m_kind;
             if (kind == 4) {
-                float* data = (float*)arr_const->m_data;
+                float* data = (float*) arr_const->m_data;
                 float val = data[idx0];
-                this->value = ASRUtils::EXPR(ASR::make_RealConstant_t(al, arr_const->base.base.loc, (double)val, el_type));
+                this->value = ASRUtils::EXPR(
+                    ASR::make_RealConstant_t(al, arr_const->base.base.loc, (double) val, el_type));
                 return;
             } else if (kind == 8) {
-                double* data = (double*)arr_const->m_data;
+                double* data = (double*) arr_const->m_data;
                 double val = data[idx0];
-                this->value = ASRUtils::EXPR(ASR::make_RealConstant_t(al, arr_const->base.base.loc, val, el_type));
+                this->value = ASRUtils::EXPR(
+                    ASR::make_RealConstant_t(al, arr_const->base.base.loc, val, el_type));
                 return;
             } else {
                 this->value = nullptr;
@@ -275,14 +307,16 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
         } else if (ASR::is_a<ASR::Logical_t>(*el_type)) {
             int kind = ASR::down_cast<ASR::Logical_t>(el_type)->m_kind;
             if (kind == 1) {
-                int8_t* data = (int8_t*)arr_const->m_data;
+                int8_t* data = (int8_t*) arr_const->m_data;
                 bool val = data[idx0] != 0;
-                this->value = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, arr_const->base.base.loc, val, el_type));
+                this->value = ASRUtils::EXPR(
+                    ASR::make_LogicalConstant_t(al, arr_const->base.base.loc, val, el_type));
                 return;
             } else {
-                int32_t* data = (int32_t*)arr_const->m_data;
+                int32_t* data = (int32_t*) arr_const->m_data;
                 bool val = data[idx0] != 0;
-                this->value = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, arr_const->base.base.loc, val, el_type));
+                this->value = ASRUtils::EXPR(
+                    ASR::make_LogicalConstant_t(al, arr_const->base.base.loc, val, el_type));
                 return;
             }
         } else {
@@ -291,7 +325,8 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
         }
     }
 
-    void visit_IntegerCompare( const ASR::IntegerCompare_t &x ) {
+    void visit_IntegerCompare(const ASR::IntegerCompare_t& x)
+    {
         int left_val, right_val;
         this->visit_expr(*x.m_left);
         left_val = ASR::down_cast<ASR::IntegerConstant_t>(value)->m_n;
@@ -319,13 +354,16 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
                 break;
             default:
                 diag.add(Diagnostic("Unsupported comparison operation in implied do loop",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
         }
         value = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, x.base.base.loc, res, x.m_type));
     }
 
-    void visit_RealCompare( const ASR::RealCompare_t &x ) {
+    void visit_RealCompare(const ASR::RealCompare_t& x)
+    {
         double left_val, right_val;
         this->visit_expr(*x.m_left);
         if (ASR::is_a<ASR::RealConstant_t>(*value)) {
@@ -361,35 +399,47 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
                 break;
             default:
                 diag.add(Diagnostic("Unsupported comparison operation in implied do loop",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
         }
         value = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, x.base.base.loc, res, x.m_type));
     }
 
-    void visit_IntegerConstant(const ASR::IntegerConstant_t &x) {
+    void visit_IntegerConstant(const ASR::IntegerConstant_t& x)
+    {
         value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, x.m_n, x.m_type));
     }
 
-    void visit_RealConstant(const ASR::RealConstant_t &x) {
+    void visit_RealConstant(const ASR::RealConstant_t& x)
+    {
         value = ASRUtils::EXPR(ASR::make_RealConstant_t(al, x.base.base.loc, x.m_r, x.m_type));
     }
 
-    void visit_LogicalConstant(const ASR::LogicalConstant_t &x) {
-        value = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, x.base.base.loc, x.m_value, x.m_type));
+    void visit_LogicalConstant(const ASR::LogicalConstant_t& x)
+    {
+        value
+            = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, x.base.base.loc, x.m_value, x.m_type));
     }
 
-    void visit_ComplexConstant(const ASR::ComplexConstant_t &x) {
-        diag.add(Diagnostic("Complex constant in compiletime evaluation implied do loop not supported",
-                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+    void visit_ComplexConstant(const ASR::ComplexConstant_t& x)
+    {
+        diag.add(
+            Diagnostic("Complex constant in compiletime evaluation implied do loop not supported",
+                       Level::Error,
+                       Stage::Semantic,
+                       { Label("", { x.base.base.loc }) }));
         throw SemanticAbort();
     }
 
-    void visit_StringConstant(const ASR::StringConstant_t &x) {
+    void visit_StringConstant(const ASR::StringConstant_t& x)
+    {
         value = ASRUtils::EXPR(ASR::make_StringConstant_t(al, x.base.base.loc, x.m_s, x.m_type));
     }
 
-    void visit_IntegerBinOp(const ASR::IntegerBinOp_t &x) {
+    void visit_IntegerBinOp(const ASR::IntegerBinOp_t& x)
+    {
         int left_val, right_val;
         this->visit_expr(*x.m_left);
         left_val = ASR::down_cast<ASR::IntegerConstant_t>(value)->m_n;
@@ -414,13 +464,16 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
                 break;
             default:
                 diag.add(Diagnostic("Unsupported binary operation in implied do loop",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
         }
         value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, res, x.m_type));
     }
 
-    void visit_RealBinOp(const ASR::RealBinOp_t &x) {
+    void visit_RealBinOp(const ASR::RealBinOp_t& x)
+    {
         double left_val, right_val;
         this->visit_expr(*x.m_left);
         if (ASR::is_a<ASR::RealConstant_t>(*value)) {
@@ -453,789 +506,944 @@ class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValu
                 break;
             default:
                 diag.add(Diagnostic("Unsupported binary operation in implied do loop",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
         }
         value = ASRUtils::EXPR(ASR::make_RealConstant_t(al, x.base.base.loc, res, x.m_type));
     }
 
-     inline size_t get_max_args(ASRUtils::IntrinsicElementalFunctions id) {
-        if( name2signature_varargs.find(id) == name2signature_varargs.end() ) {
+    inline size_t get_max_args(ASRUtils::IntrinsicElementalFunctions id)
+    {
+        if (name2signature_varargs.find(id) == name2signature_varargs.end()) {
             return 1;
         }
         return name2signature_varargs.at(id);
     }
     // handle intrinsic elemental function
-    void visit_IntrinsicElementalFunction(const ASR::IntrinsicElementalFunction_t &x) {
-        Vec<ASR::expr_t*> args; args.reserve(al, x.n_args);
+    void visit_IntrinsicElementalFunction(const ASR::IntrinsicElementalFunction_t& x)
+    {
+        Vec<ASR::expr_t*> args;
+        args.reserve(al, x.n_args);
         for (size_t i = 0; i < x.n_args; i++) {
             ASR::ttype_t* arg_type = ASRUtils::expr_type(x.m_args[i]);
             this->visit_expr(*x.m_args[i]);
             // TODO: handle multiple types
-            if (ASRUtils::is_real(*arg_type) || ASRUtils::is_integer(*arg_type) || ASRUtils::is_logical(*arg_type)) {
+            if (ASRUtils::is_real(*arg_type) || ASRUtils::is_integer(*arg_type)
+                || ASRUtils::is_logical(*arg_type)) {
                 args.push_back(al, value);
             } else {
-                diag.add(Diagnostic("Unsupported argument type in compiletime evaluation of intrinsics in implied do loop",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                diag.add(Diagnostic(
+                    "Unsupported argument type in compiletime evaluation of intrinsics in implied do loop",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
         std::string intrinsic_name = to_lower(ASRUtils::get_intrinsic_name(x.m_intrinsic_id));
-        size_t max_args = get_max_args(static_cast<ASRUtils::IntrinsicElementalFunctions>(x.m_intrinsic_id));
-        for (size_t i = x.n_args; i < max_args; i++) args.push_back(al, nullptr);
-        ASRUtils::create_intrinsic_function create_func =
-                ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(intrinsic_name);
+        size_t max_args
+            = get_max_args(static_cast<ASRUtils::IntrinsicElementalFunctions>(x.m_intrinsic_id));
+        for (size_t i = x.n_args; i < max_args; i++)
+            args.push_back(al, nullptr);
+        ASRUtils::create_intrinsic_function create_func
+            = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(intrinsic_name);
         ASR::expr_t* intrinsic_expr = ASRUtils::EXPR(create_func(al, x.base.base.loc, args, diag));
-        ASR::IntrinsicElementalFunction_t *intrinsic_func = ASR::down_cast<ASR::IntrinsicElementalFunction_t>(intrinsic_expr);
+        ASR::IntrinsicElementalFunction_t* intrinsic_func
+            = ASR::down_cast<ASR::IntrinsicElementalFunction_t>(intrinsic_expr);
         this->visit_expr(*intrinsic_func->m_value);
     }
 };
 
 
-class CommonVisitorMethods {
+class CommonVisitorMethods
+{
 public:
+    static inline ASR::expr_t* compare_helper(Allocator& al,
+                                              ASR::expr_t* left_value,
+                                              ASR::expr_t* right_value,
+                                              ASR::cmpopType asr_op,
+                                              const Location loc,
+                                              diag::Diagnostics& diag)
+    {
+        if (ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(left_value))) {
+            int64_t left_val = ASR::down_cast<ASR::IntegerConstant_t>(left_value)->m_n;
+            int64_t right_val = ASR::down_cast<ASR::IntegerConstant_t>(right_value)->m_n;
+            bool result = true;
+            switch (asr_op) {
+                case (ASR::cmpopType::Eq): {
+                    result = result && (left_val == right_val);
+                    break;
+                }
+                case (ASR::cmpopType::Gt): {
+                    result = result && (left_val > right_val);
+                    break;
+                }
+                case (ASR::cmpopType::GtE): {
+                    result = result && (left_val >= right_val);
+                    break;
+                }
+                case (ASR::cmpopType::Lt): {
+                    result = result && (left_val < right_val);
+                    break;
+                }
+                case (ASR::cmpopType::LtE): {
+                    result = result && (left_val <= right_val);
+                    break;
+                }
+                case (ASR::cmpopType::NotEq): {
+                    result = result && (left_val != right_val);
+                    break;
+                }
+                default: {
+                    diag.add(diag::Diagnostic("Comparison operator not implemented",
+                                              Level::Error,
+                                              Stage::Semantic,
+                                              { diag::Label("", { loc }) }));
+                    throw SemanticAbort();
+                }
+            }
+            return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
+                al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
 
-
-static inline ASR::expr_t* compare_helper(Allocator &al, ASR::expr_t* left_value, ASR::expr_t* right_value, ASR::cmpopType asr_op, const Location loc, diag::Diagnostics &diag) {
-    if (ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(left_value))) {
-        int64_t left_val = ASR::down_cast<ASR::IntegerConstant_t>(left_value)->m_n;
-        int64_t right_val = ASR::down_cast<ASR::IntegerConstant_t>(right_value)->m_n;
-        bool result = true;
-        switch (asr_op) {
-            case (ASR::cmpopType::Eq):  { result = result && (left_val == right_val); break; }
-            case (ASR::cmpopType::Gt): { result = result && (left_val > right_val); break; }
-            case (ASR::cmpopType::GtE): { result = result && (left_val >= right_val); break; }
-            case (ASR::cmpopType::Lt): { result = result && (left_val < right_val); break; }
-            case (ASR::cmpopType::LtE): { result = result && (left_val <= right_val); break; }
-            case (ASR::cmpopType::NotEq): { result = result && (left_val != right_val); break; }
-            default: {
-                diag.add(diag::Diagnostic(
-                    "Comparison operator not implemented",
-                    Level::Error, Stage::Semantic, {
-                    diag::Label("", {loc})}));
-                throw SemanticAbort();
+        } else if (ASR::is_a<ASR::Real_t>(*ASRUtils::expr_type(left_value))) {
+            double left_val = ASR::down_cast<ASR::RealConstant_t>(left_value)->m_r;
+            double right_val = ASR::down_cast<ASR::RealConstant_t>(right_value)->m_r;
+            bool result = true;
+            switch (asr_op) {
+                case (ASR::cmpopType::Eq): {
+                    result = result && (left_val == right_val);
+                    break;
+                }
+                case (ASR::cmpopType::Gt): {
+                    result = result && (left_val > right_val);
+                    break;
+                }
+                case (ASR::cmpopType::GtE): {
+                    result = result && (left_val >= right_val);
+                    break;
+                }
+                case (ASR::cmpopType::Lt): {
+                    result = result && (left_val < right_val);
+                    break;
+                }
+                case (ASR::cmpopType::LtE): {
+                    result = result && (left_val <= right_val);
+                    break;
+                }
+                case (ASR::cmpopType::NotEq): {
+                    result = result && (left_val != right_val);
+                    break;
+                }
+                default: {
+                    diag.add(diag::Diagnostic("Comparison operator not implemented",
+                                              Level::Error,
+                                              Stage::Semantic,
+                                              { diag::Label("", { loc }) }));
+                    throw SemanticAbort();
+                }
             }
-        }
-        return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
-            al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
-
-    } else if (ASR::is_a<ASR::Real_t>(*ASRUtils::expr_type(left_value))) {
-        double left_val = ASR::down_cast<ASR::RealConstant_t>(left_value)->m_r;
-        double right_val = ASR::down_cast<ASR::RealConstant_t>(right_value)->m_r;
-        bool result = true;
-        switch (asr_op) {
-            case (ASR::cmpopType::Eq):  { result = result && (left_val == right_val); break; }
-            case (ASR::cmpopType::Gt): { result = result && (left_val > right_val); break; }
-            case (ASR::cmpopType::GtE): { result = result && (left_val >= right_val); break; }
-            case (ASR::cmpopType::Lt): { result = result && (left_val < right_val); break; }
-            case (ASR::cmpopType::LtE): { result = result && (left_val <= right_val); break; }
-            case (ASR::cmpopType::NotEq): { result = result && (left_val != right_val); break; }
-            default: {
-                diag.add(diag::Diagnostic(
-                    "Comparison operator not implemented",
-                    Level::Error, Stage::Semantic, {
-                    diag::Label("", {loc})}));
-                throw SemanticAbort();
+            return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
+                al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
+
+        } else if (ASR::is_a<ASR::Complex_t>(*ASRUtils::expr_type(left_value))) {
+            ASR::ComplexConstant_t* left0 = ASR::down_cast<ASR::ComplexConstant_t>(left_value);
+            ASR::ComplexConstant_t* right0 = ASR::down_cast<ASR::ComplexConstant_t>(right_value);
+            std::complex<double> left_val(left0->m_re, left0->m_im);
+            std::complex<double> right_val(right0->m_re, right0->m_im);
+            bool result = true;
+            switch (asr_op) {
+                case (ASR::cmpopType::Eq): {
+                    result = result
+                             && (left_val.real() == right_val.real()
+                                 && left_val.imag() == right_val.imag());
+                    break;
+                }
+                case (ASR::cmpopType::NotEq): {
+                    result = result
+                             && (left_val.real() != right_val.real()
+                                 || left_val.imag() != right_val.imag());
+                    break;
+                }
+                default: {
+                    diag.add(diag::Diagnostic(
+                        "'" + ASRUtils::cmpop_to_str(asr_op)
+                            + "' comparison is not supported between complex numbers",
+                        Level::Error,
+                        Stage::Semantic,
+                        { diag::Label("", { loc }) }));
+                    throw SemanticAbort();
+                }
             }
-        }
-        return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
-            al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
-
-    } else if (ASR::is_a<ASR::Complex_t>(*ASRUtils::expr_type(left_value))) {
-        ASR::ComplexConstant_t *left0
-            = ASR::down_cast<ASR::ComplexConstant_t>(left_value);
-        ASR::ComplexConstant_t *right0
-            = ASR::down_cast<ASR::ComplexConstant_t>(right_value);
-        std::complex<double> left_val(left0->m_re, left0->m_im);
-        std::complex<double> right_val(right0->m_re, right0->m_im);
-        bool result = true;
-        switch (asr_op) {
-            case (ASR::cmpopType::Eq) : {
-                result = result && (left_val.real() == right_val.real() &&
-                        left_val.imag() == right_val.imag());
-                break;
+            return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
+                al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
+
+        } else if (ASR::is_a<ASR::Logical_t>(*ASRUtils::expr_type(left_value))) {
+            bool left_val = ASR::down_cast<ASR::LogicalConstant_t>(left_value)->m_value;
+            bool right_val = ASR::down_cast<ASR::LogicalConstant_t>(right_value)->m_value;
+            bool result = true;
+            switch (asr_op) {
+                case (ASR::cmpopType::Eq): {
+                    result = result && (left_val == right_val);
+                    break;
+                }
+                case (ASR::cmpopType::Gt): {
+                    result = result && (left_val > right_val);
+                    break;
+                }
+                case (ASR::cmpopType::GtE): {
+                    result = result && (left_val >= right_val);
+                    break;
+                }
+                case (ASR::cmpopType::Lt): {
+                    result = result && (left_val < right_val);
+                    break;
+                }
+                case (ASR::cmpopType::LtE): {
+                    result = result && (left_val <= right_val);
+                    break;
+                }
+                case (ASR::cmpopType::NotEq): {
+                    result = result && (left_val != right_val);
+                    break;
+                }
+                default: {
+                    diag.add(diag::Diagnostic("Comparison operator not implemented",
+                                              Level::Error,
+                                              Stage::Semantic,
+                                              { diag::Label("", { loc }) }));
+                    throw SemanticAbort();
+                }
             }
-            case (ASR::cmpopType::NotEq) : {
-                result = result && (left_val.real() != right_val.real() ||
-                        left_val.imag() != right_val.imag());
-                break;
+            return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
+                al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
+        } else if (ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(left_value))) {
+            char* left_val = ASR::down_cast<ASR::StringConstant_t>(left_value)->m_s;
+            char* right_val = ASR::down_cast<ASR::StringConstant_t>(right_value)->m_s;
+            std::string left_str = ASRUtils::remove_trailing_white_spaces(std::string(left_val));
+            std::string right_str = ASRUtils::remove_trailing_white_spaces(std::string(right_val));
+            int8_t strcmp = left_str.compare(right_str);
+            bool result = true;
+            switch (asr_op) {
+                case (ASR::cmpopType::Eq): {
+                    result = (strcmp == 0);
+                    break;
+                }
+                case (ASR::cmpopType::NotEq): {
+                    result = (strcmp != 0);
+                    break;
+                }
+                case (ASR::cmpopType::Gt): {
+                    result = (strcmp > 0);
+                    break;
+                }
+                case (ASR::cmpopType::GtE): {
+                    result = (strcmp > 0 || strcmp == 0);
+                    break;
+                }
+                case (ASR::cmpopType::Lt): {
+                    result = (strcmp < 0);
+                    break;
+                }
+                case (ASR::cmpopType::LtE): {
+                    result = (strcmp < 0 || strcmp == 0);
+                    break;
+                }
+                default:
+                    LCOMPILERS_ASSERT(false);  // should never happen
             }
-            default: {
-                diag.add(diag::Diagnostic(
-                    "'" + ASRUtils::cmpop_to_str(asr_op) +
-                    "' comparison is not supported between complex numbers",
-                    Level::Error, Stage::Semantic, {
-                    diag::Label("", {loc})}));
-                throw SemanticAbort();
+            return ASR::down_cast<ASR::expr_t>(ASR::make_LogicalConstant_t(
+                al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
+        } else {
+            diag.add(diag::Diagnostic("Comparison operator not implemented",
+                                      Level::Error,
+                                      Stage::Semantic,
+                                      { diag::Label("", { loc }) }));
+            throw SemanticAbort();
+            return nullptr;
+        }
+    }
+
+
+    static inline ASR::expr_t* evaluate_compiletime_values(
+        Allocator& al,
+        std::vector<std::pair<ASR::expr_t*, ASR::expr_t*>>& compiletime_values,
+        ASR::expr_t* left,
+        ASR::expr_t* right,
+        ASR::cmpopType asr_op,
+        ASR::ttype_t* type,
+        const Location loc,
+        diag::Diagnostics& diag)
+    {
+        if (compiletime_values.size() == 0) {
+            return compare_helper(
+                al, ASRUtils::expr_value(left), ASRUtils::expr_value(right), asr_op, loc, diag);
+        } else {
+            Vec<ASR::expr_t*> args;
+            args.reserve(al, compiletime_values.size());
+            for (size_t i = 0; i < compiletime_values.size(); i++) {
+                ASR::expr_t* left_val = compiletime_values[i].first;
+                ASR::expr_t* right_val = compiletime_values[i].second;
+                args.push_back(al, compare_helper(al, left_val, right_val, asr_op, loc, diag));
             }
+            return ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(
+                al, loc, args.p, args.size(), type, ASR::arraystorageType::ColMajor));
         }
-        return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
-            al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
+    }
 
-    } else if (ASR::is_a<ASR::Logical_t>(*ASRUtils::expr_type(left_value))) {
+    static inline void populate_compiletime_values(
+        Allocator& al,
+        std::vector<std::pair<ASR::expr_t*, ASR::expr_t*>>& compiletime_values,
+        ASR::expr_t* left,
+        ASR::expr_t* right)
+    {
+        int fixed_size_left_array = ASRUtils::get_fixed_size_of_array(
+            ASRUtils::expr_type(ASRUtils::expr_value(left)));  // 0
+        int fixed_size_right_array = ASRUtils::get_fixed_size_of_array(
+            ASRUtils::expr_type(ASRUtils::expr_value(right)));  // 0
+
+        if (ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(left))) {
+            ASR::ArrayConstant_t* array
+                = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(left));
+            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(array->m_type); i++) {
+                compiletime_values.push_back(
+                    { ASRUtils::fetch_ArrayConstant_value(al, array, i), nullptr });
+            }
+        }
+        if (ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(right))) {
+            ASR::ArrayConstant_t* array
+                = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(right));
+            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(array->m_type); i++) {
+                if (compiletime_values.size() > i) {
+                    compiletime_values[i].second
+                        = ASRUtils::fetch_ArrayConstant_value(al, array, i);
+                } else {
+                    compiletime_values.push_back(
+                        { nullptr, ASRUtils::fetch_ArrayConstant_value(al, array, i) });
+                }
+            }
+        }
 
-        bool left_val = ASR::down_cast<ASR::LogicalConstant_t>(
-                                left_value)->m_value;
-        bool right_val = ASR::down_cast<ASR::LogicalConstant_t>(
-                                right_value)->m_value;
-        bool result = true;
-        switch (asr_op) {
-            case (ASR::cmpopType::Eq):  { result = result && (left_val == right_val); break; }
-            case (ASR::cmpopType::Gt): { result = result && (left_val > right_val); break; }
-            case (ASR::cmpopType::GtE): { result = result && (left_val >= right_val); break; }
-            case (ASR::cmpopType::Lt): { result = result && (left_val < right_val); break; }
-            case (ASR::cmpopType::LtE): { result = result && (left_val <= right_val); break; }
-            case (ASR::cmpopType::NotEq): { result = result && (left_val != right_val); break; }
-            default: {
-                diag.add(diag::Diagnostic(
-                    "Comparison operator not implemented",
-                    Level::Error, Stage::Semantic, {
-                    diag::Label("", {loc})}));
-                throw SemanticAbort();
+        if (fixed_size_left_array == 0 && fixed_size_right_array == 0) {
+            return;
+        } else {
+            for (size_t i = 0; i < compiletime_values.size(); i++) {
+                if (compiletime_values[i].first == nullptr) {
+                    compiletime_values[i].first = ASRUtils::expr_value(left);
+                }
+                if (compiletime_values[i].second == nullptr) {
+                    compiletime_values[i].second = ASRUtils::expr_value(right);
+                }
             }
         }
-        return ASRUtils::EXPR(ASR::make_LogicalConstant_t(
-            al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
-    } else if (ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(left_value))) {
-        char* left_val = ASR::down_cast<ASR::StringConstant_t>(
-                                left_value)->m_s;
-        char* right_val = ASR::down_cast<ASR::StringConstant_t>(
-                                right_value)->m_s;
-        std::string left_str = ASRUtils::remove_trailing_white_spaces(std::string(left_val));
-        std::string right_str = ASRUtils::remove_trailing_white_spaces(std::string(right_val));
-        int8_t strcmp = left_str.compare(right_str);
-        bool result = true;
-        switch (asr_op) {
-            case (ASR::cmpopType::Eq) : {
-                result = (strcmp == 0);
+    }
+
+    inline static void visit_Compare(Allocator& al,
+                                     const AST::Compare_t& x,
+                                     ASR::expr_t*& left,
+                                     ASR::expr_t*& right,
+                                     ASR::asr_t*& asr,
+                                     std::string& intrinsic_op_name,
+                                     SymbolTable* curr_scope,
+                                     SetChar& current_function_dependencies,
+                                     SetChar& current_module_dependencies,
+                                     const CompilerOptions& compiler_options,
+                                     diag::Diagnostics& diag)
+    {
+        ASR::cmpopType asr_op;
+        switch (x.m_op) {
+            case (AST::cmpopType::Eq): {
+                asr_op = ASR::cmpopType::Eq;
                 break;
             }
-            case (ASR::cmpopType::NotEq) : {
-                result = (strcmp != 0);
+            case (AST::cmpopType::Gt): {
+                asr_op = ASR::cmpopType::Gt;
                 break;
             }
-            case (ASR::cmpopType::Gt) : {
-                result = (strcmp > 0);
+            case (AST::cmpopType::GtE): {
+                asr_op = ASR::cmpopType::GtE;
                 break;
             }
-            case (ASR::cmpopType::GtE) : {
-                result = (strcmp > 0 || strcmp == 0);
+            case (AST::cmpopType::Lt): {
+                asr_op = ASR::cmpopType::Lt;
                 break;
             }
-            case (ASR::cmpopType::Lt) : {
-                result = (strcmp < 0);
+            case (AST::cmpopType::LtE): {
+                asr_op = ASR::cmpopType::LtE;
                 break;
             }
-            case (ASR::cmpopType::LtE) : {
-                result = (strcmp < 0 || strcmp == 0);
+            case (AST::cmpopType::NotEq): {
+                asr_op = ASR::cmpopType::NotEq;
                 break;
             }
-            default: LCOMPILERS_ASSERT(false); // should never happen
+            default: {
+                diag.add(diag::Diagnostic("Comparison operator not implemented",
+                                          Level::Error,
+                                          Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
+            }
         }
-        return ASR::down_cast<ASR::expr_t>(ASR::make_LogicalConstant_t(
-            al, loc, result, ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4))));
-    } else {
-        diag.add(diag::Diagnostic(
-            "Comparison operator not implemented",
-            Level::Error, Stage::Semantic, {
-            diag::Label("", {loc})}));
-        throw SemanticAbort();
-        return nullptr;
-    }
-}
-
-
-static inline ASR::expr_t* evaluate_compiletime_values(Allocator &al, std::vector<std::pair<ASR::expr_t*, ASR::expr_t*>> &compiletime_values,
-                            ASR::expr_t* left, ASR::expr_t* right, ASR::cmpopType asr_op, ASR::ttype_t* type, const Location loc, diag::Diagnostics &diag) {
-
-    if (compiletime_values.size() == 0) {
-        return compare_helper(al, ASRUtils::expr_value(left), ASRUtils::expr_value(right), asr_op, loc, diag);
-    } else {
-        Vec<ASR::expr_t*> args; args.reserve(al, compiletime_values.size());
-        for (size_t i = 0; i < compiletime_values.size(); i++) {
-            ASR::expr_t* left_val = compiletime_values[i].first;
-            ASR::expr_t* right_val = compiletime_values[i].second;
-            args.push_back(al, compare_helper(al, left_val, right_val, asr_op, loc, diag));
+        // Cast LHS or RHS if necessary
+        ASR::ttype_t* left_type
+            = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(left));
+        ASR::ttype_t* right_type
+            = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(right));
+        ASR::ttype_t* left_type2 = ASRUtils::type_get_past_array(left_type);
+        ASR::ttype_t* right_type2 = ASRUtils::type_get_past_array(right_type);
+
+        ASR::expr_t* overloaded = nullptr;
+        if (ASRUtils::use_overloaded(
+                left,
+                right,
+                asr_op,
+                intrinsic_op_name,
+                curr_scope,
+                asr,
+                al,
+                x.base.base.loc,
+                current_function_dependencies,
+                current_module_dependencies,
+                [&](const std::string& msg, const Location& loc) {
+                    diag.add(diag::Diagnostic(
+                        msg, Level::Error, Stage::Semantic, { diag::Label("", { loc }) }));
+                    throw SemanticAbort();
+                })) {
+            overloaded = ASRUtils::EXPR(asr);
         }
-        return ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al, loc, args.p, args.size(), type, ASR::arraystorageType::ColMajor));
-    }
-}
 
-static inline void populate_compiletime_values(Allocator &al, std::vector<std::pair<ASR::expr_t*, ASR::expr_t*>> &compiletime_values,
-                                    ASR::expr_t* left, ASR::expr_t* right) {
-    int fixed_size_left_array = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(ASRUtils::expr_value(left))); //0
-    int fixed_size_right_array = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(ASRUtils::expr_value(right))); //0
-
-    if (ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(left))) {
-        ASR::ArrayConstant_t* array = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(left));
-        for (size_t i=0; i<(size_t) ASRUtils::get_fixed_size_of_array(array->m_type); i++) {
-            compiletime_values.push_back({ASRUtils::fetch_ArrayConstant_value(al, array, i), nullptr});
-        }
-    }
-    if (ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::expr_value(right))) {
-        ASR::ArrayConstant_t* array = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(right));
-        for (size_t i=0; i<(size_t) ASRUtils::get_fixed_size_of_array(array->m_type); i++) {
-            if(compiletime_values.size() > i) {
-                compiletime_values[i].second = ASRUtils::fetch_ArrayConstant_value(al, array, i);
-            } else {
-                compiletime_values.push_back({nullptr, ASRUtils::fetch_ArrayConstant_value(al, array, i)});
+        if (ASRUtils::is_type_parameter(*left_type) || ASRUtils::is_type_parameter(*right_type)) {
+            // if overloaded is not found, then reject
+            if (overloaded == nullptr) {
+                std::string op_str = "==";
+                switch (asr_op) {
+                    case (ASR::cmpopType::Eq):
+                        break;
+                    case (ASR::cmpopType::Gt):
+                        op_str = ">";
+                        break;
+                    case (ASR::cmpopType::GtE):
+                        op_str = ">=";
+                        break;
+                    case (ASR::cmpopType::Lt):
+                        op_str = "<";
+                        break;
+                    case (ASR::cmpopType::LtE):
+                        op_str = "<=";
+                        break;
+                    case (ASR::cmpopType::NotEq):
+                        op_str = "/=";
+                        break;
+                    default:
+                        LCOMPILERS_ASSERT(false);
+                }
+                diag.add(Diagnostic(
+                    "Operator `" + op_str + "` undefined for the types in the expression `"
+                        + ASRUtils::type_to_str_fortran_expr(left_type, left) + " " + op_str + " "
+                        + ASRUtils::type_to_str_fortran_expr(right_type, right) + "`",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             }
         }
-    }
+        ASR::ttype_t* source_type = nullptr;
+        ASR::ttype_t* dest_type = nullptr;
+
+        if (((left_type2->type != ASR::ttypeType::Real
+              && left_type2->type != ASR::ttypeType::Integer)
+             && (right_type2->type != ASR::ttypeType::Real
+                 && right_type2->type != ASR::ttypeType::Integer)
+             && ((left_type2->type != ASR::ttypeType::Complex
+                  || right_type2->type != ASR::ttypeType::Complex)
+                 && x.m_op != AST::cmpopType::Eq && x.m_op != AST::cmpopType::NotEq)
+             && (left_type2->type != ASR::ttypeType::String
+                 || right_type2->type != ASR::ttypeType::String)
+             && (left_type2->type != ASR::ttypeType::UnsignedInteger
+                 && right_type2->type != ASR::ttypeType::UnsignedInteger))
+            && overloaded == nullptr) {
+            diag.add(diag::Diagnostic(
+                "Compare: only Integer or Real can be on the LHS and RHS. "
+                "If operator is .eq. or .neq. then Complex type is also acceptable",
+                Level::Error,
+                Stage::Semantic,
+                { diag::Label("", { x.base.base.loc }) }));
+            throw SemanticAbort();
+        } else {
+            dest_type = right_type;
+            source_type = left_type;
+            if (overloaded == nullptr) {
+                ASR::expr_t** conversion_cand = &left;
+                ImplicitCastRules::find_conversion_candidate(&left,
+                                                             &right,
+                                                             left_type,
+                                                             right_type,
+                                                             conversion_cand,
+                                                             &source_type,
+                                                             &dest_type);
 
-    if (fixed_size_left_array == 0 && fixed_size_right_array == 0) {
-        return;
-    } else {
-        for (size_t i = 0; i < compiletime_values.size(); i++) {
-            if (compiletime_values[i].first == nullptr) {
-                compiletime_values[i].first = ASRUtils::expr_value(left);
-            }
-            if (compiletime_values[i].second == nullptr) {
-                compiletime_values[i].second = ASRUtils::expr_value(right);
+                ImplicitCastRules::set_converted_value(
+                    al, x.base.base.loc, conversion_cand, source_type, dest_type, diag);
             }
         }
-    }
-}
 
-inline static void visit_Compare(Allocator &al, const AST::Compare_t &x,
-                                   ASR::expr_t *&left, ASR::expr_t *&right,
-                                   ASR::asr_t *&asr, std::string& intrinsic_op_name,
-                                   SymbolTable* curr_scope,
-                                   SetChar& current_function_dependencies,
-                                   SetChar& current_module_dependencies,
-                                   const CompilerOptions &compiler_options, diag::Diagnostics &diag) {
-    ASR::cmpopType asr_op;
-    switch (x.m_op) {
-        case (AST::cmpopType::Eq): {
-        asr_op = ASR::cmpopType::Eq;
-        break;
-        }
-        case (AST::cmpopType::Gt): {
-        asr_op = ASR::cmpopType::Gt;
-        break;
-        }
-        case (AST::cmpopType::GtE): {
-        asr_op = ASR::cmpopType::GtE;
-        break;
-        }
-        case (AST::cmpopType::Lt): {
-        asr_op = ASR::cmpopType::Lt;
-        break;
-        }
-        case (AST::cmpopType::LtE): {
-        asr_op = ASR::cmpopType::LtE;
-        break;
-        }
-        case (AST::cmpopType::NotEq): {
-        asr_op = ASR::cmpopType::NotEq;
-        break;
-        }
-        default: {
-        diag.add(diag::Diagnostic(
-            "Comparison operator not implemented",
-            Level::Error, Stage::Semantic, {
-            diag::Label("", {x.base.base.loc})}));
-        throw SemanticAbort();
-        }
-    }
-    // Cast LHS or RHS if necessary
-    ASR::ttype_t *left_type = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(left));
-    ASR::ttype_t *right_type = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(right));
-    ASR::ttype_t *left_type2 = ASRUtils::type_get_past_array(left_type);
-    ASR::ttype_t *right_type2 = ASRUtils::type_get_past_array(right_type);
-
-    ASR::expr_t *overloaded = nullptr;
-    if ( ASRUtils::use_overloaded(left, right, asr_op,
-        intrinsic_op_name, curr_scope, asr, al,
-        x.base.base.loc, current_function_dependencies,
-        current_module_dependencies,
-        [&](const std::string &msg, const Location &loc) {
-                diag.add(diag::Diagnostic(
-                    msg,
-                    Level::Error, Stage::Semantic, {
-                    diag::Label("", {loc})}));
+        if (overloaded == nullptr) {
+            if (!ASRUtils::check_equal_type(
+                    ASRUtils::expr_type(left), ASRUtils::expr_type(right), left, right)) {
+                diag.add(diag::Diagnostic("Operands of comparison operator are of different types",
+                                          Level::Error,
+                                          Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
-            }) ) {
-        overloaded = ASRUtils::EXPR(asr);
-    }
+            }
+        }
+        size_t left_dims = ASRUtils::extract_n_dims_from_ttype(ASRUtils::expr_type(left));
+        size_t right_dims = ASRUtils::extract_n_dims_from_ttype(ASRUtils::expr_type(right));
+        ASR::dimension_t* result_shape = nullptr;
+        size_t result_dims = 0;
+        if (left_dims == 0 && right_dims == 0) {
+        } else if (left_dims == 0) {
+            ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(right), result_shape);
+            result_dims = right_dims;
+        } else if (right_dims == 0) {
+            ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(left), result_shape);
+            result_dims = left_dims;
+        } else {
+            LCOMPILERS_ASSERT(left_dims == right_dims);
+            ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(left), result_shape);
+            result_dims = left_dims;
+        }
+        ASR::ttype_t* type = ASRUtils::TYPE(
+            ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+        type = ASRUtils::make_Array_t_util(al, x.base.base.loc, type, result_shape, result_dims);
 
-    if (ASRUtils::is_type_parameter(*left_type) || ASRUtils::is_type_parameter(*right_type)) {
-        // if overloaded is not found, then reject
-        if (overloaded == nullptr) {
-            std::string op_str = "==";
-            switch (asr_op) {
-                case (ASR::cmpopType::Eq):
-                    break;
-                case (ASR::cmpopType::Gt):
-                    op_str = ">";
-                    break;
-                case (ASR::cmpopType::GtE):
-                    op_str = ">=";
-                    break;
-                case (ASR::cmpopType::Lt):
-                    op_str = "<";
-                    break;
-                case (ASR::cmpopType::LtE):
-                    op_str = "<=";
-                    break;
-                case (ASR::cmpopType::NotEq):
-                    op_str = "/=";
-                    break;
-                default:
-                    LCOMPILERS_ASSERT(false);
+        ASR::expr_t* value = nullptr;
+        if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr) {
+            std::vector<std::pair<ASR::expr_t*, ASR::expr_t*>> comptime_values;
+            populate_compiletime_values(al, comptime_values, left, right);
+            value = evaluate_compiletime_values(
+                al, comptime_values, left, right, asr_op, type, x.base.base.loc, diag);
+        }
+        if (ASRUtils::is_integer(*dest_type)) {
+            asr = ASR::make_IntegerCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
+        } else if (ASRUtils::is_unsigned_integer(*dest_type)) {
+            asr = ASR::make_UnsignedIntegerCompare_t(
+                al, x.base.base.loc, left, asr_op, right, type, value);
+        } else if (ASRUtils::is_real(*dest_type)) {
+            asr = ASR::make_RealCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
+        } else if (ASRUtils::is_complex(*dest_type)) {
+            asr = ASR::make_ComplexCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
+        } else if (ASRUtils::is_logical(*dest_type)) {
+            asr = ASR::make_LogicalCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
+        } else if (ASRUtils::is_character(*dest_type)) {
+            if ((ASRUtils::is_allocatable(left) && ASRUtils::is_array(ASRUtils::expr_type(left)))
+                || (ASRUtils::is_allocatable(right)
+                    && ASRUtils::is_array(ASRUtils::expr_type(right)))) {
+                type = ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(
+                    al,
+                    x.base.base.loc,
+                    ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(type))));
             }
-            diag.add(Diagnostic("Operator `" + op_str + "` undefined for the types in the expression `" + ASRUtils::type_to_str_fortran_expr(left_type, left)
-                                + " " +  op_str + " " + ASRUtils::type_to_str_fortran_expr(right_type, right) + "`", Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
-            throw SemanticAbort();
+            asr = ASR::make_StringCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
         }
-    }
-    ASR::ttype_t *source_type = nullptr;
-    ASR::ttype_t *dest_type = nullptr;
-
-    if (((left_type2->type != ASR::ttypeType::Real &&
-         left_type2->type != ASR::ttypeType::Integer) &&
-        (right_type2->type != ASR::ttypeType::Real &&
-         right_type2->type != ASR::ttypeType::Integer) &&
-        ((left_type2->type != ASR::ttypeType::Complex ||
-          right_type2->type != ASR::ttypeType::Complex) &&
-         x.m_op != AST::cmpopType::Eq && x.m_op != AST::cmpopType::NotEq) &&
-         (left_type2->type != ASR::ttypeType::String ||
-          right_type2->type != ASR::ttypeType::String) &&
-         (left_type2->type != ASR::ttypeType::UnsignedInteger &&
-          right_type2->type != ASR::ttypeType::UnsignedInteger ))
-         && overloaded == nullptr) {
-        diag.add(diag::Diagnostic(
-            "Compare: only Integer or Real can be on the LHS and RHS. "
-            "If operator is .eq. or .neq. then Complex type is also acceptable",
-            Level::Error, Stage::Semantic, {
-            diag::Label("", {x.base.base.loc})}));
-        throw SemanticAbort();
-    } else {
-      dest_type = right_type;
-      source_type = left_type;
-      if( overloaded == nullptr ) {
-        ASR::expr_t **conversion_cand = &left;
-        ImplicitCastRules::find_conversion_candidate(&left, &right, left_type,
-                                                    right_type, conversion_cand,
-                                                    &source_type, &dest_type);
-
-        ImplicitCastRules::set_converted_value(
-            al, x.base.base.loc, conversion_cand, source_type, dest_type, diag);
-      }
-    }
-
-    if( overloaded == nullptr ) {
-        if (!ASRUtils::check_equal_type(ASRUtils::expr_type(left),
-                                    ASRUtils::expr_type(right), left, right)) {
-            diag.add(diag::Diagnostic(
-                "Operands of comparison operator are of different types",
-                Level::Error, Stage::Semantic, {
-                diag::Label("", {x.base.base.loc})}));
-            throw SemanticAbort();
+        if (overloaded != nullptr) {
+            type = ASRUtils::expr_type(overloaded);
+            asr = ASR::make_OverloadedCompare_t(
+                al, x.base.base.loc, left, asr_op, right, type, value, overloaded);
         }
     }
-    size_t left_dims = ASRUtils::extract_n_dims_from_ttype(ASRUtils::expr_type(left));
-    size_t right_dims = ASRUtils::extract_n_dims_from_ttype(ASRUtils::expr_type(right));
-    ASR::dimension_t* result_shape = nullptr;
-    size_t result_dims = 0;
-    if( left_dims == 0 && right_dims == 0 ) {
-
-    } else if( left_dims == 0 ) {
-        ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(right), result_shape);
-        result_dims = right_dims;
-    } else if( right_dims == 0 ) {
-        ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(left), result_shape);
-        result_dims = left_dims;
-    } else {
-        LCOMPILERS_ASSERT(left_dims == right_dims);
-        ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(left), result_shape);
-        result_dims = left_dims;
-    }
-    ASR::ttype_t *type = ASRUtils::TYPE(
-        ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-    type = ASRUtils::make_Array_t_util(al, x.base.base.loc,
-            type, result_shape, result_dims);
-
-    ASR::expr_t *value = nullptr;
-    if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr) {
-        std::vector<std::pair<ASR::expr_t*, ASR::expr_t*>> comptime_values;
-        populate_compiletime_values(al, comptime_values, left, right);
-        value = evaluate_compiletime_values(al, comptime_values, left, right, asr_op, type, x.base.base.loc, diag);
-    }
-    if (ASRUtils::is_integer(*dest_type)) {
-        asr = ASR::make_IntegerCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
-    } else if (ASRUtils::is_unsigned_integer(*dest_type)) {
-        asr = ASR::make_UnsignedIntegerCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
-    } else if (ASRUtils::is_real(*dest_type)) {
-        asr = ASR::make_RealCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
-    } else if (ASRUtils::is_complex(*dest_type)) {
-        asr = ASR::make_ComplexCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
-    } else if (ASRUtils::is_logical(*dest_type)) {
-        asr = ASR::make_LogicalCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
-    } else if (ASRUtils::is_character(*dest_type)) {
-        if( (ASRUtils::is_allocatable(left) && ASRUtils::is_array(ASRUtils::expr_type(left)))
-            || (ASRUtils::is_allocatable(right) && ASRUtils::is_array(ASRUtils::expr_type(right))) ) {
-            type = ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(al, x.base.base.loc,
-                ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(type))));
-        }
-        asr = ASR::make_StringCompare_t(al, x.base.base.loc, left, asr_op, right, type, value);
-    }
-    if (overloaded != nullptr) {
-        type = ASRUtils::expr_type(overloaded);
-        asr = ASR::make_OverloadedCompare_t(al, x.base.base.loc, left, asr_op, right, type,
-            value, overloaded);
-    }
-}
 
-inline static bool get_boolean_comparison_value(Location loc, ASR::logicalbinopType op,
-                                                bool left_value, bool right_value, diag::Diagnostics &diag) {
-    bool result;
-    switch (op) {
-        case (ASR::And):
-            result = left_value && right_value;
-            break;
-        case (ASR::Or):
-            result = left_value || right_value;
-            break;
-        case (ASR::NEqv):
-            result = left_value != right_value;
-            break;
-        case (ASR::Eqv):
-            result = left_value == right_value;
-            break;
-        default:
-            diag.add(diag::Diagnostic(
-                R"""(Only .and., .or., .neqv., .eqv.
+    inline static bool get_boolean_comparison_value(Location loc,
+                                                    ASR::logicalbinopType op,
+                                                    bool left_value,
+                                                    bool right_value,
+                                                    diag::Diagnostics& diag)
+    {
+        bool result;
+        switch (op) {
+            case (ASR::And):
+                result = left_value && right_value;
+                break;
+            case (ASR::Or):
+                result = left_value || right_value;
+                break;
+            case (ASR::NEqv):
+                result = left_value != right_value;
+                break;
+            case (ASR::Eqv):
+                result = left_value == right_value;
+                break;
+            default:
+                diag.add(diag::Diagnostic(
+                    R"""(Only .and., .or., .neqv., .eqv.
                 implemented for logical type operands.)""",
-                Level::Error, Stage::Semantic, {
-                diag::Label("", {loc})}));
-            throw SemanticAbort();
+                    Level::Error,
+                    Stage::Semantic,
+                    { diag::Label("", { loc }) }));
+                throw SemanticAbort();
+        }
+        return result;
     }
-    return result;
-}
-
-template <typename T>
-static inline ASR::expr_t* create_boolean_result_array(Allocator &al, Location loc, ASR::logicalbinopType op,
-                                                        size_t arr_size,
-                                                        ASR::ArrayConstant_t* left,
-                                                        T right,
-                                                        bool is_right_logical_constant, diag::Diagnostics &diag) {
-    void* arr_data = nullptr;
-    bool* array = al.allocate<bool>(arr_size);
-
-    for (size_t i = 0; i < arr_size; i++) {
-        bool right_value = is_right_logical_constant ? (bool) right : (bool) (((bool*) ((ASR::ArrayConstant_t*)right)->m_data)[i]);
-        array[i] = get_boolean_comparison_value(loc, op, ((bool*) left->m_data)[i], right_value, diag);
-    }
-
-    arr_data = array;
-    ASR::expr_t* result_arr_const = ASRUtils::EXPR(
-                                        ASR::make_ArrayConstant_t(
-                                                al, loc,
-                                                left->m_n_data,arr_data,
-                                                left->m_type,
-                                                left->m_storage_format));
-    return result_arr_const;
-}
 
-inline static void visit_BoolOp(Allocator &al, const AST::BoolOp_t &x,
-                                  ASR::expr_t *&left, ASR::expr_t *&right,
-                                  ASR::asr_t *&asr, diag::Diagnostics &diag, 
-                                  std::string& intrinsic_op_name, SymbolTable* curr_scope,
-                                  SetChar current_function_dependencies, SetChar current_module_dependencies) {
-    ASR::logicalbinopType op;
-    switch (x.m_op) {
-        case (AST::And):
-            op = ASR::And;
-            break;
-        case (AST::Or):
-            op = ASR::Or;
-            break;
-        case (AST::Xor):
-            op = ASR::Xor;
-            diag.semantic_warning_label(
-                ".xor. is an LFortran extension", { x.base.base.loc }, "LFortran extension");
-            break;
-        case (AST::NEqv):
-            op = ASR::NEqv;
-            break;
-        case (AST::Eqv):
-            op = ASR::Eqv;
-            break;
-        default:
-            diag.add(diag::Diagnostic(
-                R"""(Only .and., .or., .xor., .neqv., .eqv.
+    template <typename T>
+    static inline ASR::expr_t* create_boolean_result_array(Allocator& al,
+                                                           Location loc,
+                                                           ASR::logicalbinopType op,
+                                                           size_t arr_size,
+                                                           ASR::ArrayConstant_t* left,
+                                                           T right,
+                                                           bool is_right_logical_constant,
+                                                           diag::Diagnostics& diag)
+    {
+        void* arr_data = nullptr;
+        bool* array = al.allocate<bool>(arr_size);
+
+        for (size_t i = 0; i < arr_size; i++) {
+            bool right_value = is_right_logical_constant
+                                   ? (bool) right
+                                   : (bool) (((bool*) ((ASR::ArrayConstant_t*) right)->m_data)[i]);
+            array[i] = get_boolean_comparison_value(
+                loc, op, ((bool*) left->m_data)[i], right_value, diag);
+        }
+
+        arr_data = array;
+        ASR::expr_t* result_arr_const = ASRUtils::EXPR(ASR::make_ArrayConstant_t(
+            al, loc, left->m_n_data, arr_data, left->m_type, left->m_storage_format));
+        return result_arr_const;
+    }
+
+    inline static void visit_BoolOp(Allocator& al,
+                                    const AST::BoolOp_t& x,
+                                    ASR::expr_t*& left,
+                                    ASR::expr_t*& right,
+                                    ASR::asr_t*& asr,
+                                    diag::Diagnostics& diag,
+                                    std::string& intrinsic_op_name,
+                                    SymbolTable* curr_scope,
+                                    SetChar current_function_dependencies,
+                                    SetChar current_module_dependencies)
+    {
+        ASR::logicalbinopType op;
+        switch (x.m_op) {
+            case (AST::And):
+                op = ASR::And;
+                break;
+            case (AST::Or):
+                op = ASR::Or;
+                break;
+            case (AST::Xor):
+                op = ASR::Xor;
+                diag.semantic_warning_label(
+                    ".xor. is an LFortran extension", { x.base.base.loc }, "LFortran extension");
+                break;
+            case (AST::NEqv):
+                op = ASR::NEqv;
+                break;
+            case (AST::Eqv):
+                op = ASR::Eqv;
+                break;
+            default:
+                diag.add(diag::Diagnostic(
+                    R"""(Only .and., .or., .xor., .neqv., .eqv.
                                     implemented for logical type operands.)""",
-                Level::Error, Stage::Semantic, {
-                diag::Label("", {x.base.base.loc})}));
-            throw SemanticAbort();
-    }
-    ASR::expr_t* overloaded = nullptr;
-    if ( ASRUtils::use_overloaded(left, right, op,
-        intrinsic_op_name, curr_scope, asr, al,
-        x.base.base.loc, current_function_dependencies,
-        current_module_dependencies,
-        [&](const std::string &msg, const Location &loc)
-        {
-            diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-            throw SemanticAbort();
-        }) ) {
-        overloaded = ASRUtils::EXPR(asr);
-    }
-
-    // Earlier, `.and.` between int and logical (incl. pointers) caused failures.
-    // The types were not being fully unwrapped before semantic checks.
-    // By applying `type_get_past_allocatable_pointer` on both operands,
-    // we correctly resolve to base types and catch invalid mixes.
-    ASR::ttype_t *left_type  = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(left));
-    ASR::ttype_t *right_type = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(right));
-
-    auto check_logical_type = [&](ASR::ttype_t *t, ASR::expr_t *expr, const std::string &side) {
-        if (ASR::is_a<ASR::Array_t>(*t)) {
-            ASR::Array_t *arr_type = ASR::down_cast<ASR::Array_t>(t);
-            ASR::ttype_t *element_type = ASRUtils::type_get_past_allocatable(
-                                            ASRUtils::type_get_past_pointer(arr_type->m_type));
-            if (!ASR::is_a<ASR::Logical_t>(*element_type)) {
-                diag.add(Diagnostic(
-                    side + " operand's array element type must be LOGICAL",
-                    Level::Error, Stage::Semantic, {Label("", {expr->base.loc})}
-                ));
+                    Level::Error,
+                    Stage::Semantic,
+                    { diag::Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
-            }
-        } else if (!ASR::is_a<ASR::Logical_t>(*t)) {
-            diag.add(Diagnostic(
-                side + " operand must be LOGICAL or LOGICAL array",
-                Level::Error, Stage::Semantic, {Label("", {expr->base.loc})}
-            ));
-            throw SemanticAbort();
         }
-    };
+        ASR::expr_t* overloaded = nullptr;
+        if (ASRUtils::use_overloaded(
+                left,
+                right,
+                op,
+                intrinsic_op_name,
+                curr_scope,
+                asr,
+                al,
+                x.base.base.loc,
+                current_function_dependencies,
+                current_module_dependencies,
+                [&](const std::string& msg, const Location& loc) {
+                    diag.add(
+                        Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                    throw SemanticAbort();
+                })) {
+            overloaded = ASRUtils::EXPR(asr);
+        }
 
-    if (!overloaded) {
-         check_logical_type(left_type, left, "Left");
-         check_logical_type(right_type, right, "Right");
-         LCOMPILERS_ASSERT(ASRUtils::check_equal_type(
-            ASRUtils::expr_type(left), ASRUtils::expr_type(right), left, right));
-     }
-    ASR::expr_t *value = nullptr;
-    ASR::expr_t* left_expr_value = ASRUtils::expr_value(left);
-    ASR::expr_t* right_expr_value = ASRUtils::expr_value(right);
-
-    // Assign evaluation to `value` if possible, otherwise leave nullptr
-    if (left_expr_value != nullptr && right_expr_value != nullptr) {
-        LCOMPILERS_ASSERT(ASR::is_a<ASR::Logical_t>(*ASRUtils::extract_type(left_type)));
-
-        if (ASR::is_a<ASR::LogicalBinOp_t>(*left)) {
-            left_expr_value = ASR::down_cast<ASR::LogicalBinOp_t>(left)->m_value;
-            left_type = ASRUtils::expr_type(left_expr_value);
-        }
-        if (ASR::is_a<ASR::LogicalBinOp_t>(*right)) {
-            right_expr_value = ASR::down_cast<ASR::LogicalBinOp_t>(right)->m_value;
-            right_type = ASRUtils::expr_type(right_expr_value);
-        }
-
-        if (ASRUtils::is_array(left_type) && !ASRUtils::is_array(right_type)) {
-            ASR::ArrayConstant_t* arr_const;
-            bool logical_const;
-            arr_const = ASR::down_cast<ASR::ArrayConstant_t>(left_expr_value);
-            logical_const = ASR::down_cast<ASR::LogicalConstant_t>(right_expr_value)->m_value;
-
-            size_t arr_size = ASRUtils::get_fixed_size_of_array(left_type);
-            value = create_boolean_result_array(al, x.base.base.loc, op, arr_size, arr_const, logical_const, true, diag);
-
-        } else if (!ASRUtils::is_array(left_type) && ASRUtils::is_array(right_type)) {
-            ASR::ArrayConstant_t* arr_const;
-            bool logical_const;
-            arr_const = ASR::down_cast<ASR::ArrayConstant_t>(right_expr_value);
-            logical_const = ASR::down_cast<ASR::LogicalConstant_t>(left_expr_value)->m_value;
-
-            size_t arr_size = ASRUtils::get_fixed_size_of_array(right_type);
-            value = create_boolean_result_array(al, x.base.base.loc, op, arr_size, arr_const, logical_const, true, diag);
-
-        } else if (ASRUtils::is_array(left_type) && ASRUtils::is_array(right_type)) {
-            ASR::ArrayConstant_t* left_arr_const = ASR::down_cast<ASR::ArrayConstant_t>(
-                                                        left_expr_value);
-            ASR::ArrayConstant_t* right_arr_const = ASR::down_cast<ASR::ArrayConstant_t>(
-                                                        right_expr_value);
-
-            if (ASRUtils::get_fixed_size_of_array(left_type) != ASRUtils::get_fixed_size_of_array(right_type)) {
-                diag.add(Diagnostic(
-                    "Shapes for operands are not conformable",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{ x.m_left->base.loc, x.m_right->base.loc })
-                }));
+        // Earlier, `.and.` between int and logical (incl. pointers) caused failures.
+        // The types were not being fully unwrapped before semantic checks.
+        // By applying `type_get_past_allocatable_pointer` on both operands,
+        // we correctly resolve to base types and catch invalid mixes.
+        ASR::ttype_t* left_type
+            = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(left));
+        ASR::ttype_t* right_type
+            = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(right));
+
+        auto check_logical_type = [&](ASR::ttype_t* t, ASR::expr_t* expr, const std::string& side) {
+            if (ASR::is_a<ASR::Array_t>(*t)) {
+                ASR::Array_t* arr_type = ASR::down_cast<ASR::Array_t>(t);
+                ASR::ttype_t* element_type = ASRUtils::type_get_past_allocatable(
+                    ASRUtils::type_get_past_pointer(arr_type->m_type));
+                if (!ASR::is_a<ASR::Logical_t>(*element_type)) {
+                    diag.add(Diagnostic(side + " operand's array element type must be LOGICAL",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { expr->base.loc }) }));
+                    throw SemanticAbort();
+                }
+            } else if (!ASR::is_a<ASR::Logical_t>(*t)) {
+                diag.add(Diagnostic(side + " operand must be LOGICAL or LOGICAL array",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { expr->base.loc }) }));
                 throw SemanticAbort();
             }
+        };
 
-            size_t arr_size = ASRUtils::get_fixed_size_of_array(left_type);
-            value = create_boolean_result_array(al, x.base.base.loc, op, arr_size, left_arr_const, right_arr_const, false, diag);
-
-        } else {
-            bool left_value = ASR::down_cast<ASR::LogicalConstant_t>(left_expr_value)->m_value;
-            bool right_value = ASR::down_cast<ASR::LogicalConstant_t>(right_expr_value)->m_value;
-
-            bool result = get_boolean_comparison_value(x.base.base.loc, op, left_value, right_value, diag);
-
-            value = ASR::down_cast<ASR::expr_t>(ASR::make_LogicalConstant_t(
-                al, x.base.base.loc, result, left_type));
+        if (!overloaded) {
+            check_logical_type(left_type, left, "Left");
+            check_logical_type(right_type, right, "Right");
+            LCOMPILERS_ASSERT(ASRUtils::check_equal_type(
+                ASRUtils::expr_type(left), ASRUtils::expr_type(right), left, right));
         }
-    }
-
-    ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, left, right);
-    if ( ASRUtils::is_array(right_type) ) {
-        left_type = ASRUtils::duplicate_type(al, right_type);
-    }
-    if (overloaded != nullptr) {
-        ASR::ttype_t* return_type = ASRUtils::expr_type(overloaded);
-        asr = ASR::make_OverloadedBoolOp_t(
-            al, x.base.base.loc, left, op, right, return_type, nullptr, overloaded);
-        return;
-    }
-    asr = ASR::make_LogicalBinOp_t(al, x.base.base.loc, left, op, right, left_type, value);
+        ASR::expr_t* value = nullptr;
+        ASR::expr_t* left_expr_value = ASRUtils::expr_value(left);
+        ASR::expr_t* right_expr_value = ASRUtils::expr_value(right);
+
+        // Assign evaluation to `value` if possible, otherwise leave nullptr
+        if (left_expr_value != nullptr && right_expr_value != nullptr) {
+            LCOMPILERS_ASSERT(ASR::is_a<ASR::Logical_t>(*ASRUtils::extract_type(left_type)));
+
+            if (ASR::is_a<ASR::LogicalBinOp_t>(*left)) {
+                left_expr_value = ASR::down_cast<ASR::LogicalBinOp_t>(left)->m_value;
+                left_type = ASRUtils::expr_type(left_expr_value);
+            }
+            if (ASR::is_a<ASR::LogicalBinOp_t>(*right)) {
+                right_expr_value = ASR::down_cast<ASR::LogicalBinOp_t>(right)->m_value;
+                right_type = ASRUtils::expr_type(right_expr_value);
+            }
+
+            if (ASRUtils::is_array(left_type) && !ASRUtils::is_array(right_type)) {
+                ASR::ArrayConstant_t* arr_const;
+                bool logical_const;
+                arr_const = ASR::down_cast<ASR::ArrayConstant_t>(left_expr_value);
+                logical_const = ASR::down_cast<ASR::LogicalConstant_t>(right_expr_value)->m_value;
+
+                size_t arr_size = ASRUtils::get_fixed_size_of_array(left_type);
+                value = create_boolean_result_array(
+                    al, x.base.base.loc, op, arr_size, arr_const, logical_const, true, diag);
+
+            } else if (!ASRUtils::is_array(left_type) && ASRUtils::is_array(right_type)) {
+                ASR::ArrayConstant_t* arr_const;
+                bool logical_const;
+                arr_const = ASR::down_cast<ASR::ArrayConstant_t>(right_expr_value);
+                logical_const = ASR::down_cast<ASR::LogicalConstant_t>(left_expr_value)->m_value;
+
+                size_t arr_size = ASRUtils::get_fixed_size_of_array(right_type);
+                value = create_boolean_result_array(
+                    al, x.base.base.loc, op, arr_size, arr_const, logical_const, true, diag);
+
+            } else if (ASRUtils::is_array(left_type) && ASRUtils::is_array(right_type)) {
+                ASR::ArrayConstant_t* left_arr_const
+                    = ASR::down_cast<ASR::ArrayConstant_t>(left_expr_value);
+                ASR::ArrayConstant_t* right_arr_const
+                    = ASR::down_cast<ASR::ArrayConstant_t>(right_expr_value);
+
+                if (ASRUtils::get_fixed_size_of_array(left_type)
+                    != ASRUtils::get_fixed_size_of_array(right_type)) {
+                    diag.add(
+                        Diagnostic("Shapes for operands are not conformable",
+                                   Level::Error,
+                                   Stage::Semantic,
+                                   { Label("", { x.m_left->base.loc, x.m_right->base.loc }) }));
+                    throw SemanticAbort();
+                }
 
-  }
+                size_t arr_size = ASRUtils::get_fixed_size_of_array(left_type);
+                value = create_boolean_result_array(al,
+                                                    x.base.base.loc,
+                                                    op,
+                                                    arr_size,
+                                                    left_arr_const,
+                                                    right_arr_const,
+                                                    false,
+                                                    diag);
 
-  inline static void visit_UnaryOp(Allocator &al, const AST::UnaryOp_t &x,
-                                   ASR::expr_t *&operand, ASR::asr_t *&asr,
-                                   SymbolTable* current_scope,
-                                   SetChar& current_function_dependencies,
-                                   SetChar& current_module_dependencies, diag::Diagnostics &diag) {
+            } else {
+                bool left_value = ASR::down_cast<ASR::LogicalConstant_t>(left_expr_value)->m_value;
+                bool right_value
+                    = ASR::down_cast<ASR::LogicalConstant_t>(right_expr_value)->m_value;
 
-    ASR::ttype_t *operand_type = ASRUtils::expr_type(operand);
-    ASR::expr_t *value = nullptr;
-    if (x.m_op == AST::unaryopType::UAdd) {
+                bool result = get_boolean_comparison_value(
+                    x.base.base.loc, op, left_value, right_value, diag);
 
-        if (ASRUtils::is_integer(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                int64_t op_value = ASR::down_cast<ASR::IntegerConstant_t>(
-                                        ASRUtils::expr_value(operand))->m_n;
-                asr = ASR::make_IntegerConstant_t(al, x.base.base.loc, op_value, operand_type);
-            }
-        }
-        else if (ASRUtils::is_real(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                double op_value = ASR::down_cast<ASR::RealConstant_t>(
-                                ASRUtils::expr_value(operand))->m_r;
-                asr = ASR::make_RealConstant_t(al, x.base.base.loc, op_value, operand_type);
+                value = ASR::down_cast<ASR::expr_t>(
+                    ASR::make_LogicalConstant_t(al, x.base.base.loc, result, left_type));
             }
         }
-        return;
 
-    } else if (x.m_op == AST::unaryopType::USub) {
+        ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, left, right);
+        if (ASRUtils::is_array(right_type)) {
+            left_type = ASRUtils::duplicate_type(al, right_type);
+        }
+        if (overloaded != nullptr) {
+            ASR::ttype_t* return_type = ASRUtils::expr_type(overloaded);
+            asr = ASR::make_OverloadedBoolOp_t(
+                al, x.base.base.loc, left, op, right, return_type, nullptr, overloaded);
+            return;
+        }
+        asr = ASR::make_LogicalBinOp_t(al, x.base.base.loc, left, op, right, left_type, value);
+    }
 
-        if (ASRUtils::is_integer(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                int64_t op_value = ASR::down_cast<ASR::IntegerConstant_t>(
-                                        ASRUtils::expr_value(operand))->m_n;
-                value = ASR::down_cast<ASR::expr_t>(
-                    ASR::make_IntegerConstant_t(al, x.base.base.loc, -op_value, operand_type));
+    inline static void visit_UnaryOp(Allocator& al,
+                                     const AST::UnaryOp_t& x,
+                                     ASR::expr_t*& operand,
+                                     ASR::asr_t*& asr,
+                                     SymbolTable* current_scope,
+                                     SetChar& current_function_dependencies,
+                                     SetChar& current_module_dependencies,
+                                     diag::Diagnostics& diag)
+    {
+        ASR::ttype_t* operand_type = ASRUtils::expr_type(operand);
+        ASR::expr_t* value = nullptr;
+        if (x.m_op == AST::unaryopType::UAdd) {
+            if (ASRUtils::is_integer(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    int64_t op_value
+                        = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(operand))
+                              ->m_n;
+                    asr = ASR::make_IntegerConstant_t(al, x.base.base.loc, op_value, operand_type);
+                }
+            } else if (ASRUtils::is_real(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    double op_value
+                        = ASR::down_cast<ASR::RealConstant_t>(ASRUtils::expr_value(operand))->m_r;
+                    asr = ASR::make_RealConstant_t(al, x.base.base.loc, op_value, operand_type);
+                }
             }
-            asr = ASR::make_IntegerUnaryMinus_t(al, x.base.base.loc, operand,
-                                                    operand_type, value);
             return;
-        } else if (ASRUtils::is_real(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                double op_value = ASR::down_cast<ASR::RealConstant_t>(
-                                        ASRUtils::expr_value(operand))->m_r;
-                value = ASR::down_cast<ASR::expr_t>(ASR::make_RealConstant_t(
-                    al, x.base.base.loc, -op_value, operand_type));
-            }
-            asr = ASR::make_RealUnaryMinus_t(al, x.base.base.loc, operand,
-                                             operand_type, value);
-            return;
-        } else if (ASRUtils::is_complex(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                ASR::ComplexConstant_t *c = ASR::down_cast<ASR::ComplexConstant_t>(
-                                    ASRUtils::expr_value(operand));
-                std::complex<double> op_value(c->m_re, c->m_im);
-                std::complex<double> result;
-                result = -op_value;
-                value = ASR::down_cast<ASR::expr_t>(
-                        ASR::make_ComplexConstant_t(al, x.base.base.loc, std::real(result),
-                        std::imag(result), operand_type));
+
+        } else if (x.m_op == AST::unaryopType::USub) {
+            if (ASRUtils::is_integer(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    int64_t op_value
+                        = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(operand))
+                              ->m_n;
+                    value = ASR::down_cast<ASR::expr_t>(
+                        ASR::make_IntegerConstant_t(al, x.base.base.loc, -op_value, operand_type));
+                }
+                asr = ASR::make_IntegerUnaryMinus_t(
+                    al, x.base.base.loc, operand, operand_type, value);
+                return;
+            } else if (ASRUtils::is_real(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    double op_value
+                        = ASR::down_cast<ASR::RealConstant_t>(ASRUtils::expr_value(operand))->m_r;
+                    value = ASR::down_cast<ASR::expr_t>(
+                        ASR::make_RealConstant_t(al, x.base.base.loc, -op_value, operand_type));
+                }
+                asr = ASR::make_RealUnaryMinus_t(al, x.base.base.loc, operand, operand_type, value);
+                return;
+            } else if (ASRUtils::is_complex(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    ASR::ComplexConstant_t* c
+                        = ASR::down_cast<ASR::ComplexConstant_t>(ASRUtils::expr_value(operand));
+                    std::complex<double> op_value(c->m_re, c->m_im);
+                    std::complex<double> result;
+                    result = -op_value;
+                    value = ASR::down_cast<ASR::expr_t>(ASR::make_ComplexConstant_t(
+                        al, x.base.base.loc, std::real(result), std::imag(result), operand_type));
+                }
+                asr = ASR::make_ComplexUnaryMinus_t(
+                    al, x.base.base.loc, operand, operand_type, value);
+                return;
+            } else if (ASR::is_a<ASR::StructType_t>(*operand_type)
+                       && !ASRUtils::is_class_type(operand_type)) {
+                ASR::expr_t* overloaded_uminus = nullptr;
+                if (ASRUtils::use_overloaded_unary_minus(
+                        operand,
+                        current_scope,
+                        asr,
+                        al,
+                        x.base.base.loc,
+                        current_function_dependencies,
+                        current_module_dependencies,
+                        [&](const std::string& msg, const Location& loc) {
+                            diag.add(diag::Diagnostic(
+                                msg, Level::Error, Stage::Semantic, { diag::Label("", { loc }) }));
+                            throw SemanticAbort();
+                        })) {
+                    overloaded_uminus = ASRUtils::EXPR(asr);
+                }
+                LCOMPILERS_ASSERT(overloaded_uminus != nullptr);
+                asr = ASR::make_OverloadedUnaryMinus_t(al,
+                                                       x.base.base.loc,
+                                                       operand,
+                                                       ASRUtils::expr_type(overloaded_uminus),
+                                                       nullptr,
+                                                       overloaded_uminus);
+            } else {
+                LCOMPILERS_ASSERT(false);
             }
-            asr = ASR::make_ComplexUnaryMinus_t(al, x.base.base.loc, operand,
-                                                    operand_type, value);
             return;
-        } else if( ASR::is_a<ASR::StructType_t>(*operand_type) && !ASRUtils::is_class_type(operand_type) ) {
-            ASR::expr_t* overloaded_uminus = nullptr;
-            if( ASRUtils::use_overloaded_unary_minus(operand,
-                current_scope, asr, al,
-                x.base.base.loc, current_function_dependencies,
-                current_module_dependencies,
-                [&](const std::string &msg, const Location &loc)
-                {
-                    diag.add(diag::Diagnostic(
-                        msg,
-                        Level::Error, Stage::Semantic, {
-                        diag::Label("", {loc})}));
-                    throw SemanticAbort();
-                }) ) {
-                overloaded_uminus = ASRUtils::EXPR(asr);
-            }
-            LCOMPILERS_ASSERT(overloaded_uminus != nullptr);
-            asr = ASR::make_OverloadedUnaryMinus_t(al, x.base.base.loc,
-                operand, ASRUtils::expr_type(overloaded_uminus),
-                nullptr, overloaded_uminus);
-        } else {
-            LCOMPILERS_ASSERT(false);
-        }
-        return;
 
-    } else if (x.m_op == AST::unaryopType::Invert) {
-
-        if (ASRUtils::is_integer(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                int64_t op_value = ASR::down_cast<ASR::IntegerConstant_t>(
-                                        ASRUtils::expr_value(operand))->m_n;
-                value = ASR::down_cast<ASR::expr_t>(
-                    ASR::make_IntegerConstant_t(al, x.base.base.loc, ~op_value, operand_type));
+        } else if (x.m_op == AST::unaryopType::Invert) {
+            if (ASRUtils::is_integer(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    int64_t op_value
+                        = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(operand))
+                              ->m_n;
+                    value = ASR::down_cast<ASR::expr_t>(
+                        ASR::make_IntegerConstant_t(al, x.base.base.loc, ~op_value, operand_type));
+                }
+                asr = ASR::make_IntegerBitNot_t(al, x.base.base.loc, operand, operand_type, value);
+                return;
+            } else {
+                diag.add(diag::Diagnostic("Argument of `not` intrinsic must be INTEGER",
+                                          Level::Error,
+                                          Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             }
-            asr = ASR::make_IntegerBitNot_t(al, x.base.base.loc, operand, operand_type, value);
-            return;
-        }
-        else {
-            diag.add(diag::Diagnostic(
-                "Argument of `not` intrinsic must be INTEGER",
-                Level::Error, Stage::Semantic, {
-                diag::Label("", {x.base.base.loc})}));
-            throw SemanticAbort();
-        }
 
-    } else if (x.m_op == AST::unaryopType::Not) {
-        if (ASRUtils::is_logical(*operand_type)) {
-            if (ASRUtils::expr_value(operand) != nullptr) {
-                bool op_value = ASR::down_cast<ASR::LogicalConstant_t>(
-                                ASRUtils::expr_value(operand))->m_value;
-                value = ASR::down_cast<ASR::expr_t>(ASR::make_LogicalConstant_t(
-                    al, x.base.base.loc, !op_value, operand_type));
+        } else if (x.m_op == AST::unaryopType::Not) {
+            if (ASRUtils::is_logical(*operand_type)) {
+                if (ASRUtils::expr_value(operand) != nullptr) {
+                    bool op_value
+                        = ASR::down_cast<ASR::LogicalConstant_t>(ASRUtils::expr_value(operand))
+                              ->m_value;
+                    value = ASR::down_cast<ASR::expr_t>(
+                        ASR::make_LogicalConstant_t(al, x.base.base.loc, !op_value, operand_type));
+                }
+                asr = ASR::make_LogicalNot_t(al, x.base.base.loc, operand, operand_type, value);
+                return;
+            } else {
+                diag.add(diag::Diagnostic(
+                    "Operand of .not. operator is "
+                        + std::string(ASRUtils::type_to_str_fortran_expr(operand_type, operand)),
+                    Level::Error,
+                    Stage::Semantic,
+                    { diag::Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             }
-            asr = ASR::make_LogicalNot_t(al, x.base.base.loc, operand, operand_type, value);
-            return;
-        }
-        else {
-            diag.add(diag::Diagnostic(
-                "Operand of .not. operator is "+
-                std::string(ASRUtils::type_to_str_fortran_expr(operand_type, operand)),
-                Level::Error, Stage::Semantic, {
-                diag::Label("", {x.base.base.loc})}));
-            throw SemanticAbort();
         }
     }
-  }
 
-}; // class CommonVisitorMethods
+};  // class CommonVisitorMethods
 
 
 template <class Derived>
-class CommonVisitor : public AST::BaseVisitor<Derived> {
+class CommonVisitor : public AST::BaseVisitor<Derived>
+{
 public:
-    diag::Diagnostics &diag;
+    diag::Diagnostics& diag;
     std::map<AST::operatorType, std::string> binop2str = {
-        {AST::operatorType::Mul, "~mul"},
-        {AST::operatorType::Add, "~add"},
-        {AST::operatorType::Sub, "~sub"},
-        {AST::operatorType::Div, "~div"},
+        { AST::operatorType::Mul, "~mul" },
+        { AST::operatorType::Add, "~add" },
+        { AST::operatorType::Sub, "~sub" },
+        { AST::operatorType::Div, "~div" },
     };
 
     std::map<AST::boolopType, std::string> boolop2str = {
@@ -1245,293 +1453,331 @@ public:
         { AST::boolopType::Eqv, "~eqv" },
     };
 
-    std::map<AST::cmpopType, std::string> cmpop2str = {
-        {AST::cmpopType::Eq, "~eq"},
-        {AST::cmpopType::NotEq, "~noteq"},
-        {AST::cmpopType::Lt, "~lt"},
-        {AST::cmpopType::LtE, "~lte"},
-        {AST::cmpopType::Gt, "~gt"},
-        {AST::cmpopType::GtE, "~gte"}
-    };
-
-    std::map<AST::intrinsicopType, std::string> intrinsic2str = {
-        {AST::intrinsicopType::STAR, "~mul"},
-        {AST::intrinsicopType::AND, "~and"},
-        {AST::intrinsicopType::OR, "~or"},
-        {AST::intrinsicopType::XOR, "~xor"},
-        {AST::intrinsicopType::EQV, "~eqv"},
-        {AST::intrinsicopType::NEQV, "~neqv"},
-        {AST::intrinsicopType::PLUS, "~add"},
-        {AST::intrinsicopType::MINUS, "~sub"},
-        {AST::intrinsicopType::STAR, "~mul"},
-        {AST::intrinsicopType::DIV, "~div"},
-        {AST::intrinsicopType::POW, "~pow"},
-        {AST::intrinsicopType::NOT, "~not"},
-        {AST::intrinsicopType::EQ, "~eq"},
-        {AST::intrinsicopType::NOTEQ, "~noteq"},
-        {AST::intrinsicopType::LT, "~lt"},
-        {AST::intrinsicopType::LTE, "~lte"},
-        {AST::intrinsicopType::GT, "~gt"},
-        {AST::intrinsicopType::GTE, "~gte"},
-        {AST::intrinsicopType::CONCAT, "~concat"}
-    };
+    std::map<AST::cmpopType, std::string> cmpop2str
+        = { { AST::cmpopType::Eq, "~eq" }, { AST::cmpopType::NotEq, "~noteq" },
+            { AST::cmpopType::Lt, "~lt" }, { AST::cmpopType::LtE, "~lte" },
+            { AST::cmpopType::Gt, "~gt" }, { AST::cmpopType::GtE, "~gte" } };
+
+    std::map<AST::intrinsicopType, std::string> intrinsic2str
+        = { { AST::intrinsicopType::STAR, "~mul" },     { AST::intrinsicopType::AND, "~and" },
+            { AST::intrinsicopType::OR, "~or" },        { AST::intrinsicopType::XOR, "~xor" },
+            { AST::intrinsicopType::EQV, "~eqv" },      { AST::intrinsicopType::NEQV, "~neqv" },
+            { AST::intrinsicopType::PLUS, "~add" },     { AST::intrinsicopType::MINUS, "~sub" },
+            { AST::intrinsicopType::STAR, "~mul" },     { AST::intrinsicopType::DIV, "~div" },
+            { AST::intrinsicopType::POW, "~pow" },      { AST::intrinsicopType::NOT, "~not" },
+            { AST::intrinsicopType::EQ, "~eq" },        { AST::intrinsicopType::NOTEQ, "~noteq" },
+            { AST::intrinsicopType::LT, "~lt" },        { AST::intrinsicopType::LTE, "~lte" },
+            { AST::intrinsicopType::GT, "~gt" },        { AST::intrinsicopType::GTE, "~gte" },
+            { AST::intrinsicopType::CONCAT, "~concat" } };
 
     std::map<std::string, IntrinsicSignature> name2signature = {
-        {"any", IntrinsicSignature({"mask", "dim"}, 1, 2)},
-        {"all", IntrinsicSignature({"mask", "dim"}, 1, 2)},
-        {"iany", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"iall", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"norm2", IntrinsicSignature({"array", "dim"}, 1, 2)},
-        {"sum", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"product", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"iparity", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"matmul", IntrinsicSignature({"matrix_a", "matrix_b"}, 2, 2)},
-        {"dot_product", IntrinsicSignature({"vector_a", "vector_b"}, 2, 2)},
-        {"pack", IntrinsicSignature({"array", "mask", "vector"}, 2, 3)},
-        {"unpack", IntrinsicSignature({"vector", "mask", "field"}, 3, 3)},
-        {"count", IntrinsicSignature({"mask", "dim", "kind"}, 1, 3)},
-        {"parity", IntrinsicSignature({"mask", "dim"}, 1, 2)},
-        {"maxval", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"maxloc", IntrinsicSignature({"array", "dim", "mask", "kind", "back"}, 1, 5)},
-        {"minval", IntrinsicSignature({"array", "dim", "mask"}, 1, 3)},
-        {"minloc", IntrinsicSignature({"array", "dim", "mask", "kind", "back"}, 1, 5)},
-        {"findloc", IntrinsicSignature({"array", "value", "dim", "mask", "kind", "back"}, 2, 6)},
+        { "any", IntrinsicSignature({ "mask", "dim" }, 1, 2) },
+        { "all", IntrinsicSignature({ "mask", "dim" }, 1, 2) },
+        { "iany", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "iall", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "norm2", IntrinsicSignature({ "array", "dim" }, 1, 2) },
+        { "sum", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "product", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "iparity", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "matmul", IntrinsicSignature({ "matrix_a", "matrix_b" }, 2, 2) },
+        { "dot_product", IntrinsicSignature({ "vector_a", "vector_b" }, 2, 2) },
+        { "pack", IntrinsicSignature({ "array", "mask", "vector" }, 2, 3) },
+        { "unpack", IntrinsicSignature({ "vector", "mask", "field" }, 3, 3) },
+        { "count", IntrinsicSignature({ "mask", "dim", "kind" }, 1, 3) },
+        { "parity", IntrinsicSignature({ "mask", "dim" }, 1, 2) },
+        { "maxval", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "maxloc", IntrinsicSignature({ "array", "dim", "mask", "kind", "back" }, 1, 5) },
+        { "minval", IntrinsicSignature({ "array", "dim", "mask" }, 1, 3) },
+        { "minloc", IntrinsicSignature({ "array", "dim", "mask", "kind", "back" }, 1, 5) },
+        { "findloc",
+          IntrinsicSignature({ "array", "value", "dim", "mask", "kind", "back" }, 2, 6) },
         // max0 can accept any arbitrary number of arguments 2<=x<=100
-        {"max0", IntrinsicSignature({"a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "a10", "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84", "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96", "a97", "a98", "a99", "a100"}, 2, 100)},
+        { "max0",
+          IntrinsicSignature(
+              { "a1",  "a2",  "a3",  "a4",  "a5",  "a6",  "a7",  "a8",  "a9",  "a10", "a11", "a12",
+                "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24",
+                "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36",
+                "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48",
+                "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60",
+                "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72",
+                "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84",
+                "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96",
+                "a97", "a98", "a99", "a100" },
+              2,
+              100) },
         // min0 can accept any arbitrary number of arguments 2<=x<=100
-        {"min0", IntrinsicSignature({"a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "a10", "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84", "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96", "a97", "a98", "a99", "a100"}, 2, 100)},
-        {"min", IntrinsicSignature({"a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "a10", "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84", "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96", "a97", "a98", "a99", "a100"}, 2, 100)},
-        {"max", IntrinsicSignature({"a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "a10", "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84", "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96", "a97", "a98", "a99", "a100"}, 2, 100)},
-        {"merge", IntrinsicSignature({"tsource", "fsource", "mask"}, 3, 3)},
-        {"sign", IntrinsicSignature({"a", "b"}, 2, 2)},
-        {"aint", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"nint", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"anint", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"atan2", IntrinsicSignature({"y", "x"}, 2, 2)},
-        {"shape", IntrinsicSignature({"source", "kind"}, 1, 2)},
-        {"mod", IntrinsicSignature({"a", "p"}, 2, 2)},
-        {"repeat", IntrinsicSignature({"string", "ncopies"}, 2, 2)},
-        {"verify", IntrinsicSignature({"string", "set", "back", "kind"}, 2, 4)},
-        {"scan", IntrinsicSignature({"string", "set", "back", "kind"}, 2, 4)},
-        {"index", IntrinsicSignature({"string", "substring", "back", "kind"}, 2, 4)},
-        {"cmplx", IntrinsicSignature({"x", "y", "kind"}, 1, 3)},
-        {"hypot", IntrinsicSignature({"x", "y"}, 2, 2)},
-        {"shiftr", IntrinsicSignature({"i", "shift"}, 2, 2)},
-        {"rshift", IntrinsicSignature({"i", "shift"}, 2, 2)},
-        {"shiftl", IntrinsicSignature({"i", "shift"}, 2, 2)},
-        {"lshift", IntrinsicSignature({"i", "shift"}, 2, 2)},
-        {"ishft", IntrinsicSignature({"i", "shift"}, 2, 2)},
-        {"bgt", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"blt", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"bge", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"ble", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"lgt", IntrinsicSignature({"string_A", "string_B"}, 2, 2)},
-        {"llt", IntrinsicSignature({"string_A", "string_B"}, 2, 2)},
-        {"lge", IntrinsicSignature({"string_A", "string_B"}, 2, 2)},
-        {"lle", IntrinsicSignature({"string_A", "string_B"}, 2, 2)},
-        {"iand", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"and", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"ior", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"or", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"ieor", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"xor", IntrinsicSignature({"i", "j"}, 2, 2)},
-        {"ibclr", IntrinsicSignature({"i", "pos"}, 2, 2)},
-        {"ibset", IntrinsicSignature({"i", "pos"}, 2, 2)},
-        {"btest", IntrinsicSignature({"i", "pos"}, 2, 2)},
-        {"ibits", IntrinsicSignature({"i", "pos", "len"}, 3, 3)},
-        {"floor", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"ceiling", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"scale", IntrinsicSignature({"X", "I"}, 2, 2)},
-        {"dprod", IntrinsicSignature({"X", "Y"}, 2, 2)},
-        {"maskr", IntrinsicSignature({"i", "kind"}, 1, 2)},
-        {"maskl", IntrinsicSignature({"i", "kind"}, 1, 2)},
-        {"dim", IntrinsicSignature({"X", "Y"}, 2, 2)},
-        {"selected_real_kind", IntrinsicSignature({"p", "r", "radix"}, 0, 3)},
-        {"nearest", IntrinsicSignature({"x", "s"}, 2, 2)},
-        {"_lfortran_compiler_version", IntrinsicSignature({}, 0, 0)},
-        {"compiler_options", IntrinsicSignature({}, 0, 0)},
-        {"command_argument_count", IntrinsicSignature({}, 0, 0)},
-        {"ishftc", IntrinsicSignature({"i", "shift", "size"}, 2, 3)},
-        {"ichar", IntrinsicSignature({"C", "kind"}, 1, 2)},
-        {"char", IntrinsicSignature({"I", "kind"}, 1, 2)},
-        {"achar", IntrinsicSignature({"I", "kind"}, 1, 2)},
-        {"set_exponent", IntrinsicSignature({"X", "I"}, 2, 2)},
-        {"dshiftl", IntrinsicSignature({"i", "j", "shift"}, 3, 3)},
-        {"dshiftr", IntrinsicSignature({"i", "j", "shift"}, 3, 3)},
-        {"random_init", IntrinsicSignature({"repeatable", "image"}, 2, 2)},
-        {"random_seed", IntrinsicSignature({"size", "put", "get"}, 0, 3)},
-        {"get_command", IntrinsicSignature({"command", "length", "status"}, 0, 3)},
-        {"get_command_argument", IntrinsicSignature({"number", "value", "length", "status"}, 1, 4)},
-        {"system_clock", IntrinsicSignature({"count", "count_rate", "count_max"}, 0, 3)},
-        {"date_and_time", IntrinsicSignature({"date", "time", "zone", "values"}, 0, 4)},
-        {"get_environment_variable", IntrinsicSignature({"name", "value", "length", "status", "trim_name"}, 1, 5)},
-        {"execute_command_line", IntrinsicSignature({"command", "wait", "exitstat", "cmdstat", "cmdmsg"}, 1, 5)},
-        {"move_alloc", IntrinsicSignature({"from", "to"}, 2, 2)},
-        {"mvbits", IntrinsicSignature({"from", "frompos", "len", "to", "topos"}, 5, 5)},
-        {"modulo", IntrinsicSignature({"a", "p"}, 2, 2)},
-        {"bessel_jn", IntrinsicSignature({"n", "x"}, 2, 2)},
-        {"bessel_yn", IntrinsicSignature({"n", "x"}, 2, 2)},
-        {"merge_bits", IntrinsicSignature({"i", "j", "mask"}, 3, 3)},
-        {"logical", IntrinsicSignature({"i", "kind"}, 1, 2)},
-        {"cshift", IntrinsicSignature({"array", "shift", "dim"}, 2, 3)},
-        {"eoshift", IntrinsicSignature({"array", "shift", "boundary", "dim"}, 2, 4)},
-        {"real", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"storage_size", IntrinsicSignature({"a", "kind"}, 1, 2)},
-        {"spread", IntrinsicSignature({"source", "dim", "ncopies"}, 3, 3)},
-        {"out_of_range", IntrinsicSignature({"value", "mold", "round"}, 2, 3)},
-        {"same_type_as", IntrinsicSignature({"a", "b"}, 2, 2)},
-        {"len_trim", IntrinsicSignature({"String", "Kind"}, 1, 2)},
-        {"int", IntrinsicSignature({"i", "kind"}, 1, 2)},
-        {"random_number", IntrinsicSignature({"harvest"}, 1, 1)},
-        {"abs", IntrinsicSignature({"a"}, 1, 1)},
-        {"acos", IntrinsicSignature({"x"}, 1, 1)},
-        {"acosd", IntrinsicSignature({"x"}, 1, 1)},
-        {"acosh", IntrinsicSignature({"x"}, 1, 1)},
-        {"adjustl", IntrinsicSignature({"string"}, 1, 1)},
-        {"adjustr", IntrinsicSignature({"string"}, 1, 1)},
-        {"aimag", IntrinsicSignature({"z"}, 1, 1)},
-        {"asin", IntrinsicSignature({"x"}, 1, 1)},
-        {"asind", IntrinsicSignature({"x"}, 1, 1)},
-        {"asinh", IntrinsicSignature({"x"}, 1, 1)},
-        {"atan", IntrinsicSignature({"x"}, 1, 1)},
-        {"atanh", IntrinsicSignature({"x"}, 1, 1)},
-        {"bit_size", IntrinsicSignature({"i"}, 1, 1)},
-        {"conjg", IntrinsicSignature({"z"}, 1, 1)},
-        {"cos", IntrinsicSignature({"x"}, 1, 1)},
-        {"cosd", IntrinsicSignature({"x"}, 1, 1)},
-        {"cosh", IntrinsicSignature({"x"}, 1, 1)},
-        {"erf", IntrinsicSignature({"x"}, 1, 1)},
-        {"erfc", IntrinsicSignature({"x"}, 1, 1)},
-        {"exp", IntrinsicSignature({"x"}, 1, 1)},
-        {"gamma", IntrinsicSignature({"x"}, 1, 1)},
-        {"log", IntrinsicSignature({"x"}, 1, 1)},
-        {"log10", IntrinsicSignature({"x"}, 1, 1)},
-        {"log_gamma", IntrinsicSignature({"x"}, 1, 1)},
-        {"sin", IntrinsicSignature({"x"}, 1, 1)},
-        {"sinh", IntrinsicSignature({"x"}, 1, 1)},
-        {"sqrt", IntrinsicSignature({"x"}, 1, 1)},
-        {"tan", IntrinsicSignature({"x"}, 1, 1)},
-        {"tanh", IntrinsicSignature({"x"}, 1, 1)},
-        {"tand", IntrinsicSignature({"x"}, 1, 1)},
-        {"not", IntrinsicSignature({"i"}, 1, 1)},
-        {"precision", IntrinsicSignature({"x"}, 1, 1)},
-        {"range", IntrinsicSignature({"x"}, 1, 1)},
-        {"tiny", IntrinsicSignature({"x"}, 1, 1)},
-        {"huge", IntrinsicSignature({"x"}, 1, 1)},
-        {"loc", IntrinsicSignature({"x"}, 1, 1)},
-        {"epsilon", IntrinsicSignature({"x"}, 1, 1)},
-        {"digits", IntrinsicSignature({"x"}, 1, 1)},
-        {"present", IntrinsicSignature({"a"}, 1, 1)},
-        {"leadz", IntrinsicSignature({"i"}, 1, 1)},
-        {"trailz", IntrinsicSignature({"i"}, 1, 1)},
+        { "min0",
+          IntrinsicSignature(
+              { "a1",  "a2",  "a3",  "a4",  "a5",  "a6",  "a7",  "a8",  "a9",  "a10", "a11", "a12",
+                "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24",
+                "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36",
+                "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48",
+                "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60",
+                "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72",
+                "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84",
+                "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96",
+                "a97", "a98", "a99", "a100" },
+              2,
+              100) },
+        { "min",
+          IntrinsicSignature(
+              { "a1",  "a2",  "a3",  "a4",  "a5",  "a6",  "a7",  "a8",  "a9",  "a10", "a11", "a12",
+                "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24",
+                "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36",
+                "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48",
+                "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60",
+                "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72",
+                "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84",
+                "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96",
+                "a97", "a98", "a99", "a100" },
+              2,
+              100) },
+        { "max",
+          IntrinsicSignature(
+              { "a1",  "a2",  "a3",  "a4",  "a5",  "a6",  "a7",  "a8",  "a9",  "a10", "a11", "a12",
+                "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24",
+                "a25", "a26", "a27", "a28", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36",
+                "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48",
+                "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60",
+                "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72",
+                "a73", "a74", "a75", "a76", "a77", "a78", "a79", "a80", "a81", "a82", "a83", "a84",
+                "a85", "a86", "a87", "a88", "a89", "a90", "a91", "a92", "a93", "a94", "a95", "a96",
+                "a97", "a98", "a99", "a100" },
+              2,
+              100) },
+        { "merge", IntrinsicSignature({ "tsource", "fsource", "mask" }, 3, 3) },
+        { "sign", IntrinsicSignature({ "a", "b" }, 2, 2) },
+        { "aint", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "nint", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "anint", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "atan2", IntrinsicSignature({ "y", "x" }, 2, 2) },
+        { "shape", IntrinsicSignature({ "source", "kind" }, 1, 2) },
+        { "mod", IntrinsicSignature({ "a", "p" }, 2, 2) },
+        { "repeat", IntrinsicSignature({ "string", "ncopies" }, 2, 2) },
+        { "verify", IntrinsicSignature({ "string", "set", "back", "kind" }, 2, 4) },
+        { "scan", IntrinsicSignature({ "string", "set", "back", "kind" }, 2, 4) },
+        { "index", IntrinsicSignature({ "string", "substring", "back", "kind" }, 2, 4) },
+        { "cmplx", IntrinsicSignature({ "x", "y", "kind" }, 1, 3) },
+        { "hypot", IntrinsicSignature({ "x", "y" }, 2, 2) },
+        { "shiftr", IntrinsicSignature({ "i", "shift" }, 2, 2) },
+        { "rshift", IntrinsicSignature({ "i", "shift" }, 2, 2) },
+        { "shiftl", IntrinsicSignature({ "i", "shift" }, 2, 2) },
+        { "lshift", IntrinsicSignature({ "i", "shift" }, 2, 2) },
+        { "ishft", IntrinsicSignature({ "i", "shift" }, 2, 2) },
+        { "bgt", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "blt", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "bge", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "ble", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "lgt", IntrinsicSignature({ "string_A", "string_B" }, 2, 2) },
+        { "llt", IntrinsicSignature({ "string_A", "string_B" }, 2, 2) },
+        { "lge", IntrinsicSignature({ "string_A", "string_B" }, 2, 2) },
+        { "lle", IntrinsicSignature({ "string_A", "string_B" }, 2, 2) },
+        { "iand", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "and", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "ior", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "or", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "ieor", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "xor", IntrinsicSignature({ "i", "j" }, 2, 2) },
+        { "ibclr", IntrinsicSignature({ "i", "pos" }, 2, 2) },
+        { "ibset", IntrinsicSignature({ "i", "pos" }, 2, 2) },
+        { "btest", IntrinsicSignature({ "i", "pos" }, 2, 2) },
+        { "ibits", IntrinsicSignature({ "i", "pos", "len" }, 3, 3) },
+        { "floor", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "ceiling", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "scale", IntrinsicSignature({ "X", "I" }, 2, 2) },
+        { "dprod", IntrinsicSignature({ "X", "Y" }, 2, 2) },
+        { "maskr", IntrinsicSignature({ "i", "kind" }, 1, 2) },
+        { "maskl", IntrinsicSignature({ "i", "kind" }, 1, 2) },
+        { "dim", IntrinsicSignature({ "X", "Y" }, 2, 2) },
+        { "selected_real_kind", IntrinsicSignature({ "p", "r", "radix" }, 0, 3) },
+        { "nearest", IntrinsicSignature({ "x", "s" }, 2, 2) },
+        { "_lfortran_compiler_version", IntrinsicSignature({}, 0, 0) },
+        { "compiler_options", IntrinsicSignature({}, 0, 0) },
+        { "command_argument_count", IntrinsicSignature({}, 0, 0) },
+        { "ishftc", IntrinsicSignature({ "i", "shift", "size" }, 2, 3) },
+        { "ichar", IntrinsicSignature({ "C", "kind" }, 1, 2) },
+        { "char", IntrinsicSignature({ "I", "kind" }, 1, 2) },
+        { "achar", IntrinsicSignature({ "I", "kind" }, 1, 2) },
+        { "set_exponent", IntrinsicSignature({ "X", "I" }, 2, 2) },
+        { "dshiftl", IntrinsicSignature({ "i", "j", "shift" }, 3, 3) },
+        { "dshiftr", IntrinsicSignature({ "i", "j", "shift" }, 3, 3) },
+        { "random_init", IntrinsicSignature({ "repeatable", "image" }, 2, 2) },
+        { "random_seed", IntrinsicSignature({ "size", "put", "get" }, 0, 3) },
+        { "get_command", IntrinsicSignature({ "command", "length", "status" }, 0, 3) },
+        { "get_command_argument",
+          IntrinsicSignature({ "number", "value", "length", "status" }, 1, 4) },
+        { "system_clock", IntrinsicSignature({ "count", "count_rate", "count_max" }, 0, 3) },
+        { "date_and_time", IntrinsicSignature({ "date", "time", "zone", "values" }, 0, 4) },
+        { "get_environment_variable",
+          IntrinsicSignature({ "name", "value", "length", "status", "trim_name" }, 1, 5) },
+        { "execute_command_line",
+          IntrinsicSignature({ "command", "wait", "exitstat", "cmdstat", "cmdmsg" }, 1, 5) },
+        { "move_alloc", IntrinsicSignature({ "from", "to" }, 2, 2) },
+        { "mvbits", IntrinsicSignature({ "from", "frompos", "len", "to", "topos" }, 5, 5) },
+        { "modulo", IntrinsicSignature({ "a", "p" }, 2, 2) },
+        { "bessel_jn", IntrinsicSignature({ "n", "x" }, 2, 2) },
+        { "bessel_yn", IntrinsicSignature({ "n", "x" }, 2, 2) },
+        { "merge_bits", IntrinsicSignature({ "i", "j", "mask" }, 3, 3) },
+        { "logical", IntrinsicSignature({ "i", "kind" }, 1, 2) },
+        { "cshift", IntrinsicSignature({ "array", "shift", "dim" }, 2, 3) },
+        { "eoshift", IntrinsicSignature({ "array", "shift", "boundary", "dim" }, 2, 4) },
+        { "real", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "storage_size", IntrinsicSignature({ "a", "kind" }, 1, 2) },
+        { "spread", IntrinsicSignature({ "source", "dim", "ncopies" }, 3, 3) },
+        { "out_of_range", IntrinsicSignature({ "value", "mold", "round" }, 2, 3) },
+        { "same_type_as", IntrinsicSignature({ "a", "b" }, 2, 2) },
+        { "len_trim", IntrinsicSignature({ "String", "Kind" }, 1, 2) },
+        { "int", IntrinsicSignature({ "i", "kind" }, 1, 2) },
+        { "random_number", IntrinsicSignature({ "harvest" }, 1, 1) },
+        { "abs", IntrinsicSignature({ "a" }, 1, 1) },
+        { "acos", IntrinsicSignature({ "x" }, 1, 1) },
+        { "acosd", IntrinsicSignature({ "x" }, 1, 1) },
+        { "acosh", IntrinsicSignature({ "x" }, 1, 1) },
+        { "adjustl", IntrinsicSignature({ "string" }, 1, 1) },
+        { "adjustr", IntrinsicSignature({ "string" }, 1, 1) },
+        { "aimag", IntrinsicSignature({ "z" }, 1, 1) },
+        { "asin", IntrinsicSignature({ "x" }, 1, 1) },
+        { "asind", IntrinsicSignature({ "x" }, 1, 1) },
+        { "asinh", IntrinsicSignature({ "x" }, 1, 1) },
+        { "atan", IntrinsicSignature({ "x" }, 1, 1) },
+        { "atanh", IntrinsicSignature({ "x" }, 1, 1) },
+        { "bit_size", IntrinsicSignature({ "i" }, 1, 1) },
+        { "conjg", IntrinsicSignature({ "z" }, 1, 1) },
+        { "cos", IntrinsicSignature({ "x" }, 1, 1) },
+        { "cosd", IntrinsicSignature({ "x" }, 1, 1) },
+        { "cosh", IntrinsicSignature({ "x" }, 1, 1) },
+        { "erf", IntrinsicSignature({ "x" }, 1, 1) },
+        { "erfc", IntrinsicSignature({ "x" }, 1, 1) },
+        { "exp", IntrinsicSignature({ "x" }, 1, 1) },
+        { "gamma", IntrinsicSignature({ "x" }, 1, 1) },
+        { "log", IntrinsicSignature({ "x" }, 1, 1) },
+        { "log10", IntrinsicSignature({ "x" }, 1, 1) },
+        { "log_gamma", IntrinsicSignature({ "x" }, 1, 1) },
+        { "sin", IntrinsicSignature({ "x" }, 1, 1) },
+        { "sinh", IntrinsicSignature({ "x" }, 1, 1) },
+        { "sqrt", IntrinsicSignature({ "x" }, 1, 1) },
+        { "tan", IntrinsicSignature({ "x" }, 1, 1) },
+        { "tanh", IntrinsicSignature({ "x" }, 1, 1) },
+        { "tand", IntrinsicSignature({ "x" }, 1, 1) },
+        { "not", IntrinsicSignature({ "i" }, 1, 1) },
+        { "precision", IntrinsicSignature({ "x" }, 1, 1) },
+        { "range", IntrinsicSignature({ "x" }, 1, 1) },
+        { "tiny", IntrinsicSignature({ "x" }, 1, 1) },
+        { "huge", IntrinsicSignature({ "x" }, 1, 1) },
+        { "loc", IntrinsicSignature({ "x" }, 1, 1) },
+        { "epsilon", IntrinsicSignature({ "x" }, 1, 1) },
+        { "digits", IntrinsicSignature({ "x" }, 1, 1) },
+        { "present", IntrinsicSignature({ "a" }, 1, 1) },
+        { "leadz", IntrinsicSignature({ "i" }, 1, 1) },
+        { "trailz", IntrinsicSignature({ "i" }, 1, 1) },
 
 
         // LFortran-specific intrinsics
-        {"_lfortran_set_item", IntrinsicSignature({"iterable", "index", "element"}, 3, 3)},
-        {"_lfortran_clear", IntrinsicSignature({"iterable"}, 1, 1)},
-        {"_lfortran_list_append", IntrinsicSignature({"list", "element"}, 2, 2)},
-        {"_lfortran_list_reverse", IntrinsicSignature({"list"}, 1, 1)},
-        {"_lfortran_list_insert", IntrinsicSignature({"list", "index", "element"}, 3, 3)},
-        {"_lfortran_list_remove", IntrinsicSignature({"list", "element"}, 2, 2)},
-        {"_lfortran_set_add", IntrinsicSignature({"set", "element"}, 2, 2)},
+        { "_lfortran_set_item", IntrinsicSignature({ "iterable", "index", "element" }, 3, 3) },
+        { "_lfortran_clear", IntrinsicSignature({ "iterable" }, 1, 1) },
+        { "_lfortran_list_append", IntrinsicSignature({ "list", "element" }, 2, 2) },
+        { "_lfortran_list_reverse", IntrinsicSignature({ "list" }, 1, 1) },
+        { "_lfortran_list_insert", IntrinsicSignature({ "list", "index", "element" }, 3, 3) },
+        { "_lfortran_list_remove", IntrinsicSignature({ "list", "element" }, 2, 2) },
+        { "_lfortran_set_add", IntrinsicSignature({ "set", "element" }, 2, 2) },
     };
 
 
     std::map<std::string, std::pair<std::string, std::vector<std::string>>> intrinsic_mapping = {
-        {"iabs", {"abs", {"int4"}}},
-        {"dabs", {"abs", {"real8"}}},
-        {"cabs", {"abs", {"complex4"}}},
-        {"zabs", {"abs", {"complex8"}}},
-        {"cdabs", {"abs", {"complex8"}}},
-        {"dsinh", {"sinh", {"real8"}}},
-        {"dcosh", {"cosh", {"real8"}}},
-        {"dtanh", {"tanh", {"real8"}}},
-        {"dsin", {"sin", {"real8"}}},
-        {"derf", {"erf", {"real8"}}},
-        {"derfc", {"erfc", {"real8"}}},
-        {"lgamma", {"log_gamma", {"real"}}},
-        {"algama", {"log_gamma", {"real"}}},
-        {"dlgama", {"log_gamma", {"real8"}}},
-        {"csin", {"sin", {"complex4"}}},
-        {"zsin", {"sin", {"complex8"}}},
-        {"cdsin", {"sin", {"complex8"}}},
-        {"dcos", {"cos", {"real8"}}},
-        {"ccos", {"cos", {"complex4"}}},
-        {"zcos", {"cos", {"complex8"}}},
-        {"cdcos", {"cos", {"complex8"}}},
-        {"dtan", {"tan", {"real8"}}},
-        {"datan", {"atan", {"real8"}}},
-        {"datan2", {"atan2", {"real8", "real8"}}},
-        {"dimag", {"aimag", {"complex8"}}},
-        {"imag", {"aimag", {"complex"}}},
-        {"imagpart", {"aimag", {"complex"}}},
-        {"realpart", {"real", {"complex" ,"int4"}}},
-        {"isign", {"sign", {"int4", "int4"}}},
-        {"dsign", {"sign", {"real8", "real8"}}},
-        {"dgamma", {"gamma", {"real8"}}},
-        {"dsqrt", {"sqrt", {"real8"}}},
-        {"csqrt", {"sqrt", {"complex4"}}},
-        {"zsqrt", {"sqrt", {"complex8"}}},
-        {"cdsqrt", {"sqrt", {"complex8"}}},
-        {"alog", {"log", {"real4"}}},
-        {"dlog", {"log", {"real8"}}},
-        {"clog", {"log", {"complex4"}}},
-        {"zlog", {"log", {"complex8"}}},
-        {"cdlog", {"log", {"complex8"}}},
-        {"alog10", {"log10", {"real4"}}},
-        {"dlog10", {"log10", {"real8"}}},
-        {"dexp", {"exp", {"real8"}}},
-        {"cexp", {"exp", {"complex4"}}},
-        {"zexp", {"exp", {"complex8"}}},
-        {"cdexp", {"exp", {"complex8"}}},
-        {"min0", {"min", {"int4"}}},
-        {"amin0", {"min", {"int4"}}},
-        {"min1", {"min", {"real"}}},
-        {"amin1", {"min", {"real4"}}},
-        {"dmin1", {"min", {"real"}}},
-        {"max0", {"max", {"int4"}}},
-        {"amax0", {"max", {"int4"}}},
-        {"max1", {"max", {"real"}}},
-        {"amax1", {"max", {"real4"}}},
-        {"dmax1", {"max", {"real"}}},
-        {"dcmplx", {"cmplx", {"any", "any", "int4"}}},
-        {"dacos", {"acos", {"real8"}}},
-        {"dacosh", {"acosh", {"real8"}}},
-        {"dint", {"aint", {"real8"}}},
-        {"dnint", {"anint", {"real8"}}},
-        {"dasin", {"asin", {"real8"}}},
-        {"dasinh", {"asinh", {"real8"}}},
-        {"datanh", {"atanh", {"real8"}}},
-        {"dbesj0", {"bessel_j0", {"real8"}}},
-        {"dbesj1", {"bessel_j1", {"real8"}}},
-        {"dbesy0", {"bessel_y0", {"real8"}}},
-        {"dbesy1", {"bessel_y1", {"real8"}}},
-        {"dbesjn", {"bessel_jn", {"int4", "real8"}}},
-        {"dbesyn", {"bessel_yn", {"int4", "real8"}}},
-        {"dconjg", {"conjg", {"complex"}}},
-        {"idim", {"dim", {"int4", "int4"}}},
-        {"ddim", {"dim", {"real8", "real8"}}},
-        {"amod", {"mod", {"real4", "real4"}}},
-        {"dmod", {"mod", {"real8", "real8"}}},
+        { "iabs", { "abs", { "int4" } } },
+        { "dabs", { "abs", { "real8" } } },
+        { "cabs", { "abs", { "complex4" } } },
+        { "zabs", { "abs", { "complex8" } } },
+        { "cdabs", { "abs", { "complex8" } } },
+        { "dsinh", { "sinh", { "real8" } } },
+        { "dcosh", { "cosh", { "real8" } } },
+        { "dtanh", { "tanh", { "real8" } } },
+        { "dsin", { "sin", { "real8" } } },
+        { "derf", { "erf", { "real8" } } },
+        { "derfc", { "erfc", { "real8" } } },
+        { "lgamma", { "log_gamma", { "real" } } },
+        { "algama", { "log_gamma", { "real" } } },
+        { "dlgama", { "log_gamma", { "real8" } } },
+        { "csin", { "sin", { "complex4" } } },
+        { "zsin", { "sin", { "complex8" } } },
+        { "cdsin", { "sin", { "complex8" } } },
+        { "dcos", { "cos", { "real8" } } },
+        { "ccos", { "cos", { "complex4" } } },
+        { "zcos", { "cos", { "complex8" } } },
+        { "cdcos", { "cos", { "complex8" } } },
+        { "dtan", { "tan", { "real8" } } },
+        { "datan", { "atan", { "real8" } } },
+        { "datan2", { "atan2", { "real8", "real8" } } },
+        { "dimag", { "aimag", { "complex8" } } },
+        { "imag", { "aimag", { "complex" } } },
+        { "imagpart", { "aimag", { "complex" } } },
+        { "realpart", { "real", { "complex", "int4" } } },
+        { "isign", { "sign", { "int4", "int4" } } },
+        { "dsign", { "sign", { "real8", "real8" } } },
+        { "dgamma", { "gamma", { "real8" } } },
+        { "dsqrt", { "sqrt", { "real8" } } },
+        { "csqrt", { "sqrt", { "complex4" } } },
+        { "zsqrt", { "sqrt", { "complex8" } } },
+        { "cdsqrt", { "sqrt", { "complex8" } } },
+        { "alog", { "log", { "real4" } } },
+        { "dlog", { "log", { "real8" } } },
+        { "clog", { "log", { "complex4" } } },
+        { "zlog", { "log", { "complex8" } } },
+        { "cdlog", { "log", { "complex8" } } },
+        { "alog10", { "log10", { "real4" } } },
+        { "dlog10", { "log10", { "real8" } } },
+        { "dexp", { "exp", { "real8" } } },
+        { "cexp", { "exp", { "complex4" } } },
+        { "zexp", { "exp", { "complex8" } } },
+        { "cdexp", { "exp", { "complex8" } } },
+        { "min0", { "min", { "int4" } } },
+        { "amin0", { "min", { "int4" } } },
+        { "min1", { "min", { "real" } } },
+        { "amin1", { "min", { "real4" } } },
+        { "dmin1", { "min", { "real" } } },
+        { "max0", { "max", { "int4" } } },
+        { "amax0", { "max", { "int4" } } },
+        { "max1", { "max", { "real" } } },
+        { "amax1", { "max", { "real4" } } },
+        { "dmax1", { "max", { "real" } } },
+        { "dcmplx", { "cmplx", { "any", "any", "int4" } } },
+        { "dacos", { "acos", { "real8" } } },
+        { "dacosh", { "acosh", { "real8" } } },
+        { "dint", { "aint", { "real8" } } },
+        { "dnint", { "anint", { "real8" } } },
+        { "dasin", { "asin", { "real8" } } },
+        { "dasinh", { "asinh", { "real8" } } },
+        { "datanh", { "atanh", { "real8" } } },
+        { "dbesj0", { "bessel_j0", { "real8" } } },
+        { "dbesj1", { "bessel_j1", { "real8" } } },
+        { "dbesy0", { "bessel_y0", { "real8" } } },
+        { "dbesy1", { "bessel_y1", { "real8" } } },
+        { "dbesjn", { "bessel_jn", { "int4", "real8" } } },
+        { "dbesyn", { "bessel_yn", { "int4", "real8" } } },
+        { "dconjg", { "conjg", { "complex" } } },
+        { "idim", { "dim", { "int4", "int4" } } },
+        { "ddim", { "dim", { "real8", "real8" } } },
+        { "amod", { "mod", { "real4", "real4" } } },
+        { "dmod", { "mod", { "real8", "real8" } } },
     };
 
-    ASR::asr_t *tmp;
-    std::vector<ASR::asr_t *> tmp_vec;
-    Allocator &al;
-    CompilerOptions &compiler_options;
-    SymbolTable *current_scope;
-    SymbolTable *implicit_interface_parent_scope = nullptr;
-    ASR::Module_t *current_module = nullptr;
+    ASR::asr_t* tmp;
+    std::vector<ASR::asr_t*> tmp_vec;
+    Allocator& al;
+    CompilerOptions& compiler_options;
+    SymbolTable* current_scope;
+    SymbolTable* implicit_interface_parent_scope = nullptr;
+    ASR::Module_t* current_module = nullptr;
     SetChar current_module_dependencies;
     IntrinsicProcedures intrinsic_procedures;
     IntrinsicProceduresAsASRNodes intrinsic_procedures_as_asr_nodes;
-    std::set<std::string> intrinsic_module_procedures_as_asr_nodes = {
-        "c_loc", "c_f_pointer", "c_associated", "c_funloc"
-    };
+    std::set<std::string> intrinsic_module_procedures_as_asr_nodes
+        = { "c_loc", "c_f_pointer", "c_associated", "c_funloc" };
 
     ASR::accessType dflt_access = ASR::Public;
     bool in_module = false;
-    std::map<SymbolTable*, std::map<AST::decl_attribute_t*, AST::simple_attributeType>> overloaded_ops;
+    std::map<SymbolTable*, std::map<AST::decl_attribute_t*, AST::simple_attributeType>>
+        overloaded_ops;
     std::map<SymbolTable*, ASR::accessType> assgn;
     std::map<std::string, ASR::accessType> assgnd_access;
     std::map<std::string, std::pair<ASR::storage_typeType, AST::expr_t*>> assgnd_storage;
@@ -1555,19 +1801,19 @@ public:
     bool _processing_char_len = false;
     bool _declaring_variable = false;
     bool is_implicit_interface = false;
-    Vec<ASR::stmt_t*> *current_body = nullptr;
+    Vec<ASR::stmt_t*>* current_body = nullptr;
 
     std::map<std::string, ASR::ttype_t*> implicit_dictionary;
-    std::map<uint64_t, std::map<std::string, ASR::ttype_t*>> &implicit_mapping;
+    std::map<uint64_t, std::map<std::string, ASR::ttype_t*>>& implicit_mapping;
 
     using common_block_varsyms = std::map<std::string, std::vector<AST::var_sym_t>>;
-    std::map<std::string, std::pair<bool,std::vector<ASR::expr_t*>>> common_block_dictionary;
-    std::map<uint64_t, ASR::symbol_t*> &common_variables_hash;
+    std::map<std::string, std::pair<bool, std::vector<ASR::expr_t*>>> common_block_dictionary;
+    std::map<uint64_t, ASR::symbol_t*>& common_variables_hash;
 
     std::vector<std::map<std::string, ASR::ttype_t*>> implicit_stack;
-    std::map<uint64_t, std::vector<std::string>> &external_procedures_mapping;
+    std::map<uint64_t, std::vector<std::string>>& external_procedures_mapping;
     // mapping of hash int's of scope to 'explicit_intrinsic_procedures'
-    std::map<uint64_t, std::vector<std::string>> &explicit_intrinsic_procedures_mapping;
+    std::map<uint64_t, std::vector<std::string>>& explicit_intrinsic_procedures_mapping;
     std::map<std::string, ASR::symbol_t*> changed_external_function_symbol;
     std::map<std::string, std::vector<AST::stmt_t*>> entry_point_mapping;
     std::vector<std::string> external_procedures;
@@ -1579,12 +1825,13 @@ public:
     // e.g. a declaration like: 'intrinsic abs' for an intrinsic
     // elemental function 'abs'
     std::vector<std::string> explicit_intrinsic_procedures;
-    std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>> &entry_functions;
-    std::map<std::string, std::vector<int>> &entry_function_arguments_mapping;
+    std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>>& entry_functions;
+    std::map<std::string, std::vector<int>>& entry_function_arguments_mapping;
     Vec<char*> data_member_names;
     SetChar current_function_dependencies;
     ASR::ttype_t* current_variable_type_;
-    ASR::expr_t* current_struct_type_var_expr = nullptr; // used for setting the struct symbol in `PointerNullConstant`
+    ASR::expr_t* current_struct_type_var_expr
+        = nullptr;  // used for setting the struct symbol in `PointerNullConstant`
 
     int32_t enum_init_val;
     bool default_storage_save = false;
@@ -1598,29 +1845,40 @@ public:
     std::map<int64_t, std::string> format_statements;
 
     // fields for generics
-    std::map<std::string, std::string> context_map;     // TODO: refactor treatment of context map
-    std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>> &instantiate_types;
-    std::map<uint32_t, std::map<std::string, ASR::symbol_t*>> &instantiate_symbols;
-    std::map<uint32_t, std::vector<ASR::stmt_t*>> &data_structure;
-    LCompilers::LocationManager &lm;
+    std::map<std::string, std::string> context_map;  // TODO: refactor treatment of context map
+    std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>>&
+        instantiate_types;
+    std::map<uint32_t, std::map<std::string, ASR::symbol_t*>>& instantiate_symbols;
+    std::map<uint32_t, std::vector<ASR::stmt_t*>>& data_structure;
+    LCompilers::LocationManager& lm;
 
     std::map<std::string, std::vector<std::string>> generic_procedures;
     /*
      * A struct to store the information of a postponed call to genericProcedure
      * The information should be consumed by function `evaluate_delayed_generic_procedure_calls`
      */
-    struct postponed_genericProcedure_call{
-        ASR::expr_t** holder; // Pointer to the expre that should hold the `ASR::FunctionCall`
-        SymbolTable* current_scope; // The scope where the `AST::FuncCallOrArray` should've been evaluated. 
-        AST::expr_t* func_call; // `AST::FuncCallOrArray`
-        const char* var_name; // Name of the `ASR::Variable` that the functionCall is part of [integer :: arr(genericCall())]
-        std::function<void(ASR::expr_t*)> check; // Lambda function in case the returning `ASR::expr` should be checked in specific way.
+    struct postponed_genericProcedure_call {
+        ASR::expr_t** holder;  // Pointer to the expre that should hold the `ASR::FunctionCall`
+        SymbolTable*
+            current_scope;  // The scope where the `AST::FuncCallOrArray` should've been evaluated.
+        AST::expr_t* func_call;  // `AST::FuncCallOrArray`
+        const char* var_name;    // Name of the `ASR::Variable` that the functionCall is part of
+                                 // [integer :: arr(genericCall())]
+        std::function<void(ASR::expr_t*)> check;  // Lambda function in case the returning
+                                                  // `ASR::expr` should be checked in specific way.
         // Constructor
-        postponed_genericProcedure_call( ASR::expr_t** holder, SymbolTable* current_scope,
-            AST::expr_t* func_call, const char* var_name,
-            std::function<void(ASR::expr_t*)> check
-        ) : holder(holder), current_scope(current_scope), func_call(func_call),
-            var_name(var_name), check(check) {}
+        postponed_genericProcedure_call(ASR::expr_t** holder,
+                                        SymbolTable* current_scope,
+                                        AST::expr_t* func_call,
+                                        const char* var_name,
+                                        std::function<void(ASR::expr_t*)> check)
+            : holder(holder)
+            , current_scope(current_scope)
+            , func_call(func_call)
+            , var_name(var_name)
+            , check(check)
+        {
+        }
     };
     std::vector<postponed_genericProcedure_call> postponed_genericProcedure_calls_vec;
     // global save variable
@@ -1629,111 +1887,153 @@ public:
     // implied do loop nesting
     int idl_nesting_level = 0;
 
-    CommonVisitor(Allocator &al, SymbolTable *symbol_table,
-        diag::Diagnostics &diagnostics, CompilerOptions &compiler_options,
-        std::map<uint64_t, std::map<std::string, ASR::ttype_t*>> &implicit_mapping,
+    CommonVisitor(
+        Allocator& al,
+        SymbolTable* symbol_table,
+        diag::Diagnostics& diagnostics,
+        CompilerOptions& compiler_options,
+        std::map<uint64_t, std::map<std::string, ASR::ttype_t*>>& implicit_mapping,
         std::map<uint64_t, ASR::symbol_t*>& common_variables_hash,
         std::map<uint64_t, std::vector<std::string>>& external_procedures_mapping,
         std::map<uint64_t, std::vector<std::string>>& explicit_intrinsic_procedures_mapping,
-        std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>> &instantiate_types,
-        std::map<uint32_t, std::map<std::string, ASR::symbol_t*>> &instantiate_symbols,
-        std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>> &entry_functions,
-        std::map<std::string, std::vector<int>> &entry_function_arguments_mapping,
-        std::map<uint32_t, std::vector<ASR::stmt_t*>> &data_structure,
-            LCompilers::LocationManager &lm
-    ): diag{diagnostics}, al{al}, compiler_options{compiler_options},
-          current_scope{symbol_table}, implicit_mapping{implicit_mapping},
-          common_variables_hash{common_variables_hash},
-          external_procedures_mapping{external_procedures_mapping},
-          explicit_intrinsic_procedures_mapping{explicit_intrinsic_procedures_mapping},
-          entry_functions{entry_functions},entry_function_arguments_mapping{entry_function_arguments_mapping},
-          current_variable_type_{nullptr}, instantiate_types{instantiate_types},
-          instantiate_symbols{instantiate_symbols}, data_structure{data_structure}, lm{lm}
+        std::map<uint32_t, std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>>>&
+            instantiate_types,
+        std::map<uint32_t, std::map<std::string, ASR::symbol_t*>>& instantiate_symbols,
+        std::map<std::string, std::map<std::string, std::vector<AST::stmt_t*>>>& entry_functions,
+        std::map<std::string, std::vector<int>>& entry_function_arguments_mapping,
+        std::map<uint32_t, std::vector<ASR::stmt_t*>>& data_structure,
+        LCompilers::LocationManager& lm)
+        : diag{ diagnostics }
+        , al{ al }
+        , compiler_options{ compiler_options }
+        , current_scope{ symbol_table }
+        , implicit_mapping{ implicit_mapping }
+        , common_variables_hash{ common_variables_hash }
+        , external_procedures_mapping{ external_procedures_mapping }
+        , explicit_intrinsic_procedures_mapping{ explicit_intrinsic_procedures_mapping }
+        , entry_functions{ entry_functions }
+        , entry_function_arguments_mapping{ entry_function_arguments_mapping }
+        , current_variable_type_{ nullptr }
+        , instantiate_types{ instantiate_types }
+        , instantiate_symbols{ instantiate_symbols }
+        , data_structure{ data_structure }
+        , lm{ lm }
     {
         current_module_dependencies.reserve(al, 4);
         enum_init_val = 0;
     }
 
-    ASR::symbol_t* resolve_symbol(const Location &loc, const std::string &sub_name) {
-        SymbolTable *scope = current_scope;
-        ASR::symbol_t *sub = scope->resolve_symbol(sub_name);
+    ASR::symbol_t* resolve_symbol(const Location& loc, const std::string& sub_name)
+    {
+        SymbolTable* scope = current_scope;
+        ASR::symbol_t* sub = scope->resolve_symbol(sub_name);
         if (!sub) {
-            diag.add(Diagnostic(
-                "Symbol '" + sub_name + "' not declared",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+            diag.add(Diagnostic("Symbol '" + sub_name + "' not declared",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         return sub;
     }
 
-    ASR::symbol_t* declare_implicit_variable(const Location &loc,
-            const std::string &var_name, ASR::intentType intent, ASR::expr_t* value = nullptr) {
-        ASR::ttype_t *type = nullptr;
+    ASR::symbol_t* declare_implicit_variable(const Location& loc,
+                                             const std::string& var_name,
+                                             ASR::intentType intent,
+                                             ASR::expr_t* value = nullptr)
+    {
+        ASR::ttype_t* type = nullptr;
         char first_letter = var_name[0];
         // The default implicit typing is:
         // implicit real (a-h,o-z)
         if (first_letter >= 'i' && first_letter <= 'n') {
             // it is an integer
-            type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
+            type = ASRUtils::TYPE(
+                ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
         } else {
             // it is a real
             type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, 4));
         }
         ASR::symbol_t* type_decl = nullptr;
-        if ( value != nullptr ) {
+        if (value != nullptr) {
             ASRUtils::ASRBuilder b(al, loc);
-            ASR::ttype_t *value_type = ASRUtils::expr_type(value);
+            ASR::ttype_t* value_type = ASRUtils::expr_type(value);
             value = b.t2t(value, value_type, type);
             type_decl = ASRUtils::get_struct_sym_from_struct_expr(value);
         }
         SetChar variable_dependencies_vec;
         variable_dependencies_vec.reserve(al, 1);
         ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type);
-        ASR::symbol_t *v = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al, loc,
-            current_scope, s2c(al, var_name), variable_dependencies_vec.p,
-            variable_dependencies_vec.size(), intent, value, value != nullptr ? ASRUtils::expr_value(value) : value,
-            ASR::storage_typeType::Default, type, type_decl,
-            current_procedure_abi_type, ASR::Public,
-            ASR::presenceType::Required, false));
+        ASR::symbol_t* v = ASR::down_cast<ASR::symbol_t>(
+            ASRUtils::make_Variable_t_util(al,
+                                           loc,
+                                           current_scope,
+                                           s2c(al, var_name),
+                                           variable_dependencies_vec.p,
+                                           variable_dependencies_vec.size(),
+                                           intent,
+                                           value,
+                                           value != nullptr ? ASRUtils::expr_value(value) : value,
+                                           ASR::storage_typeType::Default,
+                                           type,
+                                           type_decl,
+                                           current_procedure_abi_type,
+                                           ASR::Public,
+                                           ASR::presenceType::Required,
+                                           false));
         current_scope->add_symbol(var_name, v);
         return v;
     }
 
-    ASR::symbol_t* declare_implicit_variable2(const Location &loc,
-            const std::string &var_name, ASR::intentType intent,
-            ASR::ttype_t *type, ASR::expr_t* value = nullptr) {
+    ASR::symbol_t* declare_implicit_variable2(const Location& loc,
+                                              const std::string& var_name,
+                                              ASR::intentType intent,
+                                              ASR::ttype_t* type,
+                                              ASR::expr_t* value = nullptr)
+    {
         ASR::symbol_t* type_decl = nullptr;
-        if ( value != nullptr ) {
+        if (value != nullptr) {
             ASRUtils::ASRBuilder b(al, loc);
-            ASR::ttype_t *value_type = ASRUtils::expr_type(value);
+            ASR::ttype_t* value_type = ASRUtils::expr_type(value);
             value = b.t2t(value, value_type, type);
             type_decl = ASRUtils::get_struct_sym_from_struct_expr(value);
         }
         SetChar variable_dependencies_vec;
         variable_dependencies_vec.reserve(al, 1);
         ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type);
-        ASR::symbol_t *v = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al, loc,
-            current_scope, s2c(al, var_name), variable_dependencies_vec.p,
-            variable_dependencies_vec.size(), intent, value, value != nullptr ? ASRUtils::expr_value(value) : value,
-            ASR::storage_typeType::Default, type, type_decl,
-            current_procedure_abi_type, ASR::Public,
-            ASR::presenceType::Required, false));
+        ASR::symbol_t* v = ASR::down_cast<ASR::symbol_t>(
+            ASRUtils::make_Variable_t_util(al,
+                                           loc,
+                                           current_scope,
+                                           s2c(al, var_name),
+                                           variable_dependencies_vec.p,
+                                           variable_dependencies_vec.size(),
+                                           intent,
+                                           value,
+                                           value != nullptr ? ASRUtils::expr_value(value) : value,
+                                           ASR::storage_typeType::Default,
+                                           type,
+                                           type_decl,
+                                           current_procedure_abi_type,
+                                           ASR::Public,
+                                           ASR::presenceType::Required,
+                                           false));
         current_scope->add_symbol(var_name, v);
         return v;
     }
 
 
-    ASR::asr_t* resolve_variable(const Location &loc, const std::string &var_name) {
-        SymbolTable *scope = current_scope;
-        ASR::symbol_t *v = scope->resolve_symbol(var_name);
+    ASR::asr_t* resolve_variable(const Location& loc, const std::string& var_name)
+    {
+        SymbolTable* scope = current_scope;
+        ASR::symbol_t* v = scope->resolve_symbol(var_name);
         if (compiler_options.implicit_typing) {
             if (!in_Subroutine) {
                 if (implicit_mapping.size() != 0) {
                     implicit_dictionary = implicit_mapping[get_hash(current_scope->asr_owner)];
                     if (implicit_dictionary.size() == 0 && is_implicit_interface) {
-                        implicit_dictionary = implicit_mapping[get_hash(implicit_interface_parent_scope->asr_owner)];
+                        implicit_dictionary = implicit_mapping[get_hash(
+                            implicit_interface_parent_scope->asr_owner)];
                     }
                 }
             }
@@ -1744,7 +2044,7 @@ public:
             if (v && ASR::is_a<ASR::ExternalSymbol_t>(*v)) {
                 std::string m_name = ASR::down_cast<ASR::ExternalSymbol_t>(v)->m_module_name;
                 if (startswith(m_name, "lfortran_intrinsic")) {
-                    ASR::ttype_t *type_ = ASRUtils::TYPE(ASR::make_CPtr_t(al, loc));
+                    ASR::ttype_t* type_ = ASRUtils::TYPE(ASR::make_CPtr_t(al, loc));
                     tmp = ASR::make_PointerNullConstant_t(al, loc, type_, nullptr);
                     return tmp;
                 }
@@ -1752,19 +2052,19 @@ public:
         }
         if (!v) {
             if (compiler_options.implicit_typing) {
-                std::string first_letter = std::string(1,var_name[0]);
+                std::string first_letter = std::string(1, var_name[0]);
                 if (implicit_dictionary.find(first_letter) != implicit_dictionary.end()) {
-                    ASR::ttype_t *t = implicit_dictionary[first_letter];
+                    ASR::ttype_t* t = implicit_dictionary[first_letter];
                     if (t == nullptr) {
-                        diag.semantic_error_label("Variable '" + var_name
-                            + "' is not declared", {loc},
-                            "'" + var_name + "' is undeclared");
+                        diag.semantic_error_label("Variable '" + var_name + "' is not declared",
+                                                  { loc },
+                                                  "'" + var_name + "' is undeclared");
                         throw SemanticAbort();
                     }
                     ASR::intentType intent;
-                    if (std::find(current_procedure_args.begin(),
-                            current_procedure_args.end(), var_name) !=
-                            current_procedure_args.end()) {
+                    if (std::find(
+                            current_procedure_args.begin(), current_procedure_args.end(), var_name)
+                        != current_procedure_args.end()) {
                         intent = ASRUtils::intent_unspecified;
                     } else {
                         intent = ASRUtils::intent_local;
@@ -1772,9 +2072,9 @@ public:
                     v = declare_implicit_variable2(loc, var_name, intent, t);
                 } else {
                     ASR::intentType intent;
-                    if (std::find(current_procedure_args.begin(),
-                            current_procedure_args.end(), var_name) !=
-                            current_procedure_args.end()) {
+                    if (std::find(
+                            current_procedure_args.begin(), current_procedure_args.end(), var_name)
+                        != current_procedure_args.end()) {
                         intent = ASRUtils::intent_unspecified;
                     } else {
                         intent = ASRUtils::intent_local;
@@ -1783,72 +2083,116 @@ public:
                 }
             } else if (_processing_dimensions && !v) {
                 // Declare an implicit variable with integer type
-                ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
+                ASR::ttype_t* type = ASRUtils::TYPE(
+                    ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
                 SetChar variable_dependencies_vec;
                 variable_dependencies_vec.reserve(al, 1);
                 ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type);
-                v = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al, loc,
-                    current_scope, s2c(al, var_name), variable_dependencies_vec.p,
-                    variable_dependencies_vec.size(), ASRUtils::intent_unspecified, nullptr, nullptr,
-                    ASR::storage_typeType::Default, type, nullptr,
-                    current_procedure_abi_type, ASR::Public,
-                    ASR::presenceType::Required, false));
+                v = ASR::down_cast<ASR::symbol_t>(
+                    ASRUtils::make_Variable_t_util(al,
+                                                   loc,
+                                                   current_scope,
+                                                   s2c(al, var_name),
+                                                   variable_dependencies_vec.p,
+                                                   variable_dependencies_vec.size(),
+                                                   ASRUtils::intent_unspecified,
+                                                   nullptr,
+                                                   nullptr,
+                                                   ASR::storage_typeType::Default,
+                                                   type,
+                                                   nullptr,
+                                                   current_procedure_abi_type,
+                                                   ASR::Public,
+                                                   ASR::presenceType::Required,
+                                                   false));
                 pre_declared_array_dims[var_name] = 1;
                 current_scope->add_symbol(var_name, v);
             } else {
-                diag.semantic_error_label("Variable '" + var_name
-                    + "' is not declared", {loc},
-                    "'" + var_name + "' is undeclared");
+                diag.semantic_error_label("Variable '" + var_name + "' is not declared",
+                                          { loc },
+                                          "'" + var_name + "' is undeclared");
                 throw SemanticAbort();
             }
         }
 
         // The symbol `v` must be a Variable
-        ASR::symbol_t *vpast = ASRUtils::symbol_get_past_external(v);
+        ASR::symbol_t* vpast = ASRUtils::symbol_get_past_external(v);
         if (ASR::is_a<ASR::Variable_t>(*vpast) || ASR::is_a<ASR::Function_t>(*vpast)) {
             return ASR::make_Var_t(al, loc, v);
         } else {
             std::string sym_type = ASRUtils::symbol_type_name(*vpast);
             diag.diagnostics.push_back(diag::Diagnostic(
                 "Symbol '" + var_name + "' must be a variable or a procedure",
-                diag::Level::Error, diag::Stage::Semantic, {
-                    diag::Label("cannot use a '" + sym_type + "' as a variable", {loc}),
-                    diag::Label("'" + var_name + "' declared as a '" + sym_type + "' here", {vpast->base.loc}, false),
+                diag::Level::Error,
+                diag::Stage::Semantic,
+                {
+                    diag::Label("cannot use a '" + sym_type + "' as a variable", { loc }),
+                    diag::Label("'" + var_name + "' declared as a '" + sym_type + "' here",
+                                { vpast->base.loc },
+                                false),
                 }));
             throw SemanticAbort();
         }
     }
 
-    std::string create_getter_function(const Location& loc, ASR::symbol_t* end_sym) {
+    std::string create_getter_function(const Location& loc, ASR::symbol_t* end_sym)
+    {
         SymbolTable* current_scope_copy = current_scope;
-        SymbolTable* parent_scope = current_scope->parent; // use parent scope instead of local to avoid unintended wrong manipulation by nested_vars pass.
+        SymbolTable* parent_scope
+            = current_scope->parent;  // use parent scope instead of local to avoid unintended wrong
+                                      // manipulation by nested_vars pass.
         ASRUtils::ASRBuilder b(al, loc);
         current_scope = al.make_new<SymbolTable>(parent_scope);
 
-        std::string func_name = parent_scope->get_unique_name("__lcompilers_get_" + std::string(ASRUtils::symbol_name(end_sym)));
+        std::string func_name = parent_scope->get_unique_name(
+            "__lcompilers_get_" + std::string(ASRUtils::symbol_name(end_sym)));
         if (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym)) {
             ASRUtils::SymbolDuplicator sd(al);
             sd.duplicate_symbol(end_sym, current_scope);
             end_sym = current_scope->resolve_symbol(ASRUtils::symbol_name(end_sym));
         }
-        ASR::expr_t* return_var_expr = b.Variable(current_scope, func_name, ASRUtils::symbol_type(end_sym),
-                                ASR::intentType::ReturnVar);
+        ASR::expr_t* return_var_expr = b.Variable(
+            current_scope, func_name, ASRUtils::symbol_type(end_sym), ASR::intentType::ReturnVar);
         // populate body
-        Vec<ASR::stmt_t*> body; body.reserve(al, 1);
-        body.push_back(al, b.Assignment( return_var_expr, b.Var(end_sym) ));
-
-        ASR::symbol_t* func_sym = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Function_t_util(al, loc,
-                                current_scope, s2c(al, func_name), nullptr, 0, nullptr, 0, body.p, body.n,
-                                return_var_expr, ASR::abiType::Source,
-                                ASR::accessType::Public, ASR::deftypeType::Implementation,
-                                nullptr, false, true, false, false, false, nullptr, 0, false, false, false, nullptr));
+        Vec<ASR::stmt_t*> body;
+        body.reserve(al, 1);
+        body.push_back(al, b.Assignment(return_var_expr, b.Var(end_sym)));
+
+        ASR::symbol_t* func_sym = ASR::down_cast<ASR::symbol_t>(
+            ASRUtils::make_Function_t_util(al,
+                                           loc,
+                                           current_scope,
+                                           s2c(al, func_name),
+                                           nullptr,
+                                           0,
+                                           nullptr,
+                                           0,
+                                           body.p,
+                                           body.n,
+                                           return_var_expr,
+                                           ASR::abiType::Source,
+                                           ASR::accessType::Public,
+                                           ASR::deftypeType::Implementation,
+                                           nullptr,
+                                           false,
+                                           true,
+                                           false,
+                                           false,
+                                           false,
+                                           nullptr,
+                                           0,
+                                           false,
+                                           false,
+                                           false,
+                                           nullptr));
         current_scope = current_scope_copy;
-        parent_scope->add_symbol(func_name,func_sym);
+        parent_scope->add_symbol(func_name, func_sym);
 
         return func_name;
     }
 
-    ASR::expr_t* get_transformed_function_call(ASR::symbol_t* end_sym) {
+    ASR::expr_t* get_transformed_function_call(ASR::symbol_t* end_sym)
+    {
         /*
             module y
                 contains
@@ -1874,15 +2218,27 @@ public:
         */
         SymbolTable* parent_scope = current_scope->parent;
         std::string func_name = create_getter_function(end_sym->base.loc, end_sym);
-        ASR::symbol_t* getter_func_sym = parent_scope->resolve_symbol(LCompilers::s2c(al,func_name));
-        current_function_dependencies.push_back(al,s2c(al, func_name));
-
-        ASR::expr_t* func_call = ASRUtils::EXPR(ASRUtils::make_FunctionCall_t_util(al, getter_func_sym->base.loc,
-                                getter_func_sym, getter_func_sym, nullptr, 0, ASRUtils::symbol_type(end_sym), nullptr, nullptr, current_scope, current_function_dependencies));
+        ASR::symbol_t* getter_func_sym
+            = parent_scope->resolve_symbol(LCompilers::s2c(al, func_name));
+        current_function_dependencies.push_back(al, s2c(al, func_name));
+
+        ASR::expr_t* func_call
+            = ASRUtils::EXPR(ASRUtils::make_FunctionCall_t_util(al,
+                                                                getter_func_sym->base.loc,
+                                                                getter_func_sym,
+                                                                getter_func_sym,
+                                                                nullptr,
+                                                                0,
+                                                                ASRUtils::symbol_type(end_sym),
+                                                                nullptr,
+                                                                nullptr,
+                                                                current_scope,
+                                                                current_function_dependencies));
         return func_call;
     }
 
-    ASR::expr_t* convert_integer_binop_to_function_call(ASR::expr_t* end, bool is_argument) {
+    ASR::expr_t* convert_integer_binop_to_function_call(ASR::expr_t* end, bool is_argument)
+    {
         ASR::IntegerBinOp_t* end_bin_op = ASR::down_cast<ASR::IntegerBinOp_t>(end);
         ASR::expr_t* left = end_bin_op->m_left;
         ASR::expr_t* right = end_bin_op->m_right;
@@ -1896,8 +2252,9 @@ public:
             ASR::Var_t* end_var = ASR::down_cast<ASR::Var_t>(left);
             ASR::symbol_t* end_sym = end_var->m_v;
             SymbolTable* symbol_scope = ASRUtils::symbol_parent_symtab(end_sym);
-            if ((ASRUtils::expr_value(end) == nullptr) && (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym) ||
-                (symbol_scope->counter != current_scope->counter && is_argument)) ) {
+            if ((ASRUtils::expr_value(end) == nullptr)
+                && (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym)
+                    || (symbol_scope->counter != current_scope->counter && is_argument))) {
                 left = get_transformed_function_call(end_sym);
             }
             if (ASR::is_a<ASR::IntegerBinOp_t>(*right)) {
@@ -1913,8 +2270,9 @@ public:
             ASR::Var_t* end_var = ASR::down_cast<ASR::Var_t>(right);
             ASR::symbol_t* end_sym = end_var->m_v;
             SymbolTable* symbol_scope = ASRUtils::symbol_parent_symtab(end_sym);
-            if ((ASRUtils::expr_value(end) == nullptr) && (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym) ||
-                (symbol_scope->counter != current_scope->counter && is_argument)) ) {
+            if ((ASRUtils::expr_value(end) == nullptr)
+                && (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym)
+                    || (symbol_scope->counter != current_scope->counter && is_argument))) {
                 right = get_transformed_function_call(end_sym);
             }
             if (ASR::is_a<ASR::IntegerBinOp_t>(*left)) {
@@ -1927,12 +2285,14 @@ public:
             ASR::symbol_t* second_end_sym = ASR::down_cast<ASR::Var_t>(right)->m_v;
             SymbolTable* first_symbol_scope = ASRUtils::symbol_parent_symtab(first_end_sym);
             SymbolTable* second_symbol_scope = ASRUtils::symbol_parent_symtab(second_end_sym);
-            if ((ASRUtils::expr_value(end) == nullptr) && (ASR::is_a<ASR::ExternalSymbol_t>(*first_end_sym) ||
-                (first_symbol_scope->counter != current_scope->counter && is_argument)) ) {
+            if ((ASRUtils::expr_value(end) == nullptr)
+                && (ASR::is_a<ASR::ExternalSymbol_t>(*first_end_sym)
+                    || (first_symbol_scope->counter != current_scope->counter && is_argument))) {
                 left = get_transformed_function_call(first_end_sym);
             }
-            if ((ASRUtils::expr_value(end) == nullptr) && (ASR::is_a<ASR::ExternalSymbol_t>(*second_end_sym) ||
-                (second_symbol_scope->counter != current_scope->counter && is_argument)) ) {
+            if ((ASRUtils::expr_value(end) == nullptr)
+                && (ASR::is_a<ASR::ExternalSymbol_t>(*second_end_sym)
+                    || (second_symbol_scope->counter != current_scope->counter && is_argument))) {
                 right = get_transformed_function_call(second_end_sym);
             }
         } else {
@@ -1949,11 +2309,17 @@ public:
                 right = convert_integer_binop_to_function_call(right, is_argument);
             }
         }
-        return ASRUtils::EXPR(ASR::make_IntegerBinOp_t(al, end->base.loc,
-            left, end_bin_op->m_op, right, end_bin_op->m_type, end_bin_op->m_value));
+        return ASRUtils::EXPR(ASR::make_IntegerBinOp_t(al,
+                                                       end->base.loc,
+                                                       left,
+                                                       end_bin_op->m_op,
+                                                       right,
+                                                       end_bin_op->m_type,
+                                                       end_bin_op->m_value));
     }
 
-    void dimension_attribute_error_check(ASR::expr_t* dim_expr) {
+    void dimension_attribute_error_check(ASR::expr_t* dim_expr)
+    {
         bool error = false;
         if (ASR::is_a<ASR::Var_t>(*dim_expr)) {
             ASR::Var_t* dim_expr_var = ASR::down_cast<ASR::Var_t>(dim_expr);
@@ -1965,186 +2331,223 @@ public:
                 if (dim_expr_variable->m_type->type != ASR::ttypeType::Integer) {
                     error = true;
                 } else {
-
-                    if ((dim_expr_variable->m_storage != ASR::storage_typeType::Parameter) && !(in_Subroutine) && (symbol_scope->counter == current_scope->counter)) {
+                    if ((dim_expr_variable->m_storage != ASR::storage_typeType::Parameter)
+                        && !(in_Subroutine) && (symbol_scope->counter == current_scope->counter)) {
                         error = true;
                     }
                 }
             }
-        } else if (ASR::is_a<ASR::ArraySize_t>(*dim_expr)){
+        } else if (ASR::is_a<ASR::ArraySize_t>(*dim_expr)) {
             ASR::ArraySize_t* dim_expr_arrsize = ASR::down_cast<ASR::ArraySize_t>(dim_expr);
-            if  (ASR::is_a<ASR::Var_t>(*dim_expr_arrsize->m_v)){
+            if (ASR::is_a<ASR::Var_t>(*dim_expr_arrsize->m_v)) {
                 ASR::Var_t* arr_var = ASR::down_cast<ASR::Var_t>(dim_expr_arrsize->m_v);
                 ASR::symbol_t* arr_sym = arr_var->m_v;
                 ASR::Variable_t* arr_variable = ASR::down_cast<ASR::Variable_t>(arr_sym);
                 SymbolTable* symbol_scope = ASRUtils::symbol_parent_symtab(arr_sym);
-                if ((arr_variable->m_type->type == ASR::ttypeType::Allocatable) && !(in_Subroutine) && (symbol_scope->counter == current_scope->counter)) {
+                if ((arr_variable->m_type->type == ASR::ttypeType::Allocatable) && !(in_Subroutine)
+                    && (symbol_scope->counter == current_scope->counter)) {
                     error = true;
                 }
             }
-        }  else {
+        } else {
             ASR::ttype_t* dim_expr_type = ASRUtils::expr_type(dim_expr);
             if (dim_expr_type->type != ASR::ttypeType::Integer) {
                 error = true;
             }
         }
 
-        if(error){
-            diag.add(Diagnostic(
-                "Expecting a scalar integer or parameter annotated integer variable ",
-                Level::Error, Stage::Semantic, {
-                    Label("",{dim_expr->base.loc})
-                }));
+        if (error) {
+            diag.add(
+                Diagnostic("Expecting a scalar integer or parameter annotated integer variable ",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { dim_expr->base.loc }) }));
             throw SemanticAbort();
         }
     }
 
 
-    void dimension_variable(AST::var_sym_t const & s, const Location& loc) {
-	std::string sym = to_lower(s.m_name);
-	bool is_proc_arg = (std::find(current_procedure_args.begin(),
-	    current_procedure_args.end(), sym) != current_procedure_args.end());
-	ASR::symbol_t *get_sym = current_scope->get_symbol(sym);
-	// get actual variable from SymTab, not the current line
-	if (get_sym == nullptr) {
-	    if (compiler_options.implicit_typing) {
-		ASR::intentType intent;
-		if (is_proc_arg) {
-		    intent = ASRUtils::intent_unspecified;
-		} else {
-		    intent = ASRUtils::intent_local;
-		}
-		get_sym = declare_implicit_variable2(s.loc, sym, intent, implicit_dictionary[std::string(1,sym[0])]);
-	    } else {
-		if (symbols_having_only_attributes_without_type.find(sym) == symbols_having_only_attributes_without_type.end()) {
-	            ASR::intentType intent;
-	            ASR::abiType abi;
-	            if (is_proc_arg) {
-	                intent = ASRUtils::intent_unspecified;
-	                abi = current_procedure_abi_type;
-	            } else {
-	                intent = ASRUtils::intent_local;
-	                abi = ASR::abiType::Source;
-	            }
-	            get_sym = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al, loc, current_scope,
-	                                                    s.m_name, nullptr, 0, intent, nullptr,
-	                                                    nullptr, ASR::storage_typeType::Default, nullptr, nullptr,
-	                                                    abi, ASR::accessType::Public, ASR::presenceType::Required,
-	                                                    false, false, false));
-	        } else {
-	            get_sym = symbols_having_only_attributes_without_type[sym];
-	        }
-	    }
-	}
-
-	if (ASR::is_a<ASR::Variable_t>(*get_sym)) {
-	    bool is_compile_time = false;
-	    Vec<ASR::dimension_t> dims;
-	    dims.reserve(al, 0);
-	    ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(get_sym);
-	    bool is_char_type = false;
-            if ( v->m_type ) {
+    void dimension_variable(AST::var_sym_t const& s, const Location& loc)
+    {
+        std::string sym = to_lower(s.m_name);
+        bool is_proc_arg
+            = (std::find(current_procedure_args.begin(), current_procedure_args.end(), sym)
+               != current_procedure_args.end());
+        ASR::symbol_t* get_sym = current_scope->get_symbol(sym);
+        // get actual variable from SymTab, not the current line
+        if (get_sym == nullptr) {
+            if (compiler_options.implicit_typing) {
+                ASR::intentType intent;
+                if (is_proc_arg) {
+                    intent = ASRUtils::intent_unspecified;
+                } else {
+                    intent = ASRUtils::intent_local;
+                }
+                get_sym = declare_implicit_variable2(
+                    s.loc, sym, intent, implicit_dictionary[std::string(1, sym[0])]);
+            } else {
+                if (symbols_having_only_attributes_without_type.find(sym)
+                    == symbols_having_only_attributes_without_type.end()) {
+                    ASR::intentType intent;
+                    ASR::abiType abi;
+                    if (is_proc_arg) {
+                        intent = ASRUtils::intent_unspecified;
+                        abi = current_procedure_abi_type;
+                    } else {
+                        intent = ASRUtils::intent_local;
+                        abi = ASR::abiType::Source;
+                    }
+                    get_sym = ASR::down_cast<ASR::symbol_t>(
+                        ASRUtils::make_Variable_t_util(al,
+                                                       loc,
+                                                       current_scope,
+                                                       s.m_name,
+                                                       nullptr,
+                                                       0,
+                                                       intent,
+                                                       nullptr,
+                                                       nullptr,
+                                                       ASR::storage_typeType::Default,
+                                                       nullptr,
+                                                       nullptr,
+                                                       abi,
+                                                       ASR::accessType::Public,
+                                                       ASR::presenceType::Required,
+                                                       false,
+                                                       false,
+                                                       false));
+                } else {
+                    get_sym = symbols_having_only_attributes_without_type[sym];
+                }
+            }
+        }
+
+        if (ASR::is_a<ASR::Variable_t>(*get_sym)) {
+            bool is_compile_time = false;
+            Vec<ASR::dimension_t> dims;
+            dims.reserve(al, 0);
+            ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(get_sym);
+            bool is_char_type = false;
+            if (v->m_type) {
                 is_char_type = ASR::is_a<ASR::String_t>(*v->m_type);
             }
-	    process_dims(al, dims, s.m_dim, s.n_dim, is_compile_time, is_char_type,
-	                 is_proc_arg, s.m_name);
-
-	    bool is_star_dimension = false;
-
-	    if (s.n_dim > 0) {
-		is_star_dimension = (s.m_dim[s.n_dim-1].m_end_star == AST::dimension_typeType::DimensionStar);
-	    }
-
-	    if (v->m_type && ASRUtils::is_array(v->m_type)) {
-		/* You can't specify an attribute such as DIMENSION more than once in a scoping
-		   unit (so sayth F2023, 8.5.1 C815). There are really four ways to dimension a variable:
-		     1a. In a _type-decl_ DIMENSION attribute;
-		     1b. In a _type-decl_ _entity-decl_ _array-spec_ (overides #1a)
-		     2. In a DIMENSION statement
-		     3. In a COMMON statement
-		   Cases 1a and 1b are handled in the _type-decl_ visitor, but that visitor should
-		   also check for existence of other attribute specifications via attribute statements.
-		   This check handles cases 2 and 3.
-		*/
-                diag.add(diag::Diagnostic(
-                    "Duplicate DIMENSION attribute specified",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {s.loc})}));
+            process_dims(
+                al, dims, s.m_dim, s.n_dim, is_compile_time, is_char_type, is_proc_arg, s.m_name);
+
+            bool is_star_dimension = false;
+
+            if (s.n_dim > 0) {
+                is_star_dimension
+                    = (s.m_dim[s.n_dim - 1].m_end_star == AST::dimension_typeType::DimensionStar);
+            }
+
+            if (v->m_type && ASRUtils::is_array(v->m_type)) {
+                /* You can't specify an attribute such as DIMENSION more than once in a scoping
+                   unit (so sayth F2023, 8.5.1 C815). There are really four ways to dimension a
+                   variable: 1a. In a _type-decl_ DIMENSION attribute; 1b. In a _type-decl_
+                   _entity-decl_ _array-spec_ (overides #1a)
+                     2. In a DIMENSION statement
+                     3. In a COMMON statement
+                   Cases 1a and 1b are handled in the _type-decl_ visitor, but that visitor should
+                   also check for existence of other attribute specifications via attribute
+                   statements. This check handles cases 2 and 3.
+                */
+                diag.add(diag::Diagnostic("Duplicate DIMENSION attribute specified",
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { s.loc }) }));
                 throw SemanticAbort();
-	    }
-
-	    if ( v->m_type ) {
-		ASR::abiType abi = is_proc_arg ? current_procedure_abi_type
-		                               : ASR::abiType::Source;
-	        if (!ASRUtils::ttype_set_dimensions(&(v->m_type), dims.data(),
-	                                            dims.size(), al,
-	                                            abi, is_proc_arg,
-	                                            is_star_dimension)) {
-	            diag.add(Diagnostic(
-			         "Cannot set dimension for variable of non-numerical type",
-			         Level::Error, Stage::Semantic, {
-			             Label("",{loc})
-			         }));
-	            throw SemanticAbort();
-            	}
-            	SetChar variable_dependencies_vec;
-	            	variable_dependencies_vec.reserve(al, 1);
-	            	ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, v->m_type,
-	                                			v->m_symbolic_value, v->m_value);
-	            	v->m_dependencies = variable_dependencies_vec.p;
-	            	v->n_dependencies = variable_dependencies_vec.size();
+            }
+
+            if (v->m_type) {
+                ASR::abiType abi = is_proc_arg ? current_procedure_abi_type : ASR::abiType::Source;
+                if (!ASRUtils::ttype_set_dimensions(&(v->m_type),
+                                                    dims.data(),
+                                                    dims.size(),
+                                                    al,
+                                                    abi,
+                                                    is_proc_arg,
+                                                    is_star_dimension)) {
+                    diag.add(Diagnostic("Cannot set dimension for variable of non-numerical type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
+                    throw SemanticAbort();
+                }
+                SetChar variable_dependencies_vec;
+                variable_dependencies_vec.reserve(al, 1);
+                ASRUtils::collect_variable_dependencies(
+                    al, variable_dependencies_vec, v->m_type, v->m_symbolic_value, v->m_value);
+                v->m_dependencies = variable_dependencies_vec.p;
+                v->n_dependencies = variable_dependencies_vec.size();
             } else {
-		ASR::abiType abi = is_proc_arg ? current_procedure_abi_type
-		                               : ASR::abiType::Source;
-                v->m_type = ASRUtils::make_Array_t_util(al, loc, nullptr,
-                    dims.p, dims.size(), abi, is_proc_arg,
-                    ASR::array_physical_typeType::DescriptorArray, false,
-                    is_star_dimension);
+                ASR::abiType abi = is_proc_arg ? current_procedure_abi_type : ASR::abiType::Source;
+                v->m_type
+                    = ASRUtils::make_Array_t_util(al,
+                                                  loc,
+                                                  nullptr,
+                                                  dims.p,
+                                                  dims.size(),
+                                                  abi,
+                                                  is_proc_arg,
+                                                  ASR::array_physical_typeType::DescriptorArray,
+                                                  false,
+                                                  is_star_dimension);
                 symbols_having_only_attributes_without_type[sym] = get_sym;
             }
-	} else {
-	    diag.add(Diagnostic(
-			 "Cannot attribute non-variable type with dimension",
-			 Level::Error, Stage::Semantic, {
-			     Label("",{loc})
-			 }));
-	    throw SemanticAbort();
-	}
-    }
-
-    bool is_funcCall_to_unresolved_genereicProcedure(AST::expr_t* expr){
-        return AST::is_a<AST::FuncCallOrArray_t>(*expr) &&
-            (generic_procedures.find(
-                AST::down_cast<AST::FuncCallOrArray_t>(expr)->m_func)
-            != generic_procedures.end());
+        } else {
+            diag.add(Diagnostic("Cannot attribute non-variable type with dimension",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
+            throw SemanticAbort();
+        }
     }
 
-    void process_dims(Allocator &al, Vec<ASR::dimension_t> &dims,
-        AST::dimension_t *m_dim, size_t n_dim, bool &is_compile_time,
-        bool is_char_type, bool is_argument, char* var_name) {  
+    bool is_funcCall_to_unresolved_genereicProcedure(AST::expr_t* expr)
+    {
+        return AST::is_a<AST::FuncCallOrArray_t>(*expr)
+               && (generic_procedures.find(AST::down_cast<AST::FuncCallOrArray_t>(expr)->m_func)
+                   != generic_procedures.end());
+    }
+
+    void process_dims(Allocator& al,
+                      Vec<ASR::dimension_t>& dims,
+                      AST::dimension_t* m_dim,
+                      size_t n_dim,
+                      bool& is_compile_time,
+                      bool is_char_type,
+                      bool is_argument,
+                      char* var_name)
+    {
         LCOMPILERS_ASSERT(dims.size() == 0);
         is_compile_time = false;
         _processing_dimensions = true;
-	    dims.reserve(al, n_dim);
-	    for (size_t i=0; i<n_dim; i++) {
-	        if (is_argument &&
-	                m_dim[i].m_end_star == AST::dimension_typeType::DimensionStar
-	                && i != n_dim-1) {
-	            diag.add(diag::Diagnostic(
-	                "Assumed-size '*' is only permitted in the last dimension",
-	                diag::Level::Error, diag::Stage::Semantic, {
-	                    diag::Label("", {m_dim[i].loc})}));
-	            throw SemanticAbort();
-	        }
-	        ASR::dimension_t dim_dummy; dims.push_back(al, dim_dummy);
-	        ASR::dimension_t &dim  = const_cast<ASR::dimension_t&>(dims[dims.size()-1]);
-	        dim.m_length = nullptr; dim.m_start = nullptr;
-	        dim.loc = m_dim[i].loc;
+        dims.reserve(al, n_dim);
+        for (size_t i = 0; i < n_dim; i++) {
+            if (is_argument && m_dim[i].m_end_star == AST::dimension_typeType::DimensionStar
+                && i != n_dim - 1) {
+                diag.add(
+                    diag::Diagnostic("Assumed-size '*' is only permitted in the last dimension",
+                                     diag::Level::Error,
+                                     diag::Stage::Semantic,
+                                     { diag::Label("", { m_dim[i].loc }) }));
+                throw SemanticAbort();
+            }
+            ASR::dimension_t dim_dummy;
+            dims.push_back(al, dim_dummy);
+            ASR::dimension_t& dim = const_cast<ASR::dimension_t&>(dims[dims.size() - 1]);
+            dim.m_length = nullptr;
+            dim.m_start = nullptr;
+            dim.loc = m_dim[i].loc;
             if (m_dim[i].m_start) {
-                if(is_funcCall_to_unresolved_genereicProcedure(m_dim[i].m_start)){
-                    postponed_genericProcedure_calls_vec.emplace_back(&dim.m_start,
-                        current_scope, m_dim[i].m_start, var_name, 
-                        [this](ASR::expr_t* start){dimension_attribute_error_check(start);});
+                if (is_funcCall_to_unresolved_genereicProcedure(m_dim[i].m_start)) {
+                    postponed_genericProcedure_calls_vec.emplace_back(
+                        &dim.m_start,
+                        current_scope,
+                        m_dim[i].m_start,
+                        var_name,
+                        [this](ASR::expr_t* start) { dimension_attribute_error_check(start); });
                     dim.m_start = nullptr;
                 } else {
                     this->visit_expr(*m_dim[i].m_start);
@@ -2156,10 +2559,13 @@ public:
             }
             if (m_dim[i].m_end) {
                 ASR::expr_t* end{};
-                if(is_funcCall_to_unresolved_genereicProcedure(m_dim[i].m_end)){ // Delay
-                    postponed_genericProcedure_calls_vec.emplace_back(&dim.m_length,
-                        current_scope, m_dim[i].m_end, var_name, 
-                        [this](ASR::expr_t* start){dimension_attribute_error_check(start);});
+                if (is_funcCall_to_unresolved_genereicProcedure(m_dim[i].m_end)) {  // Delay
+                    postponed_genericProcedure_calls_vec.emplace_back(
+                        &dim.m_length,
+                        current_scope,
+                        m_dim[i].m_end,
+                        var_name,
+                        [this](ASR::expr_t* start) { dimension_attribute_error_check(start); });
                     dim.m_length = nullptr;
                 } else {
                     this->visit_expr(*m_dim[i].m_end);
@@ -2169,22 +2575,21 @@ public:
                         ASR::Var_t* end_var = ASR::down_cast<ASR::Var_t>(end);
                         ASR::symbol_t* end_sym = end_var->m_v;
                         SymbolTable* symbol_scope = ASRUtils::symbol_parent_symtab(end_sym);
-                        if ((is_argument || ASRUtils::expr_value(end) == nullptr) &&
-                            (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym) ||
-                            (symbol_scope->counter != current_scope->counter && is_argument &&
-                            ASRUtils::expr_value(end) == nullptr)) ) {
-                                end = get_transformed_function_call(end_sym);
+                        if ((is_argument || ASRUtils::expr_value(end) == nullptr)
+                            && (ASR::is_a<ASR::ExternalSymbol_t>(*end_sym)
+                                || (symbol_scope->counter != current_scope->counter && is_argument
+                                    && ASRUtils::expr_value(end) == nullptr))) {
+                            end = get_transformed_function_call(end_sym);
                         }
-                    } else if(ASR::is_a<ASR::IntegerBinOp_t>(*end)) {
+                    } else if (ASR::is_a<ASR::IntegerBinOp_t>(*end)) {
                         end = convert_integer_binop_to_function_call(end, is_argument);
                     }
-                    dim.m_length = ASRUtils::compute_length_from_start_end(al, dim.m_start,
-                                        end);
+                    dim.m_length = ASRUtils::compute_length_from_start_end(al, dim.m_start, end);
                 }
             } else {
                 dim.m_length = nullptr;
             }
-            if ( !dim.m_start && !dim.m_length ) {
+            if (!dim.m_start && !dim.m_length) {
                 is_compile_time = true;
             }
             if (m_dim[i].m_end_star && is_char_type) {
@@ -2194,9 +2599,10 @@ public:
         _processing_dimensions = false;
     }
 
-    ASR::accessType get_asr_simple_attr(AST::simple_attributeType simple_attr) {
+    ASR::accessType get_asr_simple_attr(AST::simple_attributeType simple_attr)
+    {
         ASR::accessType access_type = ASR::accessType::Public;
-        switch( simple_attr ) {
+        switch (simple_attr) {
             case AST::simple_attributeType::AttrPublic: {
                 access_type = ASR::accessType::Public;
                 break;
@@ -2211,59 +2617,94 @@ public:
         return access_type;
     }
 
-    void visit_Format(const AST::Format_t &x) {
+    void visit_Format(const AST::Format_t& x)
+    {
         format_statements[x.m_label] = x.m_fmt;
         tmp = nullptr;
     }
 
-    void visit_Include(const AST::Include_t &x) {
+    void visit_Include(const AST::Include_t& x)
+    {
         diag.semantic_error_label(
             "Include statement is not implemented at the AST level yet. You have to run LFortran with prescanning which can handle include statements.",
-            {x.base.base.loc},
-            "Enable prescanner to handle this"
-        );
+            { x.base.base.loc },
+            "Enable prescanner to handle this");
         tmp = nullptr;
     }
 
-    ASR::asr_t* create_StructInstanceMember(ASR::expr_t* target, ASR::Variable_t* target_var) {
+    ASR::asr_t* create_StructInstanceMember(ASR::expr_t* target, ASR::Variable_t* target_var)
+    {
         uint64_t hash = get_hash((ASR::asr_t*) target_var);
         std::string target_var_name = target_var->m_name;
         SymbolTable* scope = target_var->m_parent_symtab;
         if (common_variables_hash.find(hash) != common_variables_hash.end()) {
             ASR::symbol_t* curr_struct = common_variables_hash[hash];
-            ASR::Struct_t *struct_type = ASR::down_cast<ASR::Struct_t>(curr_struct);
+            ASR::Struct_t* struct_type = ASR::down_cast<ASR::Struct_t>(curr_struct);
             std::string ext_sym_name = std::string(struct_type->m_name);
             std::string module_name = "file_common_block_" + std::string(struct_type->m_name);
             ASR::symbol_t* ext_sym_struct = scope->resolve_symbol(ext_sym_name);
             if (!ext_sym_struct) {
-                ext_sym_struct = ASR::down_cast<ASR::symbol_t>(ASR::make_ExternalSymbol_t(al, curr_struct->base.loc, scope,
-                                                struct_type->m_name, curr_struct, s2c(al, module_name), nullptr, 0, struct_type->m_name, ASR::accessType::Public));
+                ext_sym_struct = ASR::down_cast<ASR::symbol_t>(
+                    ASR::make_ExternalSymbol_t(al,
+                                               curr_struct->base.loc,
+                                               scope,
+                                               struct_type->m_name,
+                                               curr_struct,
+                                               s2c(al, module_name),
+                                               nullptr,
+                                               0,
+                                               struct_type->m_name,
+                                               ASR::accessType::Public));
                 scope->add_symbol(ext_sym_name, ext_sym_struct);
             }
 
-            SymbolTable* module_scope = ASR::down_cast<ASR::Struct_t>(curr_struct)->m_symtab->parent;
-            std::string struct_var_name = "struct_instance_"+std::string(struct_type->m_name);
+            SymbolTable* module_scope
+                = ASR::down_cast<ASR::Struct_t>(curr_struct)->m_symtab->parent;
+            std::string struct_var_name = "struct_instance_" + std::string(struct_type->m_name);
             ASR::symbol_t* module_var_sym = module_scope->resolve_symbol(struct_var_name);
             ASR::symbol_t* struct_sym = scope->resolve_symbol(struct_var_name);
             if (!struct_sym) {
-                struct_sym = ASR::down_cast<ASR::symbol_t>(ASR::make_ExternalSymbol_t(al, curr_struct->base.loc, scope,
-                                                s2c(al, struct_var_name), module_var_sym, s2c(al, module_name), nullptr, 0, s2c(al, struct_var_name), ASR::accessType::Public));
+                struct_sym = ASR::down_cast<ASR::symbol_t>(
+                    ASR::make_ExternalSymbol_t(al,
+                                               curr_struct->base.loc,
+                                               scope,
+                                               s2c(al, struct_var_name),
+                                               module_var_sym,
+                                               s2c(al, module_name),
+                                               nullptr,
+                                               0,
+                                               s2c(al, struct_var_name),
+                                               ASR::accessType::Public));
                 scope->add_symbol(struct_var_name, struct_sym);
             }
 
             ASR::asr_t* struct_var_ = ASR::make_Var_t(al, target_var->base.base.loc, struct_sym);
 
-            std::string member_name = "1_"+std::string(struct_type->m_name)+"_"+target_var_name;
+            std::string member_name
+                = "1_" + std::string(struct_type->m_name) + "_" + target_var_name;
             ASR::symbol_t* member_sym = scope->resolve_symbol(member_name);
             if (!member_sym) {
-
-                member_sym = ASR::down_cast<ASR::symbol_t>(make_ExternalSymbol_t(al, target_var->base.base.loc, scope, s2c(al, member_name),
-                                                        struct_type->m_symtab->resolve_symbol(target_var_name), s2c(al, ext_sym_name), nullptr, 0, s2c(al, target_var_name), ASR::accessType::Public));
+                member_sym = ASR::down_cast<ASR::symbol_t>(
+                    make_ExternalSymbol_t(al,
+                                          target_var->base.base.loc,
+                                          scope,
+                                          s2c(al, member_name),
+                                          struct_type->m_symtab->resolve_symbol(target_var_name),
+                                          s2c(al, ext_sym_name),
+                                          nullptr,
+                                          0,
+                                          s2c(al, target_var_name),
+                                          ASR::accessType::Public));
                 scope->add_symbol(member_name, member_sym);
             }
 
-            ASR::asr_t* new_target = ASR::make_StructInstanceMember_t(al, target->base.loc, ASRUtils::EXPR(struct_var_),
-                member_sym, ASRUtils::symbol_type(struct_type->m_symtab->resolve_symbol(target_var_name)), nullptr);
+            ASR::asr_t* new_target = ASR::make_StructInstanceMember_t(
+                al,
+                target->base.loc,
+                ASRUtils::EXPR(struct_var_),
+                member_sym,
+                ASRUtils::symbol_type(struct_type->m_symtab->resolve_symbol(target_var_name)),
+                nullptr);
 
             return new_target;
         } else {
@@ -2271,7 +2712,8 @@ public:
         }
     }
 
-    ASR::expr_t* replace_with_common_block_variables(ASR::expr_t* target) {
+    ASR::expr_t* replace_with_common_block_variables(ASR::expr_t* target)
+    {
         if (!target) {
             return target;
         }
@@ -2290,10 +2732,13 @@ public:
             if (ASR::is_a<ASR::Var_t>(*target_array)) {
                 ASR::symbol_t* target_array_var_sym = ASR::down_cast<ASR::Var_t>(target_array)->m_v;
                 if (ASR::is_a<ASR::Variable_t>(*(target_array_var_sym))) {
-                    ASR::Variable_t* target_array_var = ASR::down_cast<ASR::Variable_t>(target_array_var_sym);
-                    ASR::asr_t* new_target_array = create_StructInstanceMember(target_array, target_array_var);
+                    ASR::Variable_t* target_array_var
+                        = ASR::down_cast<ASR::Variable_t>(target_array_var_sym);
+                    ASR::asr_t* new_target_array
+                        = create_StructInstanceMember(target_array, target_array_var);
                     if (new_target_array) {
-                        ASR::down_cast<ASR::ArrayItem_t>(target)->m_v = ASRUtils::EXPR(new_target_array);
+                        ASR::down_cast<ASR::ArrayItem_t>(target)->m_v
+                            = ASRUtils::EXPR(new_target_array);
                         return target;
                     }
                 }
@@ -2302,12 +2747,13 @@ public:
         return target;
     }
 
-    bool check_equal_value(AST::expr_t** values, size_t n_values) {
+    bool check_equal_value(AST::expr_t** values, size_t n_values)
+    {
         this->visit_expr(*values[0]);
         ASR::expr_t* value = ASRUtils::EXPR(tmp);
         ASR::expr_t* expression_value = ASRUtils::expr_value(value);
 
-        for (size_t i=1; i<n_values; i++) {
+        for (size_t i = 1; i < n_values; i++) {
             this->visit_expr(*values[i]);
             ASR::expr_t* value_ = ASRUtils::EXPR(tmp);
             ASR::expr_t* expression_value_ = ASRUtils::expr_value(value_);
@@ -2319,13 +2765,18 @@ public:
         return true;
     }
 
-    void handle_array_data_stmt(const AST::DataStmt_t &x, AST::DataStmtSet_t* a, ASR::ttype_t* obj_type, ASR::expr_t* object, size_t &curr_value) {
-        ASR::ttype_t* array_ttype = ASRUtils::type_get_past_allocatable(
-            ASRUtils::type_get_past_pointer(obj_type));
+    void handle_array_data_stmt(const AST::DataStmt_t& x,
+                                AST::DataStmtSet_t* a,
+                                ASR::ttype_t* obj_type,
+                                ASR::expr_t* object,
+                                size_t& curr_value)
+    {
+        ASR::ttype_t* array_ttype
+            = ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(obj_type));
         ASR::Array_t* array_type = ASR::down_cast<ASR::Array_t>(array_ttype);
         ASR::ttype_t* temp_current_variable_type_ = current_variable_type_;
         bool is_real = 0;
-        if (ASR::is_a<ASR::Real_t>(*array_type->m_type)){
+        if (ASR::is_a<ASR::Real_t>(*array_type->m_type)) {
             is_real = 1;
         }
         if (check_equal_value(a->m_value, a->n_value)) {
@@ -2345,34 +2796,39 @@ public:
             */
             // Get the Type of Object
             // If object is Real, set current_variable_type to Real
-            // This type flag is passed to Visit_BOZ, 
+            // This type flag is passed to Visit_BOZ,
             // so that Real Values are correctly decoded from BOZ String
-            if ((is_real) &&(AST::is_a<AST::BOZ_t>(*a->m_value[curr_value]))) {
+            if ((is_real) && (AST::is_a<AST::BOZ_t>(*a->m_value[curr_value]))) {
                 current_variable_type_ = array_type->m_type;
             }
             this->visit_expr(*a->m_value[curr_value++]);
             ASR::expr_t* value = ASRUtils::EXPR(tmp);
             current_variable_type_ = temp_current_variable_type_;
-            if (!ASRUtils::types_equal(ASRUtils::expr_type(value), array_type->m_type, value, object)) {
-                diag.add(Diagnostic(
-                    "Type mismatch during data initialization",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+            if (!ASRUtils::types_equal(
+                    ASRUtils::expr_type(value), array_type->m_type, value, object)) {
+                diag.add(Diagnostic("Type mismatch during data initialization",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             ASR::expr_t* expression_value = ASRUtils::expr_value(value);
             if (expression_value) {
                 ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, object, expression_value);
-                ASR::stmt_t* assignment_stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, x.base.base.loc,
-                                            object, expression_value, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+                ASR::stmt_t* assignment_stmt = ASRUtils::STMT(
+                    ASRUtils::make_Assignment_t_util(al,
+                                                     x.base.base.loc,
+                                                     object,
+                                                     expression_value,
+                                                     nullptr,
+                                                     compiler_options.po.realloc_lhs_arrays,
+                                                     false));
                 current_body->push_back(al, assignment_stmt);
             } else {
-                diag.add(Diagnostic(
-                    "The value in data must be a constant",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("The value in data must be a constant",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         } else {
@@ -2380,10 +2836,12 @@ public:
             body.reserve(al, a->n_value);
             int size_of_array = 0;
             if (ASR::is_a<ASR::ArraySection_t>(*object)) {
-                size_of_array = ASRUtils::get_fixed_size_of_ArraySection(ASR::down_cast<ASR::ArraySection_t>(object));
+                size_of_array = ASRUtils::get_fixed_size_of_ArraySection(
+                    ASR::down_cast<ASR::ArraySection_t>(object));
                 object = ASR::down_cast<ASR::ArraySection_t>(object)->m_v;
             } else {
-                size_of_array = ASRUtils::get_fixed_size_of_array(array_type->m_dims, array_type->n_dims);
+                size_of_array
+                    = ASRUtils::get_fixed_size_of_array(array_type->m_dims, array_type->n_dims);
             }
             if (size_of_array == -1) {
                 // For equivalenced arrays, the dimensions may not be available
@@ -2392,63 +2850,69 @@ public:
             }
             int tmp_curr_value = (int) curr_value;
             curr_value += size_of_array;
-            for (int j= tmp_curr_value; j < (int) curr_value; j++) {
+            for (int j = tmp_curr_value; j < (int) curr_value; j++) {
                 // Get the Type of Object
                 // If object is Real, set current_variable_type to Real
-                // This type flag is passed to Visit_BOZ, 
+                // This type flag is passed to Visit_BOZ,
                 // so that Real Values are correctly decoded from BOZ String
                 // Else, set to default type, to cover Complex Values Cases
-                if ((is_real) && (j<((int) a->n_value)) &&
-                    (AST::is_a<AST::BOZ_t>(*a->m_value[j]))){
+                if ((is_real) && (j < ((int) a->n_value))
+                    && (AST::is_a<AST::BOZ_t>(*a->m_value[j]))) {
                     current_variable_type_ = array_type->m_type;
-                }
-                else{
+                } else {
                     current_variable_type_ = temp_current_variable_type_;
                 }
                 this->visit_expr(*a->m_value[j]);
                 ASR::expr_t* value = ASRUtils::EXPR(tmp);
-                if (!ASRUtils::types_equal(ASRUtils::expr_type(value), array_type->m_type, value, object)) {
-                    diag.add(Diagnostic(
-                        "Type mismatch during data initialization",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                if (!ASRUtils::types_equal(
+                        ASRUtils::expr_type(value), array_type->m_type, value, object)) {
+                    diag.add(Diagnostic("Type mismatch during data initialization",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
                 ASR::expr_t* expression_value = ASRUtils::expr_value(value);
                 if (expression_value) {
                     body.push_back(al, expression_value);
                 } else {
-                    diag.add(Diagnostic(
-                        "The value in data must be a constant",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("The value in data must be a constant",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-
             }
             current_variable_type_ = temp_current_variable_type_;
             Vec<ASR::dimension_t> dims;
             dims.reserve(al, 1);
-            ASR::dimension_t dim; dim.m_length = nullptr; dim.m_start = nullptr;
+            ASR::dimension_t dim;
+            dim.m_length = nullptr;
+            dim.m_start = nullptr;
             dim.loc = x.base.base.loc;
-            ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-            ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
-            ASR::expr_t* x_n_args = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc,
-                                a->n_value, int_type));
+            ASR::ttype_t* int_type = ASRUtils::TYPE(
+                ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+            ASR::expr_t* one
+                = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
+            ASR::expr_t* x_n_args = ASRUtils::EXPR(
+                ASR::make_IntegerConstant_t(al, x.base.base.loc, a->n_value, int_type));
             dim.m_start = one;
             dim.m_length = x_n_args;
             dims.push_back(al, dim);
             obj_type = ASRUtils::duplicate_type(al, obj_type, &dims);
-            tmp = ASRUtils::make_ArrayConstructor_t_util(al, x.base.base.loc, body.p,
-                body.size(), obj_type, ASR::arraystorageType::ColMajor);
+            tmp = ASRUtils::make_ArrayConstructor_t_util(al,
+                                                         x.base.base.loc,
+                                                         body.p,
+                                                         body.size(),
+                                                         obj_type,
+                                                         ASR::arraystorageType::ColMajor);
             ASR::Variable_t* v2 = nullptr;
             if (ASR::is_a<ASR::StructInstanceMember_t>(*object)) {
-                ASR::StructInstanceMember_t *mem = ASR::down_cast<ASR::StructInstanceMember_t>(object);
+                ASR::StructInstanceMember_t* mem
+                    = ASR::down_cast<ASR::StructInstanceMember_t>(object);
                 v2 = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(mem->m_m));
             } else {
-                ASR::Var_t *v = ASR::down_cast<ASR::Var_t>(object);
+                ASR::Var_t* v = ASR::down_cast<ASR::Var_t>(object);
                 v2 = ASR::down_cast<ASR::Variable_t>(v->m_v);
             }
             // For pointer types (e.g. equivalenced arrays), don't set m_value
@@ -2456,8 +2920,14 @@ public:
             if (ASR::is_a<ASR::Pointer_t>(*v2->m_type)) {
                 ASR::expr_t* arr_const = ASRUtils::EXPR(tmp);
                 ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, object, arr_const);
-                ASR::stmt_t* assign_stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al,
-                            object->base.loc, object, arr_const, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+                ASR::stmt_t* assign_stmt = ASRUtils::STMT(
+                    ASRUtils::make_Assignment_t_util(al,
+                                                     object->base.loc,
+                                                     object,
+                                                     arr_const,
+                                                     nullptr,
+                                                     compiler_options.po.realloc_lhs_arrays,
+                                                     false));
                 LCOMPILERS_ASSERT(current_body != nullptr)
                 current_body->push_back(al, assign_stmt);
             } else {
@@ -2465,19 +2935,21 @@ public:
                 v2->m_symbolic_value = ASRUtils::EXPR(tmp);
                 SetChar var_deps_vec;
                 var_deps_vec.reserve(al, 1);
-                ASRUtils::collect_variable_dependencies(al, var_deps_vec, v2->m_type,
-                    v2->m_symbolic_value, v2->m_value);
+                ASRUtils::collect_variable_dependencies(
+                    al, var_deps_vec, v2->m_type, v2->m_symbolic_value, v2->m_value);
                 v2->m_dependencies = var_deps_vec.p;
                 v2->n_dependencies = var_deps_vec.size();
             }
         }
     }
 
-    void handle_implied_do_loop_data_stmt(const AST::DataStmt_t &data_stmt,
-                                          AST::DataStmtSet_t *data_stmt_set,
+    void handle_implied_do_loop_data_stmt(const AST::DataStmt_t& data_stmt,
+                                          AST::DataStmtSet_t* data_stmt_set,
                                           ASR::expr_t* implied_do_loop_expr,
-                                          size_t &value_index) {
-        ASR::ImpliedDoLoop_t *implied_do_loop = ASR::down_cast<ASR::ImpliedDoLoop_t>(implied_do_loop_expr);
+                                          size_t& value_index)
+    {
+        ASR::ImpliedDoLoop_t* implied_do_loop
+            = ASR::down_cast<ASR::ImpliedDoLoop_t>(implied_do_loop_expr);
 
         ASR::expr_t* loop_start_expr = implied_do_loop->m_start;
         ASR::expr_t* loop_end_expr = implied_do_loop->m_end;
@@ -2485,37 +2957,34 @@ public:
         ASR::expr_t* start_expr_value = ASRUtils::expr_value(loop_start_expr);
         ASR::expr_t* end_expr_value = ASRUtils::expr_value(loop_end_expr);
         if (!start_expr_value) {
-            diag.add(Diagnostic(
-                "The start variable of the data implied do loop must be constants",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loop_start_expr->base.loc})
-                }));
+            diag.add(Diagnostic("The start variable of the data implied do loop must be constants",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loop_start_expr->base.loc }) }));
             throw SemanticAbort();
         }
         if (!end_expr_value) {
-            diag.add(Diagnostic(
-                "The end variable of the data implied do loop must be constants",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loop_end_expr->base.loc})
-                }));
+            diag.add(Diagnostic("The end variable of the data implied do loop must be constants",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loop_end_expr->base.loc }) }));
             throw SemanticAbort();
         }
 
-        ASR::ttype_t *integer_type = ASRUtils::TYPE(
-                                        ASR::make_Integer_t(al, data_stmt.base.base.loc,
-                                        compiler_options.po.default_integer_kind)
-                                    );
+        ASR::ttype_t* integer_type = ASRUtils::TYPE(ASR::make_Integer_t(
+            al, data_stmt.base.base.loc, compiler_options.po.default_integer_kind));
 
         if (!loop_increment_expr) {
-            loop_increment_expr = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, data_stmt.base.base.loc, 1, integer_type));
+            loop_increment_expr = ASRUtils::EXPR(
+                ASR::make_IntegerConstant_t(al, data_stmt.base.base.loc, 1, integer_type));
         }
         ASR::expr_t* increment_expr_value = ASRUtils::expr_value(loop_increment_expr);
         if (!increment_expr_value) {
-            diag.add(Diagnostic(
-                "The increment variable of the data implied do loop must be a constant",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loop_increment_expr->base.loc})
-                }));
+            diag.add(
+                Diagnostic("The increment variable of the data implied do loop must be a constant",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { loop_increment_expr->base.loc }) }));
             throw SemanticAbort();
         }
 
@@ -2525,52 +2994,61 @@ public:
 
         ASRUtils::ExprStmtDuplicator exprDuplicator(al);
         for (int64_t loop_var = loop_start; loop_var <= loop_end; loop_var += loop_increment) {
-            for (size_t value_index_in_loop = 0; value_index_in_loop < implied_do_loop->n_values; value_index_in_loop++) {
-                ASR::expr_t* duplicatedExpr = exprDuplicator.duplicate_expr(
-                                                implied_do_loop->m_values[value_index_in_loop]);
-                ASR::ArrayItem_t* array_item_expr = ASR::down_cast<ASR::ArrayItem_t>(duplicatedExpr);
+            for (size_t value_index_in_loop = 0; value_index_in_loop < implied_do_loop->n_values;
+                 value_index_in_loop++) {
+                ASR::expr_t* duplicatedExpr
+                    = exprDuplicator.duplicate_expr(implied_do_loop->m_values[value_index_in_loop]);
+                ASR::ArrayItem_t* array_item_expr
+                    = ASR::down_cast<ASR::ArrayItem_t>(duplicatedExpr);
                 for (size_t arg_index = 0; arg_index < array_item_expr->n_args; arg_index++) {
                     ASR::array_index_t array_index = array_item_expr->m_args[arg_index];
                     ASR::expr_t* index_expr = array_index.m_right;
                     if (ASR::is_a<ASR::Var_t>(*index_expr)) {
-                        array_item_expr->m_args[arg_index].m_right = ASRUtils::EXPR(
-                                                                    ASR::make_IntegerConstant_t(al,
-                                                                        implied_do_loop->base.base.loc,
-                                                                        loop_var, integer_type)
-                                                                    );
+                        array_item_expr->m_args[arg_index].m_right
+                            = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                al, implied_do_loop->base.base.loc, loop_var, integer_type));
                     }
                 }
                 ASR::expr_t* target = ASRUtils::EXPR((ASR::asr_t*) array_item_expr);
                 ASR::ttype_t* temp_current_variable_type_ = current_variable_type_;
                 // Get the Type of Object
                 // If object is Real, set current_variable_type to Real
-                // This type flag is passed to Visit_BOZ, 
+                // This type flag is passed to Visit_BOZ,
                 // so that Real Values are correctly decoded from BOZ String
-                if ((ASR::is_a<ASR::Real_t>(*array_item_expr->m_type)) 
-                    && (value_index<(data_stmt_set->n_value)) &&
-                    (AST::is_a<AST::BOZ_t>(*data_stmt_set->m_value[value_index]))) {
+                if ((ASR::is_a<ASR::Real_t>(*array_item_expr->m_type))
+                    && (value_index < (data_stmt_set->n_value))
+                    && (AST::is_a<AST::BOZ_t>(*data_stmt_set->m_value[value_index]))) {
                     current_variable_type_ = array_item_expr->m_type;
                 }
                 this->visit_expr(*data_stmt_set->m_value[value_index++]);
                 ASR::expr_t* value = ASRUtils::EXPR(tmp);
                 current_variable_type_ = temp_current_variable_type_;
                 ASRUtils::make_ArrayBroadcast_t_util(al, data_stmt.base.base.loc, target, value);
-                ASR::stmt_t* assignStatement = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, data_stmt.base.base.loc,
-                                                                                    target, value, nullptr, compiler_options.po.realloc_lhs_arrays, false)
-                                                             );
+                ASR::stmt_t* assignStatement = ASRUtils::STMT(
+                    ASRUtils::make_Assignment_t_util(al,
+                                                     data_stmt.base.base.loc,
+                                                     target,
+                                                     value,
+                                                     nullptr,
+                                                     compiler_options.po.realloc_lhs_arrays,
+                                                     false));
                 LCOMPILERS_ASSERT(current_body != nullptr)
                 current_body->push_back(al, assignStatement);
             }
         }
     }
 
-    void handle_scalar_data_stmt(const AST::DataStmt_t &x, AST::DataStmtSet_t *a, size_t i, size_t &j) {
+    void handle_scalar_data_stmt(const AST::DataStmt_t& x,
+                                 AST::DataStmtSet_t* a,
+                                 size_t i,
+                                 size_t& j)
+    {
         this->visit_expr(*a->m_object[i]);
         ASR::expr_t* object = ASRUtils::EXPR(tmp);
         ASR::ttype_t* obj_type = ASRUtils::expr_type(object);
         // Get the Type of Object
         // If object is Real, set current_variable_type to Real
-        // This type flag is passed to Visit_BOZ, 
+        // This type flag is passed to Visit_BOZ,
         // so that Real Values are correctly decoded from BOZ String
         ASR::ttype_t* temp_current_variable_type_ = current_variable_type_;
         if (ASR::is_a<ASR::Real_t>(*obj_type)) {
@@ -2583,38 +3061,48 @@ public:
         // The `visit_expr` ensures it resolves as an expression
         // which must be a `Var_t` pointing to a `Variable_t`,
         // so no checks are needed:
-        ImplicitCastRules::set_converted_value(al, x.base.base.loc, &value,
-                                ASRUtils::expr_type(value), ASRUtils::expr_type(object), diag);
+        ImplicitCastRules::set_converted_value(al,
+                                               x.base.base.loc,
+                                               &value,
+                                               ASRUtils::expr_type(value),
+                                               ASRUtils::expr_type(object),
+                                               diag);
         ASR::expr_t* expression_value = ASRUtils::expr_value(value);
         if (!expression_value) {
-            diag.add(Diagnostic(
-                "The value in data must be a constant",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+            diag.add(Diagnostic("The value in data must be a constant",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         if (ASR::is_a<ASR::StructInstanceMember_t>(*object)) {
-            ASR::StructInstanceMember_t *mem = ASR::down_cast<ASR::StructInstanceMember_t>(object);
-            ASR::Variable_t* v2 = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(mem->m_m));
+            ASR::StructInstanceMember_t* mem = ASR::down_cast<ASR::StructInstanceMember_t>(object);
+            ASR::Variable_t* v2
+                = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(mem->m_m));
             v2->m_value = expression_value;
             v2->m_symbolic_value = expression_value;
             SetChar var_deps_vec;
             var_deps_vec.reserve(al, 1);
-            ASRUtils::collect_variable_dependencies(al, var_deps_vec, v2->m_type,
-                v2->m_symbolic_value, v2->m_value);
+            ASRUtils::collect_variable_dependencies(
+                al, var_deps_vec, v2->m_type, v2->m_symbolic_value, v2->m_value);
             v2->m_dependencies = var_deps_vec.p;
             v2->n_dependencies = var_deps_vec.size();
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, object, expression_value);
-            ASR::stmt_t* assign_stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al,
-                        object->base.loc, object, expression_value, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+            ASR::stmt_t* assign_stmt = ASRUtils::STMT(
+                ASRUtils::make_Assignment_t_util(al,
+                                                 object->base.loc,
+                                                 object,
+                                                 expression_value,
+                                                 nullptr,
+                                                 compiler_options.po.realloc_lhs_arrays,
+                                                 false));
             LCOMPILERS_ASSERT(current_body != nullptr)
             current_body->push_back(al, assign_stmt);
         } else if (ASR::is_a<ASR::Var_t>(*object)) {
             // This is the following case:
             // y / 2 /
-            ASR::Var_t *v = ASR::down_cast<ASR::Var_t>(object);
-            ASR::Variable_t *v2 = ASR::down_cast<ASR::Variable_t>(v->m_v);
+            ASR::Var_t* v = ASR::down_cast<ASR::Var_t>(object);
+            ASR::Variable_t* v2 = ASR::down_cast<ASR::Variable_t>(v->m_v);
             // For pointer types (e.g. equivalenced arrays), don't set m_value
             // as it causes issues in LLVM codegen - rely on assignment instead
             if (!ASR::is_a<ASR::Pointer_t>(*v2->m_type)) {
@@ -2622,14 +3110,20 @@ public:
                 v2->m_symbolic_value = expression_value;
                 SetChar var_deps_vec;
                 var_deps_vec.reserve(al, 1);
-                ASRUtils::collect_variable_dependencies(al, var_deps_vec, v2->m_type,
-                    v2->m_symbolic_value, v2->m_value);
+                ASRUtils::collect_variable_dependencies(
+                    al, var_deps_vec, v2->m_type, v2->m_symbolic_value, v2->m_value);
                 v2->m_dependencies = var_deps_vec.p;
                 v2->n_dependencies = var_deps_vec.size();
             }
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, object, expression_value);
-            ASR::stmt_t* assign_stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al,
-                        object->base.loc, object, expression_value, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+            ASR::stmt_t* assign_stmt = ASRUtils::STMT(
+                ASRUtils::make_Assignment_t_util(al,
+                                                 object->base.loc,
+                                                 object,
+                                                 expression_value,
+                                                 nullptr,
+                                                 compiler_options.po.realloc_lhs_arrays,
+                                                 false));
             LCOMPILERS_ASSERT(current_body != nullptr)
             current_body->push_back(al, assign_stmt);
         } else if (ASR::is_a<ASR::ArrayItem_t>(*object)) {
@@ -2643,22 +3137,29 @@ public:
             // To fix that, we would have to iterate over data statements first
             // but we can fix that later.
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, object, expression_value);
-            ASR::stmt_t* assign_stmt = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al,
-                        object->base.loc, object, expression_value, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+            ASR::stmt_t* assign_stmt = ASRUtils::STMT(
+                ASRUtils::make_Assignment_t_util(al,
+                                                 object->base.loc,
+                                                 object,
+                                                 expression_value,
+                                                 nullptr,
+                                                 compiler_options.po.realloc_lhs_arrays,
+                                                 false));
             LCOMPILERS_ASSERT(current_body != nullptr)
             current_body->push_back(al, assign_stmt);
         } else {
             diag.add(Diagnostic(
                 "The variable (object) type is not supported (only variables and array items are supported so far)",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
 
-    void visit_DataStmt(const AST::DataStmt_t &x) {
+    void visit_DataStmt(const AST::DataStmt_t& x)
+    {
         // The DataStmt is a statement, so it occurs in the BodyVisitor.
         // We add its contents into the symbol table here. This visitor
         // could probably be in either the CommonVisitor or the BodyVisitor.
@@ -2666,13 +3167,14 @@ public:
         // This outer loop is iterating over sections in the data statement,
         // for example in the following we have three items:
         //   data x / 1.0, 2.0 /, a, b / 1.0, 2.0 /, c / 1.0 /
-        for (size_t i=0; i < x.n_items; i++) {
-            AST::DataStmtSet_t *a = AST::down_cast<AST::DataStmtSet_t>(x.m_items[i]);
+        for (size_t i = 0; i < x.n_items; i++) {
+            AST::DataStmtSet_t* a = AST::down_cast<AST::DataStmtSet_t>(x.m_items[i]);
             // Now we are dealing with just one item, there are four cases possible:
             // data x / 1, 2, 3 /       ! x must be an array
             // data x / 1 /             ! x must be a scalar (integer)
             // data x, y, z / 1, 2, 3 / ! x, y, z must be a scalar (integer)
-            // data x, (y(i),i = 1,3) /1, 2, 3, 4/ ! x must be a scalar (integer) and y must be an array
+            // data x, (y(i),i = 1,3) /1, 2, 3, 4/ ! x must be a scalar (integer) and y must be an
+            // array
 
             // Validate element count: Check if total LHS elements match RHS values
             // Else, throw error
@@ -2695,11 +3197,12 @@ public:
                     }
                 } else if (ASR::is_a<ASR::ImpliedDoLoop_t>(*object)) {
                     // Calculate implied do loop iterations
-                    ASR::ImpliedDoLoop_t *implied_do_loop = ASR::down_cast<ASR::ImpliedDoLoop_t>(object);
+                    ASR::ImpliedDoLoop_t* implied_do_loop
+                        = ASR::down_cast<ASR::ImpliedDoLoop_t>(object);
                     ASR::expr_t* start_expr_value = ASRUtils::expr_value(implied_do_loop->m_start);
                     ASR::expr_t* end_expr_value = ASRUtils::expr_value(implied_do_loop->m_end);
                     ASR::expr_t* increment_expr = implied_do_loop->m_increment;
-                    
+
                     if (!start_expr_value || !end_expr_value) {
                         // Cannot evaluate at compile time
                         can_validate = false;
@@ -2715,14 +3218,15 @@ public:
                         }
                         increment = ASR::down_cast<ASR::IntegerConstant_t>(increment_value)->m_n;
                     }
-                    
+
                     int64_t start = ASR::down_cast<ASR::IntegerConstant_t>(start_expr_value)->m_n;
                     int64_t end = ASR::down_cast<ASR::IntegerConstant_t>(end_expr_value)->m_n;
                     // Calculate number of iterations
                     int64_t iterations = 0;
                     if (increment > 0) {
                         iterations = (end - start) / increment + 1;
-                        if (iterations < 0) iterations = 0;
+                        if (iterations < 0)
+                            iterations = 0;
                     } else {
                         can_validate = false;
                         break;
@@ -2736,12 +3240,13 @@ public:
             }
             // Perform validation if we can determine element counts
             if (can_validate && total_lhs_elements != a->n_value) {
-                diag.add(Diagnostic(
-                    "DATA statement element count mismatch: " + std::to_string(total_lhs_elements) + 
-                    " elements on left-hand side, " + std::to_string(a->n_value) + " values on right-hand side",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("DATA statement element count mismatch: "
+                                        + std::to_string(total_lhs_elements)
+                                        + " elements on left-hand side, "
+                                        + std::to_string(a->n_value) + " values on right-hand side",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
 
@@ -2752,7 +3257,7 @@ public:
                     this->visit_expr(*a->m_object[0]);
                     ASR::expr_t* object = ASRUtils::EXPR(tmp);
                     ASR::ttype_t* obj_type = ASRUtils::expr_type(object);
-                    if (ASRUtils::is_array(obj_type)) { // it is an array
+                    if (ASRUtils::is_array(obj_type)) {  // it is an array
                         size_t curr_value = 0;
                         handle_array_data_stmt(x, a, obj_type, object, curr_value);
                     } else if (ASR::is_a<ASR::ImpliedDoLoop_t>(*object)) {
@@ -2765,21 +3270,22 @@ public:
                     } else {
                         diag.add(Diagnostic(
                             "There is one variable and multiple values, but the variable is not an array",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 } else {
                     // This is fourth case:
-                    // data x, (y(i),i = 1,3) /1, 2, 3, 4/ ! x can be array or scalar and y must be an array
+                    // data x, (y(i),i = 1,3) /1, 2, 3, 4/ ! x can be array or scalar and y must be
+                    // an array
                     size_t curr_value = 0;
 
                     for (size_t j = 0; j < a->n_object; j++) {
                         this->visit_expr(*a->m_object[j]);
                         ASR::expr_t* object = ASRUtils::EXPR(tmp);
                         ASR::ttype_t* obj_type = ASRUtils::expr_type(object);
-                        if (ASRUtils::is_array(obj_type)) { // it is an array
+                        if (ASRUtils::is_array(obj_type)) {  // it is an array
                             handle_array_data_stmt(x, a, obj_type, object, curr_value);
                         } else if (ASR::is_a<ASR::ImpliedDoLoop_t>(*object)) {
                             handle_implied_do_loop_data_stmt(x, a, object, curr_value);
@@ -2795,7 +3301,7 @@ public:
 
                 // Note: this also happens for a case like:
                 // data x(1), x(2), x(3) / 1, 2, 3 /
-                for (size_t i=0;i<a->n_object;++i) {
+                for (size_t i = 0; i < a->n_object; ++i) {
                     // Here we are now dealing with just one variable (object)
                     // and the corresponding value at a time, such as:
                     // y / 2 /
@@ -2810,35 +3316,53 @@ public:
         tmp = nullptr;
     }
 
-    void mark_common_blocks_as_declared() {
-        for(auto &it: common_block_dictionary) {
-            if(it.second.first) {
+    void mark_common_blocks_as_declared()
+    {
+        for (auto& it : common_block_dictionary) {
+            if (it.second.first) {
                 it.second.first = false;
             }
         }
     }
 
-    ASR::symbol_t* create_common_module(Location loc, std::string common_block_name) {
+    ASR::symbol_t* create_common_module(Location loc, std::string common_block_name)
+    {
         std::string base_module_name = "file_common_block_";
         std::string base_struct_instance_name = "struct_instance_";
         std::string module_name = base_module_name + common_block_name;
-        SymbolTable *parent_scope = current_scope;
-        SymbolTable *global_scope = current_scope;
+        SymbolTable* parent_scope = current_scope;
+        SymbolTable* global_scope = current_scope;
         // get global scope
-        while(global_scope->parent) {
+        while (global_scope->parent) {
             global_scope = global_scope->parent;
         }
-        if(!global_scope->resolve_symbol(module_name)){
+        if (!global_scope->resolve_symbol(module_name)) {
             current_scope = al.make_new<SymbolTable>(global_scope);
 
             // create a struct
             SymbolTable* struct_scope = al.make_new<SymbolTable>(current_scope);
-            ASR::symbol_t* struct_symbol = ASR::down_cast<ASR::symbol_t>(make_Struct_t(
-                al, loc, struct_scope, s2c(al,common_block_name),
-                nullptr,
-                nullptr, 0, nullptr, 0, nullptr, 0, ASR::abiType::Source, ASR::accessType::Public, false, false,
-                nullptr, 0, nullptr, nullptr));
-            ASR::ttype_t* struct_type = ASRUtils::make_StructType_t_util(al, loc, struct_symbol, true);
+            ASR::symbol_t* struct_symbol
+                = ASR::down_cast<ASR::symbol_t>(make_Struct_t(al,
+                                                              loc,
+                                                              struct_scope,
+                                                              s2c(al, common_block_name),
+                                                              nullptr,
+                                                              nullptr,
+                                                              0,
+                                                              nullptr,
+                                                              0,
+                                                              nullptr,
+                                                              0,
+                                                              ASR::abiType::Source,
+                                                              ASR::accessType::Public,
+                                                              false,
+                                                              false,
+                                                              nullptr,
+                                                              0,
+                                                              nullptr,
+                                                              nullptr));
+            ASR::ttype_t* struct_type
+                = ASRUtils::make_StructType_t_util(al, loc, struct_symbol, true);
             ASR::Struct_t* struct_ = ASR::down_cast<ASR::Struct_t>(struct_symbol);
             struct_->m_struct_signature = struct_type;
             struct_symbol = ASR::down_cast<ASR::symbol_t>((ASR::asr_t*) struct_);
@@ -2847,18 +3371,35 @@ public:
             // create a struct instance
             ASR::ttype_t* type = ASRUtils::make_StructType_t_util(al, loc, struct_symbol, true);
             std::string struct_var_name = base_struct_instance_name + common_block_name;
-            ASR::symbol_t* struct_var_sym = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al, loc, current_scope, s2c(al, struct_var_name), nullptr, 0,
-                                        ASR::intentType::Local, nullptr, nullptr, ASR::storage_typeType::Default, type, struct_symbol,
-                                        ASR::abiType::Source, ASR::accessType::Public, ASR::presenceType::Required, false));
+            ASR::symbol_t* struct_var_sym = ASR::down_cast<ASR::symbol_t>(
+                ASRUtils::make_Variable_t_util(al,
+                                               loc,
+                                               current_scope,
+                                               s2c(al, struct_var_name),
+                                               nullptr,
+                                               0,
+                                               ASR::intentType::Local,
+                                               nullptr,
+                                               nullptr,
+                                               ASR::storage_typeType::Default,
+                                               type,
+                                               struct_symbol,
+                                               ASR::abiType::Source,
+                                               ASR::accessType::Public,
+                                               ASR::presenceType::Required,
+                                               false));
             current_scope->add_symbol(struct_var_name, struct_var_sym);
 
-            ASR::asr_t *tmp0 = ASR::make_Module_t(al, loc,
-                        /* a_symtab */ current_scope,
-                        /* a_name */ s2c(al, to_lower(module_name)),
-                        nullptr,
-                        nullptr,
-                        0,
-                        false, false, false);
+            ASR::asr_t* tmp0 = ASR::make_Module_t(al,
+                                                  loc,
+                                                  /* a_symtab */ current_scope,
+                                                  /* a_name */ s2c(al, to_lower(module_name)),
+                                                  nullptr,
+                                                  nullptr,
+                                                  0,
+                                                  false,
+                                                  false,
+                                                  false);
 
             ASR::symbol_t* current_module_sym = ASR::down_cast<ASR::symbol_t>(tmp0);
             global_scope->add_symbol(to_lower(module_name), current_module_sym);
@@ -2866,22 +3407,37 @@ public:
             return struct_symbol;
         } else {
             ASR::symbol_t* current_module_sym = global_scope->resolve_symbol(module_name);
-            return ASR::down_cast<ASR::Module_t>(current_module_sym)->m_symtab->resolve_symbol(common_block_name);
+            return ASR::down_cast<ASR::Module_t>(current_module_sym)
+                ->m_symtab->resolve_symbol(common_block_name);
         }
     }
 
-    void add_sym_to_struct(ASR::Variable_t* var_, ASR::Struct_t* struct_type) {
+    void add_sym_to_struct(ASR::Variable_t* var_, ASR::Struct_t* struct_type)
+    {
         char* var_name = var_->m_name;
         SymbolTable* struct_scope = struct_type->m_symtab;
-        ASR::symbol_t* var_sym_new = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al, var_->base.base.loc, struct_scope,
-                        var_->m_name, var_->m_dependencies, var_->n_dependencies, var_->m_intent,
-                        var_->m_symbolic_value, var_->m_value, var_->m_storage, var_->m_type,
-                        var_->m_type_declaration, var_->m_abi, var_->m_access, var_->m_presence, var_->m_value_attr));
+        ASR::symbol_t* var_sym_new
+            = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(al,
+                                                                           var_->base.base.loc,
+                                                                           struct_scope,
+                                                                           var_->m_name,
+                                                                           var_->m_dependencies,
+                                                                           var_->n_dependencies,
+                                                                           var_->m_intent,
+                                                                           var_->m_symbolic_value,
+                                                                           var_->m_value,
+                                                                           var_->m_storage,
+                                                                           var_->m_type,
+                                                                           var_->m_type_declaration,
+                                                                           var_->m_abi,
+                                                                           var_->m_access,
+                                                                           var_->m_presence,
+                                                                           var_->m_value_attr));
         struct_scope->add_symbol(var_name, var_sym_new);
 
         Vec<char*> members;
-        members.reserve(al, struct_type->n_members+1);
-        for (size_t i=0; i<struct_type->n_members; i++) {
+        members.reserve(al, struct_type->n_members + 1);
+        for (size_t i = 0; i < struct_type->n_members; i++) {
             members.push_back(al, struct_type->m_members[i]);
         }
         members.push_back(al, var_name);
@@ -2889,170 +3445,179 @@ public:
         struct_type->n_members = members.size();
     }
 
-    ASR::Variable_t * get_symtab_var_for_common(AST::var_sym_t const &s) {
-	std::string const sym {to_lower(s.m_name)};
-	ASR::symbol_t *get_sym = current_scope->get_symbol(sym);
-	if (get_sym == nullptr) {
-	    if (compiler_options.implicit_typing) {
-		ASR::intentType intent = ASRUtils::intent_local;
-		get_sym = declare_implicit_variable2(s.loc, sym, intent, implicit_dictionary[std::string(1,sym[0])]);
-	    } else {
-		diag.add(Diagnostic(
-			     "Cannot implicitly declare variable in COMMON block",
-			     Level::Error, Stage::Semantic, {
-				 Label("",{s.loc})
-			     }));
-		throw SemanticAbort();
-	    }
-	}
-
-	ASR::Variable_t* var_{nullptr};
-	if (ASR::is_a<ASR::Variable_t>(*get_sym)) {
-	    var_ = ASR::down_cast<ASR::Variable_t>(get_sym);
-	} else {
-	    diag.add(Diagnostic(
-			 "Can only add variables to COMMON blocks",
-			 Level::Error, Stage::Semantic, {
-			     Label("",{s.loc})
-			 }));
-	    throw SemanticAbort();
-	}
-	return var_;
-    }
-
-
-    void populate_common_dictionary(const AST::Declaration_t &x, common_block_varsyms const & objs_by_blk) {
-	for (auto const & blk : objs_by_blk) {
-	    std::string const & common_block_name = blk.first;
-	    ASR::symbol_t* common_block_struct_sym = create_common_module(x.base.base.loc,
-									  common_block_name);
-	    ASR::Struct_t* struct_type = ASR::down_cast<ASR::Struct_t>(common_block_struct_sym);
-	    size_t const num_cb_var = blk.second.size();
-
-	    auto cbd_it = common_block_dictionary.find(common_block_name);
-
-	    if (cbd_it == common_block_dictionary.end()) {
-		// Populate an entire new common_block_dictionary entry
-		std::vector<ASR::expr_t*> common_block_variables;
-		common_block_variables.reserve(num_cb_var);
-
-		// Add all the block variables
-		for (auto const &s : blk.second) {
-		    AST::expr_t* expr = s.m_initializer;
-            LCOMPILERS_ASSERT(expr != nullptr)
-		    this->visit_expr(*expr);
-		    ASR::Variable_t* var_ = get_symtab_var_for_common(s);
-		    uint64_t hash = get_hash((ASR::asr_t*) var_);
-		    common_block_variables.push_back(ASRUtils::EXPR(tmp));
-		    // add variable to struct
-		    add_sym_to_struct(var_, struct_type);
-		    common_variables_hash[hash] = common_block_struct_sym;
-		}
-
-		common_block_dictionary[common_block_name].first = true;
-		common_block_dictionary[common_block_name].second.swap(common_block_variables);
-
-	    } else {
-		// There is already an entry in the dictionary for this block name
-		if (cbd_it->second.first) {
-		    // The block has not been marked as declared, so we just append all the variables
-		    std::vector<ASR::expr_t*> & common_block_variables = cbd_it->second.second;
-		    common_block_variables.reserve(common_block_variables.size() + blk.second.size());
-
-		    for (auto const &s : blk.second) {
-			AST::expr_t* expr = s.m_initializer;
-			this->visit_expr(*expr);
-			ASR::Variable_t* var_ = get_symtab_var_for_common(s);
-			uint64_t hash = get_hash((ASR::asr_t*) var_);
-			common_block_variables.push_back(ASRUtils::EXPR(tmp));
-			common_variables_hash[hash] = common_block_struct_sym;
-			// add variable to struct
-            if (struct_type->m_symtab->resolve_symbol(var_->m_name) == nullptr) {
-                add_sym_to_struct(var_, struct_type);
-            }
-		    }
-		} else {
-		    /* The block has already been declared, so we need to compare the structure of the block
-		       declarations and update the structs holding the variables. */
-		    std::vector<ASR::expr_t*> const & common_block_variables = cbd_it->second.second;
-
-		    if (common_block_variables.size() != num_cb_var) {
-			diag.add(Diagnostic(
-				     "The number of variables in common block must be same in all programs",
-				     Level::Error, Stage::Semantic, {
-					 Label("",{x.base.base.loc})
-				     }));
-			throw SemanticAbort();
-		    }
-
-		    for (size_t i = 0; i < num_cb_var; ++i) {
-			auto &expr = common_block_variables[i];
-			auto &s = blk.second[i];
-
-			ASR::Variable_t* var_ = nullptr;
-			if (ASR::is_a<ASR::ArrayItem_t>(*expr)) {
-			    ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(expr);
-			    ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(array_item->m_v);
-			    var_ = ASR::down_cast<ASR::Variable_t>(var->m_v);
-			} else {
-			    var_ = ASRUtils::EXPR2VAR(expr);
-			}
-
-			AST::expr_t* expr_ = s.m_initializer;
-			this->visit_expr(*expr_);
-			ASR::Variable_t* var__ = nullptr;
-			if (ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp))) {
-			    ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp));
-			    ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(array_item->m_v);
-			    var__ = ASR::down_cast<ASR::Variable_t>(var->m_v);
-			} else {
-			    var__ = ASRUtils::EXPR2VAR(ASRUtils::EXPR(tmp));
-			}
-            if (!ASRUtils::check_equal_type(var_->m_type,
-                                            var__->m_type,
-                                            ASRUtils::get_expr_from_sym(al, &var_->base),
-                                            ASRUtils::get_expr_from_sym(al, &var__->base))) {
-                diag.add(Diagnostic(
-                    "The order of variables in common block must be same in all programs",
-                    Level::Error,
-                    Stage::Semantic,
-                    { Label("", { x.base.base.loc }) }));
-                throw SemanticAbort();
+    ASR::Variable_t* get_symtab_var_for_common(AST::var_sym_t const& s)
+    {
+        std::string const sym{ to_lower(s.m_name) };
+        ASR::symbol_t* get_sym = current_scope->get_symbol(sym);
+        if (get_sym == nullptr) {
+            if (compiler_options.implicit_typing) {
+                ASR::intentType intent = ASRUtils::intent_local;
+                get_sym = declare_implicit_variable2(
+                    s.loc, sym, intent, implicit_dictionary[std::string(1, sym[0])]);
+            } else {
+                diag.add(Diagnostic("Cannot implicitly declare variable in COMMON block",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { s.loc }) }));
+                throw SemanticAbort();
+            }
+        }
+
+        ASR::Variable_t* var_{ nullptr };
+        if (ASR::is_a<ASR::Variable_t>(*get_sym)) {
+            var_ = ASR::down_cast<ASR::Variable_t>(get_sym);
+        } else {
+            diag.add(Diagnostic("Can only add variables to COMMON blocks",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { s.loc }) }));
+            throw SemanticAbort();
+        }
+        return var_;
+    }
+
+
+    void populate_common_dictionary(const AST::Declaration_t& x,
+                                    common_block_varsyms const& objs_by_blk)
+    {
+        for (auto const& blk : objs_by_blk) {
+            std::string const& common_block_name = blk.first;
+            ASR::symbol_t* common_block_struct_sym
+                = create_common_module(x.base.base.loc, common_block_name);
+            ASR::Struct_t* struct_type = ASR::down_cast<ASR::Struct_t>(common_block_struct_sym);
+            size_t const num_cb_var = blk.second.size();
+
+            auto cbd_it = common_block_dictionary.find(common_block_name);
+
+            if (cbd_it == common_block_dictionary.end()) {
+                // Populate an entire new common_block_dictionary entry
+                std::vector<ASR::expr_t*> common_block_variables;
+                common_block_variables.reserve(num_cb_var);
+
+                // Add all the block variables
+                for (auto const& s : blk.second) {
+                    AST::expr_t* expr = s.m_initializer;
+                    LCOMPILERS_ASSERT(expr != nullptr)
+                    this->visit_expr(*expr);
+                    ASR::Variable_t* var_ = get_symtab_var_for_common(s);
+                    uint64_t hash = get_hash((ASR::asr_t*) var_);
+                    common_block_variables.push_back(ASRUtils::EXPR(tmp));
+                    // add variable to struct
+                    add_sym_to_struct(var_, struct_type);
+                    common_variables_hash[hash] = common_block_struct_sym;
+                }
+
+                common_block_dictionary[common_block_name].first = true;
+                common_block_dictionary[common_block_name].second.swap(common_block_variables);
+
             } else {
-                uint64_t hash = get_hash((ASR::asr_t*) var__);
-			    common_variables_hash[hash] = common_block_struct_sym;
-            }
-            if (ASRUtils::is_array(var_->m_type) && ASR::is_a<ASR::ArrayItem_t>(*expr)) {
-			    /*
-			      Update type of original symbol
-			      case:
-			      program main
-			      double precision x
-			      common /a/ x(10)
-			      end program
-			    */
-			    ASR::symbol_t* var_sym = current_scope->get_symbol(s2c(al, var_->m_name));
-			    if (ASR::is_a<ASR::Variable_t>(*var_sym)) {
-				ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(var_sym);
-				var->m_type = var_->m_type;
-			    }
-			}
-		    }
-		}
-	    }
-	}
+                // There is already an entry in the dictionary for this block name
+                if (cbd_it->second.first) {
+                    // The block has not been marked as declared, so we just append all the
+                    // variables
+                    std::vector<ASR::expr_t*>& common_block_variables = cbd_it->second.second;
+                    common_block_variables.reserve(common_block_variables.size()
+                                                   + blk.second.size());
+
+                    for (auto const& s : blk.second) {
+                        AST::expr_t* expr = s.m_initializer;
+                        this->visit_expr(*expr);
+                        ASR::Variable_t* var_ = get_symtab_var_for_common(s);
+                        uint64_t hash = get_hash((ASR::asr_t*) var_);
+                        common_block_variables.push_back(ASRUtils::EXPR(tmp));
+                        common_variables_hash[hash] = common_block_struct_sym;
+                        // add variable to struct
+                        if (struct_type->m_symtab->resolve_symbol(var_->m_name) == nullptr) {
+                            add_sym_to_struct(var_, struct_type);
+                        }
+                    }
+                } else {
+                    /* The block has already been declared, so we need to compare the structure of
+                       the block declarations and update the structs holding the variables. */
+                    std::vector<ASR::expr_t*> const& common_block_variables = cbd_it->second.second;
+
+                    if (common_block_variables.size() != num_cb_var) {
+                        diag.add(Diagnostic(
+                            "The number of variables in common block must be same in all programs",
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { x.base.base.loc }) }));
+                        throw SemanticAbort();
+                    }
+
+                    for (size_t i = 0; i < num_cb_var; ++i) {
+                        auto& expr = common_block_variables[i];
+                        auto& s = blk.second[i];
+
+                        ASR::Variable_t* var_ = nullptr;
+                        if (ASR::is_a<ASR::ArrayItem_t>(*expr)) {
+                            ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(expr);
+                            ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(array_item->m_v);
+                            var_ = ASR::down_cast<ASR::Variable_t>(var->m_v);
+                        } else {
+                            var_ = ASRUtils::EXPR2VAR(expr);
+                        }
+
+                        AST::expr_t* expr_ = s.m_initializer;
+                        this->visit_expr(*expr_);
+                        ASR::Variable_t* var__ = nullptr;
+                        if (ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp))) {
+                            ASR::ArrayItem_t* array_item
+                                = ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp));
+                            ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(array_item->m_v);
+                            var__ = ASR::down_cast<ASR::Variable_t>(var->m_v);
+                        } else {
+                            var__ = ASRUtils::EXPR2VAR(ASRUtils::EXPR(tmp));
+                        }
+                        if (!ASRUtils::check_equal_type(
+                                var_->m_type,
+                                var__->m_type,
+                                ASRUtils::get_expr_from_sym(al, &var_->base),
+                                ASRUtils::get_expr_from_sym(al, &var__->base))) {
+                            diag.add(Diagnostic(
+                                "The order of variables in common block must be same in all programs",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
+                            throw SemanticAbort();
+                        } else {
+                            uint64_t hash = get_hash((ASR::asr_t*) var__);
+                            common_variables_hash[hash] = common_block_struct_sym;
+                        }
+                        if (ASRUtils::is_array(var_->m_type)
+                            && ASR::is_a<ASR::ArrayItem_t>(*expr)) {
+                            /*
+                              Update type of original symbol
+                              case:
+                              program main
+                              double precision x
+                              common /a/ x(10)
+                              end program
+                            */
+                            ASR::symbol_t* var_sym
+                                = current_scope->get_symbol(s2c(al, var_->m_name));
+                            if (ASR::is_a<ASR::Variable_t>(*var_sym)) {
+                                ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(var_sym);
+                                var->m_type = var_->m_type;
+                            }
+                        }
+                    }
+                }
+            }
+        }
     }
 
     template <typename T>
-    void check_if_global_save_is_enabled(T &x) {
-        for ( size_t i = 0; i < x.n_decl; i++ ) {
-            if ( AST::is_a<AST::Declaration_t>(*x.m_decl[i]) ) {
+    void check_if_global_save_is_enabled(T& x)
+    {
+        for (size_t i = 0; i < x.n_decl; i++) {
+            if (AST::is_a<AST::Declaration_t>(*x.m_decl[i])) {
                 AST::Declaration_t* decl = AST::down_cast<AST::Declaration_t>(x.m_decl[i]);
-                if ( decl->n_attributes > 0 && decl->n_syms == 0 &&
-                    decl->m_trivia == nullptr &&
-                    AST::is_a<AST::SimpleAttribute_t>(*decl->m_attributes[0]) ) {
-                    AST::SimpleAttribute_t* attr = AST::down_cast<AST::SimpleAttribute_t>(decl->m_attributes[0]);
-                    if ( attr->m_attr == AST::simple_attributeType::AttrSave ) {
+                if (decl->n_attributes > 0 && decl->n_syms == 0 && decl->m_trivia == nullptr
+                    && AST::is_a<AST::SimpleAttribute_t>(*decl->m_attributes[0])) {
+                    AST::SimpleAttribute_t* attr
+                        = AST::down_cast<AST::SimpleAttribute_t>(decl->m_attributes[0]);
+                    if (attr->m_attr == AST::simple_attributeType::AttrSave) {
                         is_global_save_enabled = true;
                         break;
                     }
@@ -3061,15 +3626,18 @@ public:
         }
     }
 
-    void create_external_function(std::string sym, Location loc, ASR::ttype_t* determined_type = nullptr) {
+    void create_external_function(std::string sym,
+                                  Location loc,
+                                  ASR::ttype_t* determined_type = nullptr)
+    {
         if (compiler_options.implicit_interface) {
             bool is_subroutine = false;
             external_procedures.push_back(sym);
-            ASR::symbol_t *sym_ = current_scope->resolve_symbol(sym);
+            ASR::symbol_t* sym_ = current_scope->resolve_symbol(sym);
             assgnd_access[sym] = ASR::accessType::Public;
-            SymbolTable *parent_scope = current_scope;
+            SymbolTable* parent_scope = current_scope;
             current_scope = al.make_new<SymbolTable>(parent_scope);
-            ASR::ttype_t *type = nullptr;
+            ASR::ttype_t* type = nullptr;
             if (sym_) {
                 if (ASR::is_a<ASR::Function_t>(*sym_)) {
                     ASR::Function_t* func_sym = ASR::down_cast<ASR::Function_t>(sym_);
@@ -3084,7 +3652,7 @@ public:
                 // if explicit type provided, give preference to it.
                 type = determined_type;
             } else if (compiler_options.implicit_typing) {
-                type = implicit_dictionary[std::string(1,sym[0])];
+                type = implicit_dictionary[std::string(1, sym[0])];
                 if (!type) {
                     // There exists an `implicit none` statement, here compiler has
                     // no information about type of symbol hence keeping it real*4.
@@ -3099,111 +3667,146 @@ public:
             SetChar variable_dependencies_vec;
             variable_dependencies_vec.reserve(al, 1);
             ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type);
-            ASR::asr_t *return_var = nullptr;
-            ASR::expr_t *to_return = nullptr;
+            ASR::asr_t* return_var = nullptr;
+            ASR::expr_t* to_return = nullptr;
             if (!is_subroutine) {
-                return_var = ASRUtils::make_Variable_t_util(al, loc,
-                    current_scope, s2c(al, return_var_name), variable_dependencies_vec.p,
-                    variable_dependencies_vec.size(), ASRUtils::intent_return_var,
-                    nullptr, nullptr, ASR::storage_typeType::Default, type, nullptr,
-                    ASR::abiType::BindC, ASR::Public, ASR::presenceType::Required,
-                    false);
-                current_scope->add_symbol(return_var_name, ASR::down_cast<ASR::symbol_t>(return_var));
-                to_return = ASRUtils::EXPR(ASR::make_Var_t(al, loc,
-                    ASR::down_cast<ASR::symbol_t>(return_var)));
-            }
-            tmp = ASRUtils::make_Function_t_util(
-                al, loc,
-                /* a_symtab */ current_scope,
-                /* a_name */ s2c(al, sym),
-                nullptr, 0,
-                /* a_args */ nullptr,
-                /* n_args */ 0,
-                /* a_body */ nullptr,
-                /* n_body */ 0,
-                /* a_return_var */ to_return,
-                ASR::abiType::BindC, ASR::accessType::Public, ASR::deftypeType::Interface,
-                nullptr, false, false, false, false, false, nullptr, 0,
-                false, false, false);
+                return_var = ASRUtils::make_Variable_t_util(al,
+                                                            loc,
+                                                            current_scope,
+                                                            s2c(al, return_var_name),
+                                                            variable_dependencies_vec.p,
+                                                            variable_dependencies_vec.size(),
+                                                            ASRUtils::intent_return_var,
+                                                            nullptr,
+                                                            nullptr,
+                                                            ASR::storage_typeType::Default,
+                                                            type,
+                                                            nullptr,
+                                                            ASR::abiType::BindC,
+                                                            ASR::Public,
+                                                            ASR::presenceType::Required,
+                                                            false);
+                current_scope->add_symbol(return_var_name,
+                                          ASR::down_cast<ASR::symbol_t>(return_var));
+                to_return = ASRUtils::EXPR(
+                    ASR::make_Var_t(al, loc, ASR::down_cast<ASR::symbol_t>(return_var)));
+            }
+            tmp = ASRUtils::make_Function_t_util(al,
+                                                 loc,
+                                                 /* a_symtab */ current_scope,
+                                                 /* a_name */ s2c(al, sym),
+                                                 nullptr,
+                                                 0,
+                                                 /* a_args */ nullptr,
+                                                 /* n_args */ 0,
+                                                 /* a_body */ nullptr,
+                                                 /* n_body */ 0,
+                                                 /* a_return_var */ to_return,
+                                                 ASR::abiType::BindC,
+                                                 ASR::accessType::Public,
+                                                 ASR::deftypeType::Interface,
+                                                 nullptr,
+                                                 false,
+                                                 false,
+                                                 false,
+                                                 false,
+                                                 false,
+                                                 nullptr,
+                                                 0,
+                                                 false,
+                                                 false,
+                                                 false);
             parent_scope->add_or_overwrite_symbol(sym, ASR::down_cast<ASR::symbol_t>(tmp));
             current_scope = parent_scope;
         } else {
             diag.add(Diagnostic(
                 "function interface must be specified explicitly; you can enable implicit interfaces with `--implicit-interface`",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { loc }) }));
             throw SemanticAbort();
         }
     }
 
-    bool check_is_external(std::string sym, SymbolTable* scope = nullptr) {
+    bool check_is_external(std::string sym, SymbolTable* scope = nullptr)
+    {
         if (scope) {
             external_procedures = external_procedures_mapping[get_hash(scope->asr_owner)];
         } else if (current_scope->asr_owner) {
             external_procedures = external_procedures_mapping[get_hash(current_scope->asr_owner)];
         }
-        return ( std::find(external_procedures.begin(), external_procedures.end(), sym) != external_procedures.end() );
+        return (std::find(external_procedures.begin(), external_procedures.end(), sym)
+                != external_procedures.end());
     }
 
-    bool check_is_explicit_intrinsic(std::string sym, SymbolTable* scope=nullptr) {
+    bool check_is_explicit_intrinsic(std::string sym, SymbolTable* scope = nullptr)
+    {
         if (scope) {
-            explicit_intrinsic_procedures = explicit_intrinsic_procedures_mapping[get_hash(scope->asr_owner)];
+            explicit_intrinsic_procedures
+                = explicit_intrinsic_procedures_mapping[get_hash(scope->asr_owner)];
         } else if (current_scope->asr_owner) {
-            explicit_intrinsic_procedures = explicit_intrinsic_procedures_mapping[get_hash(current_scope->asr_owner)];
+            explicit_intrinsic_procedures
+                = explicit_intrinsic_procedures_mapping[get_hash(current_scope->asr_owner)];
         }
-        return (
-            std::find(explicit_intrinsic_procedures.begin(), explicit_intrinsic_procedures.end(), sym) != explicit_intrinsic_procedures.end()
-        );
+        return (std::find(
+                    explicit_intrinsic_procedures.begin(), explicit_intrinsic_procedures.end(), sym)
+                != explicit_intrinsic_procedures.end());
     }
 
-    void erase_from_external_mapping(std::string sym) {
+    void erase_from_external_mapping(std::string sym)
+    {
         uint64_t hash = get_hash(current_scope->asr_owner);
         external_procedures_mapping[hash].erase(
             std::remove(external_procedures_mapping[hash].begin(),
-            external_procedures_mapping[hash].end(), sym),
+                        external_procedures_mapping[hash].end(),
+                        sym),
             external_procedures_mapping[hash].end());
     }
 
-    void erase_from_explicit_intrinsic_mapping(std::string sym) {
+    void erase_from_explicit_intrinsic_mapping(std::string sym)
+    {
         uint64_t hash = get_hash(current_scope->asr_owner);
         explicit_intrinsic_procedures_mapping[hash].erase(
-            std::remove(
-                explicit_intrinsic_procedures_mapping[hash].begin(),
-                explicit_intrinsic_procedures_mapping[hash].end(),
-                sym
-            )
-        );
+            std::remove(explicit_intrinsic_procedures_mapping[hash].begin(),
+                        explicit_intrinsic_procedures_mapping[hash].end(),
+                        sym));
     }
 
     // pad (with ' ') or trim character string 'value'
-    ASR::expr_t* adjust_character_length(ASR::expr_t* value, int64_t lhs_len, int64_t rhs_len, const Location& loc, Allocator& al) {
+    ASR::expr_t* adjust_character_length(
+        ASR::expr_t* value, int64_t lhs_len, int64_t rhs_len, const Location& loc, Allocator& al)
+    {
         value = ASRUtils::expr_value(value);
         ASR::StringConstant_t* string_constant = ASR::down_cast<ASR::StringConstant_t>(value);
         char* original_str = string_constant->m_s;
         size_t new_length = static_cast<size_t>(lhs_len);
         char* adjusted_str = al.allocate<char>(new_length + 1);
 
-        if (lhs_len < rhs_len) { // trim
+        if (lhs_len < rhs_len) {  // trim
             std::memcpy(adjusted_str, original_str, new_length);
-        } else { // pad
+        } else {  // pad
             std::memcpy(adjusted_str, original_str, rhs_len);
             std::memset(adjusted_str + rhs_len, ' ', new_length - rhs_len);
         }
-        adjusted_str[new_length] = '\0'; // null-terminate the string
+        adjusted_str[new_length] = '\0';  // null-terminate the string
 
         ASR::ttype_t* value_type = ASRUtils::TYPE(ASR::make_String_t(
-            al, loc, 1,
+            al,
+            loc,
+            1,
             ASRUtils::EXPR(ASR::make_IntegerConstant_t(
                 al, loc, new_length, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4)))),
-                ASR::string_length_kindType::ExpressionLength,
-                ASR::string_physical_typeType::DescriptorString));
+            ASR::string_length_kindType::ExpressionLength,
+            ASR::string_physical_typeType::DescriptorString));
 
-        return ASRUtils::EXPR(ASR::make_StringConstant_t(
-            al, loc, adjusted_str, value_type));
+        return ASRUtils::EXPR(ASR::make_StringConstant_t(al, loc, adjusted_str, value_type));
     }
 
-    ASR::expr_t* adjust_array_character_length(ASR::expr_t* value, int64_t lhs_len, int64_t rhs_len, Allocator& al) {
+    ASR::expr_t* adjust_array_character_length(ASR::expr_t* value,
+                                               int64_t lhs_len,
+                                               int64_t rhs_len,
+                                               Allocator& al)
+    {
         ASR::ArrayConstant_t* array_constant = ASR::down_cast<ASR::ArrayConstant_t>(value);
         Vec<ASR::expr_t*> body;
         size_t array_size = ASRUtils::get_fixed_size_of_array(array_constant->m_type);
@@ -3214,7 +3817,7 @@ public:
             ASR::expr_t* item = ASRUtils::fetch_ArrayConstant_value(al, array_constant, i);
 
             if (ASR::is_a<ASR::ArrayConstant_t>(*item)) {
-                item = adjust_array_character_length(item, lhs_len, rhs_len,  al);
+                item = adjust_array_character_length(item, lhs_len, rhs_len, al);
             } else {
                 item = adjust_character_length(item, lhs_len, rhs_len, item->base.loc, al);
             }
@@ -3223,7 +3826,7 @@ public:
         }
 
         array_constant->m_data = ASRUtils::set_ArrayConstant_data(
-                body.p, body.size(), ASRUtils::extract_type(array_constant->m_type));
+            body.p, body.size(), ASRUtils::extract_type(array_constant->m_type));
         array_constant->m_n_data = array_size * lhs_len;
         {
             ASR::String_t* str_t = ASRUtils::get_string_type(array_constant->m_type);
@@ -3234,29 +3837,27 @@ public:
         return (ASR::expr_t*) array_constant;
     }
 
-    void visit_DeclarationUtil(const AST::Declaration_t &x) {
+    void visit_DeclarationUtil(const AST::Declaration_t& x)
+    {
         _declaring_variable = true;
         current_variable_type_ = nullptr;
         current_struct_type_var_expr = nullptr;
 
-        if (x.m_vartype == nullptr &&
-                x.n_attributes == 1 &&
-                AST::is_a<AST::AttrNamelist_t>(*x.m_attributes[0])) {
-            //char *name = down_cast<AttrNamelist_t>(x.m_attributes[0])->m_name;
-            diag.add(Diagnostic(
-                "Namelists not implemented yet",
-                Level::Error, Stage::Semantic, {
-                    Label("",{x.base.base.loc})
-                }));
+        if (x.m_vartype == nullptr && x.n_attributes == 1
+            && AST::is_a<AST::AttrNamelist_t>(*x.m_attributes[0])) {
+            // char *name = down_cast<AttrNamelist_t>(x.m_attributes[0])->m_name;
+            diag.add(Diagnostic("Namelists not implemented yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        for (size_t i=0; i<x.n_attributes; i++) {
+        for (size_t i = 0; i < x.n_attributes; i++) {
             if (AST::is_a<AST::AttrType_t>(*x.m_attributes[i])) {
-                diag.add(Diagnostic(
-                    "Type must be declared first",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Type must be declared first",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             };
         }
@@ -3266,464 +3867,603 @@ public:
             // public
             // private :: x, y, z
             if (x.n_attributes == 0) {
-                diag.add(Diagnostic(
-                    "No attribute specified",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("No attribute specified",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-            for (size_t i=0; i<x.n_attributes; i++) {
+            for (size_t i = 0; i < x.n_attributes; i++) {
                 if (AST::is_a<AST::SimpleAttribute_t>(*x.m_attributes[i])) {
-                    AST::SimpleAttribute_t *sa =
-                        AST::down_cast<AST::SimpleAttribute_t>(x.m_attributes[i]);
+                    AST::SimpleAttribute_t* sa
+                        = AST::down_cast<AST::SimpleAttribute_t>(x.m_attributes[i]);
                     if (x.n_syms == 0) {
                         // Example:
                         // private
-                        if (sa->m_attr == AST::simple_attributeType
-                                ::AttrPrivate) {
+                        if (sa->m_attr == AST::simple_attributeType ::AttrPrivate) {
                             dflt_access = ASR::accessType::Private;
-                        } else if (sa->m_attr == AST::simple_attributeType
-                                ::AttrPublic) {
+                        } else if (sa->m_attr == AST::simple_attributeType ::AttrPublic) {
                             // Do nothing (public access is the default)
                             LCOMPILERS_ASSERT(dflt_access == ASR::accessType::Public);
-                        } else if (sa->m_attr == AST::simple_attributeType
-                                ::AttrSave) {
+                        } else if (sa->m_attr == AST::simple_attributeType ::AttrSave) {
                             if (in_module && !in_Subroutine) {
                                 // Do nothing (all variables implicitly have the
                                 // save attribute in a module/main program)
                             } else {
                                 default_storage_save = true;
                             }
-                        } else if (sa->m_attr == AST::simple_attributeType
-                                ::AttrSequence) {
+                        } else if (sa->m_attr == AST::simple_attributeType ::AttrSequence) {
                             // TODO: Implement it for CPP backend
                         } else {
-                            diag.add(Diagnostic(
-                                "Attribute declaration not supported yet",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                            diag.add(Diagnostic("Attribute declaration not supported yet",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     } else {
                         // Example:
                         // private :: x, y, z
-                        for (size_t i=0; i<x.n_syms; i++) {
-                            AST::var_sym_t &s = x.m_syms[i];
+                        for (size_t i = 0; i < x.n_syms; i++) {
+                            AST::var_sym_t& s = x.m_syms[i];
                             if (s.m_name == nullptr) {
-                                if (s.m_spec->type == AST::decl_attributeType::AttrIntrinsicOperator) {
+                                if (s.m_spec->type
+                                    == AST::decl_attributeType::AttrIntrinsicOperator) {
                                     // Operator Overloading Encountered
-                                    if( sa->m_attr != AST::simple_attributeType::AttrPublic &&
-                                    sa->m_attr != AST::simple_attributeType::AttrPrivate ) {
-                                    overloaded_ops[current_scope][s.m_spec] = AST::simple_attributeType::AttrPublic;
+                                    if (sa->m_attr != AST::simple_attributeType::AttrPublic
+                                        && sa->m_attr != AST::simple_attributeType::AttrPrivate) {
+                                        overloaded_ops[current_scope][s.m_spec]
+                                            = AST::simple_attributeType::AttrPublic;
                                     } else {
-                                    overloaded_ops[current_scope][s.m_spec] = sa->m_attr;
+                                        overloaded_ops[current_scope][s.m_spec] = sa->m_attr;
                                     }
-                                } else if( s.m_spec->type == AST::decl_attributeType::AttrAssignment ) {
+                                } else if (s.m_spec->type
+                                           == AST::decl_attributeType::AttrAssignment) {
                                     // Assignment Overloading Encountered
-                                    if( sa->m_attr != AST::simple_attributeType::AttrPublic &&
-                                    sa->m_attr != AST::simple_attributeType::AttrPrivate ) {
-                                    assgn[current_scope] = ASR::Public;
+                                    if (sa->m_attr != AST::simple_attributeType::AttrPublic
+                                        && sa->m_attr != AST::simple_attributeType::AttrPrivate) {
+                                        assgn[current_scope] = ASR::Public;
                                     } else {
-                                    assgn[current_scope] = get_asr_simple_attr(sa->m_attr);
+                                        assgn[current_scope] = get_asr_simple_attr(sa->m_attr);
                                     }
-                                } else if (s.m_spec->type == AST::decl_attributeType::AttrDefinedOperator) {
-                                    //std::string op_name = to_lower(AST::down_cast<AST::AttrDefinedOperator_t>(s.m_spec)->m_op_name);
-                                    // Custom Operator Overloading Encountered
-                                    if( sa->m_attr != AST::simple_attributeType::AttrPublic &&
-                                    sa->m_attr != AST::simple_attributeType::AttrPrivate ) {
-                                    overloaded_ops[current_scope][s.m_spec] = AST::simple_attributeType::AttrPublic;
+                                } else if (s.m_spec->type
+                                           == AST::decl_attributeType::AttrDefinedOperator) {
+                                    // std::string op_name =
+                                    // to_lower(AST::down_cast<AST::AttrDefinedOperator_t>(s.m_spec)->m_op_name);
+                                    //  Custom Operator Overloading Encountered
+                                    if (sa->m_attr != AST::simple_attributeType::AttrPublic
+                                        && sa->m_attr != AST::simple_attributeType::AttrPrivate) {
+                                        overloaded_ops[current_scope][s.m_spec]
+                                            = AST::simple_attributeType::AttrPublic;
                                     } else {
-                                    overloaded_ops[current_scope][s.m_spec] = sa->m_attr;
+                                        overloaded_ops[current_scope][s.m_spec] = sa->m_attr;
                                     }
                                 } else {
-                                    diag.add(Diagnostic(
-                                        "Attribute type not implemented yet.",
-                                        Level::Error, Stage::Semantic, {
-                                            Label("",{x.base.base.loc})
-                                        }));
+                                    diag.add(Diagnostic("Attribute type not implemented yet.",
+                                                        Level::Error,
+                                                        Stage::Semantic,
+                                                        { Label("", { x.base.base.loc }) }));
                                     throw SemanticAbort();
                                 }
                             } else {
                                 std::string sym = to_lower(s.m_name);
-                                if (sa->m_attr == AST::simple_attributeType
-                                        ::AttrPrivate) {
+                                if (sa->m_attr == AST::simple_attributeType ::AttrPrivate) {
                                     ASR::symbol_t* sym_ = current_scope->get_symbol(sym);
                                     if (!sym_) {
                                         assgnd_access[sym] = ASR::accessType::Private;
                                     } else {
                                         sym_ = ASRUtils::symbol_get_past_external(sym_);
                                         if (ASR::is_a<ASR::Variable_t>(*sym_)) {
-                                            ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym_);
+                                            ASR::Variable_t* v
+                                                = ASR::down_cast<ASR::Variable_t>(sym_);
                                             v->m_access = ASR::accessType::Private;
                                         } else if (ASR::is_a<ASR::Function_t>(*sym_)) {
-                                            ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(sym_);
+                                            ASR::Function_t* f
+                                                = ASR::down_cast<ASR::Function_t>(sym_);
                                             f->m_access = ASR::accessType::Private;
                                         }
                                     }
-                                } else if (sa->m_attr == AST::simple_attributeType
-                                        ::AttrPublic) {
+                                } else if (sa->m_attr == AST::simple_attributeType ::AttrPublic) {
                                     ASR::symbol_t* sym_ = current_scope->get_symbol(sym);
                                     if (!sym_) {
                                         assgnd_access[sym] = ASR::accessType::Public;
                                     } else {
                                         sym_ = ASRUtils::symbol_get_past_external(sym_);
                                         if (ASR::is_a<ASR::Variable_t>(*sym_)) {
-                                            ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym_);
+                                            ASR::Variable_t* v
+                                                = ASR::down_cast<ASR::Variable_t>(sym_);
                                             v->m_access = ASR::accessType::Public;
                                         } else if (ASR::is_a<ASR::Function_t>(*sym_)) {
-                                            ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(sym_);
+                                            ASR::Function_t* f
+                                                = ASR::down_cast<ASR::Function_t>(sym_);
                                             f->m_access = ASR::accessType::Public;
                                         }
                                     }
-                                } else if (sa->m_attr == AST::simple_attributeType
-                                                ::AttrParameter) {
+                                } else if (sa->m_attr
+                                           == AST::simple_attributeType ::AttrParameter) {
                                     ASR::symbol_t* sym_ = current_scope->get_symbol(sym);
                                     if (!sym_) {
-                                        assgnd_storage[sym] = std::make_pair(ASR::storage_typeType::Parameter, s.m_initializer);
+                                        assgnd_storage[sym] = std::make_pair(
+                                            ASR::storage_typeType::Parameter, s.m_initializer);
                                     } else {
                                         this->visit_expr(*s.m_initializer);
                                         ASR::expr_t* init_val = ASRUtils::EXPR(tmp);
                                         sym_ = ASRUtils::symbol_get_past_external(sym_);
                                         if (ASR::is_a<ASR::Variable_t>(*sym_)) {
-                                            ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym_);
+                                            ASR::Variable_t* v
+                                                = ASR::down_cast<ASR::Variable_t>(sym_);
                                             v->m_storage = ASR::storage_typeType::Parameter;
                                             if (ASR::is_a<ASR::RealConstant_t>(*init_val)) {
-                                                ASR::RealConstant_t* rc = ASR::down_cast<ASR::RealConstant_t>(init_val);
-                                                init_val = ASRUtils::EXPR(ASR::make_RealConstant_t(al, x.base.base.loc, rc->m_r, v->m_type));
-                                            } else if (ASR::is_a<ASR::IntegerConstant_t>(*init_val)) {
-                                                ASR::IntegerConstant_t* ic = ASR::down_cast<ASR::IntegerConstant_t>(init_val);
-                                                init_val = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, ic->m_n, v->m_type));
+                                                ASR::RealConstant_t* rc
+                                                    = ASR::down_cast<ASR::RealConstant_t>(init_val);
+                                                init_val = ASRUtils::EXPR(ASR::make_RealConstant_t(
+                                                    al, x.base.base.loc, rc->m_r, v->m_type));
+                                            } else if (ASR::is_a<ASR::IntegerConstant_t>(
+                                                           *init_val)) {
+                                                ASR::IntegerConstant_t* ic
+                                                    = ASR::down_cast<ASR::IntegerConstant_t>(
+                                                        init_val);
+                                                init_val
+                                                    = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                                        al, x.base.base.loc, ic->m_n, v->m_type));
                                             }
                                             v->m_symbolic_value = init_val;
                                             v->m_value = ASRUtils::expr_value(init_val);
                                             SetChar variable_dependencies_vec;
                                             variable_dependencies_vec.reserve(al, 1);
-                                            ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, v->m_type, v->m_symbolic_value, v->m_value);
+                                            ASRUtils::collect_variable_dependencies(
+                                                al,
+                                                variable_dependencies_vec,
+                                                v->m_type,
+                                                v->m_symbolic_value,
+                                                v->m_value);
                                             v->m_dependencies = variable_dependencies_vec.p;
                                             v->n_dependencies = variable_dependencies_vec.size();
                                         }
                                     }
-                                } else if (sa->m_attr == AST::simple_attributeType
-                                        ::AttrOptional) {
+                                } else if (sa->m_attr == AST::simple_attributeType ::AttrOptional) {
                                     ASR::symbol_t* sym_ = current_scope->get_symbol(sym);
                                     if (!sym_) {
                                         assgnd_presence[sym] = ASR::presenceType::Optional;
                                     } else {
-                                        ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(
+                                        ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(
                                             ASRUtils::symbol_get_past_external(sym_));
                                         v->m_presence = ASR::presenceType::Optional;
                                     }
-                                } else if(sa->m_attr == AST::simple_attributeType
-                                        ::AttrIntrinsic) {
+                                } else if (sa->m_attr
+                                           == AST::simple_attributeType ::AttrIntrinsic) {
                                     explicit_intrinsic_procedures.push_back(sym);
-                                } else if (sa->m_attr == AST::simple_attributeType
-                                        ::AttrExternal) {
+                                } else if (sa->m_attr == AST::simple_attributeType ::AttrExternal) {
                                     create_external_function(sym, x.m_syms[i].loc);
-                                } else if (sa->m_attr == AST::simple_attributeType
-                                        ::AttrSave) {
+                                } else if (sa->m_attr == AST::simple_attributeType ::AttrSave) {
                                     ASR::symbol_t* sym_ = current_scope->get_symbol(sym);
                                     if (!sym_) {
                                         if (compiler_options.implicit_typing) {
-                                            ASR::ttype_t* type = implicit_dictionary[std::string(1,sym[0])];
+                                            ASR::ttype_t* type
+                                                = implicit_dictionary[std::string(1, sym[0])];
                                             if (type) {
-                                                sym_ = declare_implicit_variable(x.m_syms[i].loc, sym, ASR::intentType::Local);
-                                                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym_);
+                                                sym_ = declare_implicit_variable(
+                                                    x.m_syms[i].loc, sym, ASR::intentType::Local);
+                                                ASR::Variable_t* v
+                                                    = ASR::down_cast<ASR::Variable_t>(sym_);
                                                 v->m_storage = ASR::storage_typeType::Save;
                                             } else {
                                                 // there exists an `implicit none` statement
                                                 diag.add(Diagnostic(
                                                     "Save `" + sym + "` has no IMPLICIT Type",
-                                                    Level::Error, Stage::Semantic, {
-                                                        Label("",{x.base.base.loc})
-                                                    }));
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                                 throw SemanticAbort();
                                             }
                                         } else {
                                             diag.add(Diagnostic(
-                                                "Save `" + sym + "` has no IMPLICIT Type, use `--implicit-typing`",
-                                                Level::Error, Stage::Semantic, {
-                                                    Label("",{x.base.base.loc})
-                                                }));
+                                                "Save `" + sym
+                                                    + "` has no IMPLICIT Type, use `--implicit-typing`",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                                             throw SemanticAbort();
                                         }
                                     } else {
-                                        ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym_);
+                                        ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(sym_);
                                         v->m_storage = ASR::storage_typeType::Save;
                                     }
-                                } else if (sa->m_attr == AST::simple_attributeType::AttrEnumerator) {
-                                    ASR::symbol_t *sym;
-                                    ASR::ttype_t *init_type = ASRUtils::TYPE(
-                                        ASR::make_Integer_t(al, x.m_syms[i].loc, compiler_options.po.default_integer_kind));
-                                    ASR::expr_t *init_expr = ASRUtils::EXPR(
-                                        ASR::make_IntegerConstant_t(al, x.m_syms[i].loc,
-                                        enum_init_val, init_type));
+                                } else if (sa->m_attr
+                                           == AST::simple_attributeType::AttrEnumerator) {
+                                    ASR::symbol_t* sym;
+                                    ASR::ttype_t* init_type = ASRUtils::TYPE(ASR::make_Integer_t(
+                                        al,
+                                        x.m_syms[i].loc,
+                                        compiler_options.po.default_integer_kind));
+                                    ASR::expr_t* init_expr
+                                        = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                            al, x.m_syms[i].loc, enum_init_val, init_type));
                                     if (x.m_syms[i].m_sym == AST::symbolType::Equal) {
                                         this->visit_expr(*x.m_syms[i].m_initializer);
                                         init_expr = ASRUtils::expr_value(ASRUtils::EXPR(tmp));
-                                        if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(init_expr))) {
+                                        if (!ASR::is_a<ASR::Integer_t>(
+                                                *ASRUtils::expr_type(init_expr))) {
                                             diag.add(Diagnostic(
                                                 "Enumerator must be initialized with an integer expression",
-                                                Level::Error, Stage::Semantic, {
-                                                    Label("",{x.m_syms[i].loc})
-                                                }));
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.m_syms[i].loc }) }));
                                             throw SemanticAbort();
                                         }
                                         if (ASR::is_a<ASR::IntegerConstant_t>(*init_expr)) {
-                                            enum_init_val = ASR::down_cast<
-                                                ASR::IntegerConstant_t>(init_expr)->m_n;
+                                            enum_init_val
+                                                = ASR::down_cast<ASR::IntegerConstant_t>(init_expr)
+                                                      ->m_n;
                                         } else {
-                                            LCOMPILERS_ASSERT(false); // TODO
+                                            LCOMPILERS_ASSERT(false);  // TODO
                                         }
                                     }
                                     ASR::expr_t* init_expr_value = ASRUtils::expr_value(init_expr);
-                                    if( init_expr && !ASRUtils::is_value_constant(init_expr_value) ) {
+                                    if (init_expr
+                                        && !ASRUtils::is_value_constant(init_expr_value)) {
                                         diag.add(Diagnostic(
-                                            "Initialization of `" + std::string(x.m_syms[i].m_name) +
-                                            "` must reduce to a compile time constant.",
-                                            Level::Error, Stage::Semantic, {
-                                                Label("",{x.m_syms[i].loc})
-                                            }));
+                                            "Initialization of `" + std::string(x.m_syms[i].m_name)
+                                                + "` must reduce to a compile time constant.",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.m_syms[i].loc }) }));
                                         throw SemanticAbort();
                                     }
-                                    sym = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(
-                                        al, x.m_syms[i].loc, current_scope,
-                                        s2c(al, to_lower(x.m_syms[i].m_name)), nullptr, 0, ASR::intentType::Local,
-                                        init_expr, init_expr_value, ASR::storage_typeType::Parameter,
-                                        init_type, nullptr, ASR::abiType::Source, ASR::accessType::Public,
-                                        ASR::presenceType::Required, false, false));
-                                    current_scope->add_symbol(s2c(al, to_lower(x.m_syms[i].m_name)), sym);
+                                    sym = ASR::down_cast<ASR::symbol_t>(
+                                        ASRUtils::make_Variable_t_util(
+                                            al,
+                                            x.m_syms[i].loc,
+                                            current_scope,
+                                            s2c(al, to_lower(x.m_syms[i].m_name)),
+                                            nullptr,
+                                            0,
+                                            ASR::intentType::Local,
+                                            init_expr,
+                                            init_expr_value,
+                                            ASR::storage_typeType::Parameter,
+                                            init_type,
+                                            nullptr,
+                                            ASR::abiType::Source,
+                                            ASR::accessType::Public,
+                                            ASR::presenceType::Required,
+                                            false,
+                                            false));
+                                    current_scope->add_symbol(s2c(al, to_lower(x.m_syms[i].m_name)),
+                                                              sym);
                                     enum_init_val++;
                                 } else {
-                                    diag.add(Diagnostic(
-                                        "Attribute declaration not supported",
-                                        Level::Error, Stage::Semantic, {
-                                            Label("",{x.base.base.loc})
-                                        }));
+                                    diag.add(Diagnostic("Attribute declaration not supported",
+                                                        Level::Error,
+                                                        Stage::Semantic,
+                                                        { Label("", { x.base.base.loc }) }));
                                     throw SemanticAbort();
                                 }
                                 ASR::symbol_t* sym_ = current_scope->resolve_symbol(sym);
-                                if (!sym_ && compiler_options.implicit_typing &&
-                                    sa->m_attr != AST::simple_attributeType::AttrExternal
-                                ) {
+                                if (!sym_ && compiler_options.implicit_typing
+                                    && sa->m_attr != AST::simple_attributeType::AttrExternal) {
                                     ASR::expr_t* value = nullptr;
                                     if (sa->m_attr == AST::simple_attributeType::AttrParameter) {
                                         this->visit_expr(*s.m_initializer);
                                         value = ASRUtils::EXPR(tmp);
                                     }
-                                    if ( implicit_dictionary[std::string(1, sym[0])] != nullptr ) {
-                                        sym_ = declare_implicit_variable2(x.m_syms[i].loc, sym, ASR::intentType::Local, implicit_dictionary[std::string(1, sym[0])], value);
+                                    if (implicit_dictionary[std::string(1, sym[0])] != nullptr) {
+                                        sym_ = declare_implicit_variable2(
+                                            x.m_syms[i].loc,
+                                            sym,
+                                            ASR::intentType::Local,
+                                            implicit_dictionary[std::string(1, sym[0])],
+                                            value);
                                     }
                                 }
                             }
                         }
                     }
-		    // enable sole `dimension` attribute
-        } else if (AST::is_a<AST::AttrDimension_t>(*x.m_attributes[i])) {
-            for (size_t i=0;i<x.n_syms;++i) { // symbols for line only
-                AST::var_sym_t &s = x.m_syms[i];
-                dimension_variable(s, x.base.base.loc);
-            }
-		} else if (AST::is_a<AST::AttrCommon_t>(*x.m_attributes[i])) {
-		    AST::AttrCommon_t const & common_stmt =
-			*AST::down_cast<AST::AttrCommon_t>(x.m_attributes[i]);
-		    constexpr char BLANK_BLOCK[] = "blank#block";
-		    std::string common_block_name;
-		    /* Local dictionary to aggregate objects into:
-		       "COMMON A /B1/ B, // C", will put "A" and "C"
-		       in the blank block.  This should be done for
-		       the entire declaration-construct. */
-		    common_block_varsyms objs_by_blk;
-		    for (size_t bi = 0; bi < common_stmt.n_blks; ++bi) {
-			AST::common_block_t const &cb = common_stmt.m_blks[bi];
-			if (cb.m_name) {
-			    common_block_name = to_lower(cb.m_name);
-			} else {
-			    common_block_name = BLANK_BLOCK;
-			}
-
-			// Aggregate the objects into their named common blocks
-			for (size_t oi = 0; oi < cb.n_objects; ++oi) {
-			    AST::var_sym_t const & vs = cb.m_objects[oi];
-			    objs_by_blk[common_block_name].push_back(vs);
-			    if (vs.n_dim) {
-				/* Treat this as a dimension statement. */
-				dimension_variable(vs, x.base.base.loc);
-			    }
-			}
-		    }
-		    populate_common_dictionary(x, objs_by_blk);
-		} else if (AST::is_a<AST::AttrEquivalence_t>(*x.m_attributes[i])) {
-                    AST::AttrEquivalence_t *eq = AST::down_cast<AST::AttrEquivalence_t>(x.m_attributes[i]);
+                    // enable sole `dimension` attribute
+                } else if (AST::is_a<AST::AttrDimension_t>(*x.m_attributes[i])) {
+                    for (size_t i = 0; i < x.n_syms; ++i) {  // symbols for line only
+                        AST::var_sym_t& s = x.m_syms[i];
+                        dimension_variable(s, x.base.base.loc);
+                    }
+                } else if (AST::is_a<AST::AttrCommon_t>(*x.m_attributes[i])) {
+                    AST::AttrCommon_t const& common_stmt
+                        = *AST::down_cast<AST::AttrCommon_t>(x.m_attributes[i]);
+                    constexpr char BLANK_BLOCK[] = "blank#block";
+                    std::string common_block_name;
+                    /* Local dictionary to aggregate objects into:
+                       "COMMON A /B1/ B, // C", will put "A" and "C"
+                       in the blank block.  This should be done for
+                       the entire declaration-construct. */
+                    common_block_varsyms objs_by_blk;
+                    for (size_t bi = 0; bi < common_stmt.n_blks; ++bi) {
+                        AST::common_block_t const& cb = common_stmt.m_blks[bi];
+                        if (cb.m_name) {
+                            common_block_name = to_lower(cb.m_name);
+                        } else {
+                            common_block_name = BLANK_BLOCK;
+                        }
+
+                        // Aggregate the objects into their named common blocks
+                        for (size_t oi = 0; oi < cb.n_objects; ++oi) {
+                            AST::var_sym_t const& vs = cb.m_objects[oi];
+                            objs_by_blk[common_block_name].push_back(vs);
+                            if (vs.n_dim) {
+                                /* Treat this as a dimension statement. */
+                                dimension_variable(vs, x.base.base.loc);
+                            }
+                        }
+                    }
+                    populate_common_dictionary(x, objs_by_blk);
+                } else if (AST::is_a<AST::AttrEquivalence_t>(*x.m_attributes[i])) {
+                    AST::AttrEquivalence_t* eq
+                        = AST::down_cast<AST::AttrEquivalence_t>(x.m_attributes[i]);
                     int eq_n_args = eq->n_args;
                     for (int i = 0; i < eq_n_args; i++) {
                         if (eq->m_args[i].n_set_list == 2) {
-                            AST::expr_t *eq1 = eq->m_args[i].m_set_list[0];
-                            AST::expr_t *eq2 = eq->m_args[i].m_set_list[1];
+                            AST::expr_t* eq1 = eq->m_args[i].m_set_list[0];
+                            AST::expr_t* eq2 = eq->m_args[i].m_set_list[1];
                             this->visit_expr(*eq1);
                             ASR::expr_t* asr_eq1 = ASRUtils::EXPR(tmp);
                             this->visit_expr(*eq2);
                             ASR::expr_t* asr_eq2 = ASRUtils::EXPR(tmp);
 
-                            if (AST::is_a<AST::FuncCallOrArray_t>(*eq1) && AST::is_a<AST::FuncCallOrArray_t>(*eq2)) {
+                            if (AST::is_a<AST::FuncCallOrArray_t>(*eq1)
+                                && AST::is_a<AST::FuncCallOrArray_t>(*eq2)) {
                                 ASR::ttype_t* arg_type1 = ASRUtils::type_get_past_allocatable(
-                                            ASRUtils::type_get_past_pointer(ASRUtils::expr_type(asr_eq1)));
-                                ASR::ttype_t* pointer_type_ = ASRUtils::TYPE(ASR::make_Pointer_t(al, asr_eq1->base.loc, ASRUtils::type_get_past_array(arg_type1)));
-                                ASR::asr_t* get_pointer = ASR::make_GetPointer_t(al, asr_eq1->base.loc, asr_eq1, pointer_type_, nullptr);
-                                ASR::ttype_t *cptr = ASRUtils::TYPE(ASR::make_CPtr_t(al, asr_eq1->base.loc));
-                                ASR::asr_t* pointer_to_cptr = ASR::make_PointerToCPtr_t(al, asr_eq1->base.loc, ASRUtils::EXPR(get_pointer), cptr, nullptr);
-
-                                ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, asr_eq1->base.loc, compiler_options.po.default_integer_kind));
-                                ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, asr_eq1->base.loc, 1, int_type));
+                                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(asr_eq1)));
+                                ASR::ttype_t* pointer_type_ = ASRUtils::TYPE(
+                                    ASR::make_Pointer_t(al,
+                                                        asr_eq1->base.loc,
+                                                        ASRUtils::type_get_past_array(arg_type1)));
+                                ASR::asr_t* get_pointer = ASR::make_GetPointer_t(
+                                    al, asr_eq1->base.loc, asr_eq1, pointer_type_, nullptr);
+                                ASR::ttype_t* cptr
+                                    = ASRUtils::TYPE(ASR::make_CPtr_t(al, asr_eq1->base.loc));
+                                ASR::asr_t* pointer_to_cptr
+                                    = ASR::make_PointerToCPtr_t(al,
+                                                                asr_eq1->base.loc,
+                                                                ASRUtils::EXPR(get_pointer),
+                                                                cptr,
+                                                                nullptr);
+
+                                ASR::ttype_t* int_type = ASRUtils::TYPE(
+                                    ASR::make_Integer_t(al,
+                                                        asr_eq1->base.loc,
+                                                        compiler_options.po.default_integer_kind));
+                                ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                    al, asr_eq1->base.loc, 1, int_type));
 
                                 Vec<ASR::dimension_t> dim;
                                 dim.reserve(al, 1);
                                 ASR::dimension_t dim_;
-                                dim_.m_length = nullptr; dim_.m_start = nullptr;
+                                dim_.m_length = nullptr;
+                                dim_.m_start = nullptr;
                                 dim_.m_start = one;
                                 dim_.m_length = one;
                                 dim_.loc = asr_eq1->base.loc;
                                 dim.push_back(al, dim_);
 
-                                ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(asr_eq2);
+                                ASR::ArrayItem_t* array_item
+                                    = ASR::down_cast<ASR::ArrayItem_t>(asr_eq2);
                                 ASR::expr_t* array = array_item->m_v;
                                 ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(array);
-                                ASR::Variable_t *var__ = ASR::down_cast<ASR::Variable_t>(var->m_v);
+                                ASR::Variable_t* var__ = ASR::down_cast<ASR::Variable_t>(var->m_v);
                                 std::string name = var__->m_name;
                                 ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(var__->m_type);
                                 ASR::ttype_t* type = nullptr;
                                 ASR::ttype_t* arg_type2 = ASRUtils::type_get_past_allocatable(
-                                            ASRUtils::type_get_past_pointer(ASRUtils::expr_type(asr_eq2)));
+                                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(asr_eq2)));
 
-                                Vec<ASR::dimension_t> dim2; dim2.reserve(al, arr->n_dims);
+                                Vec<ASR::dimension_t> dim2;
+                                dim2.reserve(al, arr->n_dims);
                                 for (size_t i = 0; i < arr->n_dims; i++) {
-                                    ASR::dimension_t dim2_; dim2_.m_start = nullptr; dim2_.m_length = nullptr;
+                                    ASR::dimension_t dim2_;
+                                    dim2_.m_start = nullptr;
+                                    dim2_.m_length = nullptr;
                                     dim2_.loc = asr_eq2->base.loc;
                                     dim2.push_back(al, dim2_);
                                 }
 
                                 if (ASR::is_a<ASR::Integer_t>(*arg_type2)) {
-                                    type = ASRUtils::TYPE(ASR::make_Integer_t(al, asr_eq2->base.loc, compiler_options.po.default_integer_kind));
+                                    type = ASRUtils::TYPE(ASR::make_Integer_t(
+                                        al,
+                                        asr_eq2->base.loc,
+                                        compiler_options.po.default_integer_kind));
                                 } else if (ASR::is_a<ASR::Real_t>(*arg_type2)) {
-                                    type = ASRUtils::TYPE(ASR::make_Real_t(al, asr_eq2->base.loc, 4));
+                                    type = ASRUtils::TYPE(
+                                        ASR::make_Real_t(al, asr_eq2->base.loc, 4));
                                 } else {
                                     diag.semantic_warning_label(
                                         "This equivalence statement is not implemented yet, for now we will ignore it",
-                                        {x.base.base.loc},
-                                        "ignored for now"
-                                    );
+                                        { x.base.base.loc },
+                                        "ignored for now");
                                 }
-                                type = ASRUtils::make_Array_t_util(al, asr_eq2->base.loc, type, dim2.p, dim2.size(), ASR::abiType::Source, false, ASR::array_physical_typeType::DescriptorArray, false, false);
-                                ASR::ttype_t* ptr = ASRUtils::TYPE(ASR::make_Pointer_t(al, asr_eq2->base.loc, type));
+                                type = ASRUtils::make_Array_t_util(
+                                    al,
+                                    asr_eq2->base.loc,
+                                    type,
+                                    dim2.p,
+                                    dim2.size(),
+                                    ASR::abiType::Source,
+                                    false,
+                                    ASR::array_physical_typeType::DescriptorArray,
+                                    false,
+                                    false);
+                                ASR::ttype_t* ptr = ASRUtils::TYPE(
+                                    ASR::make_Pointer_t(al, asr_eq2->base.loc, type));
                                 var__->m_type = ptr;
 
                                 Vec<ASR::expr_t*> args;
                                 args.reserve(al, arr->n_dims);
                                 for (size_t i = 0; i < arr->n_dims; i++) {
-                                    ASR::IntegerConstant_t* ic = ASR::down_cast<ASR::IntegerConstant_t>(arr->m_dims[i].m_length);
-                                    ASR::expr_t* size = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, asr_eq1->base.loc, ic->m_n, int_type));
+                                    ASR::IntegerConstant_t* ic
+                                        = ASR::down_cast<ASR::IntegerConstant_t>(
+                                            arr->m_dims[i].m_length);
+                                    ASR::expr_t* size = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                        al, asr_eq1->base.loc, ic->m_n, int_type));
                                     args.push_back(al, size);
                                 }
 
-                                ASR::ttype_t* array_type = ASRUtils::TYPE(ASR::make_Array_t(al, asr_eq1->base.loc, int_type, dim.p, dim.size(), ASR::array_physical_typeType::PointerArray));
-                                ASR::asr_t* array_constant = ASRUtils::make_ArrayConstructor_t_util(al, asr_eq1->base.loc, args.p, args.size(), array_type, ASR::arraystorageType::ColMajor);
-                                ASR::asr_t* c_f_pointer = ASR::make_CPtrToPointer_t(al, asr_eq1->base.loc, ASRUtils::EXPR(pointer_to_cptr), ASR::down_cast<ASR::ArrayItem_t>(asr_eq2)->m_v, ASRUtils::EXPR(array_constant), nullptr);
-
-                                ASR::stmt_t *stmt = ASRUtils::STMT(c_f_pointer);
+                                ASR::ttype_t* array_type = ASRUtils::TYPE(
+                                    ASR::make_Array_t(al,
+                                                      asr_eq1->base.loc,
+                                                      int_type,
+                                                      dim.p,
+                                                      dim.size(),
+                                                      ASR::array_physical_typeType::PointerArray));
+                                ASR::asr_t* array_constant = ASRUtils::make_ArrayConstructor_t_util(
+                                    al,
+                                    asr_eq1->base.loc,
+                                    args.p,
+                                    args.size(),
+                                    array_type,
+                                    ASR::arraystorageType::ColMajor);
+                                ASR::asr_t* c_f_pointer = ASR::make_CPtrToPointer_t(
+                                    al,
+                                    asr_eq1->base.loc,
+                                    ASRUtils::EXPR(pointer_to_cptr),
+                                    ASR::down_cast<ASR::ArrayItem_t>(asr_eq2)->m_v,
+                                    ASRUtils::EXPR(array_constant),
+                                    nullptr);
+
+                                ASR::stmt_t* stmt = ASRUtils::STMT(c_f_pointer);
                                 data_structure[current_scope->counter].push_back(stmt);
                             } else {
                                 if (AST::is_a<AST::FuncCallOrArray_t>(*eq1)) {
                                     ASR::ttype_t* arg_type1 = ASRUtils::type_get_past_allocatable(
-                                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(asr_eq1)));
-                                    ASR::ttype_t* pointer_type_ = ASRUtils::TYPE(ASR::make_Pointer_t(al, asr_eq1->base.loc, ASRUtils::type_get_past_array(arg_type1)));
-                                    ASR::asr_t* get_pointer = ASR::make_GetPointer_t(al, asr_eq1->base.loc, asr_eq1, pointer_type_, nullptr);
-                                    ASR::ttype_t *cptr = ASRUtils::TYPE(ASR::make_CPtr_t(al, asr_eq1->base.loc));
-                                    ASR::asr_t* pointer_to_cptr = ASR::make_PointerToCPtr_t(al, asr_eq1->base.loc, ASRUtils::EXPR(get_pointer), cptr, nullptr);
+                                        ASRUtils::type_get_past_pointer(
+                                            ASRUtils::expr_type(asr_eq1)));
+                                    ASR::ttype_t* pointer_type_
+                                        = ASRUtils::TYPE(ASR::make_Pointer_t(
+                                            al,
+                                            asr_eq1->base.loc,
+                                            ASRUtils::type_get_past_array(arg_type1)));
+                                    ASR::asr_t* get_pointer = ASR::make_GetPointer_t(
+                                        al, asr_eq1->base.loc, asr_eq1, pointer_type_, nullptr);
+                                    ASR::ttype_t* cptr
+                                        = ASRUtils::TYPE(ASR::make_CPtr_t(al, asr_eq1->base.loc));
+                                    ASR::asr_t* pointer_to_cptr
+                                        = ASR::make_PointerToCPtr_t(al,
+                                                                    asr_eq1->base.loc,
+                                                                    ASRUtils::EXPR(get_pointer),
+                                                                    cptr,
+                                                                    nullptr);
 
                                     ASR::ttype_t* arg_type2 = ASRUtils::expr_type(asr_eq2);
                                     ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(asr_eq2);
-                                    ASR::Variable_t *var__ = ASR::down_cast<ASR::Variable_t>(var->m_v);
+                                    ASR::Variable_t* var__
+                                        = ASR::down_cast<ASR::Variable_t>(var->m_v);
                                     ASR::ttype_t* type = nullptr;
                                     if (ASR::is_a<ASR::Real_t>(*arg_type2)) {
-                                        type = ASRUtils::TYPE(ASR::make_Real_t(al, asr_eq2->base.loc, 4));
+                                        type = ASRUtils::TYPE(
+                                            ASR::make_Real_t(al, asr_eq2->base.loc, 4));
                                     } else if (ASR::is_a<ASR::Integer_t>(*arg_type2)) {
-                                        type = ASRUtils::TYPE(ASR::make_Integer_t(al, asr_eq2->base.loc, compiler_options.po.default_integer_kind));
+                                        type = ASRUtils::TYPE(ASR::make_Integer_t(
+                                            al,
+                                            asr_eq2->base.loc,
+                                            compiler_options.po.default_integer_kind));
                                     } else {
                                         diag.semantic_warning_label(
                                             "This equivalence statement is not implemented yet, for now we will ignore it",
-                                            {x.base.base.loc},
-                                            "ignored for now"
-                                        );
+                                            { x.base.base.loc },
+                                            "ignored for now");
                                     }
-                                    ASR::ttype_t* ptr = ASRUtils::TYPE(ASR::make_Pointer_t(al, asr_eq2->base.loc, type));
+                                    ASR::ttype_t* ptr = ASRUtils::TYPE(
+                                        ASR::make_Pointer_t(al, asr_eq2->base.loc, type));
                                     var__->m_type = ptr;
 
-                                    ASR::asr_t* c_f_pointer = ASR::make_CPtrToPointer_t(al, asr_eq1->base.loc, ASRUtils::EXPR(pointer_to_cptr),asr_eq2, nullptr, nullptr);
-                                    ASR::stmt_t *stmt = ASRUtils::STMT(c_f_pointer);
+                                    ASR::asr_t* c_f_pointer
+                                        = ASR::make_CPtrToPointer_t(al,
+                                                                    asr_eq1->base.loc,
+                                                                    ASRUtils::EXPR(pointer_to_cptr),
+                                                                    asr_eq2,
+                                                                    nullptr,
+                                                                    nullptr);
+                                    ASR::stmt_t* stmt = ASRUtils::STMT(c_f_pointer);
                                     data_structure[current_scope->counter].push_back(stmt);
                                 } else if (AST::is_a<AST::FuncCallOrArray_t>(*eq2)) {
                                     ASR::ttype_t* arg_type2 = ASRUtils::type_get_past_allocatable(
-                                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(asr_eq2)));
-                                    ASR::ttype_t* pointer_type_ = ASRUtils::TYPE(ASR::make_Pointer_t(al, asr_eq2->base.loc, ASRUtils::type_get_past_array(arg_type2)));
-                                    ASR::asr_t* get_pointer = ASR::make_GetPointer_t(al, asr_eq2->base.loc, asr_eq2, pointer_type_, nullptr);
-                                    ASR::ttype_t *cptr = ASRUtils::TYPE(ASR::make_CPtr_t(al, asr_eq2->base.loc));
-                                    ASR::asr_t* pointer_to_cptr = ASR::make_PointerToCPtr_t(al, asr_eq2->base.loc, ASRUtils::EXPR(get_pointer), cptr, nullptr);
+                                        ASRUtils::type_get_past_pointer(
+                                            ASRUtils::expr_type(asr_eq2)));
+                                    ASR::ttype_t* pointer_type_
+                                        = ASRUtils::TYPE(ASR::make_Pointer_t(
+                                            al,
+                                            asr_eq2->base.loc,
+                                            ASRUtils::type_get_past_array(arg_type2)));
+                                    ASR::asr_t* get_pointer = ASR::make_GetPointer_t(
+                                        al, asr_eq2->base.loc, asr_eq2, pointer_type_, nullptr);
+                                    ASR::ttype_t* cptr
+                                        = ASRUtils::TYPE(ASR::make_CPtr_t(al, asr_eq2->base.loc));
+                                    ASR::asr_t* pointer_to_cptr
+                                        = ASR::make_PointerToCPtr_t(al,
+                                                                    asr_eq2->base.loc,
+                                                                    ASRUtils::EXPR(get_pointer),
+                                                                    cptr,
+                                                                    nullptr);
 
                                     ASR::ttype_t* arg_type1 = ASRUtils::expr_type(asr_eq1);
                                     ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(asr_eq1);
-                                    ASR::Variable_t *var__ = ASR::down_cast<ASR::Variable_t>(var->m_v);
+                                    ASR::Variable_t* var__
+                                        = ASR::down_cast<ASR::Variable_t>(var->m_v);
                                     ASR::ttype_t* type = nullptr;
                                     if (ASR::is_a<ASR::Real_t>(*arg_type1)) {
-                                        type = ASRUtils::TYPE(ASR::make_Real_t(al, asr_eq1->base.loc, 4));
+                                        type = ASRUtils::TYPE(
+                                            ASR::make_Real_t(al, asr_eq1->base.loc, 4));
                                     } else if (ASR::is_a<ASR::Integer_t>(*arg_type1)) {
-                                        type = ASRUtils::TYPE(ASR::make_Integer_t(al, asr_eq1->base.loc, compiler_options.po.default_integer_kind));
+                                        type = ASRUtils::TYPE(ASR::make_Integer_t(
+                                            al,
+                                            asr_eq1->base.loc,
+                                            compiler_options.po.default_integer_kind));
                                     } else {
                                         diag.semantic_warning_label(
                                             "This equivalence statement is not implemented yet, for now we will ignore it",
-                                            {x.base.base.loc},
-                                            "ignored for now"
-                                        );
+                                            { x.base.base.loc },
+                                            "ignored for now");
                                     }
-                                    ASR::ttype_t* ptr = ASRUtils::TYPE(ASR::make_Pointer_t(al, asr_eq1->base.loc, type));
+                                    ASR::ttype_t* ptr = ASRUtils::TYPE(
+                                        ASR::make_Pointer_t(al, asr_eq1->base.loc, type));
                                     var__->m_type = ptr;
 
-                                    ASR::asr_t* c_f_pointer = ASR::make_CPtrToPointer_t(al, asr_eq2->base.loc, ASRUtils::EXPR(pointer_to_cptr),asr_eq1, nullptr, nullptr);
-                                    ASR::stmt_t *stmt = ASRUtils::STMT(c_f_pointer);
+                                    ASR::asr_t* c_f_pointer
+                                        = ASR::make_CPtrToPointer_t(al,
+                                                                    asr_eq2->base.loc,
+                                                                    ASRUtils::EXPR(pointer_to_cptr),
+                                                                    asr_eq1,
+                                                                    nullptr,
+                                                                    nullptr);
+                                    ASR::stmt_t* stmt = ASRUtils::STMT(c_f_pointer);
                                     data_structure[current_scope->counter].push_back(stmt);
                                 } else {
                                     diag.semantic_warning_label(
                                         "This equivalence statement is not implemented yet, for now we will ignore it",
-                                        {x.base.base.loc},
-                                        "ignored for now"
-                                    );
+                                        { x.base.base.loc },
+                                        "ignored for now");
                                 }
                             }
                         } else {
                             diag.semantic_warning_label(
                                 "This equivalence statement is not implemented yet, for now we will ignore it",
-                                {x.base.base.loc},
-                                "ignored for now"
-                            );
+                                { x.base.base.loc },
+                                "ignored for now");
                         }
                     }
                 } else if (AST::is_a<AST::AttrIntent_t>(*x.m_attributes[i])) {
                     AST::AttrIntent_t* ai = AST::down_cast<AST::AttrIntent_t>(x.m_attributes[i]);
                     ASR::intentType s_intent;
                     switch (ai->m_intent) {
-                        case (AST::attr_intentType::In) : {
+                        case (AST::attr_intentType::In): {
                             s_intent = ASRUtils::intent_in;
                             break;
                         }
-                        case (AST::attr_intentType::Out) : {
+                        case (AST::attr_intentType::Out): {
                             s_intent = ASRUtils::intent_out;
                             break;
                         }
-                        case (AST::attr_intentType::InOut) : {
+                        case (AST::attr_intentType::InOut): {
                             s_intent = ASRUtils::intent_inout;
                             break;
                         }
-                        default : {
+                        default: {
                             s_intent = ASRUtils::intent_unspecified;
                             break;
                         }
@@ -3731,30 +4471,30 @@ public:
                     AST::var_sym_t* s = x.m_syms;
                     std::string sym = to_lower(s->m_name);
                     ASR::symbol_t* orig_decl = current_scope->get_symbol(sym);
-                    if ( orig_decl && ASR::is_a<ASR::Variable_t>(*orig_decl) ) {
-                        ASR::Variable_t* orig_decl_variable = ASR::down_cast<ASR::Variable_t>(orig_decl);
+                    if (orig_decl && ASR::is_a<ASR::Variable_t>(*orig_decl)) {
+                        ASR::Variable_t* orig_decl_variable
+                            = ASR::down_cast<ASR::Variable_t>(orig_decl);
                         orig_decl_variable->m_intent = s_intent;
                     }
                 } else {
-                    diag.add(Diagnostic(
-                        "Attribute declaration not supported",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{x.base.base.loc})
-                        }));
+                    diag.add(Diagnostic("Attribute declaration not supported",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             }
         } else {
             // Example
             // real(dp), private :: x, y(3), z
-            for (size_t i=0; i<x.n_syms; i++) {
+            for (size_t i = 0; i < x.n_syms; i++) {
                 bool is_save = false;
                 bool implicit_save = false;
                 bool is_compile_time = false;
                 bool is_implicitly_declared = false;
                 bool is_dimension_star = false;
                 bool is_assumed_rank = false;
-                AST::var_sym_t &s = x.m_syms[i];
+                AST::var_sym_t& s = x.m_syms[i];
                 std::string sym = to_lower(s.m_name);
                 bool is_external = check_is_external(sym);
                 bool is_attr_external = false;
@@ -3764,32 +4504,35 @@ public:
                 bool target_attr = false;
                 bool contig_attr = false;
                 bool value_attr = false;
-                char *bindc_name = nullptr;
+                char* bindc_name = nullptr;
                 bool is_volatile = false;
                 bool is_protected = false;
-                AST::AttrType_t *sym_type = nullptr;
+                AST::AttrType_t* sym_type = nullptr;
 
                 if (AST::is_a<AST::AttrType_t>(*x.m_vartype))
                     sym_type = AST::down_cast<AST::AttrType_t>(x.m_vartype);
                 else if (AST::is_a<AST::AttrTypeList_t>(*x.m_vartype))
-                    sym_type = AST::down_cast<AST::AttrType_t>(
-                                AST::down_cast<AST::decl_attribute_t>(
-                                    AST::make_AttrType_t(
-                                    al, x.m_vartype->base.loc, 
-                                    AST::decl_typeType::TypeType,
-                                    nullptr, 0, x.m_vartype, 
-                                    nullptr, AST::symbolType::None)));
+                    sym_type
+                        = AST::down_cast<AST::AttrType_t>(AST::down_cast<AST::decl_attribute_t>(
+                            AST::make_AttrType_t(al,
+                                                 x.m_vartype->base.loc,
+                                                 AST::decl_typeType::TypeType,
+                                                 nullptr,
+                                                 0,
+                                                 x.m_vartype,
+                                                 nullptr,
+                                                 AST::symbolType::None)));
 
                 LCOMPILERS_ASSERT(sym_type);
 
 
                 bool is_char_type = sym_type->m_type == AST::decl_typeType::TypeCharacter;
-               
+
                 bool is_allocatable = false;
                 for (size_t a = 0; a < x.n_attributes; a++) {
-                    AST::decl_attribute_t *attr = x.m_attributes[a];
+                    AST::decl_attribute_t* attr = x.m_attributes[a];
                     if (AST::is_a<AST::SimpleAttribute_t>(*attr)) {
-                        AST::SimpleAttribute_t *sa = AST::down_cast<AST::SimpleAttribute_t>(attr);
+                        AST::SimpleAttribute_t* sa = AST::down_cast<AST::SimpleAttribute_t>(attr);
                         if (sa->m_attr == AST::simple_attributeType::AttrAllocatable) {
                             is_allocatable = true;
                             break;
@@ -3797,7 +4540,8 @@ public:
                     }
                 }
 
-                if (is_char_type && sym_type->n_kind == ASR::string_length_kindType::DeferredLength &&  is_allocatable) {
+                if (is_char_type && sym_type->n_kind == ASR::string_length_kindType::DeferredLength
+                    && is_allocatable) {
                     bool has_fixed_shape = false;
                     for (size_t d = 0; d < s.n_dim; d++) {
                         if (s.m_dim[d].m_end != nullptr && s.m_dim[d].m_end_star == 0) {
@@ -3806,12 +4550,11 @@ public:
                         }
                     }
                     if (has_fixed_shape && s.n_dim > 0) {
-                        diag.add(Diagnostic(
-                            "Allocatable array '" + std::string(x.m_syms[0].m_name)
-                            + "' must have a deferred shape or assumed rank",
-                            Level::Error,Stage::Semantic,{ 
-                                Label("", { s.loc }) 
-                            }));
+                        diag.add(Diagnostic("Allocatable array '" + std::string(x.m_syms[0].m_name)
+                                                + "' must have a deferred shape or assumed rank",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { s.loc }) }));
                         throw SemanticAbort();
                     }
                 }
@@ -3826,26 +4569,27 @@ public:
                     s.m_initializer = assgnd_storage[sym].second;
                 }
                 bool is_pointer = false;
-                if (current_scope->get_symbol(sym) !=
-                        nullptr) {
+                if (current_scope->get_symbol(sym) != nullptr) {
                     if (current_scope->parent != nullptr && !is_external) {
-                        if ( compiler_options.implicit_typing && implicit_dictionary[std::string(1, sym[0])]!=nullptr ) {
+                        if (compiler_options.implicit_typing
+                            && implicit_dictionary[std::string(1, sym[0])] != nullptr) {
                             // sym is implicitly declared
                             is_implicitly_declared = true;
-                        } else if (pre_declared_array_dims.find(sym) != pre_declared_array_dims.end()) {
+                        } else if (pre_declared_array_dims.find(sym)
+                                   != pre_declared_array_dims.end()) {
                             // sym is implicitly declared
                             is_implicitly_declared = true;
                             pre_declared_array_dims[sym] = 2;
                         } else {
                             // re-declaring a global scope variable is allowed
                             // Otherwise raise an error
-                            ASR::symbol_t *orig_decl = current_scope->get_symbol(sym);
+                            ASR::symbol_t* orig_decl = current_scope->get_symbol(sym);
                             diag.add(Diagnostic(
                                 "Symbol is already declared in the same scope",
-                                Level::Error, Stage::Semantic, {
-                                    Label("redeclaration",{s.loc}),
-                                    Label("original declaration",{orig_decl->base.loc}, false)
-                                }));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("redeclaration", { s.loc }),
+                                  Label("original declaration", { orig_decl->base.loc }, false) }));
                             throw SemanticAbort();
                         }
                     }
@@ -3853,140 +4597,133 @@ public:
                 ASR::intentType s_intent;
                 bool is_argument = false;
                 if (std::find(current_procedure_args.begin(),
-                        current_procedure_args.end(), to_lower(s.m_name)) !=
-                        current_procedure_args.end()) {
+                              current_procedure_args.end(),
+                              to_lower(s.m_name))
+                    != current_procedure_args.end()) {
                     s_intent = ASRUtils::intent_unspecified;
                     is_argument = true;
                 } else {
                     s_intent = ASRUtils::intent_local;
                 }
-                ASR::abiType s_abi = is_argument ? current_procedure_abi_type : ASR::abiType::Source;
+                ASR::abiType s_abi
+                    = is_argument ? current_procedure_abi_type : ASR::abiType::Source;
                 Vec<ASR::dimension_t> dims;
                 dims.reserve(al, 0);
                 // location for dimension(...) if present
                 Location dims_attr_loc;
                 is_allocatable = false;
                 if (x.n_attributes > 0) {
-                    for (size_t i=0; i < x.n_attributes; i++) {
-                        AST::decl_attribute_t *a = x.m_attributes[i];
+                    for (size_t i = 0; i < x.n_attributes; i++) {
+                        AST::decl_attribute_t* a = x.m_attributes[i];
                         if (AST::is_a<AST::AttrIntent_t>(*a)) {
-                            AST::AttrIntent_t *ai =
-                                AST::down_cast<AST::AttrIntent_t>(a);
+                            AST::AttrIntent_t* ai = AST::down_cast<AST::AttrIntent_t>(a);
                             switch (ai->m_intent) {
-                                case (AST::attr_intentType::In) : {
+                                case (AST::attr_intentType::In): {
                                     s_intent = ASRUtils::intent_in;
                                     break;
                                 }
-                                case (AST::attr_intentType::Out) : {
+                                case (AST::attr_intentType::Out): {
                                     s_intent = ASRUtils::intent_out;
                                     break;
                                 }
-                                case (AST::attr_intentType::InOut) : {
+                                case (AST::attr_intentType::InOut): {
                                     s_intent = ASRUtils::intent_inout;
                                     break;
                                 }
-                                default : {
+                                default: {
                                     s_intent = ASRUtils::intent_unspecified;
                                     break;
                                 }
                             }
                         }
                     }
-                    for (size_t i=0; i < x.n_attributes; i++) {
-                        AST::decl_attribute_t *a = x.m_attributes[i];
+                    for (size_t i = 0; i < x.n_attributes; i++) {
+                        AST::decl_attribute_t* a = x.m_attributes[i];
                         if (AST::is_a<AST::SimpleAttribute_t>(*a)) {
-                            AST::SimpleAttribute_t *sa =
-                                AST::down_cast<AST::SimpleAttribute_t>(a);
-                            if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrPrivate) {
+                            AST::SimpleAttribute_t* sa = AST::down_cast<AST::SimpleAttribute_t>(a);
+                            if (sa->m_attr == AST::simple_attributeType ::AttrPrivate) {
                                 s_access = ASR::accessType::Private;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrPublic) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrPublic) {
                                 s_access = ASR::accessType::Public;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrSave) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrSave) {
                                 storage_type = ASR::storage_typeType::Save;
                                 is_save = true;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrParameter) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrParameter) {
                                 storage_type = ASR::storage_typeType::Parameter;
-                            } else if( sa->m_attr == AST::simple_attributeType
-                                    ::AttrAllocatable ) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrAllocatable) {
                                 is_allocatable = true;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrPointer) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrPointer) {
                                 is_pointer = true;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrOptional) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrOptional) {
                                 s_presence = ASR::presenceType::Optional;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrTarget) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrTarget) {
                                 target_attr = true;
                                 if (storage_type == ASR::storage_typeType::Parameter) {
                                     diag.add(Diagnostic(
                                         "Parameter attribute cannot be used with Target attribute",
-                                        Level::Error, Stage::Semantic, {
-                                            Label("",{x.base.base.loc})
-                                        }));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                                     throw SemanticAbort();
                                 }
                                 // Do nothing for now
-                            } else if (sa->m_attr == AST::AttrContiguous){
+                            } else if (sa->m_attr == AST::AttrContiguous) {
                                 contig_attr = true;
-                            } else if (sa->m_attr == AST::simple_attributeType
-                                    ::AttrValue) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrValue) {
                                 value_attr = true;
-                            } else if(sa->m_attr == AST::simple_attributeType
-                                    ::AttrIntrinsic) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrIntrinsic) {
                                 excluded_from_symtab.push_back(sym);
-                            } else if(sa->m_attr == AST::simple_attributeType
-                                    ::AttrExternal) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrExternal) {
                                 is_attr_external = true;
                                 assgnd_access[sym] = ASR::accessType::Public;
                                 if (assgnd_access.count(sym)) {
                                     s_access = assgnd_access[sym];
                                 }
                                 is_external = true;
-                            } else if(sa->m_attr == AST::simple_attributeType
-                                ::AttrNoPass) {
+                            } else if (sa->m_attr == AST::simple_attributeType ::AttrNoPass) {
                             } else if (sa->m_attr == AST::simple_attributeType::AttrVolatile) {
                                 is_volatile = true;
                             } else if (sa->m_attr == AST::simple_attributeType::AttrProtected) {
                                 is_protected = true;
                             } else {
-                                diag.add(Diagnostic(
-                                    "Attribute type not implemented yet " + std::to_string(sa->m_attr),
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{x.base.base.loc})
-                                    }));
+                                diag.add(Diagnostic("Attribute type not implemented yet "
+                                                        + std::to_string(sa->m_attr),
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                         } else if (AST::is_a<AST::AttrIntent_t>(*a)) {
                             // processed already
                         } else if (AST::is_a<AST::AttrDimension_t>(*a)) {
-                            AST::AttrDimension_t *ad =
-                                AST::down_cast<AST::AttrDimension_t>(a);
+                            AST::AttrDimension_t* ad = AST::down_cast<AST::AttrDimension_t>(a);
                             if (dims.size() > 0) {
-                                diag.add(Diagnostic(
-                                    "Dimensions specified twice",
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{x.base.base.loc})
-                                    }));
+                                diag.add(Diagnostic("Dimensions specified twice",
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                             dims_attr_loc = ad->base.base.loc;
-                            process_dims(al, dims, ad->m_dim, ad->n_dim, is_compile_time, is_char_type,
-                                (s_intent == ASRUtils::intent_in || s_intent == ASRUtils::intent_out ||
-                                s_intent == ASRUtils::intent_inout) || is_argument, s.m_name);
+                            process_dims(al,
+                                         dims,
+                                         ad->m_dim,
+                                         ad->n_dim,
+                                         is_compile_time,
+                                         is_char_type,
+                                         (s_intent == ASRUtils::intent_in
+                                          || s_intent == ASRUtils::intent_out
+                                          || s_intent == ASRUtils::intent_inout)
+                                             || is_argument,
+                                         s.m_name);
                         } else if (AST::is_a<AST::AttrBind_t>(*a)) {
                             AST::AttrBind_t attr_bd = *AST::down_cast<AST::AttrBind_t>(a);
                             extract_bind(attr_bd, s_abi, bindc_name, diag);
                         } else {
-                            diag.add(Diagnostic(
-                                "Attribute type not implemented yet",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                            diag.add(Diagnostic("Attribute type not implemented yet",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
@@ -3994,65 +4731,60 @@ public:
                     if (is_protected && !in_module) {
                         diag.add((Diagnostic(
                             "`protected` attribute is only allowed in specification part of a module",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }
-                        )));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { x.base.base.loc }) })));
                         throw SemanticAbort();
                     }
                     if (is_protected && storage_type == ASR::storage_typeType::Parameter) {
-                        diag.add((Diagnostic(
-                            "`parameter` attribute conflicts with `protected` attribute",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }
-                        )));
+                        diag.add((
+                            Diagnostic("`parameter` attribute conflicts with `protected` attribute",
+                                       Level::Error,
+                                       Stage::Semantic,
+                                       { Label("", { x.base.base.loc }) })));
                         throw SemanticAbort();
                     }
 
                     if (is_allocatable && storage_type == ASR::storage_typeType::Parameter) {
                         diag.add((Diagnostic(
                             "`parameter` attribute conflicts with `allocatable` attribute",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }
-                        )));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { x.base.base.loc }) })));
                         throw SemanticAbort();
                     } else if (is_pointer && storage_type == ASR::storage_typeType::Parameter) {
-                        diag.add((Diagnostic(
-                            "`parameter` attribute conflicts with `pointer` attribute",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }
-                        )));
+                        diag.add(
+                            (Diagnostic("`parameter` attribute conflicts with `pointer` attribute",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) })));
                         throw SemanticAbort();
                     }
-    
+
                     if (is_allocatable && s.m_initializer != nullptr) {
                         diag.add(Diagnostic(
                             "An 'allocatable' variable cannot have an initialization expression",
-                            Level::Error, Stage::Semantic, {
-                                Label("", {s.loc})
-                            }));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { s.loc }) }));
                         throw SemanticAbort();
                     }
-                    
+
                     if (s_intent == ASRUtils::intent_out && value_attr) {
-                        diag.add(Diagnostic(
-                            "`value` attribute conflicts with `intent(out)` attribute",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(
+                            Diagnostic("`value` attribute conflicts with `intent(out)` attribute",
+                                       Level::Error,
+                                       Stage::Semantic,
+                                       { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                     if (!s.m_initializer && s_intent == ASRUtils::intent_local
-                            && storage_type == ASR::storage_typeType::Parameter) {
-                        diag.add(Diagnostic(
-                            "Variable `" + std::string(s.m_name) +
-                            "` with parameter attribute is not initialised",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        && storage_type == ASR::storage_typeType::Parameter) {
+                        diag.add(Diagnostic("Variable `" + std::string(s.m_name)
+                                                + "` with parameter attribute is not initialised",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 }
@@ -4062,61 +4794,85 @@ public:
                         // integer, private, dimension(2,2) :: a(2,2)
                         diag.semantic_warning_label(
                             "Dimensions are specified twice",
-                            {dims_attr_loc, s.loc}, // dimension(2,2), a(2,2)
-                            "help: consider specifying it just one way or the other"
-                        );
+                            { dims_attr_loc, s.loc },  // dimension(2,2), a(2,2)
+                            "help: consider specifying it just one way or the other");
                         dims.n = 0;
                     }
-                    if (s.m_dim[s.n_dim-1].m_end_star == AST::dimension_typeType::DimensionStar) {
+                    if (s.m_dim[s.n_dim - 1].m_end_star == AST::dimension_typeType::DimensionStar) {
                         is_dimension_star = true;
                     }
-                    for(size_t i=0; i<s.n_dim; i++) {
-                        if (s.m_dim[i].m_end_star== AST::dimension_typeType::AssumedRank) is_assumed_rank = true;
+                    for (size_t i = 0; i < s.n_dim; i++) {
+                        if (s.m_dim[i].m_end_star == AST::dimension_typeType::AssumedRank)
+                            is_assumed_rank = true;
                     }
-                    if (is_assumed_rank && s_intent == ASRUtils::intent_local ) {
-                        diag.semantic_error_label("Assumed-rank variable '" + std::string(s.m_name) + "' must be a dummy argument.",
-                            {s.loc},
-                            "");
+                    if (is_assumed_rank && s_intent == ASRUtils::intent_local) {
+                        diag.semantic_error_label("Assumed-rank variable '" + std::string(s.m_name)
+                                                      + "' must be a dummy argument.",
+                                                  { s.loc },
+                                                  "");
                         throw SemanticAbort();
                     }
-                    process_dims(al, dims, s.m_dim, s.n_dim, is_compile_time, is_char_type,
-                        (s_intent == ASRUtils::intent_in || s_intent == ASRUtils::intent_out ||
-                        s_intent == ASRUtils::intent_inout) || is_argument, s.m_name);
-                }
-                ASR::symbol_t *type_declaration;
-                ASR::ttype_t *type = nullptr;
+                    process_dims(al,
+                                 dims,
+                                 s.m_dim,
+                                 s.n_dim,
+                                 is_compile_time,
+                                 is_char_type,
+                                 (s_intent == ASRUtils::intent_in
+                                  || s_intent == ASRUtils::intent_out
+                                  || s_intent == ASRUtils::intent_inout)
+                                     || is_argument,
+                                 s.m_name);
+                }
+                ASR::symbol_t* type_declaration;
+                ASR::ttype_t* type = nullptr;
                 if (is_assumed_rank && dims.n > 1) {
-                    diag.semantic_error_label("Assumed-rank variable '" + std::string(s.m_name) + "' must not have any dimensions specified.",
-                        {s.loc},
-                        "");
+                    diag.semantic_error_label("Assumed-rank variable '" + std::string(s.m_name)
+                                                  + "' must not have any dimensions specified.",
+                                              { s.loc },
+                                              "");
                     throw SemanticAbort();
                 }
-                type = determine_type(x.base.base.loc, sym, x.m_vartype, is_pointer,
-                    is_allocatable, dims, &(x.m_syms[i]), type_declaration, s_abi,
-                    (s_intent != ASRUtils::intent_local) || is_argument, is_dimension_star, is_assumed_rank);
-                if ( is_attr_external ) create_external_function(sym, x.m_syms[i].loc, type);
-                if ( current_scope->get_symbol( sym ) != nullptr && ( is_external && !is_attr_external ) ) {
+                type = determine_type(x.base.base.loc,
+                                      sym,
+                                      x.m_vartype,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      &(x.m_syms[i]),
+                                      type_declaration,
+                                      s_abi,
+                                      (s_intent != ASRUtils::intent_local) || is_argument,
+                                      is_dimension_star,
+                                      is_assumed_rank);
+                if (is_attr_external)
+                    create_external_function(sym, x.m_syms[i].loc, type);
+                if (current_scope->get_symbol(sym) != nullptr
+                    && (is_external && !is_attr_external)) {
                     /*
                         return type of external function is specified
                         external :: x
                         integer :: x -> we are handling this case
                     */
-                    ASR::symbol_t *sym_ = current_scope->get_symbol(sym);
-                    LCOMPILERS_ASSERT( sym_ != nullptr );
+                    ASR::symbol_t* sym_ = current_scope->get_symbol(sym);
+                    LCOMPILERS_ASSERT(sym_ != nullptr);
                     // set function return type as `type`
-                    ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(sym_);
+                    ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(sym_);
                     ASRUtils::EXPR2VAR(f->m_return_var)->m_type = type;
                 }
                 current_variable_type_ = type;
                 if (is_argument && current_scope->asr_owner
                     && ASR::is_a<ASR::symbol_t>(*current_scope->asr_owner)) {
-                    ASR::symbol_t *owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
+                    ASR::symbol_t* owner_sym
+                        = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
                     if (ASR::is_a<ASR::Function_t>(*owner_sym)) {
-                        ASR::Function_t *owner_func = ASR::down_cast<ASR::Function_t>(owner_sym);
-                        ASR::FunctionType_t *owner_ft = ASR::down_cast<ASR::FunctionType_t>(owner_func->m_function_signature);
+                        ASR::Function_t* owner_func = ASR::down_cast<ASR::Function_t>(owner_sym);
+                        ASR::FunctionType_t* owner_ft
+                            = ASR::down_cast<ASR::FunctionType_t>(owner_func->m_function_signature);
                         for (size_t j = 0; j < owner_func->n_args; j++) {
                             if (ASR::is_a<ASR::Var_t>(*owner_func->m_args[j])) {
-                                ASR::Var_t *arg_var = ASR::down_cast<ASR::Var_t>(owner_func->m_args[j]);
+                                ASR::Var_t* arg_var
+                                    = ASR::down_cast<ASR::Var_t>(owner_func->m_args[j]);
                                 if (std::string(ASRUtils::symbol_name(arg_var->m_v)) == sym) {
                                     owner_ft->m_arg_types[j] = type;
                                     break;
@@ -4127,7 +4883,7 @@ public:
                 }
 
                 ASR::expr_t* init_expr = nullptr;
-                ASR::expr_t* char_length { nullptr };
+                ASR::expr_t* char_length{ nullptr };
                 ASR::expr_t* value = nullptr;
 
                 // set the character (or character array) length correctly
@@ -4136,34 +4892,45 @@ public:
                 // OR character :: x(2)*3  !> set char length to 3
                 if (is_char_type && s.m_length) {
                     this->visit_expr(*s.m_length);
-                    ASR::String_t *lhs_type = ASR::down_cast<ASR::String_t>(
-                        ASRUtils::type_get_past_array(type));
+                    ASR::String_t* lhs_type
+                        = ASR::down_cast<ASR::String_t>(ASRUtils::type_get_past_array(type));
                     char_length = ASRUtils::EXPR(tmp);
                     ASR::expr_t* c_length = ASRUtils::expr_value(char_length);
                     ASRUtils::ASRBuilder b(al, x.base.base.loc);
-                    if (c_length == nullptr) c_length = ASRUtils::expr_value(b.i32(0));
+                    if (c_length == nullptr)
+                        c_length = ASRUtils::expr_value(b.i32(0));
                     LCOMPILERS_ASSERT(ASR::is_a<ASR::IntegerConstant_t>(*c_length))
                     int64_t lhs_len = ASR::down_cast<ASR::IntegerConstant_t>(c_length)->m_n;
-                    lhs_type->m_len = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, lhs_len,
+                    lhs_type->m_len = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                        al,
+                        x.base.base.loc,
+                        lhs_len,
                         ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 8))));
-                }                
+                }
                 ASR::Variable_t* variable_added_to_symtab = nullptr;
-                if( std::find(excluded_from_symtab.begin(), excluded_from_symtab.end(), sym) == excluded_from_symtab.end() ) {
-                    if ( !is_implicitly_declared && !is_external) {
+                if (std::find(excluded_from_symtab.begin(), excluded_from_symtab.end(), sym)
+                    == excluded_from_symtab.end()) {
+                    if (!is_implicitly_declared && !is_external) {
                         SetChar variable_dependencies_vec;
                         variable_dependencies_vec.reserve(al, 1);
-                        ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type, init_expr, value);
-                        if ( symbols_having_only_attributes_without_type.find(sym) != symbols_having_only_attributes_without_type.end() ) {
-                            ASR::symbol_t* symbol = symbols_having_only_attributes_without_type[sym];
-                            ASR::Variable_t* symbol_variable = ASR::down_cast<ASR::Variable_t>(symbol);
+                        ASRUtils::collect_variable_dependencies(
+                            al, variable_dependencies_vec, type, init_expr, value);
+                        if (symbols_having_only_attributes_without_type.find(sym)
+                            != symbols_having_only_attributes_without_type.end()) {
+                            ASR::symbol_t* symbol
+                                = symbols_having_only_attributes_without_type[sym];
+                            ASR::Variable_t* symbol_variable
+                                = ASR::down_cast<ASR::Variable_t>(symbol);
                             symbol_variable->base.base.loc = s.loc;
-                            if ( symbol_variable->m_type ) {
+                            if (symbol_variable->m_type) {
                                 if (is_argument && is_dimension_star) {
                                     symbol_variable->m_type = type;
-                                } else if ( ASR::is_a<ASR::Array_t>(*symbol_variable->m_type) ) {
-                                    ASR::Array_t* array_type = ASR::down_cast<ASR::Array_t>(symbol_variable->m_type);
-                                    if(ASRUtils::is_string_only(type)){
-                                        array_type->m_physical_type = ASR::PointerArray; // Making sure it's PointerArray
+                                } else if (ASR::is_a<ASR::Array_t>(*symbol_variable->m_type)) {
+                                    ASR::Array_t* array_type
+                                        = ASR::down_cast<ASR::Array_t>(symbol_variable->m_type);
+                                    if (ASRUtils::is_string_only(type)) {
+                                        array_type->m_physical_type
+                                            = ASR::PointerArray;  // Making sure it's PointerArray
                                     }
                                     array_type->m_type = type;
                                 } else {
@@ -4175,58 +4942,86 @@ public:
                             current_scope->add_symbol(sym, symbol);
                             variable_added_to_symtab = symbol_variable;
                         } else {
-                            ASR::asr_t *v = ASRUtils::make_Variable_t_util(al, s.loc, current_scope,
-                                s2c(al, to_lower(s.m_name)), variable_dependencies_vec.p,
-                                variable_dependencies_vec.size(), s_intent, init_expr, value,
-                                storage_type, type, type_declaration, s_abi, s_access, s_presence,
-                                value_attr, target_attr, contig_attr, bindc_name, is_volatile,
-                                is_protected
-                            );
+                            ASR::asr_t* v
+                                = ASRUtils::make_Variable_t_util(al,
+                                                                 s.loc,
+                                                                 current_scope,
+                                                                 s2c(al, to_lower(s.m_name)),
+                                                                 variable_dependencies_vec.p,
+                                                                 variable_dependencies_vec.size(),
+                                                                 s_intent,
+                                                                 init_expr,
+                                                                 value,
+                                                                 storage_type,
+                                                                 type,
+                                                                 type_declaration,
+                                                                 s_abi,
+                                                                 s_access,
+                                                                 s_presence,
+                                                                 value_attr,
+                                                                 target_attr,
+                                                                 contig_attr,
+                                                                 bindc_name,
+                                                                 is_volatile,
+                                                                 is_protected);
                             current_scope->add_symbol(sym, ASR::down_cast<ASR::symbol_t>(v));
-                            variable_added_to_symtab = ASR::down_cast<ASR::Variable_t>(ASR::down_cast<ASR::symbol_t>(v));
+                            variable_added_to_symtab
+                                = ASR::down_cast<ASR::Variable_t>(ASR::down_cast<ASR::symbol_t>(v));
                         }
-                        if( is_derived_type ) {
+                        if (is_derived_type) {
                             data_member_names.push_back(al, s2c(al, to_lower(s.m_name)));
-                            if ( s.n_dim > 0 && !is_template) {
+                            if (s.n_dim > 0 && !is_template) {
                                 for (size_t dim_i = 0; dim_i < s.n_dim; dim_i++) {
                                     AST::dimension_t& dim = s.m_dim[dim_i];
-                                    if (dim.m_start != nullptr &&
-                                        AST::is_a<AST::Name_t>(*dim.m_start)) {
-                            
-                                        AST::Name_t* start_var = AST::down_cast<AST::Name_t>(dim.m_start);
-                                        std::string dim_var_name = to_lower(std::string(start_var->m_id));
-                            
-                                        ASR::symbol_t* found_sym = current_scope->resolve_symbol(dim_var_name);
+                                    if (dim.m_start != nullptr
+                                        && AST::is_a<AST::Name_t>(*dim.m_start)) {
+                                        AST::Name_t* start_var
+                                            = AST::down_cast<AST::Name_t>(dim.m_start);
+                                        std::string dim_var_name
+                                            = to_lower(std::string(start_var->m_id));
+
+                                        ASR::symbol_t* found_sym
+                                            = current_scope->resolve_symbol(dim_var_name);
                                         if (found_sym && ASR::is_a<ASR::Variable_t>(*found_sym)) {
-                                            ASR::Variable_t* dim_var = ASR::down_cast<ASR::Variable_t>(found_sym);
-                                            if (dim_var->m_storage != ASR::storage_typeType::Parameter) {
+                                            ASR::Variable_t* dim_var
+                                                = ASR::down_cast<ASR::Variable_t>(found_sym);
+                                            if (dim_var->m_storage
+                                                != ASR::storage_typeType::Parameter) {
                                                 diag.add(Diagnostic(
-                                                    "Variable `"+ dim_var_name + "` cannot appear in the expression as it is not a constant.",
-                                                    Level::Error, Stage::Semantic, {
-                                                        Label("", {dim.m_start->base.loc}),
-                                                    }
-                                                ));
+                                                    "Variable `" + dim_var_name
+                                                        + "` cannot appear in the expression as it is not a constant.",
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    {
+                                                        Label("", { dim.m_start->base.loc }),
+                                                    }));
                                                 throw SemanticAbort();
                                             }
                                         }
                                     }
-                            
-                                    if (dim.m_end != nullptr &&
-                                        AST::is_a<AST::Name_t>(*dim.m_end)) {
-                            
-                                        AST::Name_t* end_var = AST::down_cast<AST::Name_t>(dim.m_end);
-                                        std::string dim_var_name = to_lower(std::string(end_var->m_id));
-                            
-                                        ASR::symbol_t* found_sym = current_scope->resolve_symbol(dim_var_name);
+
+                                    if (dim.m_end != nullptr
+                                        && AST::is_a<AST::Name_t>(*dim.m_end)) {
+                                        AST::Name_t* end_var
+                                            = AST::down_cast<AST::Name_t>(dim.m_end);
+                                        std::string dim_var_name
+                                            = to_lower(std::string(end_var->m_id));
+
+                                        ASR::symbol_t* found_sym
+                                            = current_scope->resolve_symbol(dim_var_name);
                                         if (found_sym && ASR::is_a<ASR::Variable_t>(*found_sym)) {
-                                            ASR::Variable_t* dim_var = ASR::down_cast<ASR::Variable_t>(found_sym);
-                                            if (dim_var->m_storage != ASR::storage_typeType::Parameter) {
+                                            ASR::Variable_t* dim_var
+                                                = ASR::down_cast<ASR::Variable_t>(found_sym);
+                                            if (dim_var->m_storage
+                                                != ASR::storage_typeType::Parameter) {
                                                 diag.add(Diagnostic(
-                                                    "Variable `"+ dim_var_name + "` cannot appear in the expression as it is not a constant",
-                                                    Level::Error, Stage::Semantic, {
-                                                        Label("", {dim.m_end->base.loc}),
-                                                    }
-                                                ));
+                                                    "Variable `" + dim_var_name
+                                                        + "` cannot appear in the expression as it is not a constant",
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    {
+                                                        Label("", { dim.m_end->base.loc }),
+                                                    }));
                                                 throw SemanticAbort();
                                             }
                                         }
@@ -4234,49 +5029,62 @@ public:
                                 }
                             }
                         }
-                    } else if ( is_implicitly_declared ) {
+                    } else if (is_implicitly_declared) {
                         ASR::symbol_t* symbol = current_scope->get_symbol(sym);
                         ASR::Variable_t* symbol_variable = ASR::down_cast<ASR::Variable_t>(symbol);
                         if (is_argument && is_dimension_star) {
                             symbol_variable->m_type = type;
-                        } else if ( ASR::is_a<ASR::Array_t>(*symbol_variable->m_type) ) {
-                            ASR::Array_t* array_type = ASR::down_cast<ASR::Array_t>(symbol_variable->m_type);
+                        } else if (ASR::is_a<ASR::Array_t>(*symbol_variable->m_type)) {
+                            ASR::Array_t* array_type
+                                = ASR::down_cast<ASR::Array_t>(symbol_variable->m_type);
                             array_type->m_type = type;
-                            if ( ASR::is_a<ASR::String_t>(*type)) {
-                                array_type->m_physical_type = ASRUtils::is_fixed_size_array(array_type->m_dims, array_type->n_dims) ? ASR::array_physical_typeType::PointerArray : ASR::array_physical_typeType::DescriptorArray;
+                            if (ASR::is_a<ASR::String_t>(*type)) {
+                                array_type->m_physical_type
+                                    = ASRUtils::is_fixed_size_array(array_type->m_dims,
+                                                                    array_type->n_dims)
+                                          ? ASR::array_physical_typeType::PointerArray
+                                          : ASR::array_physical_typeType::DescriptorArray;
                             }
                         } else {
                             symbol_variable->m_type = type;
                         }
-                        if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(symbol_variable->m_type))
-                            || ASR::is_a<ASR::UnionType_t>(*ASRUtils::extract_type(symbol_variable->m_type))) {
+                        if (ASR::is_a<ASR::StructType_t>(
+                                *ASRUtils::extract_type(symbol_variable->m_type))
+                            || ASR::is_a<ASR::UnionType_t>(
+                                *ASRUtils::extract_type(symbol_variable->m_type))) {
                             symbol_variable->m_type_declaration = type_declaration;
-                        } else if ( type_declaration != nullptr ) {
-                            // This is the case where the variable is implicitly declared `public :: xx`
-                            // and later declared as a procedure variable ex: `procedure(yy), pointer :: xx`
+                        } else if (type_declaration != nullptr) {
+                            // This is the case where the variable is implicitly declared `public ::
+                            // xx` and later declared as a procedure variable ex: `procedure(yy),
+                            // pointer :: xx`
                             symbol_variable->m_type_declaration = type_declaration;
                         }
                     }
                 }
 
                 if (variable_added_to_symtab) {
-                    if (ASR::is_a<ASR::StructType_t>(*ASRUtils::extract_type(variable_added_to_symtab->m_type)) 
-                        || ASR::is_a<ASR::FunctionType_t>(*ASRUtils::extract_type(variable_added_to_symtab->m_type))) {
-                        current_struct_type_var_expr = ASRUtils::EXPR(ASR::make_Var_t(al,
-                                                            variable_added_to_symtab->base.base.loc,
-                                                            &variable_added_to_symtab->base));
+                    if (ASR::is_a<ASR::StructType_t>(
+                            *ASRUtils::extract_type(variable_added_to_symtab->m_type))
+                        || ASR::is_a<ASR::FunctionType_t>(
+                            *ASRUtils::extract_type(variable_added_to_symtab->m_type))) {
+                        current_struct_type_var_expr = ASRUtils::EXPR(
+                            ASR::make_Var_t(al,
+                                            variable_added_to_symtab->base.base.loc,
+                                            &variable_added_to_symtab->base));
                     }
                 }
 
-                if (s.m_initializer != nullptr &&
-                    sym_type->m_type == AST::decl_typeType::TypeType) {
+                if (s.m_initializer != nullptr
+                    && sym_type->m_type == AST::decl_typeType::TypeType) {
                     if (AST::is_a<AST::FuncCallOrArray_t>(*s.m_initializer)) {
-                        AST::FuncCallOrArray_t* func_call =
-                            AST::down_cast<AST::FuncCallOrArray_t>(s.m_initializer);
-                        ASR::symbol_t *sym_found = current_scope->resolve_symbol(func_call->m_func);
+                        AST::FuncCallOrArray_t* func_call
+                            = AST::down_cast<AST::FuncCallOrArray_t>(s.m_initializer);
+                        ASR::symbol_t* sym_found = current_scope->resolve_symbol(func_call->m_func);
                         bool is_struct_const = false;
-                        if (current_scope->asr_owner && ASR::is_a<ASR::symbol_t>(*current_scope->asr_owner)) {
-                            ASR::symbol_t* asr_owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
+                        if (current_scope->asr_owner
+                            && ASR::is_a<ASR::symbol_t>(*current_scope->asr_owner)) {
+                            ASR::symbol_t* asr_owner_sym
+                                = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
                             if (ASR::is_a<ASR::Module_t>(*asr_owner_sym)) {
                                 is_struct_const = true;
                             }
@@ -4288,13 +5096,16 @@ public:
                             visit_FuncCallOrArray(*func_call);
                             init_expr = ASRUtils::EXPR(tmp);
                         } else {
-                            if( ASR::is_a<ASR::Struct_t>(
-                                *ASRUtils::symbol_get_past_external(sym_found)) ) {
-                                init_expr = ASRUtils::EXPR(create_DerivedTypeConstructor(
-                                                func_call->base.base.loc,
-                                                func_call->m_args, func_call->n_args,
-                                                func_call->m_keywords, func_call->n_keywords,
-                                                sym_found, is_struct_const));
+                            if (ASR::is_a<ASR::Struct_t>(
+                                    *ASRUtils::symbol_get_past_external(sym_found))) {
+                                init_expr = ASRUtils::EXPR(
+                                    create_DerivedTypeConstructor(func_call->base.base.loc,
+                                                                  func_call->m_args,
+                                                                  func_call->n_args,
+                                                                  func_call->m_keywords,
+                                                                  func_call->n_keywords,
+                                                                  sym_found,
+                                                                  is_struct_const));
                             } else {
                                 LCOMPILERS_ASSERT(false);
                             }
@@ -4303,76 +5114,86 @@ public:
                         std::string sym_name = AST::down_cast<AST::Name_t>(s.m_initializer)->m_id;
                         sym_name = to_lower(sym_name);
                         if (sym_name == "c_null_ptr") {
-                            ASR::symbol_t *sym_found = current_scope->resolve_symbol(sym_name);
+                            ASR::symbol_t* sym_found = current_scope->resolve_symbol(sym_name);
                             if (sym_found == nullptr) {
-                                diag.add(Diagnostic(
-                                    "Symbol not found: `c_null_ptr`",
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{x.base.base.loc})
-                                    }));
+                                diag.add(Diagnostic("Symbol not found: `c_null_ptr`",
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                             // Check if c_null_ptr is imported from iso_c_binding (intrinsic module)
                             if (ASR::is_a<ASR::ExternalSymbol_t>(*sym_found)) {
-                                std::string m_name = ASR::down_cast<ASR::ExternalSymbol_t>(sym_found)->m_module_name;
+                                std::string m_name
+                                    = ASR::down_cast<ASR::ExternalSymbol_t>(sym_found)
+                                          ->m_module_name;
                                 if (startswith(m_name, "lfortran_intrinsic")) {
-                                    init_expr = ASRUtils::EXPR(ASR::make_PointerNullConstant_t(al,
-                                                    x.base.base.loc, current_variable_type_, current_struct_type_var_expr));
+                                    init_expr = ASRUtils::EXPR(ASR::make_PointerNullConstant_t(
+                                        al,
+                                        x.base.base.loc,
+                                        current_variable_type_,
+                                        current_struct_type_var_expr));
                                 }
                             } else {
-                                diag.add(Diagnostic(
-                                    "Named initialization not supported with: " + sym_name,
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{x.base.base.loc})
-                                    }));
+                                diag.add(Diagnostic("Named initialization not supported with: "
+                                                        + sym_name,
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
 
                         } else {
-                            diag.add(Diagnostic(
-                                "Named initialization not supported with: " + sym_name,
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                            diag.add(
+                                Diagnostic("Named initialization not supported with: " + sym_name,
+                                           Level::Error,
+                                           Stage::Semantic,
+                                           { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     } else if (AST::is_a<AST::ArrayInitializer_t>(*s.m_initializer)) {
-                        AST::ArrayInitializer_t *array_init = AST::down_cast<AST::ArrayInitializer_t>(s.m_initializer);
+                        AST::ArrayInitializer_t* array_init
+                            = AST::down_cast<AST::ArrayInitializer_t>(s.m_initializer);
                         if (array_init->n_args > 0) {
                             bool is_correct_type_func = false;
                             bool is_correct_type_implieddoloop = false;
                             AST::FuncCallOrArray_t* func_call = nullptr;
 
-                            is_correct_type_func = AST::is_a<AST::FuncCallOrArray_t>(*array_init->m_args[0]);
-                            is_correct_type_implieddoloop = AST::is_a<AST::ImpliedDoLoop_t>(*array_init->m_args[0]);
-                            
+                            is_correct_type_func
+                                = AST::is_a<AST::FuncCallOrArray_t>(*array_init->m_args[0]);
+                            is_correct_type_implieddoloop
+                                = AST::is_a<AST::ImpliedDoLoop_t>(*array_init->m_args[0]);
+
                             if (is_correct_type_func) {
-                                func_call = AST::down_cast<AST::FuncCallOrArray_t>(array_init->m_args[0]);
-                            }
-                            else if (is_correct_type_implieddoloop) {
-                                AST::ImpliedDoLoop_t* idoloop = AST::down_cast<AST::ImpliedDoLoop_t>(array_init->m_args[0]);
+                                func_call
+                                    = AST::down_cast<AST::FuncCallOrArray_t>(array_init->m_args[0]);
+                            } else if (is_correct_type_implieddoloop) {
+                                AST::ImpliedDoLoop_t* idoloop
+                                    = AST::down_cast<AST::ImpliedDoLoop_t>(array_init->m_args[0]);
                                 // Check if the implied do loop values construct the correct type
                                 if (idoloop->n_values > 0) {
                                     if (AST::is_a<AST::FuncCallOrArray_t>(*idoloop->m_values[0])) {
-                                        func_call = AST::down_cast<AST::FuncCallOrArray_t>(idoloop->m_values[0]);
-                                    }
-                                    else if (AST::is_a<AST::Name_t>(*idoloop->m_values[0])){
-                                        // TODO:: Check if Array Type Matches Do Loop Assignment Type, 
+                                        func_call = AST::down_cast<AST::FuncCallOrArray_t>(
+                                            idoloop->m_values[0]);
+                                    } else if (AST::is_a<AST::Name_t>(*idoloop->m_values[0])) {
+                                        // TODO:: Check if Array Type Matches Do Loop Assignment
+                                        // Type,
                                         is_correct_type_implieddoloop = true;
                                     }
-                                    } else {
-                                        is_correct_type_implieddoloop = false;
-                                    }
                                 } else {
                                     is_correct_type_implieddoloop = false;
+                                }
+                            } else {
+                                is_correct_type_implieddoloop = false;
                             }
-                            if ((!is_correct_type_func && !is_correct_type_implieddoloop) ||
-                                (func_call != nullptr && strcmp(func_call->m_func, sym_type->m_name) != 0)) {
+                            if ((!is_correct_type_func && !is_correct_type_implieddoloop)
+                                || (func_call != nullptr
+                                    && strcmp(func_call->m_func, sym_type->m_name) != 0)) {
                                 diag.add(Diagnostic(
                                     "Array members must me of the same type as the struct",
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{array_init->m_args[0]->base.loc})
-                                    }));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { array_init->m_args[0]->base.loc }) }));
                                 throw SemanticAbort();
                             }
                         }
@@ -4380,55 +5201,62 @@ public:
                         visit_ArrayInitializer(*array_init);
                         init_expr = ASRUtils::EXPR(tmp);
                     } else {
-                        diag.add(Diagnostic(
-                            "Only function call assignment is allowed for now",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                        diag.add(Diagnostic("Only function call assignment is allowed for now",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
 
                     value = ASRUtils::expr_value(init_expr);
-                    if ( init_expr ) {
-                        if( ASRUtils::is_value_constant(value) ) {
-                        } else if( ASRUtils::is_value_constant(init_expr) ) {
+                    if (init_expr) {
+                        if (ASRUtils::is_value_constant(value)) {
+                        } else if (ASRUtils::is_value_constant(init_expr)) {
                             value = nullptr;
                         } else if (ASR::is_a<ASR::ArrayConstructor_t>(*init_expr)) {
-                            ASR::ArrayConstructor_t *array_construct = ASR::down_cast<ASR::ArrayConstructor_t>(init_expr);
+                            ASR::ArrayConstructor_t* array_construct
+                                = ASR::down_cast<ASR::ArrayConstructor_t>(init_expr);
                             for (size_t j = 0; j < array_construct->n_args; j++) {
                                 if (!ASRUtils::is_value_constant(array_construct->m_args[j])) {
                                     diag.add(Diagnostic(
-                                        "Initialization of `" + std::string(x.m_syms[i].m_name) +
-                                        "` must reduce to a compile time constant.",
-                                        Level::Error, Stage::Semantic, {
-                                            Label("",{array_construct->m_args[j]->base.loc})
-                                        }));
+                                        "Initialization of `" + std::string(x.m_syms[i].m_name)
+                                            + "` must reduce to a compile time constant.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { array_construct->m_args[j]->base.loc }) }));
                                     throw SemanticAbort();
                                 }
                             }
                             value = nullptr;
                         } else {
-                            diag.add(Diagnostic(
-                                "Initialization of `" + std::string(x.m_syms[i].m_name) +
-                                "` must reduce to a compile time constant.",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                            diag.add(Diagnostic("Initialization of `"
+                                                    + std::string(x.m_syms[i].m_name)
+                                                    + "` must reduce to a compile time constant.",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
                 } else if (s.m_initializer != nullptr) {
                     ASR::ttype_t* temp_current_variable_type_ = current_variable_type_;
-                    if (s.m_initializer!=nullptr && AST::is_a<AST::ArrayInitializer_t>(*s.m_initializer) ) {
-                        // This branch is to handle cases of BOZ Declarations inside Real Array 
-                        // Initializers, e.g.: real :: x(2) = [real::b'01', 5.6] 
-                        AST::ArrayInitializer_t *array_init1 = AST::down_cast<AST::ArrayInitializer_t>(s.m_initializer);
-                        if (array_init1->m_vartype && AST::is_a<AST::AttrType_t>(*array_init1->m_vartype)) {
-                            AST::AttrType_t *attr_type = AST::down_cast<AST::AttrType_t>(array_init1->m_vartype);
+                    if (s.m_initializer != nullptr
+                        && AST::is_a<AST::ArrayInitializer_t>(*s.m_initializer)) {
+                        // This branch is to handle cases of BOZ Declarations inside Real Array
+                        // Initializers, e.g.: real :: x(2) = [real::b'01', 5.6]
+                        AST::ArrayInitializer_t* array_init1
+                            = AST::down_cast<AST::ArrayInitializer_t>(s.m_initializer);
+                        if (array_init1->m_vartype
+                            && AST::is_a<AST::AttrType_t>(*array_init1->m_vartype)) {
+                            AST::AttrType_t* attr_type
+                                = AST::down_cast<AST::AttrType_t>(array_init1->m_vartype);
                             if (attr_type->m_type == AST::decl_typeType::TypeReal) {
                                 for (size_t i = 0; i < array_init1->n_args; i++) {
-                                    if (AST::is_a<AST::BOZ_t>(*array_init1->m_args[i])){
-                                        current_variable_type_ = ASRUtils::TYPE(ASR::make_Real_t(al, (array_init1->base).base.loc, compiler_options.po.default_integer_kind));
+                                    if (AST::is_a<AST::BOZ_t>(*array_init1->m_args[i])) {
+                                        current_variable_type_ = ASRUtils::TYPE(ASR::make_Real_t(
+                                            al,
+                                            (array_init1->base).base.loc,
+                                            compiler_options.po.default_integer_kind));
                                     }
                                 }
                             }
@@ -4437,16 +5265,24 @@ public:
                     this->visit_expr(*s.m_initializer);
                     current_variable_type_ = temp_current_variable_type_;
                     if (is_compile_time && AST::is_a<AST::ArrayInitializer_t>(*s.m_initializer)) {
-                        AST::ArrayInitializer_t *temp_array =
-                            AST::down_cast<AST::ArrayInitializer_t>(s.m_initializer);
-                        // For case  `integer, parameter :: x(*) = [1,2,3], get the compile time length of RHS array.
+                        AST::ArrayInitializer_t* temp_array
+                            = AST::down_cast<AST::ArrayInitializer_t>(s.m_initializer);
+                        // For case  `integer, parameter :: x(*) = [1,2,3], get the compile time
+                        // length of RHS array.
                         Vec<ASR::dimension_t> temp_dims;
                         temp_dims.reserve(al, 1);
-                        ASR::dimension_t temp_dim; temp_dim.m_length = nullptr; temp_dim.m_start = nullptr;
+                        ASR::dimension_t temp_dim;
+                        temp_dim.m_length = nullptr;
+                        temp_dim.m_start = nullptr;
                         temp_dim.loc = (temp_array->base).base.loc;
-                        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, (temp_array->base).base.loc, compiler_options.po.default_integer_kind));
-                        ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, (temp_array->base).base.loc, 1, int_type));
-                        ASR::expr_t* x_n_args = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, (temp_array->base).base.loc, temp_array->n_args, int_type));
+                        ASR::ttype_t* int_type = ASRUtils::TYPE(
+                            ASR::make_Integer_t(al,
+                                                (temp_array->base).base.loc,
+                                                compiler_options.po.default_integer_kind));
+                        ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al, (temp_array->base).base.loc, 1, int_type));
+                        ASR::expr_t* x_n_args = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al, (temp_array->base).base.loc, temp_array->n_args, int_type));
                         temp_dim.m_start = one;
                         temp_dim.m_length = x_n_args;
                         temp_dims.push_back(al, temp_dim);
@@ -4464,84 +5300,95 @@ public:
                         if (ASR::is_a<ASR::ArrayReshape_t>(*init_expr)) {
                             is_array_reshape = true;
                         }
-                        ASR::String_t *lhs_type = ASR::down_cast<ASR::String_t>(
-                            ASRUtils::type_get_past_array(type));
-                        ASR::String_t *rhs_type = nullptr;
+                        ASR::String_t* lhs_type
+                            = ASR::down_cast<ASR::String_t>(ASRUtils::type_get_past_array(type));
+                        ASR::String_t* rhs_type = nullptr;
                         if (is_array_reshape) {
-                            ASR::ArrayReshape_t* array_reshape = ASR::down_cast<ASR::ArrayReshape_t>(init_expr);
-                            rhs_type = ASR::down_cast<ASR::String_t>(ASRUtils::type_get_past_array(array_reshape->m_type));
+                            ASR::ArrayReshape_t* array_reshape
+                                = ASR::down_cast<ASR::ArrayReshape_t>(init_expr);
+                            rhs_type = ASR::down_cast<ASR::String_t>(
+                                ASRUtils::type_get_past_array(array_reshape->m_type));
                         } else {
                             LCOMPILERS_ASSERT(
-                                !ASRUtils::is_allocatable_or_pointer(type) &&
-                                !ASRUtils::is_allocatable_or_pointer(ASRUtils::expr_type(value)))
+                                !ASRUtils::is_allocatable_or_pointer(type)
+                                && !ASRUtils::is_allocatable_or_pointer(ASRUtils::expr_type(value)))
                             rhs_type = ASR::down_cast<ASR::String_t>(
                                 ASRUtils::type_get_past_array(ASRUtils::expr_type(value)));
                         }
                         int64_t lhs_len, rhs_len;
-                        bool is_lhs_length_constant = ASRUtils::extract_value(lhs_type->m_len, lhs_len);
-                        bool is_rhs_length_constant = ASRUtils::extract_value(rhs_type->m_len, rhs_len);
-                        if( is_lhs_length_constant && is_rhs_length_constant ){
-                            if((lhs_len < rhs_len)){
+                        bool is_lhs_length_constant
+                            = ASRUtils::extract_value(lhs_type->m_len, lhs_len);
+                        bool is_rhs_length_constant
+                            = ASRUtils::extract_value(rhs_type->m_len, rhs_len);
+                        if (is_lhs_length_constant && is_rhs_length_constant) {
+                            if ((lhs_len < rhs_len)) {
                                 diag.semantic_warning_label(
-                                    "The LHS character len="
-                                        + std::to_string(lhs_len)
-                                        + " and the RHS character len="
-                                        + std::to_string(rhs_len)
+                                    "The LHS character len=" + std::to_string(lhs_len)
+                                        + " and the RHS character len=" + std::to_string(rhs_len)
                                         + " are not equal.",
-                                    {x.base.base.loc},
-                                    "help: consider changing the RHS character len to match the LHS character len"
-                                );
+                                    { x.base.base.loc },
+                                    "help: consider changing the RHS character len to match the LHS character len");
                             }
-                            if((lhs_len != rhs_len)) {
+                            if ((lhs_len != rhs_len)) {
                                 // Adjust character string by padding or trimming
-                                // Notice that we only trim when variable is parameter, to have compile-time-correct string.
-                                if(is_array_reshape){
-                                    ASR::ArrayReshape_t* array_reshape_t = ASR::down_cast<ASR::ArrayReshape_t>(init_expr);
-                                    (void)adjust_array_character_length(
-                                                array_reshape_t->m_array, lhs_len, rhs_len, al);
+                                // Notice that we only trim when variable is parameter, to have
+                                // compile-time-correct string.
+                                if (is_array_reshape) {
+                                    ASR::ArrayReshape_t* array_reshape_t
+                                        = ASR::down_cast<ASR::ArrayReshape_t>(init_expr);
+                                    (void) adjust_array_character_length(
+                                        array_reshape_t->m_array, lhs_len, rhs_len, al);
                                     if (array_reshape_t->m_value) {
-                                        (void)adjust_array_character_length(
-                                                    array_reshape_t->m_value, lhs_len, rhs_len, al);
+                                        (void) adjust_array_character_length(
+                                            array_reshape_t->m_value, lhs_len, rhs_len, al);
                                     }
                                     {
-                                        ASR::String_t* reshape_str_t = ASRUtils::get_string_type(array_reshape_t->m_type);
-                                        LCOMPILERS_ASSERT(ASRUtils::is_value_constant(reshape_str_t->m_len))
+                                        ASR::String_t* reshape_str_t
+                                            = ASRUtils::get_string_type(array_reshape_t->m_type);
+                                        LCOMPILERS_ASSERT(
+                                            ASRUtils::is_value_constant(reshape_str_t->m_len))
                                         {
-                                            ASR::String_t* arr_const_str_t = ASRUtils::get_string_type(array_reshape_t->m_array);
-                                            LCOMPILERS_ASSERT(ASRUtils::is_value_constant(arr_const_str_t->m_len))
-                                            ASR::down_cast<ASR::IntegerConstant_t>(reshape_str_t->m_len)->m_n = 
-                                                ASR::down_cast<ASR::IntegerConstant_t>(arr_const_str_t->m_len)->m_n;
+                                            ASR::String_t* arr_const_str_t
+                                                = ASRUtils::get_string_type(
+                                                    array_reshape_t->m_array);
+                                            LCOMPILERS_ASSERT(
+                                                ASRUtils::is_value_constant(arr_const_str_t->m_len))
+                                            ASR::down_cast<ASR::IntegerConstant_t>(
+                                                reshape_str_t->m_len)
+                                                ->m_n
+                                                = ASR::down_cast<ASR::IntegerConstant_t>(
+                                                      arr_const_str_t->m_len)
+                                                      ->m_n;
                                         }
                                     }
-                                } else if (ASR::is_a<ASR::ArrayConstant_t>(*value)) {   
-                                    value = adjust_array_character_length(value, lhs_len,
-                                        rhs_len, al);
+                                } else if (ASR::is_a<ASR::ArrayConstant_t>(*value)) {
+                                    value = adjust_array_character_length(
+                                        value, lhs_len, rhs_len, al);
                                 } else {
-                                    value = adjust_character_length(value, lhs_len,
-                                        rhs_len, init_expr->base.loc, al);
+                                    value = adjust_character_length(
+                                        value, lhs_len, rhs_len, init_expr->base.loc, al);
                                 }
                             }
-                            
                         }
-                        if(!is_rhs_length_constant){
-                                diag.add(Diagnostic(
-                                "The RHS character len must be known at compile time",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{rhs_type->base.base.loc})
-                                }));
+                        if (!is_rhs_length_constant) {
+                            diag.add(
+                                Diagnostic("The RHS character len must be known at compile time",
+                                           Level::Error,
+                                           Stage::Semantic,
+                                           { Label("", { rhs_type->base.base.loc }) }));
                             throw SemanticAbort();
                         }
 
                         if (lhs_type->m_len_kind == ASR::DeferredLength) {
                             diag.add(Diagnostic(
                                 "The LHS character length must not be deferred (allocatable) in a parameter declaration",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                         // Change length kind from AssumedLength to ExpressionLength + Set Length
-                        if(lhs_type->m_len_kind == ASR::AssumedLength){
+                        if (lhs_type->m_len_kind == ASR::AssumedLength) {
                             lhs_type->m_len = rhs_type->m_len;
                             lhs_type->m_len_kind = ASR::ExpressionLength;
                         }
@@ -4552,11 +5399,13 @@ public:
                         tmp_init = value;
                     }
                     if (!is_compile_time && ASR::is_a<ASR::Array_t>(*type)
-                        && (ASR::is_a<ASR::IntegerConstant_t>(*tmp_init) || ASR::is_a<ASR::RealConstant_t>(*tmp_init)
-                            || ASR::is_a<ASR::ComplexConstant_t>(*tmp_init) || ASR::is_a<ASR::RealUnaryMinus_t>(*tmp_init)
-                            || ASR::is_a<ASR::IntegerUnaryMinus_t>(*tmp_init) || ASR::is_a<ASR::StringConstant_t>(*tmp_init)
-                            || ASR::is_a<ASR::LogicalConstant_t>(*tmp_init)))
-                    {
+                        && (ASR::is_a<ASR::IntegerConstant_t>(*tmp_init)
+                            || ASR::is_a<ASR::RealConstant_t>(*tmp_init)
+                            || ASR::is_a<ASR::ComplexConstant_t>(*tmp_init)
+                            || ASR::is_a<ASR::RealUnaryMinus_t>(*tmp_init)
+                            || ASR::is_a<ASR::IntegerUnaryMinus_t>(*tmp_init)
+                            || ASR::is_a<ASR::StringConstant_t>(*tmp_init)
+                            || ASR::is_a<ASR::LogicalConstant_t>(*tmp_init))) {
                         /*
                             Case: integer :: x(2) = 1
                             which is equivalent to x(2) = [1,1]
@@ -4568,17 +5417,23 @@ public:
                         // in case of declaration like:
                         // REAL :: x(2) = 1, we need to cast `tmp_init`
                         ImplicitCastRules::set_converted_value(
-                            al, x.base.base.loc, &tmp_init,
+                            al,
+                            x.base.base.loc,
+                            &tmp_init,
                             ASRUtils::expr_type(tmp_init),
-                            ASRUtils::type_get_past_allocatable(type), diag
-                        );
+                            ASRUtils::type_get_past_allocatable(type),
+                            diag);
                         for (int64_t i = 0; i < size; i++) {
                             args.push_back(al, tmp_init);
                         }
                         init_expr = ASRUtils::expr_value(
-                            ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al, init_expr->base.loc,
-                                args.p, args.n, type, ASR::arraystorageType::ColMajor))
-                        );
+                            ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(
+                                al,
+                                init_expr->base.loc,
+                                args.p,
+                                args.n,
+                                type,
+                                ASR::arraystorageType::ColMajor)));
                         LCOMPILERS_ASSERT(ASR::is_a<ASR::ArrayConstant_t>(*init_expr));
                         value = init_expr;
                     }
@@ -4589,57 +5444,62 @@ public:
                             = ASR::down_cast<ASR::Array_t>(ASRUtils::expr_type(tmp_init));
                         if (lhs_array->n_dims != rhs_array->n_dims) {
                             diag.add(Diagnostic(
-                                "Incompatible ranks "+ std::to_string(lhs_array->n_dims) + " and "
-                                                                  + std::to_string(rhs_array->n_dims) + " in assignment",
-                                                Level::Error,
-                                                Stage::Semantic,
-                                                { Label("", { tmp_init->base.loc }) }));
+                                "Incompatible ranks " + std::to_string(lhs_array->n_dims) + " and "
+                                    + std::to_string(rhs_array->n_dims) + " in assignment",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { tmp_init->base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
-                    ASR::ttype_t *init_type = ASRUtils::expr_type(init_expr);
+                    ASR::ttype_t* init_type = ASRUtils::expr_type(init_expr);
                     if (ASRUtils::is_real(*type) && ASRUtils::is_logical(*init_type)) {
-                        diag.add(Diagnostic(
-                            "Cannot convert LOGICAL to REAL",
-                            Level::Error, Stage::Semantic, {
-                                Label("", {init_expr->base.loc})
-                            }));
+                        diag.add(Diagnostic("Cannot convert LOGICAL to REAL",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { init_expr->base.loc }) }));
                         throw SemanticAbort();
                     }
                     size_t rhs_rank = ASRUtils::extract_n_dims_from_ttype(init_type);
                     size_t lhs_rank = ASRUtils::extract_n_dims_from_ttype(type);
 
                     // when lhs_rank > rhs_rank it can broadcast
-                    if( lhs_rank != rhs_rank && lhs_rank < rhs_rank ){
-                        diag.add(Diagnostic(
-                            "Incompatible ranks `"+ std::to_string(lhs_rank) + "` and `"
-                                                                  + std::to_string(rhs_rank) + "` in assignment",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{x.base.base.loc})
-                            }));
+                    if (lhs_rank != rhs_rank && lhs_rank < rhs_rank) {
+                        diag.add(Diagnostic("Incompatible ranks `" + std::to_string(lhs_rank)
+                                                + "` and `" + std::to_string(rhs_rank)
+                                                + "` in assignment",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
 
-                     if ( ASR::is_a<ASR::Array_t>(*init_type) && ASR::is_a<ASR::ArrayReshape_t>(*init_expr) ){
+                    if (ASR::is_a<ASR::Array_t>(*init_type)
+                        && ASR::is_a<ASR::ArrayReshape_t>(*init_expr)) {
                         ASR::Array_t* arr_rhs = ASR::down_cast<ASR::Array_t>(init_type);
                         ASR::Array_t* arr_lhs = ASR::down_cast<ASR::Array_t>(type);
 
-                    for (size_t i = 0; i < arr_lhs->n_dims; i++) {
-                           std::string lhs_dim = ASRUtils::extract_dim_value(arr_lhs->m_dims[i].m_length);
-                           std::string rhs_dim = ASRUtils::extract_dim_value(arr_rhs->m_dims[i].m_length);
-                            if(lhs_dim!=":" && rhs_dim!=":" && lhs_dim!=rhs_dim){
+                        for (size_t i = 0; i < arr_lhs->n_dims; i++) {
+                            std::string lhs_dim
+                                = ASRUtils::extract_dim_value(arr_lhs->m_dims[i].m_length);
+                            std::string rhs_dim
+                                = ASRUtils::extract_dim_value(arr_rhs->m_dims[i].m_length);
+                            if (lhs_dim != ":" && rhs_dim != ":" && lhs_dim != rhs_dim) {
                                 diag.add(Diagnostic(
-                                    "Incompatible shape of array on assignment on dimension " + std::to_string(i) +
-                                    " (" + lhs_dim + " and " + rhs_dim + ")",
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{x.base.base.loc})
-                                    }));
+                                    "Incompatible shape of array on assignment on dimension "
+                                        + std::to_string(i) + " (" + lhs_dim + " and " + rhs_dim
+                                        + ")",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                         }
-                   }
+                    }
                     if (init_type->type == ASR::ttypeType::Integer
-                        && ASRUtils::type_get_past_array(ASRUtils::type_get_past_pointer(type))->type == ASR::ttypeType::String
+                        && ASRUtils::type_get_past_array(ASRUtils::type_get_past_pointer(type))
+                                   ->type
+                               == ASR::ttypeType::String
                         && s.m_sym == AST::symbolType::Asterisk) {
                         /*
                             Case: character :: a*4
@@ -4647,69 +5507,98 @@ public:
                         */
                         value = ASRUtils::expr_value(init_expr);
                         if (value == nullptr) {
-                            diag.add(Diagnostic(
-                                "Initialization of `" + std::string(x.m_syms[i].m_name) +
-                                "` must reduce to a compile time constant.",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                            diag.add(Diagnostic("Initialization of `"
+                                                    + std::string(x.m_syms[i].m_name)
+                                                    + "` must reduce to a compile time constant.",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                         if (ASR::is_a<ASR::IntegerConstant_t>(*value)) {
-                            ASR::IntegerConstant_t *int_const = ASR::down_cast<ASR::IntegerConstant_t>(value);
+                            ASR::IntegerConstant_t* int_const
+                                = ASR::down_cast<ASR::IntegerConstant_t>(value);
                             int64_t len = int_const->m_n;
                             if (ASR::is_a<ASR::Array_t>(*type)) {
                                 // case: character :: a(2)*4
-                                ASR::Array_t *array = ASR::down_cast<ASR::Array_t>(type);
-                                    array->m_type = ASRUtils::TYPE(ASR::make_String_t(al, int_const->base.base.loc, 1, 
-                                        ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, int_const->base.base.loc, len,
-                                            ASRUtils::TYPE(ASR::make_Integer_t(al, int_const->base.base.loc, 4)))),
-                                        ASR::string_length_kindType::ExpressionLength,
-                                        ASR::string_physical_typeType::DescriptorString));
+                                ASR::Array_t* array = ASR::down_cast<ASR::Array_t>(type);
+                                array->m_type = ASRUtils::TYPE(ASR::make_String_t(
+                                    al,
+                                    int_const->base.base.loc,
+                                    1,
+                                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                        al,
+                                        int_const->base.base.loc,
+                                        len,
+                                        ASRUtils::TYPE(
+                                            ASR::make_Integer_t(al, int_const->base.base.loc, 4)))),
+                                    ASR::string_length_kindType::ExpressionLength,
+                                    ASR::string_physical_typeType::DescriptorString));
                             } else {
-                                type = ASRUtils::TYPE(ASR::make_String_t(al, int_const->base.base.loc, 1, 
-                                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, int_const->base.base.loc, len,
-                                        ASRUtils::TYPE(ASR::make_Integer_t(al, int_const->base.base.loc, 4)))),
-                                    ASR::string_length_kindType::ExpressionLength,    
+                                type = ASRUtils::TYPE(ASR::make_String_t(
+                                    al,
+                                    int_const->base.base.loc,
+                                    1,
+                                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                        al,
+                                        int_const->base.base.loc,
+                                        len,
+                                        ASRUtils::TYPE(
+                                            ASR::make_Integer_t(al, int_const->base.base.loc, 4)))),
+                                    ASR::string_length_kindType::ExpressionLength,
                                     ASR::string_physical_typeType::DescriptorString));
                             }
                         } else {
-                            diag.add(Diagnostic(
-                                "Initialization of `" + std::string(x.m_syms[i].m_name) +
-                                "` must reduce to a compile time constant.",
-                                Level::Error, Stage::Semantic, {
-                                    Label("",{x.base.base.loc})
-                                }));
+                            diag.add(Diagnostic("Initialization of `"
+                                                    + std::string(x.m_syms[i].m_name)
+                                                    + "` must reduce to a compile time constant.",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                         value = nullptr;
                         init_expr = nullptr;
                     } else if (!is_char_type) {
-                        ImplicitCastRules::set_converted_value(al, x.base.base.loc, &init_expr, init_type, type, diag);
+                        ImplicitCastRules::set_converted_value(
+                            al, x.base.base.loc, &init_expr, init_type, type, diag);
                         LCOMPILERS_ASSERT(init_expr != nullptr);
                         value = ASRUtils::expr_value(init_expr);
-                        if ( init_expr && !ASR::is_a<ASR::FunctionType_t>(*
-                                ASRUtils::type_get_past_pointer(
-                                    ASRUtils::expr_type(init_expr))) ) {
-                            if( ASRUtils::is_value_constant(value) ) {
-                            } else if( ASRUtils::is_value_constant(init_expr) ) {
+                        if (init_expr
+                            && !ASR::is_a<ASR::FunctionType_t>(
+                                *ASRUtils::type_get_past_pointer(ASRUtils::expr_type(init_expr)))) {
+                            if (ASRUtils::is_value_constant(value)) {
+                            } else if (ASRUtils::is_value_constant(init_expr)) {
                                 if (ASR::is_a<ASR::Cast_t>(*init_expr)) {
-                                    ASR::Cast_t *cast = ASR::down_cast<ASR::Cast_t>(init_expr);
-                                    if (cast->m_arg && ASR::is_a<ASR::ArrayConstant_t>(*cast->m_arg)) {
+                                    ASR::Cast_t* cast = ASR::down_cast<ASR::Cast_t>(init_expr);
+                                    if (cast->m_arg
+                                        && ASR::is_a<ASR::ArrayConstant_t>(*cast->m_arg)) {
                                         ASR::cast_kindType cast_kind = cast->m_kind;
                                         bool is_convertible = false;
-                                        ASR::ArrayConstant_t *a = ASR::down_cast<ASR::ArrayConstant_t>(cast->m_arg);
+                                        ASR::ArrayConstant_t* a
+                                            = ASR::down_cast<ASR::ArrayConstant_t>(cast->m_arg);
                                         ASR::ttype_t* cast_type = cast->m_type;
                                         Vec<ASR::expr_t*> body;
-                                        body.reserve(al, ASRUtils::get_fixed_size_of_array(a->m_type));
+                                        body.reserve(al,
+                                                     ASRUtils::get_fixed_size_of_array(a->m_type));
                                         if (cast_kind == ASR::cast_kindType::IntegerToReal) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::IntegerConstant_t>(*e)) {
-                                                    ASR::IntegerConstant_t *int_const = ASR::down_cast<ASR::IntegerConstant_t>(e);
+                                                    ASR::IntegerConstant_t* int_const
+                                                        = ASR::down_cast<ASR::IntegerConstant_t>(e);
                                                     double val = int_const->m_n;
-                                                    ASR::expr_t *real_const = ASRUtils::EXPR(ASR::make_RealConstant_t(al, int_const->base.base.loc,
-                                                        val, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* real_const
+                                                        = ASRUtils::EXPR(ASR::make_RealConstant_t(
+                                                            al,
+                                                            int_const->base.base.loc,
+                                                            val,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, real_const);
                                                     is_convertible = true;
                                                 } else {
@@ -4717,13 +5606,23 @@ public:
                                                 }
                                             }
                                         } else if (cast_kind == ASR::cast_kindType::RealToInteger) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::RealConstant_t>(*e)) {
-                                                    ASR::RealConstant_t *real_const = ASR::down_cast<ASR::RealConstant_t>(e);
+                                                    ASR::RealConstant_t* real_const
+                                                        = ASR::down_cast<ASR::RealConstant_t>(e);
                                                     int64_t val = real_const->m_r;
-                                                    ASR::expr_t *int_const = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, real_const->base.base.loc,
-                                                        val, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* int_const = ASRUtils::EXPR(
+                                                        ASR::make_IntegerConstant_t(
+                                                            al,
+                                                            real_const->base.base.loc,
+                                                            val,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, int_const);
                                                     is_convertible = true;
                                                 } else {
@@ -4731,42 +5630,75 @@ public:
                                                 }
                                             }
                                         } else if (cast_kind == ASR::cast_kindType::RealToReal) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::RealConstant_t>(*e)) {
-                                                    ASR::RealConstant_t *real_const = ASR::down_cast<ASR::RealConstant_t>(e);
+                                                    ASR::RealConstant_t* real_const
+                                                        = ASR::down_cast<ASR::RealConstant_t>(e);
                                                     int64_t val = real_const->m_r;
-                                                    ASR::expr_t *real_const2 = ASRUtils::EXPR(ASR::make_RealConstant_t(al, real_const->base.base.loc,
-                                                        val, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* real_const2
+                                                        = ASRUtils::EXPR(ASR::make_RealConstant_t(
+                                                            al,
+                                                            real_const->base.base.loc,
+                                                            val,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, real_const2);
                                                     is_convertible = true;
                                                 } else {
                                                     break;
                                                 }
                                             }
-                                        } else if (cast_kind == ASR::cast_kindType::ComplexToInteger) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                        } else if (cast_kind
+                                                   == ASR::cast_kindType::ComplexToInteger) {
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::ComplexConstant_t>(*e)) {
-                                                    ASR::ComplexConstant_t *complex_const = ASR::down_cast<ASR::ComplexConstant_t>(e);
+                                                    ASR::ComplexConstant_t* complex_const
+                                                        = ASR::down_cast<ASR::ComplexConstant_t>(e);
                                                     int64_t val = complex_const->m_re;
-                                                    ASR::expr_t *integer_const = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, complex_const->base.base.loc,
-                                                        val, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* integer_const = ASRUtils::EXPR(
+                                                        ASR::make_IntegerConstant_t(
+                                                            al,
+                                                            complex_const->base.base.loc,
+                                                            val,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, integer_const);
                                                     is_convertible = true;
                                                 } else {
                                                     break;
                                                 }
                                             }
-                                        } else if (cast_kind == ASR::cast_kindType::IntegerToComplex) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                        } else if (cast_kind
+                                                   == ASR::cast_kindType::IntegerToComplex) {
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::IntegerConstant_t>(*e)) {
-                                                    ASR::IntegerConstant_t *integer_const = ASR::down_cast<ASR::IntegerConstant_t>(e);
+                                                    ASR::IntegerConstant_t* integer_const
+                                                        = ASR::down_cast<ASR::IntegerConstant_t>(e);
                                                     int64_t val = integer_const->m_n;
                                                     double y_val_ = 0.0;
-                                                    ASR::expr_t *complex_const = ASRUtils::EXPR(ASR::make_ComplexConstant_t(al, integer_const->base.base.loc,
-                                                        val, y_val_, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* complex_const = ASRUtils::EXPR(
+                                                        ASR::make_ComplexConstant_t(
+                                                            al,
+                                                            integer_const->base.base.loc,
+                                                            val,
+                                                            y_val_,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, complex_const);
                                                     is_convertible = true;
                                                 } else {
@@ -4774,43 +5706,78 @@ public:
                                                 }
                                             }
                                         } else if (cast_kind == ASR::cast_kindType::ComplexToReal) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::ComplexConstant_t>(*e)) {
-                                                    ASR::ComplexConstant_t *complex_const = ASR::down_cast<ASR::ComplexConstant_t>(e);
+                                                    ASR::ComplexConstant_t* complex_const
+                                                        = ASR::down_cast<ASR::ComplexConstant_t>(e);
                                                     int64_t val = complex_const->m_re;
-                                                    ASR::expr_t *real_const = ASRUtils::EXPR(ASR::make_RealConstant_t(al, complex_const->base.base.loc,
-                                                        val, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* real_const
+                                                        = ASRUtils::EXPR(ASR::make_RealConstant_t(
+                                                            al,
+                                                            complex_const->base.base.loc,
+                                                            val,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, real_const);
                                                     is_convertible = true;
                                                 } else {
                                                     break;
                                                 }
                                             }
-                                        } else if (cast_kind == ASR::cast_kindType::ComplexToComplex) {
-                                            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                        } else if (cast_kind
+                                                   == ASR::cast_kindType::ComplexToComplex) {
+                                            for (size_t i = 0;
+                                                 i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                     a->m_type);
+                                                 i++) {
+                                                ASR::expr_t* e
+                                                    = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                                 if (ASR::is_a<ASR::ComplexConstant_t>(*e)) {
-                                                    ASR::ComplexConstant_t *complex_const = ASR::down_cast<ASR::ComplexConstant_t>(e);
+                                                    ASR::ComplexConstant_t* complex_const
+                                                        = ASR::down_cast<ASR::ComplexConstant_t>(e);
                                                     int64_t val1 = complex_const->m_re;
                                                     int64_t val2 = complex_const->m_im;
-                                                    ASR::expr_t *complex_const2 = ASRUtils::EXPR(ASR::make_ComplexConstant_t(al, complex_const->base.base.loc,
-                                                        val1, val2, ASRUtils::type_get_past_array(cast_type)));
+                                                    ASR::expr_t* complex_const2 = ASRUtils::EXPR(
+                                                        ASR::make_ComplexConstant_t(
+                                                            al,
+                                                            complex_const->base.base.loc,
+                                                            val1,
+                                                            val2,
+                                                            ASRUtils::type_get_past_array(
+                                                                cast_type)));
                                                     body.push_back(al, complex_const2);
                                                     is_convertible = true;
                                                 } else {
                                                     break;
                                                 }
                                             }
-                                        } else if (cast_kind == ASR::cast_kindType::IntegerToLogical) {
+                                        } else if (cast_kind
+                                                   == ASR::cast_kindType::IntegerToLogical) {
                                             if (compiler_options.logical_casting) {
-                                                for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                                    ASR::expr_t *e = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                                for (size_t i = 0;
+                                                     i < (size_t) ASRUtils::get_fixed_size_of_array(
+                                                         a->m_type);
+                                                     i++) {
+                                                    ASR::expr_t* e
+                                                        = ASRUtils::fetch_ArrayConstant_value(
+                                                            al, a, i);
                                                     if (ASR::is_a<ASR::IntegerConstant_t>(*e)) {
-                                                        ASR::IntegerConstant_t *int_const = ASR::down_cast<ASR::IntegerConstant_t>(e);
+                                                        ASR::IntegerConstant_t* int_const
+                                                            = ASR::down_cast<
+                                                                ASR::IntegerConstant_t>(e);
                                                         bool val = int_const->m_n;
-                                                        ASR::expr_t *logical_const = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, int_const->base.base.loc,
-                                                            val, ASRUtils::type_get_past_array(cast_type)));
+                                                        ASR::expr_t* logical_const = ASRUtils::EXPR(
+                                                            ASR::make_LogicalConstant_t(
+                                                                al,
+                                                                int_const->base.base.loc,
+                                                                val,
+                                                                ASRUtils::type_get_past_array(
+                                                                    cast_type)));
                                                         body.push_back(al, logical_const);
                                                         is_convertible = true;
                                                     } else {
@@ -4820,73 +5787,88 @@ public:
                                             } else {
                                                 diag.add(Diagnostic(
                                                     "Type mismatch in array initialization.\n Enable logical casting by setting `--logical-casting = true`",
-                                                    Level::Error, Stage::Semantic, {
-                                                        Label("",{x.base.base.loc})
-                                                    }));
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                                 throw SemanticAbort();
                                             }
                                         }
                                         if (is_convertible) {
-                                                ASR::expr_t* array_const = ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al, a->base.base.loc, body.p, body.size(), cast_type, a->m_storage_format));
-                                                cast->m_value = ASRUtils::expr_value(array_const);
-                                                value = cast->m_value;
+                                            ASR::expr_t* array_const = ASRUtils::EXPR(
+                                                ASRUtils::make_ArrayConstructor_t_util(
+                                                    al,
+                                                    a->base.base.loc,
+                                                    body.p,
+                                                    body.size(),
+                                                    cast_type,
+                                                    a->m_storage_format));
+                                            cast->m_value = ASRUtils::expr_value(array_const);
+                                            value = cast->m_value;
                                         } else {
-                                            diag.add(Diagnostic(
-                                                "Type mismatch in array initialization",
-                                                Level::Error, Stage::Semantic, {
-                                                    Label("",{x.base.base.loc})
-                                                }));
+                                            diag.add(
+                                                Diagnostic("Type mismatch in array initialization",
+                                                           Level::Error,
+                                                           Stage::Semantic,
+                                                           { Label("", { x.base.base.loc }) }));
                                             throw SemanticAbort();
                                         }
                                     }
                                 } else {
                                     value = nullptr;
                                 }
-                            } else if ( ASR::is_a<ASR::ArrayConstructor_t>(*init_expr) ||
-                                ( ASR::is_a<ASR::Cast_t>(*init_expr) &&
-                                ASR::is_a<ASR::ArrayConstructor_t>(*ASR::down_cast<ASR::Cast_t>(init_expr)->m_arg) )
-                                || ASR::is_a<ASR::IntrinsicElementalFunction_t>(*init_expr) ||
-                                ASR::is_a<ASR::IntrinsicArrayFunction_t>(*init_expr) ||
-                                ASR::is_a<ASR::TypeInquiry_t>(*init_expr) ||
-                                ASR::is_a<ASR::StringLen_t>(*init_expr) ) {
+                            } else if (ASR::is_a<ASR::ArrayConstructor_t>(*init_expr)
+                                       || (ASR::is_a<ASR::Cast_t>(*init_expr)
+                                           && ASR::is_a<ASR::ArrayConstructor_t>(
+                                               *ASR::down_cast<ASR::Cast_t>(init_expr)->m_arg))
+                                       || ASR::is_a<ASR::IntrinsicElementalFunction_t>(*init_expr)
+                                       || ASR::is_a<ASR::IntrinsicArrayFunction_t>(*init_expr)
+                                       || ASR::is_a<ASR::TypeInquiry_t>(*init_expr)
+                                       || ASR::is_a<ASR::StringLen_t>(*init_expr)) {
                                 value = init_expr;
-                            } else if (ASR::is_a<ASR::IntegerBinOp_t>(*init_expr) || ASR::is_a<ASR::RealBinOp_t>(*init_expr) ||
-                                        ASR::is_a<ASR::ComplexBinOp_t>(*init_expr)) {
+                            } else if (ASR::is_a<ASR::IntegerBinOp_t>(*init_expr)
+                                       || ASR::is_a<ASR::RealBinOp_t>(*init_expr)
+                                       || ASR::is_a<ASR::ComplexBinOp_t>(*init_expr)) {
                                 value = init_expr;
-                            } else if (ASR::is_a<ASR::ArrayReshape_t>(*init_expr) || ASR::is_a<ASR::BitCast_t>(*init_expr) ||
-                                ASR::is_a<ASR::IntegerCompare_t>(*init_expr)) {
+                            } else if (ASR::is_a<ASR::ArrayReshape_t>(*init_expr)
+                                       || ASR::is_a<ASR::BitCast_t>(*init_expr)
+                                       || ASR::is_a<ASR::IntegerCompare_t>(*init_expr)) {
                                 value = init_expr;
                             } else {
                                 diag.add(Diagnostic(
-                                    "Initialization of `" + std::string(x.m_syms[i].m_name) +
-                                    "` must reduce to a compile time constant.",
-                                    Level::Error, Stage::Semantic, {
-                                        Label("",{x.base.base.loc})
-                                    }));
+                                    "Initialization of `" + std::string(x.m_syms[i].m_name)
+                                        + "` must reduce to a compile time constant.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                         }
                     }
                     if (storage_type == ASR::storage_typeType::Parameter) {
-                        if( ASRUtils::is_array(type) ) {
-                            ASR::array_physical_typeType var_ptype = ASRUtils::extract_physical_type(type);
-                            ASR::array_physical_typeType init_expr_ptype = ASRUtils::extract_physical_type(
-                                ASRUtils::expr_type(init_expr));
-                            if( var_ptype != init_expr_ptype &&
-                                var_ptype == ASR::array_physical_typeType::DescriptorArray ) {
+                        if (ASRUtils::is_array(type)) {
+                            ASR::array_physical_typeType var_ptype
+                                = ASRUtils::extract_physical_type(type);
+                            ASR::array_physical_typeType init_expr_ptype
+                                = ASRUtils::extract_physical_type(ASRUtils::expr_type(init_expr));
+                            if (var_ptype != init_expr_ptype
+                                && var_ptype == ASR::array_physical_typeType::DescriptorArray) {
                                 type = ASRUtils::duplicate_type(al, ASRUtils::expr_type(init_expr));
                             }
                         }
-                        if( value ) {
+                        if (value) {
                             // TODO: move this into `expr_value` itself:
                             if (ASR::is_a<ASR::ArrayConstant_t>(*value)) {
                                 // For constant arrays we iterate over each element
                                 // and copy over the value
-                                ASR::ArrayConstant_t *a = ASR::down_cast<ASR::ArrayConstant_t>(value);
+                                ASR::ArrayConstant_t* a
+                                    = ASR::down_cast<ASR::ArrayConstant_t>(value);
                                 Vec<ASR::expr_t*> body;
                                 body.reserve(al, ASRUtils::get_fixed_size_of_array(a->m_type));
-                                for (size_t i=0; i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type); i++) {
-                                    ASR::expr_t* a_m_args = ASRUtils::fetch_ArrayConstant_value(al, a, i);
+                                for (size_t i = 0;
+                                     i < (size_t) ASRUtils::get_fixed_size_of_array(a->m_type);
+                                     i++) {
+                                    ASR::expr_t* a_m_args
+                                        = ASRUtils::fetch_ArrayConstant_value(al, a, i);
                                     // if( a_m_args == nullptr ) {
                                     //     a_m_args = a->m_args[i];
                                     // }
@@ -4899,54 +5881,62 @@ public:
                             if (ASR::is_a<ASR::ArrayConstructor_t>(*value)) {
                                 // For constant arrays we iterate over each element
                                 // and copy over the value
-                                ASR::ArrayConstructor_t *a = ASR::down_cast<ASR::ArrayConstructor_t>(value);
+                                ASR::ArrayConstructor_t* a
+                                    = ASR::down_cast<ASR::ArrayConstructor_t>(value);
                                 Vec<ASR::expr_t*> body;
                                 body.reserve(al, a->n_args);
-                                for (size_t i=0; i < a->n_args; i++) {
+                                for (size_t i = 0; i < a->n_args; i++) {
                                     ASR::expr_t* a_m_args = ASRUtils::expr_value(a->m_args[i]);
-                                    if( a_m_args == nullptr ) {
+                                    if (a_m_args == nullptr) {
                                         a_m_args = a->m_args[i];
                                     }
                                     body.push_back(al, a_m_args);
                                 }
-                                value = ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al,
-                                    a->base.base.loc, body.p, body.size(),
-                                    a->m_type, a->m_storage_format));
+                                value = ASRUtils::EXPR(
+                                    ASRUtils::make_ArrayConstructor_t_util(al,
+                                                                           a->base.base.loc,
+                                                                           body.p,
+                                                                           body.size(),
+                                                                           a->m_type,
+                                                                           a->m_storage_format));
                                 if (ASRUtils::is_dimension_empty(dims.p, dims.n)) {
                                     type = a->m_type;
                                 }
                             }
                             if (ASR::is_a<ASR::StringLen_t>(*value)) {
-                                ASR::StringLen_t *a = ASR::down_cast<ASR::StringLen_t>(value);
+                                ASR::StringLen_t* a = ASR::down_cast<ASR::StringLen_t>(value);
                                 value = a->m_value;
                             }
                         }
                     } else {
                         implicit_save = true;
-                        storage_type = ASR::storage_typeType::Save; // implicit save
+                        storage_type = ASR::storage_typeType::Save;  // implicit save
                     }
                 }
                 if (is_Function && implicit_save && !is_save) {
                     // throw warning to that particular variable
-                    if ( !is_global_save_enabled ) {
+                    if (!is_global_save_enabled) {
                         diag.semantic_warning_label(
                             "Assuming implicit save attribute for variable declaration",
-                            {x.m_syms[i].loc},
-                            "help: add explicit save attribute or parameter attribute or initialize in a separate statement"
-                        );
+                            { x.m_syms[i].loc },
+                            "help: add explicit save attribute or parameter attribute or initialize in a separate statement");
                     }
                 }
-                if ( variable_added_to_symtab != nullptr ) {
+                if (variable_added_to_symtab != nullptr) {
                     variable_added_to_symtab->m_value = value;
                     variable_added_to_symtab->m_symbolic_value = init_expr;
                     variable_added_to_symtab->m_storage = storage_type;
-                    if ( !is_implicitly_declared && !is_external) {
-                        if ( symbols_having_only_attributes_without_type.find(sym) != symbols_having_only_attributes_without_type.end() ) {
-                            ASR::symbol_t* symbol = symbols_having_only_attributes_without_type[sym];
-                            ASR::Variable_t* symbol_variable = ASR::down_cast<ASR::Variable_t>(symbol);
-                            if ( symbol_variable->m_type ) {
-                                if ( ASR::is_a<ASR::Array_t>(*symbol_variable->m_type) ) {
-                                    ASR::Array_t* array_type = ASR::down_cast<ASR::Array_t>(symbol_variable->m_type);
+                    if (!is_implicitly_declared && !is_external) {
+                        if (symbols_having_only_attributes_without_type.find(sym)
+                            != symbols_having_only_attributes_without_type.end()) {
+                            ASR::symbol_t* symbol
+                                = symbols_having_only_attributes_without_type[sym];
+                            ASR::Variable_t* symbol_variable
+                                = ASR::down_cast<ASR::Variable_t>(symbol);
+                            if (symbol_variable->m_type) {
+                                if (ASR::is_a<ASR::Array_t>(*symbol_variable->m_type)) {
+                                    ASR::Array_t* array_type
+                                        = ASR::down_cast<ASR::Array_t>(symbol_variable->m_type);
                                     array_type->m_type = type;
                                 } else {
                                     symbol_variable->m_type = type;
@@ -4963,7 +5953,8 @@ public:
                     }
                     SetChar variable_dependencies_vec;
                     variable_dependencies_vec.reserve(al, 1);
-                    ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type, init_expr, value, sym);
+                    ASRUtils::collect_variable_dependencies(
+                        al, variable_dependencies_vec, type, init_expr, value, sym);
                     variable_added_to_symtab->m_dependencies = variable_dependencies_vec.p;
                     variable_added_to_symtab->n_dependencies = variable_dependencies_vec.n;
 
@@ -4973,7 +5964,8 @@ public:
                             *variable_added_to_symtab->m_type_declaration)
                         && ASR::down_cast<ASR::ExternalSymbol_t>(
                                variable_added_to_symtab->m_type_declaration)
-                                   ->m_external == nullptr) {
+                                   ->m_external
+                               == nullptr) {
                         if (vars_with_deferred_struct_declaration.find(
                                 ASRUtils::symbol_name(variable_added_to_symtab->m_type_declaration))
                             != vars_with_deferred_struct_declaration.end()) {
@@ -4990,101 +5982,145 @@ public:
                         }
                     }
                 }
-            } // for m_syms
+            }  // for m_syms
         }
         _declaring_variable = false;
     }
 
-    void visit_BlockData(const AST::BlockData_t&/*x*/) {
-
+    void visit_BlockData(const AST::BlockData_t& /*x*/)
+    {
     }
 
-    void visit_Interface(const AST::Interface_t &/*x*/) {
-
+    void visit_Interface(const AST::Interface_t& /*x*/)
+    {
     }
 
-    void visit_DeclarationPragma(const AST::DeclarationPragma_t &/*x*/) {
-
+    void visit_DeclarationPragma(const AST::DeclarationPragma_t& /*x*/)
+    {
     }
 
-    void visit_DerivedType(const AST::DerivedType_t &/*x*/) {
-
+    void visit_DerivedType(const AST::DerivedType_t& /*x*/)
+    {
     }
 
-    void visit_Enum(const AST::Enum_t &/*x*/) {
-
+    void visit_Enum(const AST::Enum_t& /*x*/)
+    {
     }
 
-    void visit_Union(const AST::Union_t &/*x*/) {
-
+    void visit_Union(const AST::Union_t& /*x*/)
+    {
     }
 
-    ASR::ttype_t* determine_type(const Location &loc, std::string& sym,
-        AST::decl_attribute_t* decl_attribute, bool is_pointer,
-        bool is_allocatable, Vec<ASR::dimension_t>& dims,
-        AST::var_sym_t* var_sym,
-        ASR::symbol_t *&type_declaration, ASR::abiType abi, bool is_argument=false, bool is_dimension_star=false, bool is_assumed_rank=false) {
-
+    ASR::ttype_t* determine_type(const Location& loc,
+                                 std::string& sym,
+                                 AST::decl_attribute_t* decl_attribute,
+                                 bool is_pointer,
+                                 bool is_allocatable,
+                                 Vec<ASR::dimension_t>& dims,
+                                 AST::var_sym_t* var_sym,
+                                 ASR::symbol_t*& type_declaration,
+                                 ASR::abiType abi,
+                                 bool is_argument = false,
+                                 bool is_dimension_star = false,
+                                 bool is_assumed_rank = false)
+    {
         if (AST::is_a<AST::AttrTypeList_t>(*decl_attribute)) {
             // ONLY supposed to be used for LFortran specific types
-            AST::AttrTypeList_t *sym_type = AST::down_cast<AST::AttrTypeList_t>(decl_attribute);
+            AST::AttrTypeList_t* sym_type = AST::down_cast<AST::AttrTypeList_t>(decl_attribute);
 
             if (sym_type->m_type == AST::decl_typeType::TypeDict) {
                 if (sym_type->n_attr != 2) {
-                    diag.add(Diagnostic(
-                        "Dict declaration needs exactly two types",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                    diag.add(Diagnostic("Dict declaration needs exactly two types",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                ASR::ttype_t *key_type = determine_type(loc, sym, sym_type->m_attr[0], is_pointer,
-                                                       is_allocatable, dims, var_sym, type_declaration, abi);
+                ASR::ttype_t* key_type = determine_type(loc,
+                                                        sym,
+                                                        sym_type->m_attr[0],
+                                                        is_pointer,
+                                                        is_allocatable,
+                                                        dims,
+                                                        var_sym,
+                                                        type_declaration,
+                                                        abi);
 
                 // Implicitly consider deferred length descriptor string as allocatable
-                if (ASRUtils::is_deferredLength_string(key_type) && ASRUtils::is_descriptorString(key_type))
-                    key_type = determine_type(loc, sym, sym_type->m_attr[0],
-                                    is_pointer, true, dims, var_sym, type_declaration, abi);
-
-                ASR::ttype_t *value_type = determine_type(loc, sym, sym_type->m_attr[1], is_pointer, 
-                                                       is_allocatable, dims, var_sym, type_declaration, abi);
-
-                if (ASRUtils::is_deferredLength_string(value_type) && ASRUtils::is_descriptorString(value_type))
-                    value_type = determine_type(loc, sym, sym_type->m_attr[1],
-                                    is_pointer, true, dims, var_sym, type_declaration, abi);
-
-                return ASRUtils::TYPE(ASR::make_Dict_t(al, sym_type->base.base.loc, key_type, value_type));
+                if (ASRUtils::is_deferredLength_string(key_type)
+                    && ASRUtils::is_descriptorString(key_type))
+                    key_type = determine_type(loc,
+                                              sym,
+                                              sym_type->m_attr[0],
+                                              is_pointer,
+                                              true,
+                                              dims,
+                                              var_sym,
+                                              type_declaration,
+                                              abi);
+
+                ASR::ttype_t* value_type = determine_type(loc,
+                                                          sym,
+                                                          sym_type->m_attr[1],
+                                                          is_pointer,
+                                                          is_allocatable,
+                                                          dims,
+                                                          var_sym,
+                                                          type_declaration,
+                                                          abi);
+
+                if (ASRUtils::is_deferredLength_string(value_type)
+                    && ASRUtils::is_descriptorString(value_type))
+                    value_type = determine_type(loc,
+                                                sym,
+                                                sym_type->m_attr[1],
+                                                is_pointer,
+                                                true,
+                                                dims,
+                                                var_sym,
+                                                type_declaration,
+                                                abi);
+
+                return ASRUtils::TYPE(
+                    ASR::make_Dict_t(al, sym_type->base.base.loc, key_type, value_type));
             } else if (sym_type->m_type == AST::decl_typeType::TypeTuple) {
                 if (sym_type->n_attr < 1) {
-                    diag.add(Diagnostic(
-                        "Tuple declaration needs atleast one type",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                    diag.add(Diagnostic("Tuple declaration needs atleast one type",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
-                Vec<ASR::ttype_t *> type_vec;
+                Vec<ASR::ttype_t*> type_vec;
                 type_vec.reserve(al, sym_type->n_attr);
 
-                for (size_t i=0;i<sym_type->n_attr;i++)
-                    type_vec.push_back(al, determine_type(loc, sym, sym_type->m_attr[i], is_pointer, 
-                                                       is_allocatable, dims, var_sym, type_declaration, abi));
-
-                return ASRUtils::TYPE(ASR::make_Tuple_t(al, sym_type->base.base.loc, type_vec.p, type_vec.n));
-            }
-
-            diag.add(Diagnostic(
-                "Only LFortran specific types (dict, tuple) uses this syntax",
-                Level::Error, Stage::Semantic, {
-                    Label("",{sym_type->base.base.loc})
-                }));
+                for (size_t i = 0; i < sym_type->n_attr; i++)
+                    type_vec.push_back(al,
+                                       determine_type(loc,
+                                                      sym,
+                                                      sym_type->m_attr[i],
+                                                      is_pointer,
+                                                      is_allocatable,
+                                                      dims,
+                                                      var_sym,
+                                                      type_declaration,
+                                                      abi));
+
+                return ASRUtils::TYPE(
+                    ASR::make_Tuple_t(al, sym_type->base.base.loc, type_vec.p, type_vec.n));
+            }
+
+            diag.add(Diagnostic("Only LFortran specific types (dict, tuple) uses this syntax",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { sym_type->base.base.loc }) }));
             throw SemanticAbort();
         }
 
-        AST::AttrType_t *sym_type = AST::down_cast<AST::AttrType_t>(decl_attribute);
-        ASR::ttype_t *type = nullptr;
+        AST::AttrType_t* sym_type = AST::down_cast<AST::AttrType_t>(decl_attribute);
+        ASR::ttype_t* type = nullptr;
         type_declaration = nullptr;
 
         int a_kind = 4;
@@ -5094,172 +6130,230 @@ public:
 
         // general assignments and checks except when it's a
         // "Character" declaration
-        if (sym_type->m_type != AST::decl_typeType::TypeCharacter &&
-            sym_type->m_kind != nullptr
-        ) {
+        if (sym_type->m_type != AST::decl_typeType::TypeCharacter && sym_type->m_kind != nullptr) {
             if (sym_type->m_kind->m_value) {
                 this->visit_expr(*sym_type->m_kind->m_value);
                 ASR::expr_t* kind_expr = ASRUtils::EXPR(tmp);
-                a_kind = ASRUtils::extract_kind<SemanticAbort>(kind_expr, sym_type->m_kind->loc, diag);
+                a_kind
+                    = ASRUtils::extract_kind<SemanticAbort>(kind_expr, sym_type->m_kind->loc, diag);
             }
             // kind=* only allowed for "Character"
             else if (sym_type->m_kind->m_type == AST::kind_item_typeType::Star) {
-                diag.add(Diagnostic(
-                    "Expected initialization expression for kind",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{sym_type->m_kind->loc})
-                    }));
+                diag.add(Diagnostic("Expected initialization expression for kind",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { sym_type->m_kind->loc }) }));
                 throw SemanticAbort();
             }
         }
         if (sym_type->m_type == AST::decl_typeType::TypeReal) {
             if (a_kind != 4 && a_kind != 8) {
-                diag.add(Diagnostic(
-                    "Kind " + std::to_string(a_kind) + " is not supported for Real",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{sym_type->m_kind->loc})
-                    }));
+                diag.add(Diagnostic("Kind " + std::to_string(a_kind) + " is not supported for Real",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { sym_type->m_kind->loc }) }));
                 throw SemanticAbort();
             }
             type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, a_kind));
             if (is_assumed_rank) {
-                type = ASRUtils::TYPE(ASR::make_Array_t(al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
+                type = ASRUtils::TYPE(ASR::make_Array_t(
+                    al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
             } else {
-                type = ASRUtils::make_Array_t_util(
-                    al, loc, type, dims.p, dims.size(), abi, is_argument, ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star);
-            }            if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   type,
+                                                   dims.p,
+                                                   dims.size(),
+                                                   abi,
+                                                   is_argument,
+                                                   ASR::array_physical_typeType::DescriptorArray,
+                                                   false,
+                                                   is_dimension_star);
+            }
+            if (is_pointer) {
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeDoublePrecision) {
             a_kind = 8;
             type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, a_kind));
             if (is_assumed_rank) {
-                type = ASRUtils::TYPE(ASR::make_Array_t(al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
+                type = ASRUtils::TYPE(ASR::make_Array_t(
+                    al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
             } else {
-                type = ASRUtils::make_Array_t_util(
-                    al, loc, type, dims.p, dims.size(), abi, is_argument, ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star);
+                type = ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   type,
+                                                   dims.p,
+                                                   dims.size(),
+                                                   abi,
+                                                   is_argument,
+                                                   ASR::array_physical_typeType::DescriptorArray,
+                                                   false,
+                                                   is_dimension_star);
             }
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeInteger) {
             if (a_kind != 1 && a_kind != 2 && a_kind != 4 && a_kind != 8) {
-                diag.add(Diagnostic(
-                    "Kind " + std::to_string(a_kind) + " is not supported for Integer",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{sym_type->m_kind->loc})
-                    }));
+                diag.add(
+                    Diagnostic("Kind " + std::to_string(a_kind) + " is not supported for Integer",
+                               Level::Error,
+                               Stage::Semantic,
+                               { Label("", { sym_type->m_kind->loc }) }));
                 throw SemanticAbort();
             }
             type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, a_kind));
             if (is_assumed_rank) {
-                type = ASRUtils::TYPE(ASR::make_Array_t(al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
+                type = ASRUtils::TYPE(ASR::make_Array_t(
+                    al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
             } else {
-                type = ASRUtils::make_Array_t_util(
-                    al, loc, type, dims.p, dims.size(), abi, is_argument, ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star);
+                type = ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   type,
+                                                   dims.p,
+                                                   dims.size(),
+                                                   abi,
+                                                   is_argument,
+                                                   ASR::array_physical_typeType::DescriptorArray,
+                                                   false,
+                                                   is_dimension_star);
             }
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeLogical) {
             if (a_kind != 1 && a_kind != 2 && a_kind != 4 && a_kind != 8) {
-                diag.add(Diagnostic(
-                    "Kind " + std::to_string(a_kind) + " is not supported for Logical",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{sym_type->m_kind->loc})
-                    }));
+                diag.add(
+                    Diagnostic("Kind " + std::to_string(a_kind) + " is not supported for Logical",
+                               Level::Error,
+                               Stage::Semantic,
+                               { Label("", { sym_type->m_kind->loc }) }));
                 throw SemanticAbort();
             }
             // currently we change the kind's of all logical's to
             // 'default_integer_kind'. GFortran support's logical's of
             // different kind's, we need to think about this
-            type = ASRUtils::TYPE(ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
-            type = ASRUtils::make_Array_t_util(
-                al, loc, type, dims.p, dims.size(), abi, is_argument, ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star);
+            type = ASRUtils::TYPE(
+                ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
+            type = ASRUtils::make_Array_t_util(al,
+                                               loc,
+                                               type,
+                                               dims.p,
+                                               dims.size(),
+                                               abi,
+                                               is_argument,
+                                               ASR::array_physical_typeType::DescriptorArray,
+                                               false,
+                                               is_dimension_star);
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeComplex) {
             if (a_kind != 4 && a_kind != 8) {
-                diag.add(Diagnostic(
-                    "Kind " + std::to_string(a_kind) + " is not supported for Complex",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{sym_type->m_kind->loc})
-                    }));
+                diag.add(
+                    Diagnostic("Kind " + std::to_string(a_kind) + " is not supported for Complex",
+                               Level::Error,
+                               Stage::Semantic,
+                               { Label("", { sym_type->m_kind->loc }) }));
                 throw SemanticAbort();
             }
             type = ASRUtils::TYPE(ASR::make_Complex_t(al, loc, a_kind));
             if (is_assumed_rank) {
-                type = ASRUtils::TYPE(ASR::make_Array_t(al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
+                type = ASRUtils::TYPE(ASR::make_Array_t(
+                    al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
             } else {
-                type = ASRUtils::make_Array_t_util(
-                    al, loc, type, dims.p, dims.size(), abi, is_argument, ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star);
+                type = ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   type,
+                                                   dims.p,
+                                                   dims.size(),
+                                                   abi,
+                                                   is_argument,
+                                                   ASR::array_physical_typeType::DescriptorArray,
+                                                   false,
+                                                   is_dimension_star);
             }
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeDoubleComplex) {
             a_kind = 8;
             type = ASRUtils::TYPE(ASR::make_Complex_t(al, loc, a_kind));
             if (is_assumed_rank) {
-                type = ASRUtils::TYPE(ASR::make_Array_t(al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
+                type = ASRUtils::TYPE(ASR::make_Array_t(
+                    al, loc, type, nullptr, 0, ASR::array_physical_typeType::AssumedRankArray));
             } else {
-                type = ASRUtils::make_Array_t_util(
-                    al, loc, type, dims.p, dims.size(), abi, is_argument, ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star);
+                type = ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   type,
+                                                   dims.p,
+                                                   dims.size(),
+                                                   abi,
+                                                   is_argument,
+                                                   ASR::array_physical_typeType::DescriptorArray,
+                                                   false,
+                                                   is_dimension_star);
             }
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeCharacter) {
             a_kind = 1;
             // Create String type.
-            type = ASRUtils::TYPE(ASR::make_String_t(
-                al, loc, a_kind, nullptr, // Invalid state. Should be captured by ASR_Verify (If not modified later). 
-                ASR::string_length_kindType::ExpressionLength,
-                    ASR::string_physical_typeType::DescriptorString));
+            type = ASRUtils::TYPE(
+                ASR::make_String_t(al,
+                                   loc,
+                                   a_kind,
+                                   nullptr,  // Invalid state. Should be captured by ASR_Verify (If
+                                             // not modified later).
+                                   ASR::string_length_kindType::ExpressionLength,
+                                   ASR::string_physical_typeType::DescriptorString));
             ASR::String_t* str = ASR::down_cast<ASR::String_t>(type);
 
             LCOMPILERS_ASSERT(sym_type->n_kind < 3)
-            
+
             if (sym_type->n_kind == 1) {
-                const auto &item = sym_type->m_kind[0];
+                const auto& item = sym_type->m_kind[0];
                 std::string id = item.m_id ? to_lower(item.m_id) : "";
 
                 if (id != "kind" && id != "len" && id != "") {
                     diag.add(Diagnostic(
                         "Syntax error in CHARACTER declaration: only 'len' and 'kind' are allowed as type parameters",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
                 if (id == "kind") {
-                    //TODO: Handle kind attribute on item (ideally should be a function call)
-                    determine_char_len_and_kind(nullptr, &item, sym_type, var_sym, sym, str, is_argument, abi);
+                    // TODO: Handle kind attribute on item (ideally should be a function call)
+                    determine_char_len_and_kind(
+                        nullptr, &item, sym_type, var_sym, sym, str, is_argument, abi);
                 } else {
-                    determine_char_len_and_kind(&item, nullptr, sym_type, var_sym, sym, str, is_argument, abi);
+                    determine_char_len_and_kind(
+                        &item, nullptr, sym_type, var_sym, sym, str, is_argument, abi);
                 }
 
             } else if (sym_type->n_kind == 2) {
-                const auto &item1 = sym_type->m_kind[0];
-                const auto &item2 = sym_type->m_kind[1];
+                const auto& item1 = sym_type->m_kind[0];
+                const auto& item2 = sym_type->m_kind[1];
                 std::string id1 = item1.m_id ? to_lower(item1.m_id) : "";
                 std::string id2 = item2.m_id ? to_lower(item2.m_id) : "";
 
-                if ((id1 != "kind" && id1 != "len" && id1 != "") ||
-                        (id2 != "kind" && id2 != "len" && id2 != "")) {
+                if ((id1 != "kind" && id1 != "len" && id1 != "")
+                    || (id2 != "kind" && id2 != "len" && id2 != "")) {
                     diag.add(Diagnostic(
                         "Syntax error in CHARACTER declaration: only 'len' and 'kind' are allowed as keyword arguments",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
@@ -5267,9 +6361,9 @@ public:
                 if (id1 == id2 && id1 != "") {
                     diag.add(Diagnostic(
                         "Syntax error in CHARACTER declaration: can't use a keyword argument more than once",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
@@ -5277,9 +6371,9 @@ public:
                 if (id1 != "" && id2 == "") {
                     diag.add(Diagnostic(
                         "Syntax error in CHARACTER declaration: positional type parameters cannot follow a keyword argument",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
@@ -5287,105 +6381,168 @@ public:
                 if (id1 == "" && id2 == "len") {
                     diag.add(Diagnostic(
                         "Syntax error in CHARACTER declaration: using only 'len' keyword argument after a positional type is invalid",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{sym_type->base.base.loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { sym_type->base.base.loc }) }));
                     throw SemanticAbort();
                 }
 
                 if (id1 == "kind" && id2 == "len") {
-                    determine_char_len_and_kind(&item2, &item1, sym_type, var_sym, sym, str, is_argument, abi);
+                    determine_char_len_and_kind(
+                        &item2, &item1, sym_type, var_sym, sym, str, is_argument, abi);
 
-                    //TODO: Handle kind attribute on item1 (ideally should be a function call)
+                    // TODO: Handle kind attribute on item1 (ideally should be a function call)
                 } else {
-                    determine_char_len_and_kind(&item1, &item2, sym_type, var_sym, sym, str, is_argument, abi);
+                    determine_char_len_and_kind(
+                        &item1, &item2, sym_type, var_sym, sym, str, is_argument, abi);
 
-                    //TODO: Handle kind attribute on item2 (ideally should be a function call)
+                    // TODO: Handle kind attribute on item2 (ideally should be a function call)
                 }
             } else {
-                determine_char_len_and_kind(nullptr, nullptr, sym_type, var_sym, sym, str, is_argument, abi);
+                determine_char_len_and_kind(
+                    nullptr, nullptr, sym_type, var_sym, sym, str, is_argument, abi);
             }
 
             type = ASRUtils::make_Array_t_util(
-                al, loc, type, dims.p, dims.size(), abi, is_argument,
-                dims.size() > 0 && abi == ASR::abiType::BindC ? ASR::array_physical_typeType::StringArraySinglePointer :
-                                ASRUtils::is_fixed_size_array(dims.p, dims.n) ? ASR::array_physical_typeType::PointerArray :
-                                ASR::array_physical_typeType::DescriptorArray,
+                al,
+                loc,
+                type,
+                dims.p,
+                dims.size(),
+                abi,
+                is_argument,
+                dims.size() > 0 && abi == ASR::abiType::BindC
+                    ? ASR::array_physical_typeType::StringArraySinglePointer
+                : ASRUtils::is_fixed_size_array(dims.p, dims.n)
+                    ? ASR::array_physical_typeType::PointerArray
+                    : ASR::array_physical_typeType::DescriptorArray,
                 dims.size() > 0 ? true : false);
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
-            
+
             if (abi == ASR::abiType::BindC) {
                 int64_t char_len;
-                ASR::String_t *str_type = ASR::down_cast<ASR::String_t>(ASRUtils::type_get_past_array(type));
+                ASR::String_t* str_type
+                    = ASR::down_cast<ASR::String_t>(ASRUtils::type_get_past_array(type));
                 bool has_len = ASRUtils::extract_value(str_type->m_len, char_len);
                 if (!has_len || char_len != 1) {
                     diag.add(Diagnostic(
-                        "Character dummy argument `" + sym +
-                        "` must be of constant length of one or assumed length, "
-                        "unless it has assumed shape or assumed rank in a BIND(C) procedure",
-                        Level::Error, Stage::Semantic, {
-                            Label("", {loc})
-                        }));
+                        "Character dummy argument `" + sym
+                            + "` must be of constant length of one or assumed length, "
+                              "unless it has assumed shape or assumed rank in a BIND(C) procedure",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeType) {
             if (sym_type->m_attr) {
-                return determine_type(loc, sym, sym_type->m_attr,
-                    is_pointer, is_allocatable, dims, var_sym, type_declaration, abi,
-                    is_argument);
+                return determine_type(loc,
+                                      sym,
+                                      sym_type->m_attr,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
             }
             if (!sym_type->m_name) {
-                diag.add(Diagnostic(
-                    "Type must have a name",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{loc})
-                    }));
+                diag.add(Diagnostic("Type must have a name",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
             std::string derived_type_name = to_lower(sym_type->m_name);
             if (derived_type_name == "integer") {
                 sym_type->m_type = AST::decl_typeType::TypeInteger;
-                return determine_type(loc, sym, decl_attribute, is_pointer,
-                    is_allocatable, dims, var_sym, type_declaration, abi, is_argument);
+                return determine_type(loc,
+                                      sym,
+                                      decl_attribute,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
             } else if (derived_type_name == "real") {
                 sym_type->m_type = AST::decl_typeType::TypeReal;
-                return determine_type(loc, sym, decl_attribute, is_pointer,
-                    is_allocatable, dims, var_sym, type_declaration, abi, is_argument);
+                return determine_type(loc,
+                                      sym,
+                                      decl_attribute,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
             } else if (derived_type_name == "complex") {
                 sym_type->m_type = AST::decl_typeType::TypeComplex;
-                return determine_type(loc, sym, decl_attribute, is_pointer,
-                    is_allocatable, dims, var_sym, type_declaration, abi, is_argument);
+                return determine_type(loc,
+                                      sym,
+                                      decl_attribute,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
             } else if (derived_type_name == "logical") {
                 sym_type->m_type = AST::decl_typeType::TypeLogical;
-                return determine_type(loc, sym, decl_attribute, is_pointer,
-                    is_allocatable, dims, var_sym, type_declaration, abi, is_argument);
+                return determine_type(loc,
+                                      sym,
+                                      decl_attribute,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
             } else if (derived_type_name == "character") {
                 sym_type->m_type = AST::decl_typeType::TypeCharacter;
-                return determine_type(loc, sym, decl_attribute, is_pointer,
-                    is_allocatable, dims, var_sym, type_declaration, abi, is_argument);
+                return determine_type(loc,
+                                      sym,
+                                      decl_attribute,
+                                      is_pointer,
+                                      is_allocatable,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
             } else if (derived_type_name == "unsigned") {
                 return ASRUtils::TYPE(ASR::make_UnsignedInteger_t(al, loc, 4));
             }
 
             ASR::symbol_t* v = current_scope->resolve_symbol(derived_type_name);
             if (v && ASR::is_a<ASR::Variable_t>(*v)
-                  && ASR::is_a<ASR::TypeParameter_t>(*
-                    ASRUtils::type_get_past_array(
-                        ASR::down_cast<ASR::Variable_t>(v)->m_type))) {
-                type = ASRUtils::TYPE(ASR::make_TypeParameter_t(al, loc,
-                                        s2c(al, derived_type_name)));
+                && ASR::is_a<ASR::TypeParameter_t>(
+                    *ASRUtils::type_get_past_array(ASR::down_cast<ASR::Variable_t>(v)->m_type))) {
+                type = ASRUtils::TYPE(
+                    ASR::make_TypeParameter_t(al, loc, s2c(al, derived_type_name)));
                 type = ASRUtils::make_Array_t_util(
                     al, loc, type, dims.p, dims.size(), abi, is_argument);
             } else if (v && ASRUtils::is_c_ptr(v, derived_type_name)) {
                 type = ASRUtils::TYPE(ASR::make_CPtr_t(al, loc));
-                type = ASRUtils::make_Array_t_util(
-                    al, loc, type, dims.p, dims.size(), abi, is_argument,
-                    ASR::array_physical_typeType::DescriptorArray, false, is_dimension_star
-                );
+                type = ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   type,
+                                                   dims.p,
+                                                   dims.size(),
+                                                   abi,
+                                                   is_argument,
+                                                   ASR::array_physical_typeType::DescriptorArray,
+                                                   false,
+                                                   is_dimension_star);
             } else if (v && ASRUtils::is_c_funptr(v, derived_type_name)) {
                 type = ASRUtils::TYPE(ASR::make_CPtr_t(al, loc));
             } else if (v && ASR::is_a<ASR::Union_t>(*v)) {
@@ -5393,42 +6550,50 @@ public:
                 type = ASRUtils::get_union_type(al, loc, v);
             } else {
                 if (!v) {
-                    if (is_template) { 
-                        diag.add(Diagnostic(
-                            "Type parameter '" + derived_type_name + "' is not specified "
-                            "in any requirements",
-                            Level::Error, Stage::Semantic, {
-                                Label("",{loc})
-                            }));
+                    if (is_template) {
+                        diag.add(Diagnostic("Type parameter '" + derived_type_name
+                                                + "' is not specified "
+                                                  "in any requirements",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     } else if (this->is_derived_type && (is_pointer || is_allocatable)) {
                         // Placeholder symbol for StructType type
                         // Derived type can be used before its actually defined
-                        v = ASR::down_cast<ASR::symbol_t>(ASR::make_ExternalSymbol_t(
-                                al, loc, current_scope, s2c(al, derived_type_name),
-                                nullptr, nullptr, nullptr, 0, s2c(al, derived_type_name),
-                                ASR::accessType::Private));
+                        v = ASR::down_cast<ASR::symbol_t>(
+                            ASR::make_ExternalSymbol_t(al,
+                                                       loc,
+                                                       current_scope,
+                                                       s2c(al, derived_type_name),
+                                                       nullptr,
+                                                       nullptr,
+                                                       nullptr,
+                                                       0,
+                                                       s2c(al, derived_type_name),
+                                                       ASR::accessType::Private));
                         // set the variable's type declaration to the derived type
                         type_declaration = v;
                         type = ASRUtils::TYPE(ASR::make_StructType_t(
-                        al,
-                        loc,
-                        nullptr,
-                        0,
-                        nullptr,
-                        0,
-                        true,
-                        ASRUtils::symbol_name(v) == std::string("~unlimited_polymorphic_type")
-                        ? true
-                        : false));
-                    } else { 
-                        diag.add(Diagnostic(
-                            "Derived type `" + derived_type_name + "` is not defined",
-                            diag::Level::Error, Stage::Semantic, {
-                                Label("Type used here is not defined in any scope", {decl_attribute->base.loc})
-                            }));
+                            al,
+                            loc,
+                            nullptr,
+                            0,
+                            nullptr,
+                            0,
+                            true,
+                            ASRUtils::symbol_name(v) == std::string("~unlimited_polymorphic_type")
+                                ? true
+                                : false));
+                    } else {
+                        diag.add(
+                            Diagnostic("Derived type `" + derived_type_name + "` is not defined",
+                                       diag::Level::Error,
+                                       Stage::Semantic,
+                                       { Label("Type used here is not defined in any scope",
+                                               { decl_attribute->base.loc }) }));
                         throw SemanticAbort();
-                    }                   
+                    }
                 } else if (v && ASRUtils::symbol_get_past_external(v)
                            && ASR::is_a<ASR::Struct_t>(*ASRUtils::symbol_get_past_external(v))) {
                     // set the variable's type declaration to the derived type
@@ -5438,63 +6603,100 @@ public:
                 // set the variable's type declaration to the derived type
                 type_declaration = v;
                 // type = ASRUtils::TYPE(ASRUtils::make_StructType_t_util(al, loc, v));
-                if (v && ASRUtils::symbol_get_past_external(v) && ASR::is_a<ASR::Union_t>(*ASRUtils::symbol_get_past_external(v))) {    
+                if (v && ASRUtils::symbol_get_past_external(v)
+                    && ASR::is_a<ASR::Union_t>(*ASRUtils::symbol_get_past_external(v))) {
                     type = ASRUtils::get_union_type(al, loc, ASRUtils::symbol_get_past_external(v));
-                } else if ( v && ASRUtils::symbol_get_past_external(v) ) {
+                } else if (v && ASRUtils::symbol_get_past_external(v)) {
                     type = ASRUtils::make_StructType_t_util(al, loc, v, true);
                 }
                 type = ASRUtils::make_Array_t_util(
                     al, loc, type, dims.p, dims.size(), abi, is_argument);
                 if (is_pointer) {
-                    type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                        type));
+                    type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc, type));
                 }
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeList) {
-            ASR::ttype_t* type = determine_type(loc, sym, sym_type->m_attr,
-                    is_pointer, is_allocatable, dims, var_sym, type_declaration, abi,
-                    is_argument);
+            ASR::ttype_t* type = determine_type(loc,
+                                                sym,
+                                                sym_type->m_attr,
+                                                is_pointer,
+                                                is_allocatable,
+                                                dims,
+                                                var_sym,
+                                                type_declaration,
+                                                abi,
+                                                is_argument);
 
             // Implicitly consider deferred length descriptor string as allocatable
             if (ASRUtils::is_deferredLength_string(type) && ASRUtils::is_descriptorString(type))
-                type = determine_type(loc, sym, sym_type->m_attr,
-                                is_pointer, true, dims, var_sym, type_declaration, abi,
-                                is_argument);
-
-            return ASRUtils::TYPE(ASR::make_List_t(al, loc, type)); 
-        }  else if (sym_type->m_type == AST::decl_typeType::TypeSet) {
-            return ASRUtils::TYPE(ASR::make_Set_t(al, loc, determine_type(loc, sym, sym_type->m_attr,
-                    is_pointer, is_allocatable, dims, var_sym, type_declaration, abi,
-                    is_argument))); 
+                type = determine_type(loc,
+                                      sym,
+                                      sym_type->m_attr,
+                                      is_pointer,
+                                      true,
+                                      dims,
+                                      var_sym,
+                                      type_declaration,
+                                      abi,
+                                      is_argument);
+
+            return ASRUtils::TYPE(ASR::make_List_t(al, loc, type));
+        } else if (sym_type->m_type == AST::decl_typeType::TypeSet) {
+            return ASRUtils::TYPE(ASR::make_Set_t(al,
+                                                  loc,
+                                                  determine_type(loc,
+                                                                 sym,
+                                                                 sym_type->m_attr,
+                                                                 is_pointer,
+                                                                 is_allocatable,
+                                                                 dims,
+                                                                 var_sym,
+                                                                 type_declaration,
+                                                                 abi,
+                                                                 is_argument)));
         } else if (sym_type->m_type == AST::decl_typeType::TypeClass) {
             std::string derived_type_name;
-            if( !sym_type->m_name ) {
+            if (!sym_type->m_name) {
                 derived_type_name = "~unlimited_polymorphic_type";
             } else {
                 derived_type_name = to_lower(sym_type->m_name);
             }
-            ASR::symbol_t *v = current_scope->resolve_symbol(derived_type_name);
-            if( !v ) {
-                if( derived_type_name != "~unlimited_polymorphic_type" ) {
-                    diag.add(Diagnostic(
-                        "Derived type '" + derived_type_name
-                        + "' not declared",
-                        Level::Error, Stage::Semantic, {
-                            Label("",{loc})
-                        }));
+            ASR::symbol_t* v = current_scope->resolve_symbol(derived_type_name);
+            if (!v) {
+                if (derived_type_name != "~unlimited_polymorphic_type") {
+                    diag.add(Diagnostic("Derived type '" + derived_type_name + "' not declared",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
-                SymbolTable *parent_scope = current_scope;
+                SymbolTable* parent_scope = current_scope;
                 current_scope = al.make_new<SymbolTable>(parent_scope);
-                ASR::asr_t* dtype = ASR::make_Struct_t(al, loc, current_scope,
-                                                s2c(al, to_lower(derived_type_name)), nullptr, nullptr, 0, nullptr, 0,
-                                                nullptr, 0, ASR::abiType::Source, dflt_access, false, true,
-                                                nullptr, 0, nullptr, nullptr);
+                ASR::asr_t* dtype = ASR::make_Struct_t(al,
+                                                       loc,
+                                                       current_scope,
+                                                       s2c(al, to_lower(derived_type_name)),
+                                                       nullptr,
+                                                       nullptr,
+                                                       0,
+                                                       nullptr,
+                                                       0,
+                                                       nullptr,
+                                                       0,
+                                                       ASR::abiType::Source,
+                                                       dflt_access,
+                                                       false,
+                                                       true,
+                                                       nullptr,
+                                                       0,
+                                                       nullptr,
+                                                       nullptr);
                 ASR::symbol_t* struct_symbol = ASR::down_cast<ASR::symbol_t>(dtype);
-                ASR::ttype_t* struct_type = ASRUtils::make_StructType_t_util(al, loc, struct_symbol, false);
+                ASR::ttype_t* struct_type
+                    = ASRUtils::make_StructType_t_util(al, loc, struct_symbol, false);
                 ASR::Struct_t* struct_ = ASR::down_cast<ASR::Struct_t>(struct_symbol);
                 struct_->m_struct_signature = struct_type;
-                struct_symbol = ASR::down_cast<ASR::symbol_t>((ASR::asr_t*)struct_);
+                struct_symbol = ASR::down_cast<ASR::symbol_t>((ASR::asr_t*) struct_);
                 v = ASR::down_cast<ASR::symbol_t>(dtype);
                 parent_scope->add_symbol(derived_type_name, v);
                 current_scope = parent_scope;
@@ -5503,22 +6705,20 @@ public:
             // set the variable's type declaration to the derived type
             type_declaration = v;
             type = ASRUtils::make_StructType_t_util(al, loc, v, false);
-            type = ASRUtils::make_Array_t_util(
-                al, loc, type, dims.p, dims.size(), abi, is_argument);
+            type
+                = ASRUtils::make_Array_t_util(al, loc, type, dims.p, dims.size(), abi, is_argument);
             if (is_pointer) {
-                type = ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(type)));
+                type = ASRUtils::TYPE(
+                    ASR::make_Pointer_t(al, loc, ASRUtils::type_get_past_allocatable(type)));
             }
         } else if (sym_type->m_type == AST::decl_typeType::TypeProcedure) {
             std::string func_name = to_lower(sym_type->m_name);
-            ASR::symbol_t *v = current_scope->resolve_symbol(func_name);
-            if( !v ) {
-                diag.add(Diagnostic(
-                    "Procedure type '" + func_name
-                    + "' not declared",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{loc})
-                    }));
+            ASR::symbol_t* v = current_scope->resolve_symbol(func_name);
+            if (!v) {
+                diag.add(Diagnostic("Procedure type '" + func_name + "' not declared",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
             type_declaration = v;
@@ -5527,24 +6727,29 @@ public:
             type = ASR::down_cast<ASR::Function_t>(v)->m_function_signature;
         } else {
             diag.add(Diagnostic("Type not implemented yet.",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
-        if( is_allocatable ) {
-            type = ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(al, loc,
-                ASRUtils::type_get_past_allocatable(type)));
+        if (is_allocatable) {
+            type = ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(
+                al, loc, ASRUtils::type_get_past_allocatable(type)));
         }
 
         return type;
     }
 
 
-    ASR::asr_t* create_DerivedTypeConstructor(const Location &loc,
-            AST::fnarg_t* m_args, size_t n_args, AST::keyword_t* kwargs,
-            size_t n_kwargs, ASR::symbol_t *v, bool is_const = false) {
+    ASR::asr_t* create_DerivedTypeConstructor(const Location& loc,
+                                              AST::fnarg_t* m_args,
+                                              size_t n_args,
+                                              AST::keyword_t* kwargs,
+                                              size_t n_kwargs,
+                                              ASR::symbol_t* v,
+                                              bool is_const = false)
+    {
         Vec<ASR::call_arg_t> vals;
         visit_expr_list(m_args, n_args, vals);
         visit_kwargs(vals, kwargs, n_kwargs, loc, v, diag);
@@ -5552,97 +6757,110 @@ public:
 
         // Ensure all values are constant before creating StructConstant
         for (const auto& val : vals) {
-            // If val.m_value is nullptr, default value is not needed and it is still const (Variable with Allocatable type)
-            if (val.m_value &&
-                    !(ASRUtils::is_value_constant(val.m_value) ||
-                      ASRUtils::is_value_constant(ASRUtils::expr_value(val.m_value)))) {
-                    is_const = false;
-                    break;
+            // If val.m_value is nullptr, default value is not needed and it is still const
+            // (Variable with Allocatable type)
+            if (val.m_value
+                && !(ASRUtils::is_value_constant(val.m_value)
+                     || ASRUtils::is_value_constant(ASRUtils::expr_value(val.m_value)))) {
+                is_const = false;
+                break;
             }
         }
         if (is_const) {
-           return ASR::make_StructConstant_t(al, loc,
-                    v, vals.p, vals.size(), der);
+            return ASR::make_StructConstant_t(al, loc, v, vals.p, vals.size(), der);
         }
-        return ASR::make_StructConstructor_t(al, loc,
-                v, vals.p, vals.size(), der, nullptr);
+        return ASR::make_StructConstructor_t(al, loc, v, vals.p, vals.size(), der, nullptr);
     }
 
-    int get_based_indexing(ASR::symbol_t* v) {
+    int get_based_indexing(ASR::symbol_t* v)
+    {
         if (v != nullptr && ASR::is_a<ASR::Variable_t>(*ASRUtils::symbol_get_past_external(v))) {
-            ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(v));
-            if (ASRUtils::is_array(var->m_type) && var->m_value && var->m_storage == ASR::storage_typeType::Parameter) {
+            ASR::Variable_t* var
+                = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(v));
+            if (ASRUtils::is_array(var->m_type) && var->m_value
+                && var->m_storage == ASR::storage_typeType::Parameter) {
                 ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(var->m_type);
                 for (size_t i = 0; i < arr->n_dims; i++) {
                     ASR::dimension_t dim = arr->m_dims[i];
                     if (dim.m_start != nullptr) {
-                        ASR::expr_t *start = ASRUtils::expr_value(dim.m_start);
+                        ASR::expr_t* start = ASRUtils::expr_value(dim.m_start);
                         if (start) {
-                            ASR::IntegerConstant_t *start2 = ASR::down_cast<ASR::IntegerConstant_t>(start);
+                            ASR::IntegerConstant_t* start2
+                                = ASR::down_cast<ASR::IntegerConstant_t>(start);
                             return start2->m_n;
                         }
                     }
                 }
             }
         }
-        return 1; // default
+        return 1;  // default
     }
 
-    ASR::asr_t* create_ArrayRef(const Location &loc, AST::fnarg_t* m_args,
-        size_t n_args, AST::fnarg_t* m_subargs, size_t n_subargs,
-        ASR::expr_t* v_expr, ASR::symbol_t *v, ASR::symbol_t *f2) {
-        ASR::ttype_t* root_v_type = ASRUtils::type_get_past_pointer(
-            ASRUtils::symbol_type(v));
+    ASR::asr_t* create_ArrayRef(const Location& loc,
+                                AST::fnarg_t* m_args,
+                                size_t n_args,
+                                AST::fnarg_t* m_subargs,
+                                size_t n_subargs,
+                                ASR::expr_t* v_expr,
+                                ASR::symbol_t* v,
+                                ASR::symbol_t* f2)
+    {
+        ASR::ttype_t* root_v_type = ASRUtils::type_get_past_pointer(ASRUtils::symbol_type(v));
         size_t n_dims = ASRUtils::extract_n_dims_from_ttype(root_v_type);
         bool is_assumed_rank = false;
         if (ASRUtils::is_assumed_rank_array(root_v_type)) {
             is_assumed_rank = true;
             std::string var_name = ASRUtils::symbol_name(v);
             if (assumed_rank_arrays.find(var_name) == assumed_rank_arrays.end()) {
-                diag.add(Diagnostic(
-                    "Assumed-rank array `" + var_name +
-                    "` cannot be accessed outside a select rank block",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{loc})
-                    }));
+                diag.add(Diagnostic("Assumed-rank array `" + var_name
+                                        + "` cannot be accessed outside a select rank block",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             } else {
                 size_t rank = assumed_rank_arrays[var_name];
-                ASR::ttype_t* new_type = ASRUtils::create_array_type_with_empty_dims(al, rank, ASRUtils::extract_type(root_v_type));
+                ASR::ttype_t* new_type = ASRUtils::create_array_type_with_empty_dims(
+                    al, rank, ASRUtils::extract_type(root_v_type));
                 root_v_type = new_type;
                 n_dims = rank;
             }
         }
         if (ASRUtils::is_array(root_v_type) && n_dims != n_args) {
             std::string var_name = ASRUtils::symbol_name(v);
-            diag.add(Diagnostic(
-                "Rank mismatch in array reference: the array `"
-                + var_name + "` has rank `" + std::to_string(n_dims) +
-                "`, but is referenced as rank `" + std::to_string(n_args) + "`",
-                Level::Error, Stage::Semantic, {
-                    Label("",{loc})
-                }));
+            diag.add(Diagnostic("Rank mismatch in array reference: the array `" + var_name
+                                    + "` has rank `" + std::to_string(n_dims)
+                                    + "`, but is referenced as rank `" + std::to_string(n_args)
+                                    + "`",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         bool is_item = true;
         Vec<ASR::array_index_t> args;
         args.reserve(al, n_args);
         ASR::expr_t* v_Var = nullptr;
-        if( v_expr ) {
+        if (v_expr) {
             ASR::ttype_t* struct_t_mem_type = ASRUtils::symbol_type(v);
             ASR::symbol_t* v_ext = ASRUtils::import_struct_instance_member(al, v, current_scope);
             v_Var = ASRUtils::EXPR(ASR::make_StructInstanceMember_t(
-                        al, v_expr->base.loc, v_expr, v_ext, struct_t_mem_type, nullptr));
+                al, v_expr->base.loc, v_expr, v_ext, struct_t_mem_type, nullptr));
         } else {
             v_Var = ASRUtils::EXPR(ASR::make_Var_t(al, loc, v));
             if (is_assumed_rank) {
-                ASR::expr_t* cast_expr = ASRUtils::EXPR(ASRUtils::make_ArrayPhysicalCast_t_util(al, loc, 
-                    v_Var, ASR::array_physical_typeType::AssumedRankArray, ASR::array_physical_typeType::DescriptorArray, 
-                    root_v_type, nullptr));
+                ASR::expr_t* cast_expr = ASRUtils::EXPR(ASRUtils::make_ArrayPhysicalCast_t_util(
+                    al,
+                    loc,
+                    v_Var,
+                    ASR::array_physical_typeType::AssumedRankArray,
+                    ASR::array_physical_typeType::DescriptorArray,
+                    root_v_type,
+                    nullptr));
                 v_Var = cast_expr;
             }
         }
-        for (size_t i=0; i<n_args; i++) {
+        for (size_t i = 0; i < n_args; i++) {
             ASR::array_index_t ai;
             ai.loc = loc;
             ASR::expr_t *m_start, *m_end, *m_step;
@@ -5657,17 +6875,22 @@ public:
                 m_end = ASRUtils::EXPR(tmp);
                 ai.loc = m_end->base.loc;
             } else {
-                if(ASR::is_a<ASR::String_t>(*ASRUtils::type_get_past_allocatable_pointer(root_v_type))) {
+                if (ASR::is_a<ASR::String_t>(
+                        *ASRUtils::type_get_past_allocatable_pointer(root_v_type))) {
                     ASR::String_t* char_type = ASR::down_cast<ASR::String_t>(
                         ASRUtils::extract_type(ASRUtils::symbol_type(v)));
-                    int64_t m_len_value; // Dummy to just use below.
-                    bool is_comp_time_value =  ASRUtils::extract_value(char_type->m_len, m_len_value);
-                    if( is_comp_time_value ) {
+                    int64_t m_len_value;  // Dummy to just use below.
+                    bool is_comp_time_value
+                        = ASRUtils::extract_value(char_type->m_len, m_len_value);
+                    if (is_comp_time_value) {
                         m_end = ASRUtils::expr_value(char_type->m_len);
                     } else {
-                        m_end = ASRUtils::EXPR(ASR::make_StringLen_t(al, loc,
-                            v_Var, ASRUtils::TYPE(
-                                ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind)),
+                        m_end = ASRUtils::EXPR(ASR::make_StringLen_t(
+                            al,
+                            loc,
+                            v_Var,
+                            ASRUtils::TYPE(ASR::make_Integer_t(
+                                al, loc, compiler_options.po.default_integer_kind)),
                             nullptr));
                     }
                 } else {
@@ -5680,131 +6903,147 @@ public:
                 m_step = ASRUtils::EXPR(tmp);
                 ai.loc = m_step->base.loc;
             }
-            if( m_start != nullptr &&
-                ASR::is_a<ASR::Var_t>(*m_start) &&
-                ASR::is_a<ASR::Var_t>(*m_end) ) {
-                ASR::Variable_t* startv = ASRUtils::EXPR2VAR(m_start);
-                ASR::Variable_t* endv = ASRUtils::EXPR2VAR(m_end);
-                is_item = is_item && (startv == endv);
-                if( is_item ) {
-                    m_start = nullptr;
-                    m_step = nullptr;
-                }
-            } else {
-                is_item = is_item && (m_start == nullptr &&
-                                      m_step == nullptr &&
-                                      m_end != nullptr);
+            // NEW LOGIC: If colon is used  must be ArraySection, even if lb == ub.
+            // Colon is used when either m_start or m_end is explicitly provided.
+            bool colon_used = (m_args[i].m_start != nullptr) || (m_args[i].m_end != nullptr);
+
+            // If colon is used  NOT an ArrayItem.
+            if (colon_used) {
+                is_item = false;
             }
+
             ai.m_left = m_start;
             ai.m_right = m_end;
             ai.m_step = m_step;
             args.push_back(al, ai);
         }
 
-        ASR::ttype_t *type = nullptr;
+        ASR::ttype_t* type = nullptr;
         type = ASRUtils::type_get_past_pointer(ASRUtils::symbol_type(f2));
-        ASR::expr_t *arr_ref_val = nullptr;
+        ASR::expr_t* arr_ref_val = nullptr;
         bool all_args_eval = ASRUtils::all_args_evaluated(args);
         Vec<ASR::dimension_t> res_dims_vec;
         res_dims_vec.reserve(al, n_args);
         bool is_arg_array = false;
-        for( auto& a : args ) {
+        for (auto& a : args) {
             // Assume that indices are constant integers
             int64_t start = 1, end = -1, step = 1;
             bool flag = false;
-            if( a.m_left ) {
-                if( all_args_eval ) {
+            if (a.m_left) {
+                if (all_args_eval) {
                     ASR::expr_t* m_left_expr = ASRUtils::expr_value(a.m_left);
                     if (!ASR::is_a<ASR::IntegerConstant_t>(*m_left_expr)) {
                         diag.add(Diagnostic("Substring start index at must be of type integer",
-                            Level::Error, Stage::Semantic, {Label("", {m_left_expr->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { m_left_expr->base.loc }) }));
                         throw SemanticAbort();
                     }
-                    ASR::IntegerConstant_t *m_left = ASR::down_cast<ASR::IntegerConstant_t>(m_left_expr);
+                    ASR::IntegerConstant_t* m_left
+                        = ASR::down_cast<ASR::IntegerConstant_t>(m_left_expr);
                     start = m_left->m_n;
                 }
             }
-            if( a.m_right ) {
+            if (a.m_right) {
                 if (ASRUtils::is_array(ASRUtils::expr_type(a.m_right))) {
                     is_arg_array = true;
                     ASR::dimension_t* arg_dim = nullptr;
-                    if (!(ASRUtils::extract_dimensions_from_ttype(
-                            ASRUtils::expr_type(a.m_right), arg_dim) == 1)) {
+                    if (!(ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(a.m_right),
+                                                                  arg_dim)
+                          == 1)) {
                         diag.add(Diagnostic("Array index must be of rank 1",
-                            Level::Error, Stage::Semantic, {Label("", {a.m_right->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { a.m_right->base.loc }) }));
                         throw SemanticAbort();
                     }
                     res_dims_vec.push_back(al, arg_dim[0]);
-                } else if( all_args_eval ) {
+                } else if (all_args_eval) {
                     flag = true;
                     ASR::expr_t* m_right_expr = ASRUtils::expr_value(a.m_right);
-                    if(!ASR::is_a<ASR::IntegerConstant_t>(*m_right_expr)) {
+                    if (!ASR::is_a<ASR::IntegerConstant_t>(*m_right_expr)) {
                         diag.add(Diagnostic("Substring end index at must be of type integer",
-                            Level::Error, Stage::Semantic, {Label("", {m_right_expr->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { m_right_expr->base.loc }) }));
                         throw SemanticAbort();
                     }
-                    ASR::IntegerConstant_t *m_right = ASR::down_cast<ASR::IntegerConstant_t>(m_right_expr);
+                    ASR::IntegerConstant_t* m_right
+                        = ASR::down_cast<ASR::IntegerConstant_t>(m_right_expr);
                     end = m_right->m_n;
                 }
             }
-            if( a.m_step ) {
-                if( all_args_eval ) {
+            if (a.m_step) {
+                if (all_args_eval) {
                     ASR::expr_t* m_step_expr = ASRUtils::expr_value(a.m_step);
-                    if(!ASR::is_a<ASR::IntegerConstant_t>(*m_step_expr)) {
+                    if (!ASR::is_a<ASR::IntegerConstant_t>(*m_step_expr)) {
                         diag.add(Diagnostic("Substring stride must be of type integer",
-                            Level::Error, Stage::Semantic, {Label("", {m_step_expr->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { m_step_expr->base.loc }) }));
                         throw SemanticAbort();
                     }
-                    ASR::IntegerConstant_t *m_step = ASR::down_cast<ASR::IntegerConstant_t>(m_step_expr);
+                    ASR::IntegerConstant_t* m_step
+                        = ASR::down_cast<ASR::IntegerConstant_t>(m_step_expr);
                     step = m_step->m_n;
                 }
             }
-            if( v->type == ASR::symbolType::Variable ) {
-                ASR::Variable_t *var = ASR::down_cast<ASR::Variable_t>(v);
-                ASR::expr_t *m_value = var->m_value;
-                if( m_value && m_value->type == ASR::exprType::StringConstant ) {
-                    ASR::StringConstant_t *m_str = ASR::down_cast<ASR::StringConstant_t>(m_value);
+            if (v->type == ASR::symbolType::Variable) {
+                ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(v);
+                ASR::expr_t* m_value = var->m_value;
+                if (m_value && m_value->type == ASR::exprType::StringConstant) {
+                    ASR::StringConstant_t* m_str = ASR::down_cast<ASR::StringConstant_t>(m_value);
                     ASR::String_t* s_type = ASR::down_cast<ASR::String_t>(
                         ASRUtils::type_get_past_allocatable_pointer(var->m_type));
                     std::string sliced_str;
-                    int64_t str_length; // Set by function below.
-                    if(!ASRUtils::extract_value(s_type->m_len, str_length)){LCOMPILERS_ASSERT(false)}
-                    if( start <= 0 ) {
+                    int64_t str_length;  // Set by function below.
+                    if (!ASRUtils::extract_value(s_type->m_len, str_length)) {
+                        LCOMPILERS_ASSERT(false)
+                    }
+                    if (start <= 0) {
                         diag.add(Diagnostic("Substring `start` is less than one",
-                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                    if(end > str_length) {
+                    if (end > str_length) {
                         diag.add(Diagnostic("Substring end index exceeds the string length",
-                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                    if( end == -1 && !flag ) {
+                    if (end == -1 && !flag) {
                         end = str_length;
                     } else {
-                        for( int i = start - 1; i < end; i += step ) {
+                        for (int i = start - 1; i < end; i += step) {
                             sliced_str.push_back(m_str->m_s[i]);
                         }
                         Str l_str;
                         l_str.from_str(al, sliced_str);
-                        arr_ref_val = ASRUtils::EXPR(ASR::make_StringConstant_t(al, loc, l_str.c_str(al), 
-                            ASRUtils::TYPE(ASR::make_String_t(al, loc, 1, 
-                                ASRUtils::EXPR(
-                                    ASR::make_IntegerConstant_t(
-                                        al, loc, sliced_str.size(),
-                                        ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind))
-                                    )
-                                ),
+                        arr_ref_val = ASRUtils::EXPR(ASR::make_StringConstant_t(
+                            al,
+                            loc,
+                            l_str.c_str(al),
+                            ASRUtils::TYPE(ASR::make_String_t(
+                                al,
+                                loc,
+                                1,
+                                ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                    al,
+                                    loc,
+                                    sliced_str.size(),
+                                    ASRUtils::TYPE(ASR::make_Integer_t(
+                                        al, loc, compiler_options.po.default_integer_kind)))),
                                 ASR::ExpressionLength,
-                                ASR::DescriptorString
-                            ))
-                        ));
+                                ASR::DescriptorString))));
                     }
                 }
             }
         }
 
-        if( is_item ) {
+        if (is_item) {
             Vec<ASR::dimension_t> empty_dims;
             empty_dims.reserve(al, 1);
             if (ASR::is_a<ASR::StructInstanceMember_t>(*v_Var)) {
@@ -5816,18 +7055,23 @@ public:
                 if (args.size() == 1) {
                     ASR::array_index_t arg = args[0];
                     if (arg.m_left == nullptr && arg.m_step == nullptr) {
-                        ASR::expr_t *val = ASRUtils::expr_value(v_Var);
-                        ASR::expr_t *index = ASRUtils::expr_value(arg.m_right);
+                        ASR::expr_t* val = ASRUtils::expr_value(v_Var);
+                        ASR::expr_t* index = ASRUtils::expr_value(arg.m_right);
                         if (val && index) {
                             val = ASRUtils::expr_value(val);
-                            ASR::ArrayConstant_t *val2 = ASR::down_cast<ASR::ArrayConstant_t>(val);
-                            ASR::IntegerConstant_t *index2 = ASR::down_cast<ASR::IntegerConstant_t>(index);
+                            ASR::ArrayConstant_t* val2 = ASR::down_cast<ASR::ArrayConstant_t>(val);
+                            ASR::IntegerConstant_t* index2
+                                = ASR::down_cast<ASR::IntegerConstant_t>(index);
                             int based_indexing = get_based_indexing(v);
-                            int64_t index3 = index2->m_n-based_indexing;
+                            int64_t index3 = index2->m_n - based_indexing;
                             size_t index4 = index3;
-                            if (index3 < 0 || index4 >= (size_t) ASRUtils::get_fixed_size_of_array(val2->m_type)) {
+                            if (index3 < 0
+                                || index4 >= (size_t) ASRUtils::get_fixed_size_of_array(
+                                       val2->m_type)) {
                                 diag.add(Diagnostic("The index is out of bounds",
-                                    Level::Error, Stage::Semantic, {Label("", {index2->base.base.loc})}));
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { index2->base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                             arr_ref_val = ASRUtils::fetch_ArrayConstant_value(al, val2, index4);
@@ -5835,28 +7079,38 @@ public:
                     }
                 }
             }
-            if( ASRUtils::is_character(*root_v_type) &&
-                !ASRUtils::is_array(root_v_type) ) {
-                ASR::ttype_t  *char_type = ASRUtils::TYPE(ASR::make_String_t(
-                    al, type->base.loc, 1,
-                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, type->base.loc, 1,
+            if (ASRUtils::is_character(*root_v_type) && !ASRUtils::is_array(root_v_type)) {
+                ASR::ttype_t* char_type = ASRUtils::TYPE(ASR::make_String_t(
+                    al,
+                    type->base.loc,
+                    1,
+                    ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                        al,
+                        type->base.loc,
+                        1,
                         ASRUtils::TYPE(ASR::make_Integer_t(al, type->base.loc, 4)))),
-                        ASR::string_length_kindType::ExpressionLength,
+                    ASR::string_length_kindType::ExpressionLength,
                     ASR::string_physical_typeType::DescriptorString));
-                return ASR::make_StringItem_t(al, loc,
-                    v_Var, args.p[0].m_right, char_type, arr_ref_val);
-            } else if ( ASRUtils::is_character(*root_v_type) &&
-                        ASRUtils::is_array(root_v_type) &&
-                        n_subargs > 0) {
-                ASR::expr_t* array_item = replace_with_common_block_variables(ASRUtils::EXPR(ASRUtils::make_ArrayItem_t_util(al, loc,
-                    v_Var, args.p, args.size(), ASRUtils::type_get_past_pointer(
-                        ASRUtils::type_get_past_allocatable(type)),
-                    ASR::arraystorageType::ColMajor, arr_ref_val)));
+                return ASR::make_StringItem_t(
+                    al, loc, v_Var, args.p[0].m_right, char_type, arr_ref_val);
+            } else if (ASRUtils::is_character(*root_v_type) && ASRUtils::is_array(root_v_type)
+                       && n_subargs > 0) {
+                ASR::expr_t* array_item = replace_with_common_block_variables(
+                    ASRUtils::EXPR(ASRUtils::make_ArrayItem_t_util(
+                        al,
+                        loc,
+                        v_Var,
+                        args.p,
+                        args.size(),
+                        ASRUtils::type_get_past_pointer(ASRUtils::type_get_past_allocatable(type)),
+                        ASR::arraystorageType::ColMajor,
+                        arr_ref_val)));
                 LCOMPILERS_ASSERT(n_subargs == 1);
 
-                ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
-                ASR::expr_t* const_1 = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc,
-                                            1, int_type));
+                ASR::ttype_t* int_type = ASRUtils::TYPE(
+                    ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
+                ASR::expr_t* const_1
+                    = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1, int_type));
                 ASR::expr_t *l = nullptr, *r = nullptr, *step = nullptr;
                 if (m_subargs[0].m_start) {
                     this->visit_expr(*(m_subargs[0].m_start));
@@ -5871,115 +7125,146 @@ public:
                     r = CastingUtil::perform_casting(r, int_type, al, loc);
                 } else {
                     r = ASRUtils::EXPR(ASR::make_StringLen_t(
-                                al, loc, v_Var, 
-                                ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind)),
-                                ASRUtils::get_string_type(root_v_type)->m_len));
+                        al,
+                        loc,
+                        v_Var,
+                        ASRUtils::TYPE(
+                            ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind)),
+                        ASRUtils::get_string_type(root_v_type)->m_len));
                 }
                 this->visit_expr(*(m_subargs[0].m_step));
                 step = ASRUtils::EXPR(tmp);
                 step = CastingUtil::perform_casting(step, int_type, al, loc);
 
-                ASR::ttype_t *string_tt;
+                ASR::ttype_t* string_tt;
                 {
                     ASRUtils::ASRBuilder b(al, loc);
-                    string_tt = ASRUtils::TYPE(ASR::make_String_t(
-                        al, loc, 1,
-                        b.Add(b.Sub(r, l), b.i_t(1, ASRUtils::expr_type(r))),
-                        ASR::ExpressionLength, 
-                        ASR::DescriptorString));
-                }
-                return ASR::make_StringSection_t(al, loc, array_item, l,
-                        r, ASRUtils::EXPR(tmp), string_tt, arr_ref_val);
+                    string_tt = ASRUtils::TYPE(
+                        ASR::make_String_t(al,
+                                           loc,
+                                           1,
+                                           b.Add(b.Sub(r, l), b.i_t(1, ASRUtils::expr_type(r))),
+                                           ASR::ExpressionLength,
+                                           ASR::DescriptorString));
+                }
+                return ASR::make_StringSection_t(
+                    al, loc, array_item, l, r, ASRUtils::EXPR(tmp), string_tt, arr_ref_val);
             } else {
                 ASR::ttype_t* final_type;
                 if (is_arg_array) {
-                  ASR::ttype_t *op_type = ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_Var));
-                  final_type = ASRUtils::duplicate_type(al, op_type, &res_dims_vec);
+                    ASR::ttype_t* op_type
+                        = ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_Var));
+                    final_type = ASRUtils::duplicate_type(al, op_type, &res_dims_vec);
                 } else {
-                  final_type = ASRUtils::type_get_past_pointer(
+                    final_type = ASRUtils::type_get_past_pointer(
                         ASRUtils::type_get_past_allocatable(type));
                 }
-                if ( current_scope->asr_owner && ASR::is_a<ASR::symbol_t>(*current_scope->asr_owner) &&
-                    !ASR::is_a<ASR::Block_t>(*ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner)) &&
-                    !ASRUtils::is_array(ASRUtils::expr_type(v_Var))) {
+                if (current_scope->asr_owner && ASR::is_a<ASR::symbol_t>(*current_scope->asr_owner)
+                    && !ASR::is_a<ASR::Block_t>(
+                        *ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner))
+                    && !ASRUtils::is_array(ASRUtils::expr_type(v_Var))) {
                     diag.add(Diagnostic("Array reference is not allowed on scalar variable",
-                        Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
-                return (ASR::asr_t*) replace_with_common_block_variables(ASRUtils::EXPR(ASRUtils::make_ArrayItem_t_util(al, loc,
-                    v_Var, args.p, args.size(), final_type,
-                    ASR::arraystorageType::ColMajor, arr_ref_val)));
+                return (ASR::asr_t*) replace_with_common_block_variables(
+                    ASRUtils::EXPR(ASRUtils::make_ArrayItem_t_util(al,
+                                                                   loc,
+                                                                   v_Var,
+                                                                   args.p,
+                                                                   args.size(),
+                                                                   final_type,
+                                                                   ASR::arraystorageType::ColMajor,
+                                                                   arr_ref_val)));
             }
         } else {
-            ASR::ttype_t *v_type = ASRUtils::symbol_type(v);
+            ASR::ttype_t* v_type = ASRUtils::symbol_type(v);
             if (ASR::is_a<ASR::Pointer_t>(*v_type)) {
                 v_type = ASR::down_cast<ASR::Pointer_t>(v_type)->m_type;
             }
             if (ASRUtils::is_character(*v_type)) {
                 int dims = ASRUtils::extract_n_dims_from_ttype(
-                        ASRUtils::type_get_past_allocatable(v_type));
+                    ASRUtils::type_get_past_allocatable(v_type));
                 if (dims == 0) {
                     // this is the case of String Section (or slicing)
                     LCOMPILERS_ASSERT(n_args == 1);
-                    ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
+                    ASR::ttype_t* int_type = ASRUtils::TYPE(
+                        ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind));
                     ASR::expr_t *l = nullptr, *r = nullptr;
 
                     if (m_args[0].m_start) {
                         ASR::expr_t* left_value = ASRUtils::expr_value(args[0].m_left);
 
-                        if (left_value != nullptr && ASR::is_a<ASR::IntegerConstant_t>(*left_value) ) {
+                        if (left_value != nullptr
+                            && ASR::is_a<ASR::IntegerConstant_t>(*left_value)) {
                             int64_t a = ASR::down_cast<ASR::IntegerConstant_t>(left_value)->m_n;
-                            if ( a < 1 ) {
-                                diag.add(Diagnostic("The first index in string section is less than 1",
-                                    Level::Error, Stage::Semantic, {Label("", {loc})}));
+                            if (a < 1) {
+                                diag.add(
+                                    Diagnostic("The first index in string section is less than 1",
+                                               Level::Error,
+                                               Stage::Semantic,
+                                               { Label("", { loc }) }));
                                 throw SemanticAbort();
                             }
                         }
                         l = args[0].m_left;
                         l = CastingUtil::perform_casting(l, int_type, al, loc);
                     } else {
-                        l = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1,
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind))));
+                        l = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al,
+                            loc,
+                            1,
+                            ASRUtils::TYPE(ASR::make_Integer_t(
+                                al, loc, compiler_options.po.default_integer_kind))));
                     }
                     if (m_args[0].m_end) {
                         r = args[0].m_right;
                         r = CastingUtil::perform_casting(r, int_type, al, loc);
                     } else {
                         r = ASRUtils::EXPR(ASR::make_StringLen_t(
-                            al, loc, v_Var, 
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, compiler_options.po.default_integer_kind)),
+                            al,
+                            loc,
+                            v_Var,
+                            ASRUtils::TYPE(ASR::make_Integer_t(
+                                al, loc, compiler_options.po.default_integer_kind)),
                             ASRUtils::get_string_type(v_type)->m_len));
                     }
-                    ASR::expr_t* casted_step = CastingUtil::perform_casting(args[0].m_step, int_type, al, loc);
-                    ASR::ttype_t *char_type = nullptr;
+                    ASR::expr_t* casted_step
+                        = CastingUtil::perform_casting(args[0].m_step, int_type, al, loc);
+                    ASR::ttype_t* char_type = nullptr;
                     if (arr_ref_val) {
                         char_type = ASRUtils::expr_type(arr_ref_val);
                     } else {
-                        ASR::expr_t *a_len_expr = nullptr;
-                        if (ASRUtils::is_value_constant(r) && 
-                            ASRUtils::is_value_constant(l)) {
-                            int64_t a_len_value = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(r))->m_n -
-                                                  ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(l))->m_n + 
-                                                  1;
-                            a_len_expr = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, a_len_value, int_type));
+                        ASR::expr_t* a_len_expr = nullptr;
+                        if (ASRUtils::is_value_constant(r) && ASRUtils::is_value_constant(l)) {
+                            int64_t a_len_value
+                                = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(r))
+                                      ->m_n
+                                  - ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(l))
+                                        ->m_n
+                                  + 1;
+                            a_len_expr = ASRUtils::EXPR(
+                                ASR::make_IntegerConstant_t(al, loc, a_len_value, int_type));
                         } else {
                             ASRUtils::ASRBuilder b(al, loc);
                             a_len_expr = b.Add(b.Sub(r, l), b.i_t(1, ASRUtils::expr_type(l)));
                         }
-                        char_type = ASRUtils::TYPE(
-                            ASR::make_String_t(al, loc, 1, a_len_expr, ASR::ExpressionLength, ASR::DescriptorString));
+                        char_type = ASRUtils::TYPE(ASR::make_String_t(
+                            al, loc, 1, a_len_expr, ASR::ExpressionLength, ASR::DescriptorString));
                     }
-                    return ASR::make_StringSection_t(al, loc, v_Var, l,
-                            r, casted_step, char_type, arr_ref_val);
+                    return ASR::make_StringSection_t(
+                        al, loc, v_Var, l, r, casted_step, char_type, arr_ref_val);
                 }
             }
 
             Vec<ASR::dimension_t> array_section_dims;
             array_section_dims.reserve(al, n_args);
-            for( size_t i = 0; i < n_args; i++ ) {
-                if( args.p[i].m_step != nullptr &&
-                    args.p[i].m_left == nullptr ) {
-                    args.p[i].m_left = ASRUtils::get_bound<SemanticAbort>(v_Var, i + 1, "lbound", al, diag);
+            for (size_t i = 0; i < n_args; i++) {
+                if (args.p[i].m_step != nullptr && args.p[i].m_left == nullptr) {
+                    args.p[i].m_left
+                        = ASRUtils::get_bound<SemanticAbort>(v_Var, i + 1, "lbound", al, diag);
                 }
                 if (args.p[i].m_step != nullptr
                     || (args.p[i].m_step == nullptr && args.p[i].m_right != nullptr
@@ -5995,111 +7280,150 @@ public:
                 int right_kind = -1;
                 int step_kind = -1;
                 if (args.p[i].m_left) {
-                    left_kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args.p[i].m_left));
+                    left_kind = ASRUtils::extract_kind_from_ttype_t(
+                        ASRUtils::expr_type(args.p[i].m_left));
                     max_kind = std::max(max_kind, left_kind);
-                } 
+                }
                 if (args.p[i].m_right) {
-                    right_kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args.p[i].m_right));
+                    right_kind = ASRUtils::extract_kind_from_ttype_t(
+                        ASRUtils::expr_type(args.p[i].m_right));
                     max_kind = std::max(max_kind, right_kind);
                 }
                 if (args.p[i].m_step) {
-                    step_kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args.p[i].m_step));
+                    step_kind = ASRUtils::extract_kind_from_ttype_t(
+                        ASRUtils::expr_type(args.p[i].m_step));
                     max_kind = std::max(max_kind, step_kind);
                 }
 
                 if (left_kind != -1 && left_kind != max_kind) {
                     if (ASRUtils::is_value_constant(args.p[i].m_left)) {
-                        args.p[i].m_left = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc,
-                            ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(args.p[i].m_left))->m_n,
+                        args.p[i].m_left = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al,
+                            loc,
+                            ASR::down_cast<ASR::IntegerConstant_t>(
+                                ASRUtils::expr_value(args.p[i].m_left))
+                                ->m_n,
                             ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind))));
                     } else {
-                        args.p[i].m_left = ASRUtils::EXPR(ASR::make_Cast_t(al, loc, 
-                            args.p[i].m_left, ASR::cast_kindType::IntegerToInteger, 
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind)), nullptr));
+                        args.p[i].m_left = ASRUtils::EXPR(
+                            ASR::make_Cast_t(al,
+                                             loc,
+                                             args.p[i].m_left,
+                                             ASR::cast_kindType::IntegerToInteger,
+                                             ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind)),
+                                             nullptr));
                     }
                 }
                 if (right_kind != -1 && right_kind != max_kind) {
                     if (ASRUtils::is_value_constant(args.p[i].m_right)) {
-                        args.p[i].m_right = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc,
-                            ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(args.p[i].m_right))->m_n,
+                        args.p[i].m_right = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al,
+                            loc,
+                            ASR::down_cast<ASR::IntegerConstant_t>(
+                                ASRUtils::expr_value(args.p[i].m_right))
+                                ->m_n,
                             ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind))));
                     } else {
-                        args.p[i].m_right = ASRUtils::EXPR(ASR::make_Cast_t(al, loc, 
-                            args.p[i].m_right, ASR::cast_kindType::IntegerToInteger, 
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind)), nullptr));
+                        args.p[i].m_right = ASRUtils::EXPR(
+                            ASR::make_Cast_t(al,
+                                             loc,
+                                             args.p[i].m_right,
+                                             ASR::cast_kindType::IntegerToInteger,
+                                             ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind)),
+                                             nullptr));
                     }
                 }
                 if (step_kind != -1 && step_kind != max_kind) {
                     if (ASRUtils::is_value_constant(args.p[i].m_step)) {
-                        args.p[i].m_step = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc,
-                            ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(args.p[i].m_step))->m_n,
+                        args.p[i].m_step = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al,
+                            loc,
+                            ASR::down_cast<ASR::IntegerConstant_t>(
+                                ASRUtils::expr_value(args.p[i].m_step))
+                                ->m_n,
                             ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind))));
                     } else {
-                        args.p[i].m_step = ASRUtils::EXPR(ASR::make_Cast_t(al, loc, 
-                            args.p[i].m_step, ASR::cast_kindType::IntegerToInteger, 
-                            ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind)), nullptr));
+                        args.p[i].m_step = ASRUtils::EXPR(
+                            ASR::make_Cast_t(al,
+                                             loc,
+                                             args.p[i].m_step,
+                                             ASR::cast_kindType::IntegerToInteger,
+                                             ASRUtils::TYPE(ASR::make_Integer_t(al, loc, max_kind)),
+                                             nullptr));
                     }
                 }
             }
-            type = ASRUtils::duplicate_type(al, ASRUtils::type_get_past_allocatable(type),
-                    &array_section_dims);
-            return ASR::make_ArraySection_t(al, loc,
-                v_Var, args.p, args.size(), type, arr_ref_val);
+            type = ASRUtils::duplicate_type(
+                al, ASRUtils::type_get_past_allocatable(type), &array_section_dims);
+            return ASR::make_ArraySection_t(al, loc, v_Var, args.p, args.size(), type, arr_ref_val);
         }
     }
 
-    void check_if_type_spec_has_asterisk(const ASR::ttype_t* type) {
-        if (type && 
-            ASR::is_a<ASR::String_t>(*type) &&
-            ASR::down_cast<ASR::String_t>(type)->m_len_kind == ASR::string_length_kindType::AssumedLength) {
+    void check_if_type_spec_has_asterisk(const ASR::ttype_t* type)
+    {
+        if (type && ASR::is_a<ASR::String_t>(*type)
+            && ASR::down_cast<ASR::String_t>(type)->m_len_kind
+                   == ASR::string_length_kindType::AssumedLength) {
             // e.g. [character(len=*) :: "a", "apple"], this isn't allowed
-                diag.add(Diagnostic("Type-spec cannot contain an asterisk for a type "
-                    "parameter", Level::Error, Stage::Semantic,
-                    {Label("",{type->base.loc})}));
-                throw SemanticAbort();
+            diag.add(Diagnostic("Type-spec cannot contain an asterisk for a type "
+                                "parameter",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { type->base.loc }) }));
+            throw SemanticAbort();
         }
     }
 
-    void visit_ArrayInitializer(const AST::ArrayInitializer_t &x) {
+    void visit_ArrayInitializer(const AST::ArrayInitializer_t& x)
+    {
         Vec<ASR::expr_t*> body;
         body.reserve(al, x.n_args);
-        ASR::ttype_t *type = nullptr;
+        ASR::ttype_t* type = nullptr;
         Vec<ASR::dimension_t> dims;
         dims.reserve(al, 1);
         if (x.m_vartype != nullptr) {
             std::string sym = "";
-            ASR::symbol_t *type_declaration;
-            type = determine_type(x.base.base.loc, sym, x.m_vartype, false, false,
-                dims, nullptr, type_declaration, ASR::abiType::Source);
+            ASR::symbol_t* type_declaration;
+            type = determine_type(x.base.base.loc,
+                                  sym,
+                                  x.m_vartype,
+                                  false,
+                                  false,
+                                  dims,
+                                  nullptr,
+                                  type_declaration,
+                                  ASR::abiType::Source);
             if (ASR::is_a<ASR::StructType_t>(*type)) {
                 std::string derived_type_name = ASRUtils::symbol_name(type_declaration);
-                diag.add(Diagnostic(
-                    "Invalid syntax of derived type for array constructor",
-                    Level::Error, Stage::Semantic, {
-                        Label("help: use just the derived type name '" + derived_type_name + "', without the keyword 'type'",{x.m_vartype->base.loc})
-                    }));
+                diag.add(
+                    Diagnostic("Invalid syntax of derived type for array constructor",
+                               Level::Error,
+                               Stage::Semantic,
+                               { Label("help: use just the derived type name '" + derived_type_name
+                                           + "', without the keyword 'type'",
+                                       { x.m_vartype->base.loc }) }));
                 throw SemanticAbort();
             }
         } else if (x.m_classtype) {
             std::string sym = x.m_classtype;
-            ASR::symbol_t* type_declaration = ASRUtils::symbol_get_past_external(current_scope->resolve_symbol(to_lower(sym)));
+            ASR::symbol_t* type_declaration
+                = ASRUtils::symbol_get_past_external(current_scope->resolve_symbol(to_lower(sym)));
             if (type_declaration == nullptr) {
-                diag.add(Diagnostic(
-                    "Class type `" + sym + "` is not defined",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Class type `" + sym + "` is not defined",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             } else if (ASR::is_a<ASR::Struct_t>(*type_declaration)) {
-                type = ASRUtils::make_StructType_t_util(al, x.base.base.loc, type_declaration, true);
+                type
+                    = ASRUtils::make_StructType_t_util(al, x.base.base.loc, type_declaration, true);
             }
         } else {
             if (x.n_args == 0) {
-                diag.add(Diagnostic(
-                    "Empty array constructor is not allowed",
-                    Level::Error, Stage::Semantic, {
-                        Label("",{x.base.base.loc})
-                    }));
+                diag.add(Diagnostic("Empty array constructor is not allowed",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
@@ -6108,29 +7432,32 @@ public:
         // the array-constructor shall have the same type and kind type parameters,
         // otherwise each element in the array-constructor is cast using "ImplicitCastRules"
         // (e.g. "[real :: 1, 2, 3, 4]")
-        bool is_type_spec_ommitted { type == nullptr };
+        bool is_type_spec_ommitted{ type == nullptr };
         check_if_type_spec_has_asterisk(type);
 
         bool is_fixed_size_implied_do_loop = true;
-        bool use_descriptorArray = false; // Set to true if any argument has no fixed size (array arguments).
-        ASR::ttype_t* extracted_type { type ? ASRUtils::extract_type(type) : nullptr };
+        bool use_descriptorArray
+            = false;  // Set to true if any argument has no fixed size (array arguments).
+        ASR::ttype_t* extracted_type{ type ? ASRUtils::extract_type(type) : nullptr };
         size_t n_elements = 0;
-        for (size_t i=0; i<x.n_args; i++) {
+        for (size_t i = 0; i < x.n_args; i++) {
             this->visit_expr(*x.m_args[i]);
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
 
-            if( ASR::is_a<ASR::ImpliedDoLoop_t>(*expr) ) {
+            if (ASR::is_a<ASR::ImpliedDoLoop_t>(*expr)) {
                 ASR::ImpliedDoLoop_t* idl = ASR::down_cast<ASR::ImpliedDoLoop_t>(expr);
                 if (idl->m_value && ASR::is_a<ASR::ArrayConstant_t>(*idl->m_value)) {
-                    ASR::ArrayConstant_t* array_constant = ASR::down_cast<ASR::ArrayConstant_t>(idl->m_value);
+                    ASR::ArrayConstant_t* array_constant
+                        = ASR::down_cast<ASR::ArrayConstant_t>(idl->m_value);
                     idl->m_type = array_constant->m_type;
                 };
-                is_fixed_size_implied_do_loop = ASRUtils::is_fixed_size_array(ASRUtils::expr_type(expr));
+                is_fixed_size_implied_do_loop
+                    = ASRUtils::is_fixed_size_array(ASRUtils::expr_type(expr));
             }
 
-            ASR::ttype_t* expr_type { ASRUtils::expr_type(expr) };
-            if (ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable_pointer(expr_type))){
-                if(!ASRUtils::is_value_constant(expr)) 
+            ASR::ttype_t* expr_type{ ASRUtils::expr_type(expr) };
+            if (ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable_pointer(expr_type))) {
+                if (!ASRUtils::is_value_constant(expr))
                     use_descriptorArray = true;
             }
             if (type == nullptr) {
@@ -6140,16 +7467,24 @@ public:
                 // as the "type-spec" is omitted, each element should be the same type
                 ASR::ttype_t* extracted_new_type = ASRUtils::extract_type(expr_type);
                 if (!ASRUtils::check_equal_type(extracted_new_type, extracted_type, expr, expr)) {
-                    diag.add(Diagnostic("Element in `" + ASRUtils::type_to_str_fortran_expr(extracted_type, expr) 
-                    + "(" + std::string(std::to_string(ASRUtils::extract_kind_from_ttype_t(extracted_type))) + ")" +
-                        "` array constructor is `" + ASRUtils::type_to_str_fortran_expr(extracted_new_type, expr) 
-                        + "(" + std::string(std::to_string(ASRUtils::extract_kind_from_ttype_t(extracted_new_type))) + ")" + "`",
-                        Level::Error, Stage::Semantic, {Label("",{expr->base.loc})}));
+                    diag.add(Diagnostic(
+                        "Element in `" + ASRUtils::type_to_str_fortran_expr(extracted_type, expr)
+                            + "("
+                            + std::string(
+                                std::to_string(ASRUtils::extract_kind_from_ttype_t(extracted_type)))
+                            + ")" + "` array constructor is `"
+                            + ASRUtils::type_to_str_fortran_expr(extracted_new_type, expr) + "("
+                            + std::string(std::to_string(
+                                ASRUtils::extract_kind_from_ttype_t(extracted_new_type)))
+                            + ")" + "`",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { expr->base.loc }) }));
                     throw SemanticAbort();
                 }
             } else if (!ASRUtils::check_equal_type(expr_type, type, expr, expr)) {
-                ImplicitCastRules::set_converted_value(al, expr->base.loc,
-                    &expr, expr_type, type, diag);
+                ImplicitCastRules::set_converted_value(
+                    al, expr->base.loc, &expr, expr_type, type, diag);
             }
 
             if (ASRUtils::is_fixed_size_array(expr_type)) {
@@ -6162,19 +7497,22 @@ public:
 
         ASR::dimension_t dim;
         dim.loc = x.base.base.loc;
-        ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-        ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
+        ASR::ttype_t* int_type = ASRUtils::TYPE(
+            ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+        ASR::expr_t* one
+            = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
         dim.m_start = one;
-        if( !is_fixed_size_implied_do_loop || use_descriptorArray) {
+        if (!is_fixed_size_implied_do_loop || use_descriptorArray) {
             dim.m_length = nullptr;
         } else {
-            ASR::expr_t* x_n_args = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, n_elements, int_type));
+            ASR::expr_t* x_n_args = ASRUtils::EXPR(
+                ASR::make_IntegerConstant_t(al, x.base.base.loc, n_elements, int_type));
             dim.m_length = x_n_args;
         }
         dims.push_back(al, dim);
-        if (use_descriptorArray){
-            type = ASRUtils::duplicate_type(al, type, &dims,
-                    ASR::array_physical_typeType::DescriptorArray, true);
+        if (use_descriptorArray) {
+            type = ASRUtils::duplicate_type(
+                al, type, &dims, ASR::array_physical_typeType::DescriptorArray, true);
         } else {
             type = ASRUtils::duplicate_type(al, type, &dims);
         }
@@ -6192,36 +7530,40 @@ public:
                 ASR::expr_t* a_value = ASRUtils::expr_value(body[i]);
                 Array_constant &= ASRUtils::is_value_constant(a_value);
             }
-            if (is_type_spec_ommitted &&
-                Array_constant &&
-                ASRUtils::is_array_of_strings(type)) {
-                for(size_t i = 0; i < body.size(); i++){
+            if (is_type_spec_ommitted && Array_constant && ASRUtils::is_array_of_strings(type)) {
+                for (size_t i = 0; i < body.size(); i++) {
                     int64_t l1, l2;
-                    if (ASRUtils::extract_value(ASRUtils::get_string_type(type)->m_len, l1) &&
-                        ASRUtils::extract_value(ASRUtils::get_string_type(body[i])->m_len, l2)) {
+                    if (ASRUtils::extract_value(ASRUtils::get_string_type(type)->m_len, l1)
+                        && ASRUtils::extract_value(ASRUtils::get_string_type(body[i])->m_len, l2)) {
                         if (l1 != l2) {
-                            diag.add(Diagnostic("Different `character` lengths " + std::to_string(l1)
-                                + " and " + std::to_string(l2) + " in array constructor",
-                                Level::Error, Stage::Semantic, {Label("",{body[i]->base.loc})}));
+                            diag.add(Diagnostic("Different `character` lengths "
+                                                    + std::to_string(l1) + " and "
+                                                    + std::to_string(l2) + " in array constructor",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { body[i]->base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
                 }
             }
 
-            if( ASRUtils::is_array_of_strings(type) &&
-                ((Array_constant && !is_type_spec_ommitted))){ // Adjust 
+            if (ASRUtils::is_array_of_strings(type)
+                && ((Array_constant && !is_type_spec_ommitted))) {  // Adjust
                 // Adjust constant strings based on array's length.
-                int64_t arr_len {};
-                if(ASRUtils::extract_value(ASRUtils::get_string_type(type)->m_len, arr_len)){
+                int64_t arr_len{};
+                if (ASRUtils::extract_value(ASRUtils::get_string_type(type)->m_len, arr_len)) {
                     int64_t item_len;
-                    for(size_t i = 0; i < body.size(); i++){
-                        if( ASRUtils::extract_value(ASRUtils::get_string_type(body[i])->m_len, item_len) ){
-                            if(arr_len != item_len){
-                                if(ASRUtils::is_array(ASRUtils::expr_type(body[i]))){
-                                    *(body.p+i) = adjust_array_character_length(body[i], arr_len, item_len, al);
+                    for (size_t i = 0; i < body.size(); i++) {
+                        if (ASRUtils::extract_value(ASRUtils::get_string_type(body[i])->m_len,
+                                                    item_len)) {
+                            if (arr_len != item_len) {
+                                if (ASRUtils::is_array(ASRUtils::expr_type(body[i]))) {
+                                    *(body.p + i) = adjust_array_character_length(
+                                        body[i], arr_len, item_len, al);
                                 } else {
-                                    *(body.p+i) = adjust_character_length(body[i], arr_len, item_len, body[i]->base.loc, al);
+                                    *(body.p + i) = adjust_character_length(
+                                        body[i], arr_len, item_len, body[i]->base.loc, al);
                                 }
                             }
                         }
@@ -6230,12 +7572,15 @@ public:
             }
         }
 
-        tmp = ASRUtils::make_ArrayConstructor_t_util(al, x.base.base.loc, body.p,
-            body.size(), type, ASR::arraystorageType::ColMajor);
+        tmp = ASRUtils::make_ArrayConstructor_t_util(
+            al, x.base.base.loc, body.p, body.size(), type, ASR::arraystorageType::ColMajor);
     }
 
-    void fill_expr_in_ttype_t(std::vector<ASR::expr_t*>& exprs, ASR::dimension_t* dims, size_t n_dims) {
-        for( size_t i = 0; i < n_dims; i++ ) {
+    void fill_expr_in_ttype_t(std::vector<ASR::expr_t*>& exprs,
+                              ASR::dimension_t* dims,
+                              size_t n_dims)
+    {
+        for (size_t i = 0; i < n_dims; i++) {
             exprs.push_back(dims[i].m_start);
             exprs.push_back(dims[i].m_length);
         }
@@ -6243,12 +7588,17 @@ public:
 
     void fix_exprs_ttype_t(std::vector<ASR::expr_t*>& exprs,
                            Vec<ASR::call_arg_t>& orig_args,
-                           ASR::Function_t* orig_func=nullptr) {
+                           ASR::Function_t* orig_func = nullptr)
+    {
         ASRUtils::ExprStmtDuplicator expr_duplicator(al);
         expr_duplicator.allow_procedure_calls = true;
-        ASRUtils::ReplaceArgVisitor arg_replacer(al, current_scope, orig_func,
-                        orig_args, current_function_dependencies, current_module_dependencies);
-        for( size_t i = 0; i < exprs.size(); i++ ) {
+        ASRUtils::ReplaceArgVisitor arg_replacer(al,
+                                                 current_scope,
+                                                 orig_func,
+                                                 orig_args,
+                                                 current_function_dependencies,
+                                                 current_module_dependencies);
+        for (size_t i = 0; i < exprs.size(); i++) {
             ASR::expr_t* expri = exprs[i];
             if (expri) {
                 expr_duplicator.success = true;
@@ -6261,10 +7611,12 @@ public:
         }
     }
 
-    void fill_new_dims(ASR::Array_t* t, const std::vector<ASR::expr_t*>& func_calls,
-        Vec<ASR::dimension_t>& new_dims) {
+    void fill_new_dims(ASR::Array_t* t,
+                       const std::vector<ASR::expr_t*>& func_calls,
+                       Vec<ASR::dimension_t>& new_dims)
+    {
         new_dims.reserve(al, t->n_dims);
-        for( size_t i = 0, j = 0; i < func_calls.size(); i += 2, j++ ) {
+        for (size_t i = 0, j = 0; i < func_calls.size(); i += 2, j++) {
             ASR::dimension_t new_dim;
             if (func_calls[i] != nullptr) {
                 new_dim.loc = func_calls[i]->base.loc;
@@ -6277,25 +7629,29 @@ public:
         }
     }
 
-    ASR::ttype_t* handle_return_type(ASR::ttype_t *return_type, const Location &loc,
+    ASR::ttype_t* handle_return_type(ASR::ttype_t* return_type,
+                                     const Location& loc,
                                      Vec<ASR::call_arg_t>& args,
-                                     ASR::Function_t* f=nullptr) {
+                                     ASR::Function_t* f = nullptr)
+    {
         // Rebuild the return type if needed and make FunctionCalls use ExternalSymbol
         std::vector<ASR::expr_t*> func_calls;
-        switch( return_type->type ) {
+        switch (return_type->type) {
             case ASR::ttypeType::Allocatable: {
                 ASR::Allocatable_t* allocatable_t = ASR::down_cast<ASR::Allocatable_t>(return_type);
-                return ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(al, loc,
-                    ASRUtils::type_get_past_allocatable(
-                        ASRUtils::type_get_past_pointer(
-                            handle_return_type(allocatable_t->m_type, loc, args, f)))));
+                return ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(
+                    al,
+                    loc,
+                    ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(
+                        handle_return_type(allocatable_t->m_type, loc, args, f)))));
             }
             case ASR::ttypeType::Pointer: {
                 ASR::Pointer_t* pointer_t = ASR::down_cast<ASR::Pointer_t>(return_type);
-                return ASRUtils::TYPE(ASR::make_Pointer_t(al, loc,
-                    ASRUtils::type_get_past_allocatable(
-                        ASRUtils::type_get_past_pointer(
-                            handle_return_type(pointer_t->m_type, loc, args, f)))));
+                return ASRUtils::TYPE(ASR::make_Pointer_t(
+                    al,
+                    loc,
+                    ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(
+                        handle_return_type(pointer_t->m_type, loc, args, f)))));
             }
             case ASR::ttypeType::Array: {
                 ASR::Array_t* t = ASR::down_cast<ASR::Array_t>(return_type);
@@ -6305,33 +7661,38 @@ public:
                 Vec<ASR::dimension_t> new_dims;
                 fill_new_dims(t, func_calls, new_dims);
                 bool for_type = true;
-                for( size_t k = 0; k < new_dims.size(); k++ ) {
-                    if( new_dims[k].m_length &&
-                        ASR::is_a<ASR::ArraySize_t>(*new_dims[k].m_length) ) {
-                        ASR::ArraySize_t* array_size_t =
-                            ASR::down_cast<ASR::ArraySize_t>(new_dims[k].m_length);
-                        if( (ASR::is_a<ASR::FunctionCall_t>(*array_size_t->m_v) &&
-                            ASRUtils::is_allocatable(array_size_t->m_v)) ||
-                            ASR::is_a<ASR::IntrinsicArrayFunction_t>(*array_size_t->m_v) ) {
+                for (size_t k = 0; k < new_dims.size(); k++) {
+                    if (new_dims[k].m_length
+                        && ASR::is_a<ASR::ArraySize_t>(*new_dims[k].m_length)) {
+                        ASR::ArraySize_t* array_size_t
+                            = ASR::down_cast<ASR::ArraySize_t>(new_dims[k].m_length);
+                        if ((ASR::is_a<ASR::FunctionCall_t>(*array_size_t->m_v)
+                             && ASRUtils::is_allocatable(array_size_t->m_v))
+                            || ASR::is_a<ASR::IntrinsicArrayFunction_t>(*array_size_t->m_v)) {
                             for_type = false;
                             break;
                         }
                     }
                 }
-                return ASRUtils::make_Array_t_util(
-                    al, loc, t_m_type, new_dims.p, new_dims.size(),
-                    current_procedure_abi_type, false,
-                    ASR::DescriptorArray, false, false, for_type);
+                return ASRUtils::make_Array_t_util(al,
+                                                   loc,
+                                                   t_m_type,
+                                                   new_dims.p,
+                                                   new_dims.size(),
+                                                   current_procedure_abi_type,
+                                                   false,
+                                                   ASR::DescriptorArray,
+                                                   false,
+                                                   false,
+                                                   for_type);
             }
             case ASR::ttypeType::String: {
-                ASR::String_t *t = ASR::down_cast<ASR::String_t>(return_type);
+                ASR::String_t* t = ASR::down_cast<ASR::String_t>(return_type);
                 func_calls.push_back(t->m_len);
                 fix_exprs_ttype_t(func_calls, args, f);
-                ASR::expr_t* a_len = func_calls[0] ?  func_calls[0] : t->m_len;
+                ASR::expr_t* a_len = func_calls[0] ? func_calls[0] : t->m_len;
                 return ASRUtils::TYPE(ASR::make_String_t(
-                    al, loc, t->m_kind, a_len,
-                    t->m_len_kind,
-                    t->m_physical_type));
+                    al, loc, t->m_kind, a_len, t->m_len_kind, t->m_physical_type));
             }
             case ASR::ttypeType::StructType: {
                 return ASRUtils::duplicate_type(al, return_type);
@@ -6343,30 +7704,34 @@ public:
         return nullptr;
     }
 
-    ASR::asr_t* symbol_resolve_external_generic_procedure_util(const Location &loc,
-        int idx, ASR::symbol_t *v, Vec<ASR::call_arg_t>& args,
-        ASR::GenericProcedure_t *g, ASR::ExternalSymbol_t *p) {
-        ASR::symbol_t *final_sym;
+    ASR::asr_t* symbol_resolve_external_generic_procedure_util(const Location& loc,
+                                                               int idx,
+                                                               ASR::symbol_t* v,
+                                                               Vec<ASR::call_arg_t>& args,
+                                                               ASR::GenericProcedure_t* g,
+                                                               ASR::ExternalSymbol_t* p)
+    {
+        ASR::symbol_t* final_sym;
         final_sym = ASRUtils::symbol_get_past_external(g->m_procs[idx]);
         if (!ASR::is_a<ASR::Function_t>(*final_sym)) {
             diag.add(Diagnostic("ExternalSymbol must point to a Function",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
-        ASR::ttype_t *return_type = nullptr;
+        ASR::ttype_t* return_type = nullptr;
         ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(final_sym);
 
         ASR::expr_t* first_array_arg = ASRUtils::find_first_array_arg_if_elemental(func, args);
         if (first_array_arg) {
             ASR::dimension_t* array_dims;
             size_t array_n_dims = ASRUtils::extract_dimensions_from_ttype(
-                ASRUtils::expr_type(first_array_arg), array_dims
-            );
+                ASRUtils::expr_type(first_array_arg), array_dims);
             Vec<ASR::dimension_t> new_dims;
             new_dims.from_pointer_n_copy(al, array_dims, array_n_dims);
             return_type = ASRUtils::duplicate_type(
-                al, ASRUtils::get_FunctionType(func)->m_return_var_type, &new_dims
-            );
+                al, ASRUtils::get_FunctionType(func)->m_return_var_type, &new_dims);
         } else {
             return_type = ASRUtils::EXPR2VAR(func->m_return_var)->m_type;
             return_type = handle_return_type(return_type, loc, args, func);
@@ -6375,89 +7740,104 @@ public:
         // We mangle the new ExternalSymbol's local name as:
         //   generic_procedure_local_name @
         //     specific_procedure_remote_name
-        std::string local_sym = std::string(p->m_name) + "@"
-            + ASRUtils::symbol_name(final_sym);
+        std::string local_sym = std::string(p->m_name) + "@" + ASRUtils::symbol_name(final_sym);
         if (current_scope->get_symbol(local_sym) == nullptr) {
             Str name;
             name.from_str(al, local_sym);
-            char *cname = name.c_str(al);
-            ASR::asr_t *sub = ASR::make_ExternalSymbol_t(
-                al, g->base.base.loc,
+            char* cname = name.c_str(al);
+            ASR::asr_t* sub = ASR::make_ExternalSymbol_t(
+                al,
+                g->base.base.loc,
                 /* a_symtab */ current_scope,
                 /* a_name */ cname,
                 final_sym,
                 ASRUtils::symbol_name(ASRUtils::get_asr_owner(final_sym)),
-                nullptr, 0, ASRUtils::symbol_name(final_sym),
-                ASR::accessType::Private
-                );
+                nullptr,
+                0,
+                ASRUtils::symbol_name(final_sym),
+                ASR::accessType::Private);
             final_sym = ASR::down_cast<ASR::symbol_t>(sub);
             current_scope->add_symbol(local_sym, final_sym);
         } else {
             final_sym = current_scope->get_symbol(local_sym);
         }
-        ASR::expr_t *value = nullptr;
+        ASR::expr_t* value = nullptr;
         ASR::symbol_t* final_sym2 = ASRUtils::symbol_get_past_external(final_sym);
         if (ASR::is_a<ASR::Function_t>(*final_sym2)) {
-            ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(final_sym2);
+            ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(final_sym2);
             if (ASRUtils::is_intrinsic_procedure(f)) {
                 ASR::symbol_t* v2 = ASRUtils::symbol_get_past_external(v);
-                ASR::GenericProcedure_t *gp = ASR::down_cast<ASR::GenericProcedure_t>(v2);
+                ASR::GenericProcedure_t* gp = ASR::down_cast<ASR::GenericProcedure_t>(v2);
 
                 if (args.size() <= 2) {
-                    value = intrinsic_procedures.comptime_eval(gp->m_name, al, loc, args, compiler_options);
+                    value = intrinsic_procedures.comptime_eval(
+                        gp->m_name, al, loc, args, compiler_options);
                 }
             }
         }
-        if (ASRUtils::symbol_parent_symtab(final_sym)->get_counter() != current_scope->get_counter()) {
+        if (ASRUtils::symbol_parent_symtab(final_sym)->get_counter()
+            != current_scope->get_counter()) {
             ADD_ASR_DEPENDENCIES(current_scope, final_sym, current_function_dependencies);
         }
         ASRUtils::insert_module_dependency(final_sym, al, current_module_dependencies);
         ASRUtils::set_absent_optional_arguments_to_null(args, func, al);
-        return ASRUtils::make_FunctionCall_t_util(al, loc,
-            final_sym, v, args.p, args.size(), return_type,
-            value, nullptr, current_scope, current_function_dependencies);
-    }
-
-    ASR::asr_t* symbol_resolve_external_generic_procedure(
-                const Location &loc,
-                ASR::symbol_t *v, Vec<ASR::call_arg_t>& args) {
-        ASR::ExternalSymbol_t *p = ASR::down_cast<ASR::ExternalSymbol_t>(v);
-        ASR::symbol_t *f2 = ASR::down_cast<ASR::ExternalSymbol_t>(v)->m_external;
-        ASR::GenericProcedure_t *g = ASR::down_cast<ASR::GenericProcedure_t>(f2);
-        int idx = ASRUtils::select_generic_procedure(args, *g, loc,
-                    [&](const std::string &msg, const Location &loc) {
-                            diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                            throw SemanticAbort();
-                        });
+        return ASRUtils::make_FunctionCall_t_util(al,
+                                                  loc,
+                                                  final_sym,
+                                                  v,
+                                                  args.p,
+                                                  args.size(),
+                                                  return_type,
+                                                  value,
+                                                  nullptr,
+                                                  current_scope,
+                                                  current_function_dependencies);
+    }
+
+    ASR::asr_t* symbol_resolve_external_generic_procedure(const Location& loc,
+                                                          ASR::symbol_t* v,
+                                                          Vec<ASR::call_arg_t>& args)
+    {
+        ASR::ExternalSymbol_t* p = ASR::down_cast<ASR::ExternalSymbol_t>(v);
+        ASR::symbol_t* f2 = ASR::down_cast<ASR::ExternalSymbol_t>(v)->m_external;
+        ASR::GenericProcedure_t* g = ASR::down_cast<ASR::GenericProcedure_t>(f2);
+        int idx = ASRUtils::select_generic_procedure(
+            args, *g, loc, [&](const std::string& msg, const Location& loc) {
+                diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                throw SemanticAbort();
+            });
         return symbol_resolve_external_generic_procedure_util(loc, idx, v, args, g, p);
     }
 
     ASR::asr_t* symbol_resolve_external_generic_procedure_with_ast_node(
-                const AST::FuncCallOrArray_t &x,
-                ASR::symbol_t *v, Vec<ASR::call_arg_t>& args) {
+        const AST::FuncCallOrArray_t& x, ASR::symbol_t* v, Vec<ASR::call_arg_t>& args)
+    {
         const Location& loc = x.base.base.loc;
-        ASR::ExternalSymbol_t *p = ASR::down_cast<ASR::ExternalSymbol_t>(v);
-        ASR::symbol_t *f2 = ASR::down_cast<ASR::ExternalSymbol_t>(v)->m_external;
-        ASR::GenericProcedure_t *g = ASR::down_cast<ASR::GenericProcedure_t>(f2);
-        int idx = ASRUtils::select_generic_procedure(args, *g, loc,
-                    [&](const std::string &msg, const Location &loc) {
-                        diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                        throw SemanticAbort();
-                    },
-                    false);
-        if( idx == -1 ) {
+        ASR::ExternalSymbol_t* p = ASR::down_cast<ASR::ExternalSymbol_t>(v);
+        ASR::symbol_t* f2 = ASR::down_cast<ASR::ExternalSymbol_t>(v)->m_external;
+        ASR::GenericProcedure_t* g = ASR::down_cast<ASR::GenericProcedure_t>(f2);
+        int idx = ASRUtils::select_generic_procedure(
+            args,
+            *g,
+            loc,
+            [&](const std::string& msg, const Location& loc) {
+                diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                throw SemanticAbort();
+            },
+            false);
+        if (idx == -1) {
             // if no GenericProcedure matches, we try matching it with
             // StructConstructor first, we do this before trying an intrinsic
             // procedure
             ASR::symbol_t* tmp_v = current_scope->resolve_symbol(std::string(x.m_func));
             if (tmp_v && ASR::is_a<ASR::Struct_t>(*ASRUtils::symbol_get_past_external(tmp_v))) {
-                return create_DerivedTypeConstructor(x.base.base.loc, x.m_args, x.n_args,
-                    x.m_keywords, x.n_keywords, tmp_v);
+                return create_DerivedTypeConstructor(
+                    x.base.base.loc, x.m_args, x.n_args, x.m_keywords, x.n_keywords, tmp_v);
             }
 
             bool is_function = true;
             v = intrinsic_as_node(x, is_function);
-            if( !is_function ) {
+            if (!is_function) {
                 return tmp;
             }
             return create_FunctionCall(loc, v, args);
@@ -6466,15 +7846,20 @@ public:
         }
     }
 
-    ASR::asr_t* create_StructMethodDeclaration(const Location &loc,
-                AST::fnarg_t* m_args, size_t n_args,
-                AST::keyword_t* m_kwargs, size_t n_kwargs,
-                 size_t n_member, ASR::symbol_t *v,
-                    ASR::expr_t *v_expr) {
+    ASR::asr_t* create_StructMethodDeclaration(const Location& loc,
+                                               AST::fnarg_t* m_args,
+                                               size_t n_args,
+                                               AST::keyword_t* m_kwargs,
+                                               size_t n_kwargs,
+                                               size_t n_member,
+                                               ASR::symbol_t* v,
+                                               ASR::expr_t* v_expr)
+    {
         Vec<ASR::call_arg_t> args;
         visit_expr_list(m_args, n_args, args);
-        ASR::StructMethodDeclaration_t *v_class_proc = ASR::down_cast<ASR::StructMethodDeclaration_t>(ASRUtils::symbol_get_past_external(v));
-        ASR::ttype_t *type = nullptr;
+        ASR::StructMethodDeclaration_t* v_class_proc
+            = ASR::down_cast<ASR::StructMethodDeclaration_t>(ASRUtils::symbol_get_past_external(v));
+        ASR::ttype_t* type = nullptr;
         ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(v_class_proc->m_proc);
 
         if (!v_class_proc->m_is_nopass) {
@@ -6487,13 +7872,11 @@ public:
         if (first_array_arg) {
             ASR::dimension_t* array_dims;
             size_t array_n_dims = ASRUtils::extract_dimensions_from_ttype(
-                ASRUtils::expr_type(first_array_arg), array_dims
-            );
+                ASRUtils::expr_type(first_array_arg), array_dims);
             Vec<ASR::dimension_t> new_dims;
             new_dims.from_pointer_n_copy(al, array_dims, array_n_dims);
-            type = ASRUtils::duplicate_type(al,
-                            ASRUtils::get_FunctionType(func)->m_return_var_type,
-                            &new_dims);
+            type = ASRUtils::duplicate_type(
+                al, ASRUtils::get_FunctionType(func)->m_return_var_type, &new_dims);
         } else {
             type = ASRUtils::EXPR2VAR(func->m_return_var)->m_type;
             if (!v_class_proc->m_is_nopass) {
@@ -6503,7 +7886,8 @@ public:
                 args = {};
                 args.reserve(al, func->n_args);
                 visit_expr_list(m_args, n_args, args);
-                args.push_front(al, self_arg);  // push self arg to fulfill correct number of args in definition
+                args.push_front(
+                    al, self_arg);  // push self arg to fulfill correct number of args in definition
             }
             // Set the correct return type.
             type = handle_return_type(type, func->m_return_var->base.loc, args, func);
@@ -6517,108 +7901,145 @@ public:
         }
         if (n_kwargs > 0) {
             diag::Diagnostics diags;
-            visit_kwargs(args, m_kwargs, n_kwargs,
-                            func->m_args, func->n_args, loc, func,
-                            diags, n_member, v_class_proc->m_is_nopass);
-            if( diags.has_error() ) {
-                diag.diagnostics.insert(diag.diagnostics.end(),
-                    diags.diagnostics.begin(), diags.diagnostics.end());
+            visit_kwargs(args,
+                         m_kwargs,
+                         n_kwargs,
+                         func->m_args,
+                         func->n_args,
+                         loc,
+                         func,
+                         diags,
+                         n_member,
+                         v_class_proc->m_is_nopass);
+            if (diags.has_error()) {
+                diag.diagnostics.insert(
+                    diag.diagnostics.end(), diags.diagnostics.begin(), diags.diagnostics.end());
                 throw SemanticAbort();
             }
         }
         ASRUtils::insert_module_dependency(v, al, current_module_dependencies);
-        ASRUtils::set_absent_optional_arguments_to_null(args, func, al, v_expr, v_class_proc->m_is_nopass);
-        return ASRUtils::make_FunctionCall_t_util(al, loc,
-                v, nullptr, args.p, args.size(), type, nullptr,
-                v_expr, current_scope, current_function_dependencies);
-    }
-
-    ASR::asr_t* create_GenericProcedure(const Location &loc,
-                Vec<ASR::call_arg_t>& args, ASR::symbol_t *v) {
+        ASRUtils::set_absent_optional_arguments_to_null(
+            args, func, al, v_expr, v_class_proc->m_is_nopass);
+        return ASRUtils::make_FunctionCall_t_util(al,
+                                                  loc,
+                                                  v,
+                                                  nullptr,
+                                                  args.p,
+                                                  args.size(),
+                                                  type,
+                                                  nullptr,
+                                                  v_expr,
+                                                  current_scope,
+                                                  current_function_dependencies);
+    }
+
+    ASR::asr_t* create_GenericProcedure(const Location& loc,
+                                        Vec<ASR::call_arg_t>& args,
+                                        ASR::symbol_t* v)
+    {
         if (ASR::is_a<ASR::ExternalSymbol_t>(*v)) {
-            return symbol_resolve_external_generic_procedure(loc, v,
-                    args);
+            return symbol_resolve_external_generic_procedure(loc, v, args);
         } else {
-            ASR::GenericProcedure_t *p = ASR::down_cast<ASR::GenericProcedure_t>(v);
-            int idx = ASRUtils::select_generic_procedure(args, *p, loc,
-                    [&](const std::string &msg, const Location &loc) {
-                            diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                            throw SemanticAbort();
-                        },
-                    false);
-            if( idx == -1 ) {
+            ASR::GenericProcedure_t* p = ASR::down_cast<ASR::GenericProcedure_t>(v);
+            int idx = ASRUtils::select_generic_procedure(
+                args,
+                *p,
+                loc,
+                [&](const std::string& msg, const Location& loc) {
+                    diag.add(
+                        Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                    throw SemanticAbort();
+                },
+                false);
+            if (idx == -1) {
                 std::string v_name = ASRUtils::symbol_name(v);
                 v = resolve_intrinsic_function(loc, v_name);
-                if( !v ) {
+                if (!v) {
                     diag.add(Diagnostic("Couldn't find any function " + v_name + ".",
-                        Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 return create_FunctionCall(loc, v, args);
             }
-            ASR::symbol_t *final_sym = p->m_procs[idx];
+            ASR::symbol_t* final_sym = p->m_procs[idx];
 
-            ASR::ttype_t *type = nullptr;
+            ASR::ttype_t* type = nullptr;
             ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(final_sym);
             ASR::expr_t* first_array_arg = ASRUtils::find_first_array_arg_if_elemental(func, args);
             if (first_array_arg) {
                 ASR::dimension_t* array_dims;
                 size_t array_n_dims = ASRUtils::extract_dimensions_from_ttype(
-                    ASRUtils::expr_type(first_array_arg), array_dims
-                );
+                    ASRUtils::expr_type(first_array_arg), array_dims);
                 Vec<ASR::dimension_t> new_dims;
                 new_dims.from_pointer_n_copy(al, array_dims, array_n_dims);
-                type = ASRUtils::duplicate_type(al,
-                                ASRUtils::get_FunctionType(func)->m_return_var_type,
-                                &new_dims);
+                type = ASRUtils::duplicate_type(
+                    al, ASRUtils::get_FunctionType(func)->m_return_var_type, &new_dims);
             } else {
                 type = ASRUtils::EXPR2VAR(func->m_return_var)->m_type;
                 type = handle_return_type(type, loc, args, func);
             }
-            if (ASRUtils::symbol_parent_symtab(final_sym)->get_counter() != current_scope->get_counter()) {
+            if (ASRUtils::symbol_parent_symtab(final_sym)->get_counter()
+                != current_scope->get_counter()) {
                 ADD_ASR_DEPENDENCIES(current_scope, final_sym, current_function_dependencies);
             }
             ASRUtils::insert_module_dependency(final_sym, al, current_module_dependencies);
             ASRUtils::set_absent_optional_arguments_to_null(args, func, al);
-            return ASRUtils::make_FunctionCall_t_util(al, loc,
-                final_sym, v, args.p, args.size(), type,
-                nullptr, nullptr, current_scope, current_function_dependencies);
+            return ASRUtils::make_FunctionCall_t_util(al,
+                                                      loc,
+                                                      final_sym,
+                                                      v,
+                                                      args.p,
+                                                      args.size(),
+                                                      type,
+                                                      nullptr,
+                                                      nullptr,
+                                                      current_scope,
+                                                      current_function_dependencies);
         }
     }
 
     ASR::asr_t* create_GenericProcedureWithASTNode(const AST::FuncCallOrArray_t& x,
-                Vec<ASR::call_arg_t>& args, ASR::symbol_t *v) {
+                                                   Vec<ASR::call_arg_t>& args,
+                                                   ASR::symbol_t* v)
+    {
         const Location& loc = x.base.base.loc;
         if (ASR::is_a<ASR::ExternalSymbol_t>(*v)) {
-            return symbol_resolve_external_generic_procedure_with_ast_node(x, v,
-                    args);
+            return symbol_resolve_external_generic_procedure_with_ast_node(x, v, args);
         } else {
-            ASR::GenericProcedure_t *p = ASR::down_cast<ASR::GenericProcedure_t>(v);
-            int idx = ASRUtils::select_generic_procedure(args, *p, loc,
-                    [&](const std::string &msg, const Location &loc) {
-                            diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                            throw SemanticAbort();
-                        },
-                    false);
-            if( idx == -1 ) {
+            ASR::GenericProcedure_t* p = ASR::down_cast<ASR::GenericProcedure_t>(v);
+            int idx = ASRUtils::select_generic_procedure(
+                args,
+                *p,
+                loc,
+                [&](const std::string& msg, const Location& loc) {
+                    diag.add(
+                        Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                    throw SemanticAbort();
+                },
+                false);
+            if (idx == -1) {
                 bool is_function = true;
                 v = intrinsic_as_node(x, is_function);
-                if( !is_function ) {
+                if (!is_function) {
                     return tmp;
                 }
                 return create_FunctionCall(loc, v, args);
             }
-            ASR::symbol_t *final_sym = p->m_procs[idx];
+            ASR::symbol_t* final_sym = p->m_procs[idx];
 
-            ASR::ttype_t *type = nullptr;
-            ASR::symbol_t *cp_s = nullptr;
+            ASR::ttype_t* type = nullptr;
+            ASR::symbol_t* cp_s = nullptr;
             if (ASR::is_a<ASR::StructMethodDeclaration_t>(*final_sym)) {
-                cp_s = ASRUtils::import_class_procedure(al, x.base.base.loc,
-                    final_sym, current_scope);
+                cp_s = ASRUtils::import_class_procedure(
+                    al, x.base.base.loc, final_sym, current_scope);
                 final_sym = ASR::down_cast<ASR::StructMethodDeclaration_t>(final_sym)->m_proc;
             }
-            LCOMPILERS_ASSERT(ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(final_sym)))
-            ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(final_sym));
+            LCOMPILERS_ASSERT(
+                ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(final_sym)))
+            ASR::Function_t* func
+                = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(final_sym));
             ASR::expr_t* first_array_arg = ASRUtils::find_first_array_arg_if_elemental(func, args);
             if (first_array_arg) {
                 ASR::dimension_t* array_dims;
@@ -6626,60 +8047,90 @@ public:
                     ASRUtils::expr_type(first_array_arg), array_dims);
                 Vec<ASR::dimension_t> new_dims;
                 new_dims.from_pointer_n_copy(al, array_dims, array_n_dims);
-                type = ASRUtils::duplicate_type(al,
-                        ASRUtils::get_FunctionType(func)->m_return_var_type,
-                        &new_dims);
+                type = ASRUtils::duplicate_type(
+                    al, ASRUtils::get_FunctionType(func)->m_return_var_type, &new_dims);
             } else {
                 type = ASRUtils::EXPR2VAR(func->m_return_var)->m_type;
                 type = handle_return_type(type, loc, args, func);
             }
             if (cp_s != nullptr) {
-                if (ASRUtils::symbol_parent_symtab(cp_s)->get_counter() != current_scope->get_counter()) {
+                if (ASRUtils::symbol_parent_symtab(cp_s)->get_counter()
+                    != current_scope->get_counter()) {
                     ADD_ASR_DEPENDENCIES(current_scope, cp_s, current_function_dependencies);
                 }
                 ASRUtils::insert_module_dependency(cp_s, al, current_module_dependencies);
                 ASRUtils::insert_module_dependency(final_sym, al, current_module_dependencies);
-                Vec<ASR::call_arg_t> args_without_dt; args_without_dt.reserve(al, args.size() - 1);
+                Vec<ASR::call_arg_t> args_without_dt;
+                args_without_dt.reserve(al, args.size() - 1);
                 for (size_t i = 1; i < args.size(); i++) {
                     args_without_dt.push_back(al, args[i]);
                 }
                 ASRUtils::set_absent_optional_arguments_to_null(args, func, al);
-                return ASRUtils::make_FunctionCall_t_util(al, loc,
-                    cp_s, nullptr, args_without_dt.p, args_without_dt.size(), type,
-                    nullptr, args[0].m_value, current_scope, current_function_dependencies);
+                return ASRUtils::make_FunctionCall_t_util(al,
+                                                          loc,
+                                                          cp_s,
+                                                          nullptr,
+                                                          args_without_dt.p,
+                                                          args_without_dt.size(),
+                                                          type,
+                                                          nullptr,
+                                                          args[0].m_value,
+                                                          current_scope,
+                                                          current_function_dependencies);
             } else {
-                if (ASRUtils::symbol_parent_symtab(final_sym)->get_counter() != current_scope->get_counter()) {
+                if (ASRUtils::symbol_parent_symtab(final_sym)->get_counter()
+                    != current_scope->get_counter()) {
                     ADD_ASR_DEPENDENCIES(current_scope, final_sym, current_function_dependencies);
                 }
                 ASRUtils::insert_module_dependency(v, al, current_module_dependencies);
                 ASRUtils::insert_module_dependency(final_sym, al, current_module_dependencies);
                 ASRUtils::set_absent_optional_arguments_to_null(args, func, al);
-                return ASRUtils::make_FunctionCall_t_util(al, loc,
-                    final_sym, v, args.p, args.size(), type,
-                    nullptr, nullptr, current_scope, current_function_dependencies);
+                return ASRUtils::make_FunctionCall_t_util(al,
+                                                          loc,
+                                                          final_sym,
+                                                          v,
+                                                          args.p,
+                                                          args.size(),
+                                                          type,
+                                                          nullptr,
+                                                          nullptr,
+                                                          current_scope,
+                                                          current_function_dependencies);
             }
         }
     }
 
-    void replace_ArrayItem_in_SubroutineCall(Allocator &al, bool legacy_array_sections, SymbolTable* current_scope) {
-
-    class ReplaceArrayItemWithArraySection: public ASR::BaseExprReplacer<ReplaceArrayItemWithArraySection> {
+    void replace_ArrayItem_in_SubroutineCall(Allocator& al,
+                                             bool legacy_array_sections,
+                                             SymbolTable* current_scope)
+    {
+        class ReplaceArrayItemWithArraySection
+            : public ASR::BaseExprReplacer<ReplaceArrayItemWithArraySection>
+        {
         private:
             Allocator& al;
+
         public:
             ASR::expr_t** current_expr;
 
-            ReplaceArrayItemWithArraySection(Allocator& al_) :
-                al(al_), current_expr(nullptr) {}
+            ReplaceArrayItemWithArraySection(Allocator& al_)
+                : al(al_)
+                , current_expr(nullptr)
+            {
+            }
 
-            void replace_ArrayItem(ASR::ArrayItem_t* x) {
+            void replace_ArrayItem(ASR::ArrayItem_t* x)
+            {
                 ASR::ttype_t* array_type = ASRUtils::expr_type(x->m_v);
-                ASR::array_physical_typeType phys_type = ASRUtils::extract_physical_type(array_type);
-                bool is_unbounded = (phys_type == ASR::array_physical_typeType::UnboundedPointerArray);
-                Vec<ASR::array_index_t> array_indices; array_indices.reserve(al, x->n_args);
+                ASR::array_physical_typeType phys_type
+                    = ASRUtils::extract_physical_type(array_type);
+                bool is_unbounded
+                    = (phys_type == ASR::array_physical_typeType::UnboundedPointerArray);
+                Vec<ASR::array_index_t> array_indices;
+                array_indices.reserve(al, x->n_args);
                 ASRUtils::ASRBuilder b(al, x->base.base.loc);
 
-                for ( size_t i = 0; i < x->n_args; i++ ) {
+                for (size_t i = 0; i < x->n_args; i++) {
                     ASR::array_index_t array_index;
                     array_index.loc = x->m_args[i].loc;
                     array_index.m_left = x->m_args[i].m_right;
@@ -6688,42 +8139,55 @@ public:
                         array_index.m_step = b.i32(1);
                     } else {
                         array_index.m_right = b.ArrayUBound(x->m_v, i + 1);
-                        if ( ASRUtils::expr_value(array_index.m_right) ) {
+                        if (ASRUtils::expr_value(array_index.m_right)) {
                             array_index.m_right = ASRUtils::expr_value(array_index.m_right);
                         }
-                        array_index.m_step = b.i32( i + 1 );
+                        array_index.m_step = b.i32(i + 1);
                     }
                     array_indices.push_back(al, array_index);
                 }
-                ASR::array_physical_typeType section_phys_type = is_unbounded ? phys_type
-                    : ASR::array_physical_typeType::DescriptorArray;
-                ASR::ttype_t* new_type = ASRUtils::duplicate_type_with_empty_dims(al, array_type,
-                    section_phys_type, is_unbounded);
-                *current_expr = ASRUtils::EXPR(ASR::make_ArraySection_t(al, x->base.base.loc, x->m_v,
-                    array_indices.p, array_indices.n, new_type, nullptr));
+                ASR::array_physical_typeType section_phys_type
+                    = is_unbounded ? phys_type : ASR::array_physical_typeType::DescriptorArray;
+                ASR::ttype_t* new_type = ASRUtils::duplicate_type_with_empty_dims(
+                    al, array_type, section_phys_type, is_unbounded);
+                *current_expr = ASRUtils::EXPR(ASR::make_ArraySection_t(al,
+                                                                        x->base.base.loc,
+                                                                        x->m_v,
+                                                                        array_indices.p,
+                                                                        array_indices.n,
+                                                                        new_type,
+                                                                        nullptr));
             }
+        };
 
-    };
-
-    class LegacyArraySectionsVisitor : public ASR::CallReplacerOnExpressionsVisitor<LegacyArraySectionsVisitor> {
+        class LegacyArraySectionsVisitor
+            : public ASR::CallReplacerOnExpressionsVisitor<LegacyArraySectionsVisitor>
+        {
         private:
             Allocator& al;
             ReplaceArrayItemWithArraySection replacer;
+
         public:
             ASR::expr_t** current_expr;
-            LegacyArraySectionsVisitor(Allocator& al_) :
-                al(al_), replacer(al_), current_expr(nullptr) {}
+            LegacyArraySectionsVisitor(Allocator& al_)
+                : al(al_)
+                , replacer(al_)
+                , current_expr(nullptr)
+            {
+            }
 
-            void call_replacer_() {
+            void call_replacer_()
+            {
                 replacer.current_expr = current_expr;
                 replacer.replace_expr(*current_expr);
                 current_expr = replacer.current_expr;
             }
 
-            void transform_stmts(ASR::stmt_t **&m_body, size_t &n_body) {
+            void transform_stmts(ASR::stmt_t**& m_body, size_t& n_body)
+            {
                 Vec<ASR::stmt_t*> body;
                 body.reserve(al, n_body);
-                for (size_t i=0; i<n_body; i++) {
+                for (size_t i = 0; i < n_body; i++) {
                     this->visit_stmt(*m_body[i]);
                     body.push_back(al, m_body[i]);
                 }
@@ -6731,29 +8195,33 @@ public:
                 n_body = body.size();
             }
 
-            void visit_Function(const ASR::Function_t &x) {
+            void visit_Function(const ASR::Function_t& x)
+            {
                 ASR::Function_t& xx = const_cast<ASR::Function_t&>(x);
 
-                for (auto &a : xx.m_symtab->get_scope()) {
+                for (auto& a : xx.m_symtab->get_scope()) {
                     this->visit_symbol(*a.second);
                 }
 
                 transform_stmts(xx.m_body, xx.n_body);
             }
 
-            void visit_Program(const ASR::Program_t &x) {
+            void visit_Program(const ASR::Program_t& x)
+            {
                 ASR::Program_t& xx = const_cast<ASR::Program_t&>(x);
 
-                for (auto &a : xx.m_symtab->get_scope()) {
+                for (auto& a : xx.m_symtab->get_scope()) {
                     this->visit_symbol(*a.second);
                 }
 
                 transform_stmts(xx.m_body, xx.n_body);
             }
 
-            void visit_SubroutineCall(const ASR::SubroutineCall_t& x) {
-                if ( ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(x.m_name)) ) {
-                    ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(x.m_name));
+            void visit_SubroutineCall(const ASR::SubroutineCall_t& x)
+            {
+                if (ASR::is_a<ASR::Function_t>(*ASRUtils::symbol_get_past_external(x.m_name))) {
+                    ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(
+                        ASRUtils::symbol_get_past_external(x.m_name));
                     std::vector<int> array_arg_index;
                     for (size_t i = 0; i < f->n_args; i++) {
                         if (ASRUtils::is_array(ASRUtils::expr_type(f->m_args[i]))) {
@@ -6761,24 +8229,31 @@ public:
                         }
                     }
                     // iterate only over args of type array.
-                    for( int arg_i: array_arg_index ) {
+                    for (int arg_i : array_arg_index) {
                         ASR::expr_t* arg_expr = x.m_args[arg_i].m_value;
                         ASR::ttype_t* dummy_type = ASRUtils::expr_type(f->m_args[arg_i]);
-                        ASR::array_physical_typeType expected_phys_type = ASRUtils::extract_physical_type(dummy_type);
-                        bool expected_unbounded = (expected_phys_type == ASR::array_physical_typeType::UnboundedPointerArray);
+                        ASR::array_physical_typeType expected_phys_type
+                            = ASRUtils::extract_physical_type(dummy_type);
+                        bool expected_unbounded
+                            = (expected_phys_type
+                               == ASR::array_physical_typeType::UnboundedPointerArray);
                         // Only convert top-level ArrayItem to ArraySection.
                         // Do NOT recurse into nested ArrayItem expressions in indices.
-                        if ( arg_expr != nullptr && ASR::is_a<ASR::ArrayItem_t>(*arg_expr) ) {
-                            ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(arg_expr);
+                        if (arg_expr != nullptr && ASR::is_a<ASR::ArrayItem_t>(*arg_expr)) {
+                            ASR::ArrayItem_t* array_item
+                                = ASR::down_cast<ASR::ArrayItem_t>(arg_expr);
                             ASR::ttype_t* array_type = ASRUtils::expr_type(array_item->m_v);
-                            ASR::array_physical_typeType actual_phys_type = ASRUtils::extract_physical_type(array_type);
-                            bool unbounded_tail = expected_unbounded ||
-                                (actual_phys_type == ASR::array_physical_typeType::UnboundedPointerArray);
+                            ASR::array_physical_typeType actual_phys_type
+                                = ASRUtils::extract_physical_type(array_type);
+                            bool unbounded_tail
+                                = expected_unbounded
+                                  || (actual_phys_type
+                                      == ASR::array_physical_typeType::UnboundedPointerArray);
                             Vec<ASR::array_index_t> array_indices;
                             array_indices.reserve(al, array_item->n_args);
                             ASRUtils::ASRBuilder b(al, array_item->base.base.loc);
 
-                            for ( size_t j = 0; j < array_item->n_args; j++ ) {
+                            for (size_t j = 0; j < array_item->n_args; j++) {
                                 ASR::array_index_t array_index;
                                 array_index.loc = array_item->m_args[j].loc;
                                 array_index.m_left = array_item->m_args[j].m_right;
@@ -6787,36 +8262,43 @@ public:
                                     array_index.m_step = b.i32(1);
                                 } else {
                                     array_index.m_right = b.ArrayUBound(array_item->m_v, j + 1);
-                                    if ( ASRUtils::expr_value(array_index.m_right) ) {
-                                        array_index.m_right = ASRUtils::expr_value(array_index.m_right);
+                                    if (ASRUtils::expr_value(array_index.m_right)) {
+                                        array_index.m_right
+                                            = ASRUtils::expr_value(array_index.m_right);
                                     }
-                                    array_index.m_step = b.i32( j + 1 );
+                                    array_index.m_step = b.i32(j + 1);
                                 }
                                 array_indices.push_back(al, array_index);
                             }
-                            ASR::array_physical_typeType section_phys_type = unbounded_tail ?
-                                ASR::array_physical_typeType::UnboundedPointerArray :
-                                ASR::array_physical_typeType::DescriptorArray;
+                            ASR::array_physical_typeType section_phys_type
+                                = unbounded_tail
+                                      ? ASR::array_physical_typeType::UnboundedPointerArray
+                                      : ASR::array_physical_typeType::DescriptorArray;
                             ASR::ttype_t* new_type = ASRUtils::duplicate_type_with_empty_dims(
                                 al, array_type, section_phys_type, unbounded_tail);
-                            x.m_args[arg_i].m_value = ASRUtils::EXPR(ASR::make_ArraySection_t(
-                                al, array_item->base.base.loc, array_item->m_v,
-                                array_indices.p, array_indices.n, new_type, nullptr));
+                            x.m_args[arg_i].m_value
+                                = ASRUtils::EXPR(ASR::make_ArraySection_t(al,
+                                                                          array_item->base.base.loc,
+                                                                          array_item->m_v,
+                                                                          array_indices.p,
+                                                                          array_indices.n,
+                                                                          new_type,
+                                                                          nullptr));
                         }
                     }
                 }
             }
-    };
+        };
 
-        if ( legacy_array_sections ) {
+        if (legacy_array_sections) {
             LegacyArraySectionsVisitor v(al);
             ASR::asr_t* asr_owner = current_scope->asr_owner;
-            if ( ASR::is_a<ASR::symbol_t>(*asr_owner) ) {
+            if (ASR::is_a<ASR::symbol_t>(*asr_owner)) {
                 ASR::symbol_t* sym = ASR::down_cast<ASR::symbol_t>(asr_owner);
-                if ( ASR::is_a<ASR::Function_t>(*sym) ) {
+                if (ASR::is_a<ASR::Function_t>(*sym)) {
                     ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(sym);
                     v.visit_Function(*f);
-                } else if ( ASR::is_a<ASR::Program_t>(*sym) ) {
+                } else if (ASR::is_a<ASR::Program_t>(*sym)) {
                     ASR::Program_t* p = ASR::down_cast<ASR::Program_t>(sym);
                     v.visit_Program(*p);
                 }
@@ -6824,95 +8306,112 @@ public:
         }
     }
 
-    void validate_create_function_arguments(Vec<ASR::call_arg_t>& args, ASR::symbol_t *v){
-        ASR::symbol_t *f2 = ASRUtils::symbol_get_past_external(v);
+    void validate_create_function_arguments(Vec<ASR::call_arg_t>& args, ASR::symbol_t* v)
+    {
+        ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(v);
         ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(f2);
         ASR::FunctionType_t* func_type = ASRUtils::get_FunctionType(v);
 
         // Currently present function is supporting only integer arguments
         // After implementing present below if condition should be removed
-        if( to_lower(func->m_name) != "present" ){
-            for( size_t i = 0; i < args.size(); i++ ) {
-                if( args.p[i].m_value == nullptr ) {
+        if (to_lower(func->m_name) != "present") {
+            for (size_t i = 0; i < args.size(); i++) {
+                if (args.p[i].m_value == nullptr) {
                     continue;
                 }
                 ASR::expr_t* arg = args.p[i].m_value;
                 ASR::ttype_t* arg_type = ASRUtils::type_get_past_allocatable(
-                        ASRUtils::type_get_past_pointer(ASRUtils::expr_type(arg)));
+                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(arg)));
                 ASR::ttype_t* orig_arg_type = ASRUtils::type_get_past_allocatable(
-                        ASRUtils::type_get_past_pointer(func_type->m_arg_types[i]));
+                    ASRUtils::type_get_past_pointer(func_type->m_arg_types[i]));
 
-                if( ASR::is_a<ASR::FunctionType_t>(*arg_type) ) continue;
+                if (ASR::is_a<ASR::FunctionType_t>(*arg_type))
+                    continue;
 
                 bool is_compile_time = true;
                 size_t rhs_rank = ASRUtils::extract_n_dims_from_ttype(orig_arg_type);
                 size_t lhs_rank = ASRUtils::extract_n_dims_from_ttype(arg_type);
 
-                if( ASRUtils::is_array(arg_type) ){
+                if (ASRUtils::is_array(arg_type)) {
                     ASR::Array_t* arr_lhs = ASR::down_cast<ASR::Array_t>(arg_type);
-                    for(size_t i = 0; i < lhs_rank; i++){
-                        if( !arr_lhs->m_dims[i].m_length || !(ASRUtils::expr_value(arr_lhs->m_dims[i].m_length)) ){
+                    for (size_t i = 0; i < lhs_rank; i++) {
+                        if (!arr_lhs->m_dims[i].m_length
+                            || !(ASRUtils::expr_value(arr_lhs->m_dims[i].m_length))) {
                             is_compile_time = false;
                             break;
                         }
                     }
                 }
 
-                if( ASRUtils::is_array(orig_arg_type) ){
+                if (ASRUtils::is_array(orig_arg_type)) {
                     ASR::Array_t* arr_rhs = ASR::down_cast<ASR::Array_t>(orig_arg_type);
-                    for(size_t i = 0; i < rhs_rank; i++){
-                        if( !arr_rhs->m_dims[i].m_length || !(ASRUtils::expr_value(arr_rhs->m_dims[i].m_length)) ){
+                    for (size_t i = 0; i < rhs_rank; i++) {
+                        if (!arr_rhs->m_dims[i].m_length
+                            || !(ASRUtils::expr_value(arr_rhs->m_dims[i].m_length))) {
                             is_compile_time = false;
                             break;
                         }
                     }
                 }
 
-                if( is_compile_time ){
-                    if ( ASR::is_a<ASR::Array_t>(*arg_type) && ASR::is_a<ASR::Array_t>(*orig_arg_type) ){
+                if (is_compile_time) {
+                    if (ASR::is_a<ASR::Array_t>(*arg_type)
+                        && ASR::is_a<ASR::Array_t>(*orig_arg_type)) {
                         ASR::Array_t* arr_rhs = ASR::down_cast<ASR::Array_t>(orig_arg_type);
                         ASR::Array_t* arr_lhs = ASR::down_cast<ASR::Array_t>(arg_type);
                         int lhs_ele = 1;
                         int rhs_ele = 1;
                         for (size_t i = 0; i < arr_rhs->n_dims; i++) {
-                            std::int64_t rhs_dim = ASRUtils::extract_dim_value_int(arr_rhs->m_dims[i].m_length);
-                            if( rhs_dim != -1 ){
+                            std::int64_t rhs_dim
+                                = ASRUtils::extract_dim_value_int(arr_rhs->m_dims[i].m_length);
+                            if (rhs_dim != -1) {
                                 rhs_ele *= rhs_dim;
                             }
                         }
                         for (size_t i = 0; i < arr_lhs->n_dims; i++) {
-                            std::int64_t lhs_dim = ASRUtils::extract_dim_value_int(arr_lhs->m_dims[i].m_length);
-                            if( lhs_dim != -1 ){
+                            std::int64_t lhs_dim
+                                = ASRUtils::extract_dim_value_int(arr_lhs->m_dims[i].m_length);
+                            if (lhs_dim != -1) {
                                 lhs_ele *= lhs_dim;
                             } else {
                                 lhs_ele = rhs_ele;
                                 break;
                             }
                         }
-                        if( lhs_ele < rhs_ele ){
-                            diag.add(Diagnostic("Array passed into function has `" + std::to_string(lhs_ele) +
-                                "` elements but function expects `" + std::to_string(rhs_ele) + "`.",
-                                Level::Error, Stage::Semantic, {Label("", {args.p[i].loc})}));
+                        if (lhs_ele < rhs_ele) {
+                            diag.add(Diagnostic("Array passed into function has `"
+                                                    + std::to_string(lhs_ele)
+                                                    + "` elements but function expects `"
+                                                    + std::to_string(rhs_ele) + "`.",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { args.p[i].loc }) }));
                             throw SemanticAbort();
                         }
                     }
                 }
 
-                if(!ASRUtils::check_equal_type(arg_type,orig_arg_type, arg, func->m_args[i]) &&
-                    !ASRUtils::check_class_assignment_compatibility(func->m_args[i], arg)){
+                if (!ASRUtils::check_equal_type(arg_type, orig_arg_type, arg, func->m_args[i])
+                    && !ASRUtils::check_class_assignment_compatibility(func->m_args[i], arg)) {
                     std::string arg_str = ASRUtils::type_to_str_fortran_expr(arg_type, arg);
-                    std::string orig_arg_str = ASRUtils::type_to_str_fortran_expr(orig_arg_type, func->m_args[i]);
-                    diag.add(Diagnostic("Type mismatch in argument at argument (" + std::to_string(i+1) +
-                                        "); passed `" + arg_str + "` to `" + orig_arg_str + "`.",
-                                        Level::Error, Stage::Semantic, {Label("", {args.p[i].loc})}));
+                    std::string orig_arg_str
+                        = ASRUtils::type_to_str_fortran_expr(orig_arg_type, func->m_args[i]);
+                    diag.add(Diagnostic("Type mismatch in argument at argument ("
+                                            + std::to_string(i + 1) + "); passed `" + arg_str
+                                            + "` to `" + orig_arg_str + "`.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { args.p[i].loc }) }));
                     throw SemanticAbort();
                 }
             }
         }
-
     }
 
-    void legacy_array_sections_helper(ASR::symbol_t *v, Vec<ASR::call_arg_t>& args, const Location &loc) {
+    void legacy_array_sections_helper(ASR::symbol_t* v,
+                                      Vec<ASR::call_arg_t>& args,
+                                      const Location& loc)
+    {
         ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(v));
         if (compiler_options.legacy_array_sections) {
             // call b(w(icon)) -> call b(w(icon:)) if b is expecting an array
@@ -6928,8 +8427,10 @@ public:
                 // check if i is in array_arg_idx
                 if (array_arg_idx.find(i) != array_arg_idx.end()) {
                     ASR::call_arg_t arg = args[i];
-                    ASR::array_physical_typeType expected_phys = ASRUtils::extract_physical_type(array_arg_idx[i]);
-                    ASR::ttype_t* expected_arg_type = ASRUtils::duplicate_type(al, array_arg_idx[i], nullptr, expected_phys, true);
+                    ASR::array_physical_typeType expected_phys
+                        = ASRUtils::extract_physical_type(array_arg_idx[i]);
+                    ASR::ttype_t* expected_arg_type = ASRUtils::duplicate_type(
+                        al, array_arg_idx[i], nullptr, expected_phys, true);
                     ASR::expr_t* arg_expr = arg.m_value;
                     if (arg_expr && ASR::is_a<ASR::ArrayItem_t>(*arg_expr)) {
                         ASR::ArrayItem_t* array_item = ASR::down_cast<ASR::ArrayItem_t>(arg_expr);
@@ -6945,23 +8446,34 @@ public:
                         dim.m_length = nullptr;
                         dim.m_start = nullptr;
                         dims.push_back(al, dim);
-                        ASR::asr_t* descriptor_array = ASR::make_Array_t(al, loc, ASRUtils::type_get_past_array(expected_arg_type),
-                                                        dims.p, dims.size(), ASR::array_physical_typeType::DescriptorArray);
+                        ASR::asr_t* descriptor_array
+                            = ASR::make_Array_t(al,
+                                                loc,
+                                                ASRUtils::type_get_past_array(expected_arg_type),
+                                                dims.p,
+                                                dims.size(),
+                                                ASR::array_physical_typeType::DescriptorArray);
 
                         ASR::Array_t* array_t = ASR::down_cast<ASR::Array_t>(expected_arg_type);
 
-                        // Replace FunctionParam in dimensions and check whether its symbols are accessible from current_scope
+                        // Replace FunctionParam in dimensions and check whether its symbols are
+                        // accessible from current_scope
                         SetChar temp_function_dependencies;
                         ASRUtils::ReplaceFunctionParamWithArg r(al, args.p, args.n);
-                        ASRUtils::CheckSymbolReplacer c(al, current_scope, temp_function_dependencies);
+                        ASRUtils::CheckSymbolReplacer c(
+                            al, current_scope, temp_function_dependencies);
                         bool valid_symbols = true;
-                        Vec<ASR::dimension_t> dimensions_; dimensions_.reserve(al, array_t->n_dims);
+                        Vec<ASR::dimension_t> dimensions_;
+                        dimensions_.reserve(al, array_t->n_dims);
                         for (size_t i = 0; i < array_t->n_dims; i++) {
                             ASR::dimension_t dim;
                             dim.loc = array_t->m_dims[i].loc;
-                            dim.m_start = r.replace_FunctionParam_with_arg(array_t->m_dims[i].m_start);
-                            dim.m_length = r.replace_FunctionParam_with_arg(array_t->m_dims[i].m_length);
-                            valid_symbols = c.check_and_update_symbols(dim.m_length) && c.check_and_update_symbols(dim.m_start);
+                            dim.m_start
+                                = r.replace_FunctionParam_with_arg(array_t->m_dims[i].m_start);
+                            dim.m_length
+                                = r.replace_FunctionParam_with_arg(array_t->m_dims[i].m_length);
+                            valid_symbols = c.check_and_update_symbols(dim.m_length)
+                                            && c.check_and_update_symbols(dim.m_start);
                             if (!valid_symbols) {
                                 break;
                             }
@@ -6972,17 +8484,22 @@ public:
                                 array_t->m_dims[i] = dimensions_[i];
                             }
                             for (size_t i = 0; i < temp_function_dependencies.n; i++) {
-                                current_function_dependencies.push_back(al, temp_function_dependencies[i]);
+                                current_function_dependencies.push_back(
+                                    al, temp_function_dependencies[i]);
                             }
                         } else {
                             expected_arg_type = ASRUtils::duplicate_type_with_empty_dims(
-                                al, array_arg_idx[i], expected_phys, true
-                            );
+                                al, array_arg_idx[i], expected_phys, true);
                             array_t = ASR::down_cast<ASR::Array_t>(expected_arg_type);
                         }
 
-                        ASR::asr_t* expected_array = ASR::make_Array_t(al, loc, ASRUtils::type_get_past_array(expected_arg_type),
-                                                        array_t->m_dims, array_t->n_dims, ASRUtils::extract_physical_type(expected_arg_type));
+                        ASR::asr_t* expected_array
+                            = ASR::make_Array_t(al,
+                                                loc,
+                                                ASRUtils::type_get_past_array(expected_arg_type),
+                                                array_t->m_dims,
+                                                array_t->n_dims,
+                                                ASRUtils::extract_physical_type(expected_arg_type));
 
                         // make ArraySection
                         Vec<ASR::array_index_t> array_indices;
@@ -6992,19 +8509,33 @@ public:
                             array_indices.push_back(al, array_item->m_args[i]);
                         }
 
-                        ASR::array_physical_typeType expected_phys_type = ASRUtils::extract_physical_type(expected_arg_type);
-                        ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1, ASRUtils::extract_type(ASRUtils::expr_type(idx))));
+                        ASR::array_physical_typeType expected_phys_type
+                            = ASRUtils::extract_physical_type(expected_arg_type);
+                        ASR::expr_t* one = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                            al, loc, 1, ASRUtils::extract_type(ASRUtils::expr_type(idx))));
                         ASR::array_index_t array_idx;
                         array_idx.loc = array_item->base.base.loc;
                         array_idx.m_left = idx;
-                        array_idx.m_right = ASRUtils::get_bound<SemanticAbort>(array_expr, 1, "ubound", al, diag);
+                        array_idx.m_right
+                            = ASRUtils::get_bound<SemanticAbort>(array_expr, 1, "ubound", al, diag);
                         array_idx.m_step = one;
                         array_indices.p[0] = array_idx;
-                        ASR::expr_t* array_section = ASRUtils::EXPR(ASR::make_ArraySection_t(al, array_item->base.base.loc,
-                                                    array_expr, array_indices.p, array_indices.size(),
-                                                    ASRUtils::TYPE(descriptor_array), nullptr));
-                        ASR::asr_t* array_cast = ASRUtils::make_ArrayPhysicalCast_t_util(al, array_item->base.base.loc, array_section,
-                                                ASRUtils::extract_physical_type(ASRUtils::TYPE(descriptor_array)), expected_phys_type, ASRUtils::TYPE(expected_array), nullptr);
+                        ASR::expr_t* array_section = ASRUtils::EXPR(
+                            ASR::make_ArraySection_t(al,
+                                                     array_item->base.base.loc,
+                                                     array_expr,
+                                                     array_indices.p,
+                                                     array_indices.size(),
+                                                     ASRUtils::TYPE(descriptor_array),
+                                                     nullptr));
+                        ASR::asr_t* array_cast = ASRUtils::make_ArrayPhysicalCast_t_util(
+                            al,
+                            array_item->base.base.loc,
+                            array_section,
+                            ASRUtils::extract_physical_type(ASRUtils::TYPE(descriptor_array)),
+                            expected_phys_type,
+                            ASRUtils::TYPE(expected_array),
+                            nullptr);
                         arg.m_value = ASRUtils::EXPR(array_cast);
 
                         args_with_array_section.push_back(al, arg);
@@ -7019,21 +8550,22 @@ public:
             // There can be a possibility that initially it is ArrayItem and now we realised
             // that it must be an ArraySection instead.
             array_arg_idx.clear();
-            for ( size_t i = 0; i < args.size(); i++ ) {
+            for (size_t i = 0; i < args.size(); i++) {
                 ASR::expr_t* arg_expr = args[i].m_value;
-                if ( arg_expr && ASRUtils::is_array(ASRUtils::expr_type(arg_expr)) ) {
+                if (arg_expr && ASRUtils::is_array(ASRUtils::expr_type(arg_expr))) {
                     array_arg_idx[i] = ASRUtils::expr_type(arg_expr);
                 }
             }
             // bool visit_required = false;
-            for ( auto it: array_arg_idx ) {
+            for (auto it : array_arg_idx) {
                 ASR::expr_t* func_arg = f->m_args[it.first];
-                ASR::FunctionType_t* f_type =
-                    ASR::down_cast<ASR::FunctionType_t>(f->m_function_signature);
+                ASR::FunctionType_t* f_type
+                    = ASR::down_cast<ASR::FunctionType_t>(f->m_function_signature);
                 bool is_elemental = (f_type->m_abi == ASR::abiType::Source && f_type->m_elemental);
                 if (!is_elemental && !ASRUtils::is_array(ASRUtils::EXPR2VAR(func_arg)->m_type)) {
                     // create array type with empty dimensions and physical type as PointerArray
-                    ASR::ttype_t* new_type = ASRUtils::duplicate_type_with_empty_dims(al, it.second, ASR::array_physical_typeType::PointerArray, true);
+                    ASR::ttype_t* new_type = ASRUtils::duplicate_type_with_empty_dims(
+                        al, it.second, ASR::array_physical_typeType::PointerArray, true);
                     ASRUtils::EXPR2VAR(func_arg)->m_type = new_type;
                     f_type->m_arg_types[it.first] = new_type;
                     // visit_required = true;
@@ -7042,10 +8574,10 @@ public:
         }
     }
 
-    ASR::asr_t* create_Function(const Location &loc,
-                Vec<ASR::call_arg_t>& args, ASR::symbol_t *v) {
-        ASR::symbol_t *f2 = ASRUtils::symbol_get_past_external(v);
-        
+    ASR::asr_t* create_Function(const Location& loc, Vec<ASR::call_arg_t>& args, ASR::symbol_t* v)
+    {
+        ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(v);
+
         // Special handling for compiler_options(): replace with CompilerOptions ASR node
         if (std::string(ASRUtils::symbol_name(f2)) == "compiler_options") {
             Vec<ASR::expr_t*> expr_args;
@@ -7055,20 +8587,18 @@ public:
             }
             return ASRUtils::CompilerOptions::create_CompilerOptions(al, loc, expr_args, diag);
         }
-        
-        ASR::ttype_t *return_type = nullptr;
+
+        ASR::ttype_t* return_type = nullptr;
         ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(f2);
         ASR::expr_t* first_array_arg = ASRUtils::find_first_array_arg_if_elemental(func, args);
         if (first_array_arg) {
             ASR::dimension_t* array_dims;
             size_t array_n_dims = ASRUtils::extract_dimensions_from_ttype(
-                ASRUtils::expr_type(first_array_arg), array_dims
-            );
+                ASRUtils::expr_type(first_array_arg), array_dims);
             Vec<ASR::dimension_t> new_dims;
             new_dims.from_pointer_n_copy(al, array_dims, array_n_dims);
-            return_type = ASRUtils::duplicate_type(al,
-                            ASRUtils::get_FunctionType(func)->m_return_var_type,
-                            &new_dims);
+            return_type = ASRUtils::duplicate_type(
+                al, ASRUtils::get_FunctionType(func)->m_return_var_type, &new_dims);
         } else {
             return_type = ASRUtils::EXPR2VAR(func->m_return_var)->m_type;
             return_type = handle_return_type(return_type, loc, args, func);
@@ -7076,59 +8606,92 @@ public:
         ASR::expr_t* value = nullptr;
         if (ASR::is_a<ASR::ExternalSymbol_t>(*v)) {
             // Populate value
-            ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(f2);
+            ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f2);
             if (ASRUtils::is_intrinsic_procedure(f)) {
-                value = intrinsic_procedures.comptime_eval(f->m_name, al, loc, args, compiler_options);
-                char *mod = ASR::down_cast<ASR::ExternalSymbol_t>(
-                    current_scope->resolve_symbol(f->m_name))->m_module_name;
+                value = intrinsic_procedures.comptime_eval(
+                    f->m_name, al, loc, args, compiler_options);
+                char* mod = ASR::down_cast<ASR::ExternalSymbol_t>(
+                                current_scope->resolve_symbol(f->m_name))
+                                ->m_module_name;
                 current_module_dependencies.push_back(al, mod);
             }
         }
         if (ASRUtils::symbol_parent_symtab(v)->get_counter() != current_scope->get_counter()) {
             ADD_ASR_DEPENDENCIES(current_scope, v, current_function_dependencies);
         }
-        if ((_processing_dimensions || _processing_char_len) && _declaring_variable &&
-            ASRUtils::symbol_parent_symtab(v)->get_counter() != current_scope->get_counter() &&
-            !ASR::is_a<ASR::ExternalSymbol_t>(*v)) {
+        if ((_processing_dimensions || _processing_char_len) && _declaring_variable
+            && ASRUtils::symbol_parent_symtab(v)->get_counter() != current_scope->get_counter()
+            && !ASR::is_a<ASR::ExternalSymbol_t>(*v)) {
             current_function_dependencies.push_back(al, ASRUtils::symbol_name(v));
         }
         ASR::Module_t* v_module = ASRUtils::get_sym_module0(f2);
-        if( v_module ) {
+        if (v_module) {
             current_module_dependencies.push_back(al, v_module->m_name);
         }
         ASRUtils::insert_module_dependency(v, al, current_module_dependencies);
         if (args.size() > func->n_args) {
-            const Location args_loc { ASRUtils::get_vec_loc(args) };
-            diag.add(diag::Diagnostic(
-                    "More actual than formal arguments in procedure call",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {args_loc})}));
+            const Location args_loc{ ASRUtils::get_vec_loc(args) };
+            diag.add(diag::Diagnostic("More actual than formal arguments in procedure call",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { args_loc }) }));
             throw SemanticAbort();
         }
         ASRUtils::set_absent_optional_arguments_to_null(args, func, al);
         legacy_array_sections_helper(v, args, loc);
         validate_create_function_arguments(args, v);
-        return ASRUtils::make_FunctionCall_t_util(al, loc, v, nullptr,
-            args.p, args.size(), return_type, value, nullptr, current_scope, current_function_dependencies);
-    }
-
-    ASR::asr_t* create_FunctionFromFunctionTypeVariable(const Location &loc,
-                Vec<ASR::call_arg_t>& args, ASR::symbol_t *v, bool is_dt_present=false) {
+        return ASRUtils::make_FunctionCall_t_util(al,
+                                                  loc,
+                                                  v,
+                                                  nullptr,
+                                                  args.p,
+                                                  args.size(),
+                                                  return_type,
+                                                  value,
+                                                  nullptr,
+                                                  current_scope,
+                                                  current_function_dependencies);
+    }
+
+    ASR::asr_t* create_FunctionFromFunctionTypeVariable(const Location& loc,
+                                                        Vec<ASR::call_arg_t>& args,
+                                                        ASR::symbol_t* v,
+                                                        bool is_dt_present = false)
+    {
         ASR::FunctionType_t* func = ASR::down_cast<ASR::FunctionType_t>(ASRUtils::symbol_type(v));
-        ASR::ttype_t *return_type = func->m_return_var_type;
+        ASR::ttype_t* return_type = func->m_return_var_type;
         if (ASRUtils::symbol_parent_symtab(v)->get_counter() != current_scope->get_counter()) {
             ADD_ASR_DEPENDENCIES(current_scope, v, current_function_dependencies);
         }
         // TODO: Uncomment later
-        // ASRUtils::set_absent_optional_arguments_to_null(args, ASR::down_cast<ASR::Function_t>(v), al);
-        if( is_dt_present ) {
+        // ASRUtils::set_absent_optional_arguments_to_null(args, ASR::down_cast<ASR::Function_t>(v),
+        // al);
+        if (is_dt_present) {
             ASR::expr_t* dt = ASRUtils::EXPR(ASR::make_StructInstanceMember_t(
                 al, loc, args.p[0].m_value, v, ASRUtils::symbol_type(v), nullptr));
-            return ASRUtils::make_FunctionCall_t_util(al, loc, v, nullptr,
-                args.p + 1, args.size() - 1, return_type, nullptr, dt, current_scope, current_function_dependencies);
+            return ASRUtils::make_FunctionCall_t_util(al,
+                                                      loc,
+                                                      v,
+                                                      nullptr,
+                                                      args.p + 1,
+                                                      args.size() - 1,
+                                                      return_type,
+                                                      nullptr,
+                                                      dt,
+                                                      current_scope,
+                                                      current_function_dependencies);
         } else {
-            return ASRUtils::make_FunctionCall_t_util(al, loc, v, nullptr,
-                args.p, args.size(), return_type, nullptr, nullptr, current_scope, current_function_dependencies);
+            return ASRUtils::make_FunctionCall_t_util(al,
+                                                      loc,
+                                                      v,
+                                                      nullptr,
+                                                      args.p,
+                                                      args.size(),
+                                                      return_type,
+                                                      nullptr,
+                                                      nullptr,
+                                                      current_scope,
+                                                      current_function_dependencies);
         }
     }
 
@@ -7142,9 +8705,11 @@ public:
     //
     // If `fn` is intrinsic, it will also try to evaluate it into the `value`
     // member of the returned `FunctionCall`.
-    ASR::asr_t* create_FunctionCall(const Location &loc,
-                ASR::symbol_t *fn, Vec<ASR::call_arg_t>& args) {
-        ASR::symbol_t *f2 = ASRUtils::symbol_get_past_external(fn);
+    ASR::asr_t* create_FunctionCall(const Location& loc,
+                                    ASR::symbol_t* fn,
+                                    Vec<ASR::call_arg_t>& args)
+    {
+        ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(fn);
         if (ASR::is_a<ASR::Function_t>(*f2)) {
             return create_Function(loc, args, fn);
         } else {
@@ -7154,8 +8719,11 @@ public:
     }
 
     ASR::asr_t* create_FunctionCallWithASTNode(const AST::FuncCallOrArray_t& x,
-                ASR::symbol_t *v, Vec<ASR::call_arg_t>& args, bool is_dt_present=false) {
-        ASR::symbol_t *f2 = ASRUtils::symbol_get_past_external(v);
+                                               ASR::symbol_t* v,
+                                               Vec<ASR::call_arg_t>& args,
+                                               bool is_dt_present = false)
+    {
+        ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(v);
         if (ASR::is_a<ASR::Function_t>(*f2)) {
             return create_Function(x.base.base.loc, args, v);
         } else if (ASR::is_a<ASR::Variable_t>(*f2)) {
@@ -7166,7 +8734,12 @@ public:
         }
     }
 
-    void make_ArrayItem_from_struct_m_args(AST::fnarg_t* struct_m_args, size_t struct_n_args, ASR::expr_t* expr, ASR::asr_t* &array_item_node, const Location &loc) {
+    void make_ArrayItem_from_struct_m_args(AST::fnarg_t* struct_m_args,
+                                           size_t struct_n_args,
+                                           ASR::expr_t* expr,
+                                           ASR::asr_t*& array_item_node,
+                                           const Location& loc)
+    {
         if (struct_n_args == 0) {
             return;
         }
@@ -7174,26 +8747,28 @@ public:
         Vec<ASR::array_index_t> indices;
         indices.reserve(al, struct_n_args);
         bool is_array_section = false;
-        for( size_t j = 0; j < struct_n_args; j++ ) {
+        for (size_t j = 0; j < struct_n_args; j++) {
             is_array_section = is_array_section || (struct_m_args[j].m_step != nullptr);
             ASR::array_index_t index;
-            if( struct_m_args[j].m_step == nullptr ) {
+            if (struct_m_args[j].m_step == nullptr) {
                 this->visit_expr(*struct_m_args[j].m_end);
                 index.m_right = ASRUtils::EXPR(tmp);
                 index.m_left = nullptr;
                 index.m_step = nullptr;
             } else {
-                if( struct_m_args[j].m_start ) {
+                if (struct_m_args[j].m_start) {
                     this->visit_expr(*struct_m_args[j].m_start);
                     index.m_left = ASRUtils::EXPR(tmp);
                 } else {
-                    index.m_left = ASRUtils::get_bound<SemanticAbort>(expr, j + 1, "lbound", al, diag);
+                    index.m_left
+                        = ASRUtils::get_bound<SemanticAbort>(expr, j + 1, "lbound", al, diag);
                 }
-                if( struct_m_args[j].m_end ) {
+                if (struct_m_args[j].m_end) {
                     this->visit_expr(*struct_m_args[j].m_end);
                     index.m_right = ASRUtils::EXPR(tmp);
                 } else {
-                    index.m_right = ASRUtils::get_bound<SemanticAbort>(expr, j + 1, "ubound", al, diag);
+                    index.m_right
+                        = ASRUtils::get_bound<SemanticAbort>(expr, j + 1, "ubound", al, diag);
                 }
                 this->visit_expr(*struct_m_args[j].m_step);
                 index.m_step = ASRUtils::EXPR(tmp);
@@ -7202,11 +8777,11 @@ public:
             indices.push_back(al, index);
         }
         tmp = tmp_copy;
-        if( is_array_section ) {
+        if (is_array_section) {
             Vec<ASR::dimension_t> array_section_dims;
             array_section_dims.reserve(al, struct_n_args);
-            for( size_t j = 0; j < struct_n_args; j++ ) {
-                if( struct_m_args[j].m_step != nullptr ) {
+            for (size_t j = 0; j < struct_n_args; j++) {
+                if (struct_m_args[j].m_step != nullptr) {
                     ASR::dimension_t empty_dim;
                     empty_dim.loc = loc;
                     empty_dim.m_start = nullptr;
@@ -7214,46 +8789,64 @@ public:
                     array_section_dims.push_back(al, empty_dim);
                 }
             }
-            ASR::ttype_t *array_section_type =
-                ASRUtils::duplicate_type(al, ASRUtils::extract_type(ASRUtils::expr_type(expr)),
-                        &array_section_dims);
-            array_item_node = ASR::make_ArraySection_t(al, loc, expr, indices.p,
-                indices.size(), array_section_type, nullptr);
+            ASR::ttype_t* array_section_type = ASRUtils::duplicate_type(
+                al, ASRUtils::extract_type(ASRUtils::expr_type(expr)), &array_section_dims);
+            array_item_node = ASR::make_ArraySection_t(
+                al, loc, expr, indices.p, indices.size(), array_section_type, nullptr);
         } else {
-            array_item_node = ASRUtils::make_ArrayItem_t_util(al, loc, expr, indices.p,
-                indices.size(), ASRUtils::duplicate_type(al, ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(expr))),
-                ASR::arraystorageType::ColMajor, nullptr);
-        }
-        array_item_node = (ASR::asr_t*) replace_with_common_block_variables(
-            ASRUtils::EXPR(array_item_node));
-    }
-
-    ASR::asr_t* resolve_variable2(const Location &loc, const std::string &var_name,
-            const std::string &dt_name, SymbolTable*& scope,
-            AST::fnarg_t* dt_struct_m_args=nullptr, size_t dt_struct_n_args=0,
-            AST::fnarg_t* member_struct_m_args=nullptr, size_t member_struct_n_args=0) {
-
-        ASR::symbol_t *v = scope->resolve_symbol(dt_name);
+            array_item_node = ASRUtils::make_ArrayItem_t_util(
+                al,
+                loc,
+                expr,
+                indices.p,
+                indices.size(),
+                ASRUtils::duplicate_type(
+                    al, ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(expr))),
+                ASR::arraystorageType::ColMajor,
+                nullptr);
+        }
+        array_item_node
+            = (ASR::asr_t*) replace_with_common_block_variables(ASRUtils::EXPR(array_item_node));
+    }
+
+    ASR::asr_t* resolve_variable2(const Location& loc,
+                                  const std::string& var_name,
+                                  const std::string& dt_name,
+                                  SymbolTable*& scope,
+                                  AST::fnarg_t* dt_struct_m_args = nullptr,
+                                  size_t dt_struct_n_args = 0,
+                                  AST::fnarg_t* member_struct_m_args = nullptr,
+                                  size_t member_struct_n_args = 0)
+    {
+        ASR::symbol_t* v = scope->resolve_symbol(dt_name);
         if (!v) {
             diag.add(Diagnostic("Variable '" + dt_name + "' not declared",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
-        ASR::Variable_t* v_variable = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(v));
-        ASR::ttype_t* v_variable_m_type = ASRUtils::duplicate_type(al, ASRUtils::extract_type(v_variable->m_type));
+        ASR::Variable_t* v_variable
+            = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(v));
+        ASR::ttype_t* v_variable_m_type
+            = ASRUtils::duplicate_type(al, ASRUtils::extract_type(v_variable->m_type));
         if (ASR::is_a<ASR::StructType_t>(*v_variable_m_type)) {
             ASR::ttype_t* v_type = v_variable_m_type;
-            ASR::symbol_t *derived_type = nullptr;
+            ASR::symbol_t* derived_type = nullptr;
             if (ASR::is_a<ASR::StructType_t>(*v_type)) {
                 derived_type = v_variable->m_type_declaration;
             }
-            ASR::Struct_t *der_type;
+            ASR::Struct_t* der_type;
             if (ASR::is_a<ASR::ExternalSymbol_t>(*derived_type)) {
-                ASR::ExternalSymbol_t* der_ext = ASR::down_cast<ASR::ExternalSymbol_t>(derived_type);
+                ASR::ExternalSymbol_t* der_ext
+                    = ASR::down_cast<ASR::ExternalSymbol_t>(derived_type);
                 ASR::symbol_t* der_sym = der_ext->m_external;
                 if (der_sym == nullptr) {
-                    diag.add(Diagnostic("'" + std::string(der_ext->m_name) + "' isn't a Derived or Union type.",
-                        Level::Error, Stage::Semantic, {Label("", {loc})}));
+                    diag.add(Diagnostic("'" + std::string(der_ext->m_name)
+                                            + "' isn't a Derived or Union type.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 } else {
                     der_type = ASR::down_cast<ASR::Struct_t>(der_sym);
@@ -7261,24 +8854,26 @@ public:
             } else {
                 der_type = ASR::down_cast<ASR::Struct_t>(derived_type);
             }
-            ASR::Struct_t *par_der_type = der_type;
+            ASR::Struct_t* par_der_type = der_type;
             // scope = der_type->m_symtab;
             // ASR::symbol_t* member = der_type->m_symtab->resolve_symbol(var_name);
             ASR::symbol_t* member = nullptr;
-            while( par_der_type != nullptr && member == nullptr ) {
+            while (par_der_type != nullptr && member == nullptr) {
                 scope = par_der_type->m_symtab;
                 member = par_der_type->m_symtab->get_symbol(var_name);
-                if( par_der_type->m_parent != nullptr ) {
-                    ASR::symbol_t* parent_sym = ASRUtils::symbol_get_past_external(par_der_type->m_parent);
+                if (par_der_type->m_parent != nullptr) {
+                    ASR::symbol_t* parent_sym
+                        = ASRUtils::symbol_get_past_external(par_der_type->m_parent);
                     par_der_type = ASR::down_cast<ASR::Struct_t>(parent_sym);
-                    if (par_der_type->m_name == var_name) {    // if the parent type is the member itself
+                    if (par_der_type->m_name
+                        == var_name) {  // if the parent type is the member itself
                         member = parent_sym;
                     }
                 } else {
                     par_der_type = nullptr;
                 }
             }
-            if( member != nullptr ) {
+            if (member != nullptr) {
                 ASR::asr_t* v_var = ASR::make_Var_t(al, loc, v);
                 make_ArrayItem_from_struct_m_args(
                     dt_struct_m_args, dt_struct_n_args, ASRUtils::EXPR(v_var), v_var, loc);
@@ -7288,25 +8883,32 @@ public:
                     member_struct_m_args, member_struct_n_args, ASRUtils::EXPR(expr_), expr_, loc);
                 return expr_;
             }
-            diag.add(Diagnostic("Variable '" + dt_name + "' doesn't have any member named, '" + var_name + "'.",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+            diag.add(Diagnostic("Variable '" + dt_name + "' doesn't have any member named, '"
+                                    + var_name + "'.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
 
         if (ASR::is_a<ASR::UnionType_t>(*v_variable_m_type)) {
             ASR::ttype_t* v_type = v_variable_m_type;
-            ASR::symbol_t *derived_type = nullptr;
+            ASR::symbol_t* derived_type = nullptr;
             if (ASR::is_a<ASR::UnionType_t>(*v_type)) {
                 derived_type = ASRUtils::symbol_get_past_external(v_variable->m_type_declaration);
             }
-            ASR::Union_t *der_type;
+            ASR::Union_t* der_type;
             if (ASR::is_a<ASR::ExternalSymbol_t>(*derived_type)) {
-                ASR::ExternalSymbol_t* der_ext = ASR::down_cast<ASR::ExternalSymbol_t>(derived_type);
+                ASR::ExternalSymbol_t* der_ext
+                    = ASR::down_cast<ASR::ExternalSymbol_t>(derived_type);
                 ASR::symbol_t* der_sym = der_ext->m_external;
                 if (der_sym == nullptr) {
-                    diag.add(Diagnostic("'" + std::string(der_ext->m_name) + "' isn't a Derived or Union type.",
-                        Level::Error, Stage::Semantic, {Label("", {loc})}));
+                    diag.add(Diagnostic("'" + std::string(der_ext->m_name)
+                                            + "' isn't a Derived or Union type.",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 } else {
                     der_type = ASR::down_cast<ASR::Union_t>(der_sym);
@@ -7314,34 +8916,44 @@ public:
             } else {
                 der_type = ASR::down_cast<ASR::Union_t>(derived_type);
             }
-            ASR::Union_t *par_der_type = der_type;
+            ASR::Union_t* par_der_type = der_type;
             // scope = der_type->m_symtab;
             // ASR::symbol_t* member = der_type->m_symtab->resolve_symbol(var_name);
             ASR::symbol_t* member = nullptr;
-            while( par_der_type != nullptr && member == nullptr ) {
+            while (par_der_type != nullptr && member == nullptr) {
                 scope = par_der_type->m_symtab;
                 member = par_der_type->m_symtab->resolve_symbol(var_name);
-                if( par_der_type->m_parent != nullptr ) {
-                    par_der_type = ASR::down_cast<ASR::Union_t>(ASRUtils::symbol_get_past_external(par_der_type->m_parent));
+                if (par_der_type->m_parent != nullptr) {
+                    par_der_type = ASR::down_cast<ASR::Union_t>(
+                        ASRUtils::symbol_get_past_external(par_der_type->m_parent));
                 } else {
                     par_der_type = nullptr;
                 }
             }
-            if( member != nullptr ) {
+            if (member != nullptr) {
                 ASR::asr_t* v_var = ASR::make_Var_t(al, loc, v);
                 ASR::Variable_t* member_var = ASR::down_cast<ASR::Variable_t>(member);
                 ASR::asr_t* expr_ = (ASR::asr_t*) ASR::make_UnionInstanceMember_t(
-                    al, loc, ASR::down_cast<ASR::expr_t>(v_var), member, member_var->m_type, nullptr);
+                    al,
+                    loc,
+                    ASR::down_cast<ASR::expr_t>(v_var),
+                    member,
+                    member_var->m_type,
+                    nullptr);
                 return expr_;
             }
-            diag.add(Diagnostic("Variable '" + dt_name + "' doesn't have any member named, '" + var_name + "'.",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+            diag.add(Diagnostic("Variable '" + dt_name + "' doesn't have any member named, '"
+                                    + var_name + "'.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
         // Handle type parameter inquiry kind first because others depend on their type
         if (var_name == "kind") {
-            ASRUtils::create_intrinsic_function create_func = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(var_name);
+            ASRUtils::create_intrinsic_function create_func
+                = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(var_name);
             Vec<ASR::expr_t*> args;
             args.reserve(al, 1);
             ASR::asr_t* v_var = ASR::make_Var_t(al, loc, v);
@@ -7351,14 +8963,18 @@ public:
 
         if (ASR::is_a<ASR::Complex_t>(*v_variable_m_type)) {
             if (var_name != "re" && var_name != "im") {
-                diag.add(Diagnostic("Complex variable '" + dt_name + "' only has %re, %im, and %kind members, not '" + var_name + "'",
-                    Level::Error, Stage::Semantic, {Label("", {loc})}));
+                diag.add(Diagnostic("Complex variable '" + dt_name
+                                        + "' only has %re, %im, and %kind members, not '" + var_name
+                                        + "'",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
 
             if (ASRUtils::is_array(v_variable->m_type)) {
-                ASR::expr_t* desc_arr = ASRUtils::cast_to_descriptor(al, ASRUtils::EXPR(
-                        ASR::make_Var_t(al, loc, v)));
+                ASR::expr_t* desc_arr
+                    = ASRUtils::cast_to_descriptor(al, ASRUtils::EXPR(ASR::make_Var_t(al, loc, v)));
                 ASR::ttype_t* v_variable_arr_type = ASRUtils::type_get_past_allocatable(
                     ASRUtils::type_get_past_pointer(v_variable->m_type));
                 int kind = ASRUtils::extract_kind_from_ttype_t(v_variable_arr_type);
@@ -7366,42 +8982,50 @@ public:
                 int n_dims = ASRUtils::extract_dimensions_from_ttype(v_variable_arr_type, m_dims);
                 Vec<ASR::dimension_t> dim_vec;
                 dim_vec.from_pointer_n_copy(al, m_dims, n_dims);
-                ASR::ttype_t *real_type = ASR::down_cast<ASR::ttype_t>(
-                    ASR::make_Real_t(al, loc, kind));
-                ASR::ttype_t* complex_arr_ret_type = ASRUtils::duplicate_type(al, real_type, &dim_vec,
-                    ASR::array_physical_typeType::DescriptorArray, true);
+                ASR::ttype_t* real_type
+                    = ASR::down_cast<ASR::ttype_t>(ASR::make_Real_t(al, loc, kind));
+                ASR::ttype_t* complex_arr_ret_type = ASRUtils::duplicate_type(
+                    al, real_type, &dim_vec, ASR::array_physical_typeType::DescriptorArray, true);
                 if (var_name == "re") {
                     return ASR::make_ComplexRe_t(al, loc, desc_arr, complex_arr_ret_type, nullptr);
                 } else {
                     return ASR::make_ComplexIm_t(al, loc, desc_arr, complex_arr_ret_type, nullptr);
                 }
             } else {
-                ASR::expr_t *val = ASRUtils::EXPR(ASR::make_Var_t(al, loc, v));
-                ASR::ttype_t *real_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc,
-                    ASRUtils::extract_kind_from_ttype_t(v_variable_m_type)));
-                
+                ASR::expr_t* val = ASRUtils::EXPR(ASR::make_Var_t(al, loc, v));
+                ASR::ttype_t* real_type = ASRUtils::TYPE(ASR::make_Real_t(
+                    al, loc, ASRUtils::extract_kind_from_ttype_t(v_variable_m_type)));
+
                 if (var_name == "re") {
-                    ASR::expr_t *complex_value = ASRUtils::expr_value(val);
-                    ASR::expr_t *re_value = nullptr;
+                    ASR::expr_t* complex_value = ASRUtils::expr_value(val);
+                    ASR::expr_t* re_value = nullptr;
                     if (complex_value && ASR::is_a<ASR::ComplexConstant_t>(*complex_value)) {
-                        ASR::ComplexConstant_t *c = ASR::down_cast<ASR::ComplexConstant_t>(complex_value);
-                        re_value = ASRUtils::EXPR(ASR::make_RealConstant_t(al, loc, c->m_re, real_type));
+                        ASR::ComplexConstant_t* c
+                            = ASR::down_cast<ASR::ComplexConstant_t>(complex_value);
+                        re_value
+                            = ASRUtils::EXPR(ASR::make_RealConstant_t(al, loc, c->m_re, real_type));
                     }
                     return ASR::make_ComplexRe_t(al, loc, val, real_type, re_value);
                 } else {
-                    ASR::expr_t *complex_value = ASRUtils::expr_value(val);
-                    ASR::expr_t *im_value = nullptr;
+                    ASR::expr_t* complex_value = ASRUtils::expr_value(val);
+                    ASR::expr_t* im_value = nullptr;
                     if (complex_value && ASR::is_a<ASR::ComplexConstant_t>(*complex_value)) {
-                        ASR::ComplexConstant_t *c = ASR::down_cast<ASR::ComplexConstant_t>(complex_value);
-                        im_value = ASRUtils::EXPR(ASR::make_RealConstant_t(al, loc, c->m_im, real_type));
+                        ASR::ComplexConstant_t* c
+                            = ASR::down_cast<ASR::ComplexConstant_t>(complex_value);
+                        im_value
+                            = ASRUtils::EXPR(ASR::make_RealConstant_t(al, loc, c->m_im, real_type));
                     }
                     return ASR::make_ComplexIm_t(al, loc, val, real_type, im_value);
                 }
             }
         } else if (ASR::is_a<ASR::String_t>(*v_variable_m_type)) {
             if (var_name != "len") {
-                diag.add(Diagnostic("Character variable '" + dt_name + "' only has %len and %kind members, not '" + var_name + "'",
-                    Level::Error, Stage::Semantic, {Label("", {loc})}));
+                diag.add(Diagnostic("Character variable '" + dt_name
+                                        + "' only has %len and %kind members, not '" + var_name
+                                        + "'",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
             ASR::asr_t* v_var = ASR::make_Var_t(al, loc, v);
@@ -7410,27 +9034,36 @@ public:
             return create_StringLen_from_expr(ASRUtils::EXPR(v_var), int32, loc);
         } else {
             diag.add(Diagnostic("Variable '" + dt_name + "' is not a derived or union type",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
     }
 
-    ASR::symbol_t* resolve_deriv_type_proc(const Location &loc, const std::string &var_name,
-            const std::string dt_name, ASR::expr_t* dt_expr, ASR::ttype_t* dt_type, SymbolTable*& scope,
-            ASR::symbol_t* parent=nullptr) {
+    ASR::symbol_t* resolve_deriv_type_proc(const Location& loc,
+                                           const std::string& var_name,
+                                           const std::string dt_name,
+                                           ASR::expr_t* dt_expr,
+                                           ASR::ttype_t* dt_type,
+                                           SymbolTable*& scope,
+                                           ASR::symbol_t* parent = nullptr)
+    {
         ASR::symbol_t* v = nullptr;
         ASR::Struct_t* der_type = nullptr;
-        if( dt_type ) {
-            dt_type = ASRUtils::type_get_past_array(
-                ASRUtils::type_get_past_allocatable(dt_type));
-        }
-        if( parent == nullptr ) {
-            if ( ASR::is_a<ASR::StructType_t>(*dt_type) ) {
-                der_type = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(
-                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(dt_expr))));
+        if (dt_type) {
+            dt_type = ASRUtils::type_get_past_array(ASRUtils::type_get_past_allocatable(dt_type));
+        }
+        if (parent == nullptr) {
+            if (ASR::is_a<ASR::StructType_t>(*dt_type)) {
+                der_type = ASR::down_cast<ASR::Struct_t>(
+                    ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(
+                        ASRUtils::get_struct_sym_from_struct_expr(dt_expr))));
             } else {
                 diag.add(Diagnostic("Variable '" + dt_name + "' is not a derived type",
-                    Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         } else {
@@ -7438,13 +9071,17 @@ public:
             der_type = ASR::down_cast<ASR::Struct_t>(v);
         }
         ASR::symbol_t* member = der_type->m_symtab->get_symbol(var_name);
-        if( member != nullptr ) {
+        if (member != nullptr) {
             scope = der_type->m_symtab;
-        } else if( der_type->m_parent != nullptr ) {
-            member = resolve_deriv_type_proc(loc, var_name, "", nullptr, nullptr, scope, der_type->m_parent);
+        } else if (der_type->m_parent != nullptr) {
+            member = resolve_deriv_type_proc(
+                loc, var_name, "", nullptr, nullptr, scope, der_type->m_parent);
         } else {
-            diag.add(Diagnostic("Variable '" + dt_name + "' doesn't have any member named, '" + var_name + "'.",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+            diag.add(Diagnostic("Variable '" + dt_name + "' doesn't have any member named, '"
+                                    + var_name + "'.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         return member;
@@ -7453,45 +9090,54 @@ public:
     // TODO: Use Vec<expr_t*> instead of std::vector<expr_t*> for performance
     template <typename T>
     bool handle_intrinsic_node_args(const T& x,
-        Vec<ASR::expr_t*>& args, std::vector<std::string>& kwarg_names,
-        size_t min_args, size_t max_args, const std::string& intrinsic_name,
-        bool raise_error=true) {
+                                    Vec<ASR::expr_t*>& args,
+                                    std::vector<std::string>& kwarg_names,
+                                    size_t min_args,
+                                    size_t max_args,
+                                    const std::string& intrinsic_name,
+                                    bool raise_error = true)
+    {
         // raise_error is used only when the error is not related to number of arguments
         size_t total_args = x.n_args + x.n_keywords;
-        if( !(total_args <= max_args && total_args >= min_args) ) {
+        if (!(total_args <= max_args && total_args >= min_args)) {
             if (min_args == max_args) {
-                diag.add(diag::Diagnostic(
-                    "Incorrect number of arguments "
-                    "passed to the '" + intrinsic_name + "' intrinsic. "
-                    "It accepts exactly " + std::to_string(min_args) +
-                    " arguments.",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
-                    throw SemanticAbort();
+                diag.add(diag::Diagnostic("Incorrect number of arguments "
+                                          "passed to the '"
+                                              + intrinsic_name
+                                              + "' intrinsic. "
+                                                "It accepts exactly "
+                                              + std::to_string(min_args) + " arguments.",
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             } else {
-                diag.add(diag::Diagnostic(
-                    "Incorrect number of arguments "
-                    "passed to the '" + intrinsic_name + "' intrinsic. "
-                    "It accepts at least " + std::to_string(min_args) +
-                    " and at most " + std::to_string(max_args) + " arguments.",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
-                    throw SemanticAbort();
+                diag.add(diag::Diagnostic("Incorrect number of arguments "
+                                          "passed to the '"
+                                              + intrinsic_name
+                                              + "' intrinsic. "
+                                                "It accepts at least "
+                                              + std::to_string(min_args) + " and at most "
+                                              + std::to_string(max_args) + " arguments.",
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
+                throw SemanticAbort();
             }
         }
         args.reserve(al, max_args);
 
-        for( size_t i = 0; i < max_args; i++ ) {
+        for (size_t i = 0; i < max_args; i++) {
             args.push_back(al, nullptr);
         }
-        for( size_t i = 0; i < x.n_args; i++ ) {
+        for (size_t i = 0; i < x.n_args; i++) {
             // Handle BOZ constants in real() function
             ASR::ttype_t* temp_current_variable_type = current_variable_type_;
-            if (intrinsic_name == "real" && i == 0 && x.m_args[i].m_end && 
-                AST::is_a<AST::BOZ_t>(*x.m_args[i].m_end)) {
+            if (intrinsic_name == "real" && i == 0 && x.m_args[i].m_end
+                && AST::is_a<AST::BOZ_t>(*x.m_args[i].m_end)) {
                 // Set current_variable_type to Real for BOZ conversion in real() function
-                current_variable_type_ = ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, 
-                    compiler_options.po.default_integer_kind));
+                current_variable_type_ = ASRUtils::TYPE(ASR::make_Real_t(
+                    al, x.base.base.loc, compiler_options.po.default_integer_kind));
             }
             AST::expr_t* arg_expr = x.m_args[i].m_end;
             this->visit_expr(*x.m_args[i].m_end);
@@ -7505,7 +9151,8 @@ public:
                     if (assumed_rank_arrays.find(var_name) != assumed_rank_arrays.end()) {
                         // TODO: Use Array Physical Cast to convert assumed rank to descriptor array
                         int rank = assumed_rank_arrays[var_name];
-                        Vec<ASR::dimension_t> dims; dims.reserve(al, rank);
+                        Vec<ASR::dimension_t> dims;
+                        dims.reserve(al, rank);
                         for (int r = 0; r < rank; r++) {
                             ASR::dimension_t dim;
                             dim.loc = arg_expr->base.loc;
@@ -7513,68 +9160,87 @@ public:
                             dim.m_length = nullptr;
                             dims.push_back(al, dim);
                         }
-                        ASR::ttype_t* elem_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(temp));
-                        ASR::ttype_t* desc_type = ASRUtils::make_Array_t_util(al, arg_expr->base.loc,
-                            elem_type, dims.p, dims.size(), ASR::abiType::Source, false, 
-                            ASR::array_physical_typeType::DescriptorArray, false, false, true
-                            );
+                        ASR::ttype_t* elem_type
+                            = ASRUtils::type_get_past_array(ASRUtils::expr_type(temp));
+                        ASR::ttype_t* desc_type = ASRUtils::make_Array_t_util(
+                            al,
+                            arg_expr->base.loc,
+                            elem_type,
+                            dims.p,
+                            dims.size(),
+                            ASR::abiType::Source,
+                            false,
+                            ASR::array_physical_typeType::DescriptorArray,
+                            false,
+                            false,
+                            true);
                         ASR::asr_t* array_cast = ASRUtils::make_ArrayPhysicalCast_t_util(
-                            al, arg_expr->base.loc, temp, ASR::array_physical_typeType::AssumedRankArray,
-                            ASR::array_physical_typeType::DescriptorArray, desc_type, nullptr
-                        );
+                            al,
+                            arg_expr->base.loc,
+                            temp,
+                            ASR::array_physical_typeType::AssumedRankArray,
+                            ASR::array_physical_typeType::DescriptorArray,
+                            desc_type,
+                            nullptr);
                         temp = ASRUtils::EXPR(array_cast);
-                    } else if (!(intrinsic_name == "size" || intrinsic_name == "lbound" || intrinsic_name == "ubound" || 
-                        intrinsic_name == "rank" || intrinsic_name == "shape" || intrinsic_name == "is_contiguous" || 
-                        intrinsic_name == "associated" || intrinsic_name == "allocated" || intrinsic_name == "present")) {
-                        diag.semantic_error_label("Assumed rank arrays cannot be used as arguments to intrinsics",
-                            {arg_expr->base.loc}, "");
+                    } else if (!(intrinsic_name == "size" || intrinsic_name == "lbound"
+                                 || intrinsic_name == "ubound" || intrinsic_name == "rank"
+                                 || intrinsic_name == "shape" || intrinsic_name == "is_contiguous"
+                                 || intrinsic_name == "associated" || intrinsic_name == "allocated"
+                                 || intrinsic_name == "present")) {
+                        diag.semantic_error_label(
+                            "Assumed rank arrays cannot be used as arguments to intrinsics",
+                            { arg_expr->base.loc },
+                            "");
                         throw SemanticAbort();
                     }
                 }
             }
             args.p[i] = temp;
-            if (intrinsic_name == "and" || intrinsic_name == "or" || intrinsic_name == "xor" || intrinsic_name == "repeat" || intrinsic_name == "selected_int_kind"
-            || intrinsic_name == "selected_real_kind" || intrinsic_name == "selected_char_kind") {
-                if( ASRUtils::is_array(ASRUtils::expr_type(args[i]))) {
-                    diag.add(diag::Diagnostic(
-                    "arguments of `" + intrinsic_name + "` intrinsic must be scalar",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+            if (intrinsic_name == "and" || intrinsic_name == "or" || intrinsic_name == "xor"
+                || intrinsic_name == "repeat" || intrinsic_name == "selected_int_kind"
+                || intrinsic_name == "selected_real_kind"
+                || intrinsic_name == "selected_char_kind") {
+                if (ASRUtils::is_array(ASRUtils::expr_type(args[i]))) {
+                    diag.add(diag::Diagnostic("arguments of `" + intrinsic_name
+                                                  + "` intrinsic must be scalar",
+                                              diag::Level::Error,
+                                              diag::Stage::Semantic,
+                                              { diag::Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             }
         }
-        for( size_t i = 0; i < x.n_keywords; i++ ) {
+        for (size_t i = 0; i < x.n_keywords; i++) {
             std::string curr_kwarg_name = to_lower(x.m_keywords[i].m_arg);
-            if( std::find(kwarg_names.begin(), kwarg_names.end(),
-                          curr_kwarg_name) == kwarg_names.end() ) {
-                if( !raise_error ) {
+            if (std::find(kwarg_names.begin(), kwarg_names.end(), curr_kwarg_name)
+                == kwarg_names.end()) {
+                if (!raise_error) {
                     return false;
                 }
-                diag.add(Diagnostic(
-                    "Unrecognized keyword argument " + curr_kwarg_name +
-                    " passed to " + intrinsic_name + " intrinsic.",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})}));
+                diag.add(Diagnostic("Unrecognized keyword argument " + curr_kwarg_name
+                                        + " passed to " + intrinsic_name + " intrinsic.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
 
-        for( size_t i = 0; i < x.n_keywords; i++ ) {
+        for (size_t i = 0; i < x.n_keywords; i++) {
             std::string curr_kwarg_name = to_lower(x.m_keywords[i].m_arg);
-            auto it = std::find(kwarg_names.begin(), kwarg_names.end(),
-                                curr_kwarg_name);
+            auto it = std::find(kwarg_names.begin(), kwarg_names.end(), curr_kwarg_name);
             int64_t kwarg_idx = it - kwarg_names.begin();
-            if( args[kwarg_idx] != nullptr ) {
-                if( !raise_error ) {
+            if (args[kwarg_idx] != nullptr) {
+                if (!raise_error) {
                     return false;
                 }
-                diag.add(diag::Diagnostic(
-                    curr_kwarg_name + " has already " +
-                    "been specified as a positional/keyword " +
-                    "argument to " + intrinsic_name,
-                    diag::Level::Error, diag::Stage::Semantic, {
-                        diag::Label("", {x.base.base.loc})}));
+                diag.add(diag::Diagnostic(curr_kwarg_name + " has already "
+                                              + "been specified as a positional/keyword "
+                                              + "argument to " + intrinsic_name,
+                                          diag::Level::Error,
+                                          diag::Stage::Semantic,
+                                          { diag::Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             this->visit_expr(*x.m_keywords[i].m_value);
@@ -7583,147 +9249,161 @@ public:
         fill_optional_args(intrinsic_name, args, x.base.base.loc);
         for (size_t i = 0; i < min_args; ++i) {
             if (args[i] == nullptr) {
-                std::string missing_name = (i < kwarg_names.size() && !kwarg_names[i].empty()) ? kwarg_names[i] : ("argument(" + std::to_string(i+1) + ")");
-                diag.add(Diagnostic(
-                    "Missing actual argument '" + missing_name + "' in call to '" + intrinsic_name + "'",
-                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                std::string missing_name = (i < kwarg_names.size() && !kwarg_names[i].empty())
+                                               ? kwarg_names[i]
+                                               : ("argument(" + std::to_string(i + 1) + ")");
+                diag.add(Diagnostic("Missing actual argument '" + missing_name + "' in call to '"
+                                        + intrinsic_name + "'",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
         return true;
     }
 
-    int64_t handle_kind(ASR::expr_t* kind) {
-        if( kind == nullptr ) {
+    int64_t handle_kind(ASR::expr_t* kind)
+    {
+        if (kind == nullptr) {
             return compiler_options.po.default_integer_kind;
         }
 
         ASR::expr_t* kind_value = ASRUtils::expr_value(kind);
-        if( kind_value == nullptr ) {
-            diag.add(diag::Diagnostic(
-                "Only Integer literals or expressions "
-                "which reduce to constant Integer are "
-                "accepted as kind parameters.",
-                diag::Level::Error, diag::Stage::Semantic, {
-                    diag::Label("", {kind->base.loc})}));
-                throw SemanticAbort();
+        if (kind_value == nullptr) {
+            diag.add(diag::Diagnostic("Only Integer literals or expressions "
+                                      "which reduce to constant Integer are "
+                                      "accepted as kind parameters.",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { kind->base.loc }) }));
+            throw SemanticAbort();
         }
         return ASR::down_cast<ASR::IntegerConstant_t>(kind_value)->m_n;
     }
 
-    ASR::asr_t* create_ArrayBound(const AST::FuncCallOrArray_t& x, std::string& bound_name) {
+    ASR::asr_t* create_ArrayBound(const AST::FuncCallOrArray_t& x, std::string& bound_name)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"array", "dim", "kind"};
+        std::vector<std::string> kwarg_names = { "array", "dim", "kind" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 3, bound_name);
         ASR::expr_t *v_Var = args[0], *dim = args[1], *kind = args[2];
         ASR::arrayboundType bound = ASR::arrayboundType::LBound;
-        if( bound_name == "lbound" ) {
+        if (bound_name == "lbound") {
             bound = ASR::arrayboundType::LBound;
-        } else if( bound_name == "ubound" ) {
+        } else if (bound_name == "ubound") {
             bound = ASR::arrayboundType::UBound;
         }
         int64_t kind_const = handle_kind(kind);
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_const));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_const));
         ASR::expr_t* bound_value = nullptr;
         if (dim == nullptr) {
             int n_dims = ASRUtils::extract_n_dims_from_ttype(ASRUtils::expr_type(v_Var));
             // For assumed-size arrays (UnboundedPointerArray), ubound requires DIM
-            ASR::ttype_t* v_Var_type = ASRUtils::type_get_past_allocatable_pointer(
-                ASRUtils::expr_type(v_Var));
-            if (bound == ASR::arrayboundType::UBound &&
-                ASR::is_a<ASR::Array_t>(*v_Var_type) &&
-                ASR::down_cast<ASR::Array_t>(v_Var_type)->m_physical_type ==
-                    ASR::array_physical_typeType::UnboundedPointerArray) {
-                diag.add(Diagnostic(
-                    "The DIM argument must be present when calling UBOUND "
-                    "on an assumed-size array",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})}));
+            ASR::ttype_t* v_Var_type
+                = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(v_Var));
+            if (bound == ASR::arrayboundType::UBound && ASR::is_a<ASR::Array_t>(*v_Var_type)
+                && ASR::down_cast<ASR::Array_t>(v_Var_type)->m_physical_type
+                       == ASR::array_physical_typeType::UnboundedPointerArray) {
+                diag.add(Diagnostic("The DIM argument must be present when calling UBOUND "
+                                    "on an assumed-size array",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             Vec<ASR::expr_t*> arr_args;
             arr_args.reserve(al, 0);
-            ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+            ASR::ttype_t* int_type = ASRUtils::TYPE(
+                ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
             for (int i = 1; i <= n_dims; i++) {
-                ASR::expr_t* dim_ = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, i, int_type));
-                arr_args.push_back(al, ASRUtils::EXPR(ASR::make_ArrayBound_t(al, x.base.base.loc, v_Var, dim_, type,
-                                      bound, bound_value)));
+                ASR::expr_t* dim_
+                    = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, i, int_type));
+                arr_args.push_back(
+                    al,
+                    ASRUtils::EXPR(ASR::make_ArrayBound_t(
+                        al, x.base.base.loc, v_Var, dim_, type, bound, bound_value)));
             }
-            return ASRUtils::make_ArrayConstructor_t_util(al, x.base.base.loc, arr_args.p,
-                arr_args.size(), type, ASR::arraystorageType::ColMajor);
-
+            return ASRUtils::make_ArrayConstructor_t_util(al,
+                                                          x.base.base.loc,
+                                                          arr_args.p,
+                                                          arr_args.size(),
+                                                          type,
+                                                          ASR::arraystorageType::ColMajor);
         }
 
         ASR::expr_t* dim_value = ASRUtils::expr_value(dim);
-        if( ASRUtils::is_value_constant(dim_value) ) {
+        if (ASRUtils::is_value_constant(dim_value)) {
             int64_t const_dim = -1;
-            if( !ASRUtils::extract_value(dim_value, const_dim) ) {
+            if (!ASRUtils::extract_value(dim_value, const_dim)) {
                 LCOMPILERS_ASSERT(false);
             }
             ASR::dimension_t* v_Var_dims = nullptr;
-            int v_Var_n_dims = ASRUtils::extract_dimensions_from_ttype(
-                ASRUtils::expr_type(v_Var), v_Var_dims);
-            if( const_dim > v_Var_n_dims || const_dim < 1) {
-                diag.add(Diagnostic(
-                    "Dimension " + std::to_string(const_dim) +
-                    " is invalid. Rank of the array, " +
-                    std::to_string(v_Var_n_dims),
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})}));
+            int v_Var_n_dims
+                = ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(v_Var), v_Var_dims);
+            if (const_dim > v_Var_n_dims || const_dim < 1) {
+                diag.add(Diagnostic("Dimension " + std::to_string(const_dim)
+                                        + " is invalid. Rank of the array, "
+                                        + std::to_string(v_Var_n_dims),
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-            // For assumed-size arrays (UnboundedPointerArray), ubound of the last dimension is undefined
-            ASR::ttype_t* v_Var_type = ASRUtils::type_get_past_allocatable_pointer(
-                ASRUtils::expr_type(v_Var));
-            if (bound == ASR::arrayboundType::UBound &&
-                const_dim == v_Var_n_dims &&
-                ASR::is_a<ASR::Array_t>(*v_Var_type) &&
-                ASR::down_cast<ASR::Array_t>(v_Var_type)->m_physical_type ==
-                    ASR::array_physical_typeType::UnboundedPointerArray) {
-                diag.add(Diagnostic(
-                    "The upper bound of an assumed-size array's last "
-                    "dimension is not defined",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {x.base.base.loc})}));
+            // For assumed-size arrays (UnboundedPointerArray), ubound of the last dimension is
+            // undefined
+            ASR::ttype_t* v_Var_type
+                = ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(v_Var));
+            if (bound == ASR::arrayboundType::UBound && const_dim == v_Var_n_dims
+                && ASR::is_a<ASR::Array_t>(*v_Var_type)
+                && ASR::down_cast<ASR::Array_t>(v_Var_type)->m_physical_type
+                       == ASR::array_physical_typeType::UnboundedPointerArray) {
+                diag.add(Diagnostic("The upper bound of an assumed-size array's last "
+                                    "dimension is not defined",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             const_dim = const_dim - 1;
-            if( v_Var_dims[const_dim].m_start && v_Var_dims[const_dim].m_length ) {
+            if (v_Var_dims[const_dim].m_start && v_Var_dims[const_dim].m_length) {
                 ASR::expr_t* v_Var_start = ASRUtils::expr_value(v_Var_dims[const_dim].m_start);
                 ASR::expr_t* v_Var_length = ASRUtils::expr_value(v_Var_dims[const_dim].m_length);
-                if( bound == ASR::arrayboundType::LBound &&
-                    ASRUtils::is_value_constant(v_Var_start) ) {
+                if (bound == ASR::arrayboundType::LBound
+                    && ASRUtils::is_value_constant(v_Var_start)) {
                     int64_t const_lbound = -1;
-                    if( !ASRUtils::extract_value(v_Var_start, const_lbound) ) {
+                    if (!ASRUtils::extract_value(v_Var_start, const_lbound)) {
                         LCOMPILERS_ASSERT(false);
                     }
-                    bound_value = make_ConstantWithType(make_IntegerConstant_t,
-                                    const_lbound, type, x.base.base.loc);
-                } else if( bound == ASR::arrayboundType::UBound &&
-                ASRUtils::is_value_constant(v_Var_start) &&
-                ASRUtils::is_value_constant(v_Var_length) ) {
+                    bound_value = make_ConstantWithType(
+                        make_IntegerConstant_t, const_lbound, type, x.base.base.loc);
+                } else if (bound == ASR::arrayboundType::UBound
+                           && ASRUtils::is_value_constant(v_Var_start)
+                           && ASRUtils::is_value_constant(v_Var_length)) {
                     int64_t const_lbound = -1;
-                    if( !ASRUtils::extract_value(v_Var_start, const_lbound) ) {
+                    if (!ASRUtils::extract_value(v_Var_start, const_lbound)) {
                         LCOMPILERS_ASSERT(false);
                     }
                     int64_t const_length = -1;
-                    if( !ASRUtils::extract_value(v_Var_length, const_length) ) {
+                    if (!ASRUtils::extract_value(v_Var_length, const_length)) {
                         LCOMPILERS_ASSERT(false);
                     }
                     bound_value = make_ConstantWithType(make_IntegerConstant_t,
-                                    const_lbound + const_length - 1, type, x.base.base.loc);
+                                                        const_lbound + const_length - 1,
+                                                        type,
+                                                        x.base.base.loc);
                 }
             }
         }
-        return ASR::make_ArrayBound_t(al, x.base.base.loc, v_Var, dim, type,
-                                      bound, bound_value);
+        return ASR::make_ArrayBound_t(al, x.base.base.loc, v_Var, dim, type, bound, bound_value);
     }
 
-    ASR::asr_t* create_ArrayRank(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_ArrayRank(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"a"};
+        std::vector<std::string> kwarg_names = { "a" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 1, std::string("rank"));
-        ASR::expr_t *v_Var = args[0];
+        ASR::expr_t* v_Var = args[0];
 
         ASR::ttype_t* integer_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
         int compile_time_rank = -1;
@@ -7741,25 +9421,24 @@ public:
         return ASR::make_ArrayRank_t(al, x.base.base.loc, v_Var, integer_type, rank_value);
     }
 
-    ASR::asr_t* create_ArraySize(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_ArraySize(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"array", "dim", "kind"};
+        std::vector<std::string> kwarg_names = { "array", "dim", "kind" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 3, std::string("size"));
-        ASR::expr_t *v_Var = args[0], *dim = args[1], *kind = args[2];  
+        ASR::expr_t *v_Var = args[0], *dim = args[1], *kind = args[2];
 
         // general check for all arguments other than array
         if (!ASRUtils::is_array(ASRUtils::expr_type(v_Var))) {
-            diag.add(Diagnostic(
-                "Argument of 'size' must be an array",
-                Level::Error, Stage::Semantic, {
-                    Label("", {v_Var->base.loc})
-                }
-            ));
+            diag.add(Diagnostic("Argument of 'size' must be an array",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { v_Var->base.loc }) }));
             throw SemanticAbort();
         }
 
         int64_t kind_const = handle_kind(kind);
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_const));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_const));
         ASR::dimension_t* m_dims = nullptr;
         int n_dims = ASRUtils::extract_dimensions_from_ttype(ASRUtils::expr_type(v_Var), m_dims);
         int64_t compile_time_size = 1;
@@ -7780,39 +9459,45 @@ public:
                 }
             }
         } else {
-            if (n_dims == 0) compile_time_size = -1;
-            for( int i = 0; i < n_dims; i++ ) {
+            if (n_dims == 0)
+                compile_time_size = -1;
+            for (int i = 0; i < n_dims; i++) {
                 ASR::dimension_t m_dim = m_dims[i];
                 ASR::expr_t* length_expr = m_dim.m_length;
                 int64_t length = -1;
                 ASRUtils::extract_value(length_expr, length);
-                if( length == -1 ) {
+                if (length == -1) {
                     compile_time_size = -1;
-                    break ;
+                    break;
                 }
                 compile_time_size *= length;
             }
         }
         ASR::expr_t* size_compiletime = nullptr;
-        if( compile_time_size != -1 ) {
-            size_compiletime = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc,
-                                                compile_time_size, type));
+        if (compile_time_size != -1) {
+            size_compiletime = ASRUtils::EXPR(
+                ASR::make_IntegerConstant_t(al, x.base.base.loc, compile_time_size, type));
         }
-        return ASRUtils::make_ArraySize_t_util(al, x.base.base.loc, v_Var, dim, type, size_compiletime, false);
+        return ASRUtils::make_ArraySize_t_util(
+            al, x.base.base.loc, v_Var, dim, type, size_compiletime, false);
     }
 
-    ASR::asr_t* create_StringLen_from_expr(ASR::expr_t* v, ASR::ttype_t* type, const Location& loc) {
+    ASR::asr_t* create_StringLen_from_expr(ASR::expr_t* v, ASR::ttype_t* type, const Location& loc)
+    {
         ASR::expr_t* len_compiletime = nullptr;
-        if( ASRUtils::is_array(ASRUtils::expr_type(v)) ) {
-            ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(v)));
+        if (ASRUtils::is_array(ASRUtils::expr_type(v))) {
+            ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(
+                ASRUtils::type_get_past_allocatable_pointer(ASRUtils::expr_type(v)));
             ASR::String_t* str = ASR::down_cast<ASR::String_t>(arr->m_type);
             int64_t length;
-            len_compiletime = ASRUtils::extract_value(str->m_len, length) ? 
-            make_ConstantWithType(make_IntegerConstant_t, length, type, loc) : nullptr;
+            len_compiletime = ASRUtils::extract_value(str->m_len, length)
+                                  ? make_ConstantWithType(make_IntegerConstant_t, length, type, loc)
+                                  : nullptr;
             // TODO: If possible try to use m_len of `character(len=m_len)`
             int n_dims = ASRUtils::extract_n_dims_from_ttype(ASRUtils::expr_type(v));
-            Vec<ASR::array_index_t> lbs; lbs.reserve(al, n_dims);
-            for( int i = 0; i < n_dims; i++ ) {
+            Vec<ASR::array_index_t> lbs;
+            lbs.reserve(al, n_dims);
+            for (int i = 0; i < n_dims; i++) {
                 ASR::array_index_t index;
                 index.loc = loc;
                 index.m_left = nullptr;
@@ -7820,24 +9505,32 @@ public:
                 index.m_step = nullptr;
                 lbs.push_back(al, index);
             }
-            v = ASRUtils::EXPR(ASRUtils::make_ArrayItem_t_util(al, loc, v, lbs.p, lbs.size(),
-                    ASRUtils::extract_type(ASRUtils::expr_type(v)),
-                        ASR::arraystorageType::ColMajor, nullptr));
-        } else if(ASR::is_a<ASR::ArrayItem_t>(*v)) {
+            v = ASRUtils::EXPR(
+                ASRUtils::make_ArrayItem_t_util(al,
+                                                loc,
+                                                v,
+                                                lbs.p,
+                                                lbs.size(),
+                                                ASRUtils::extract_type(ASRUtils::expr_type(v)),
+                                                ASR::arraystorageType::ColMajor,
+                                                nullptr));
+        } else if (ASR::is_a<ASR::ArrayItem_t>(*v)) {
             ASR::ArrayItem_t* arr_item = ASR::down_cast<ASR::ArrayItem_t>(v);
             ASR::Var_t* arr_var = ASR::down_cast<ASR::Var_t>(arr_item->m_v);
             ASR::symbol_t* arr_sym = arr_var->m_v;
-            ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(ASRUtils::type_get_past_allocatable_pointer(ASRUtils::symbol_type(arr_sym)));
+            ASR::Array_t* arr = ASR::down_cast<ASR::Array_t>(
+                ASRUtils::type_get_past_allocatable_pointer(ASRUtils::symbol_type(arr_sym)));
             ASR::String_t* str = ASR::down_cast<ASR::String_t>(arr->m_type);
             int length;
-            len_compiletime = ASRUtils::extract_value(str->m_len, length) ? make_ConstantWithType(
-                make_IntegerConstant_t, length, type, loc) : nullptr;
+            len_compiletime = ASRUtils::extract_value(str->m_len, length)
+                                  ? make_ConstantWithType(make_IntegerConstant_t, length, type, loc)
+                                  : nullptr;
         }
 
-        { // Try to get expression's string length (if exist)
+        {  // Try to get expression's string length (if exist)
             ASR::String_t* string_t = ASRUtils::get_string_type(ASRUtils::expr_type(v));
             int64_t len = -1;
-            if( ASRUtils::extract_value(string_t->m_len, len) ) {
+            if (ASRUtils::extract_value(string_t->m_len, len)) {
                 len_compiletime = make_ConstantWithType(make_IntegerConstant_t, len, type, loc);
             } else {
                 len_compiletime = nullptr;
@@ -7846,53 +9539,61 @@ public:
         return ASR::make_StringLen_t(al, loc, v, type, len_compiletime);
     }
 
-    ASR::asr_t* create_StringLen(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_StringLen(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"string", "kind"};
+        std::vector<std::string> kwarg_names = { "string", "kind" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 2, std::string("len"));
         ASR::expr_t *v_var = args[0], *kind = args[1];
         int64_t kind_const = handle_kind(kind);
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_const));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_const));
         return create_StringLen_from_expr(v_var, type, x.base.base.loc);
     }
 
-    ASR::asr_t* create_ArrayReshape(const AST::FuncCallOrArray_t& x) {
-        if( x.n_args + x.n_keywords < 2 || x.n_args + x.n_keywords > 4 ) {
-            diag.add(Diagnostic("reshape expects number at least 2 and at most 4 arguments, got " +
-                                std::to_string(x.n_args + x.n_keywords) + " arguments instead.",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+    ASR::asr_t* create_ArrayReshape(const AST::FuncCallOrArray_t& x)
+    {
+        if (x.n_args + x.n_keywords < 2 || x.n_args + x.n_keywords > 4) {
+            diag.add(Diagnostic("reshape expects number at least 2 and at most 4 arguments, got "
+                                    + std::to_string(x.n_args + x.n_keywords)
+                                    + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         AST::expr_t* source = nullptr;
         AST::expr_t* shape = nullptr;
         AST::expr_t* order = nullptr;
         AST::expr_t* pad = nullptr;
-        if ( x.n_args > 0 ) {
+        if (x.n_args > 0) {
             source = x.m_args[0].m_end;
         }
-        if ( x.n_args > 1 ) {
+        if (x.n_args > 1) {
             shape = x.m_args[1].m_end;
         }
-        if (x.n_args > 2){
+        if (x.n_args > 2) {
             pad = x.m_args[2].m_end;
         }
-        if (x.n_args > 3){
+        if (x.n_args > 3) {
             pad = x.m_args[2].m_end;
             order = x.m_args[3].m_end;
         }
-        for( size_t i=0;i<x.n_keywords;i++ ) {
-            if( to_lower(x.m_keywords[i].m_arg) == "source" ) {
+        for (size_t i = 0; i < x.n_keywords; i++) {
+            if (to_lower(x.m_keywords[i].m_arg) == "source") {
                 source = x.m_keywords[i].m_value;
-            } else if( to_lower(x.m_keywords[i].m_arg) == "shape" ) {
+            } else if (to_lower(x.m_keywords[i].m_arg) == "shape") {
                 shape = x.m_keywords[i].m_value;
-            } else if( to_lower(x.m_keywords[i].m_arg) == "pad" ) {
+            } else if (to_lower(x.m_keywords[i].m_arg) == "pad") {
                 pad = x.m_keywords[i].m_value;
-            } else if( to_lower(x.m_keywords[i].m_arg) == "order" ) {
+            } else if (to_lower(x.m_keywords[i].m_arg) == "order") {
                 order = x.m_keywords[i].m_value;
             } else {
-                diag.add(Diagnostic("Unrecognized keyword argument " +
-                                    std::string(x.m_keywords[1].m_arg) + " passed to reshape.",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                diag.add(Diagnostic("Unrecognized keyword argument "
+                                        + std::string(x.m_keywords[1].m_arg)
+                                        + " passed to reshape.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
@@ -7902,83 +9603,130 @@ public:
         ASR::expr_t* newshape = ASRUtils::EXPR(tmp);
         ASR::expr_t* order_expr = nullptr;
         ASR::expr_t* pad_expr = nullptr;
-        if (order!=nullptr){
+        if (order != nullptr) {
             this->visit_expr(*order);
             order_expr = ASRUtils::EXPR(tmp);
         }
-        if (pad != nullptr){
+        if (pad != nullptr) {
             this->visit_expr(*pad);
             pad_expr = ASRUtils::EXPR(tmp);
         }
-        if( !ASRUtils::is_array(ASRUtils::expr_type(array)) ) {
-            diag.add(Diagnostic("reshape accepts arrays for `source` argument, found " +
-                ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array) +
-                " instead.", Level::Error, Stage::Semantic, {Label("", {array->base.loc})}));
+        if (!ASRUtils::is_array(ASRUtils::expr_type(array))) {
+            diag.add(Diagnostic(
+                "reshape accepts arrays for `source` argument, found "
+                    + ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array)
+                    + " instead.",
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { array->base.loc }) }));
             throw SemanticAbort();
         }
-        if( !ASRUtils::is_array(ASRUtils::expr_type(newshape)) ) {
-            diag.add(Diagnostic("reshape accepts arrays for `shape` argument, found " +
-                ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(newshape), newshape) +
-                " instead.", Level::Error, Stage::Semantic, {Label("", {shape->base.loc})}));
+        if (!ASRUtils::is_array(ASRUtils::expr_type(newshape))) {
+            diag.add(Diagnostic(
+                "reshape accepts arrays for `shape` argument, found "
+                    + ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(newshape), newshape)
+                    + " instead.",
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { shape->base.loc }) }));
             throw SemanticAbort();
         }
         if (order_expr) {
-            if (!ASRUtils::is_array(ASRUtils::expr_type(order_expr))){
-                diag.add(Diagnostic("reshape accepts arrays for `order` argument, found " +
-                    ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(order_expr), order_expr) +
-                    " instead.", Level::Error, Stage::Semantic, {Label("", {order->base.loc})}));
+            if (!ASRUtils::is_array(ASRUtils::expr_type(order_expr))) {
+                diag.add(Diagnostic("reshape accepts arrays for `order` argument, found "
+                                        + ASRUtils::type_to_str_fortran_expr(
+                                            ASRUtils::expr_type(order_expr), order_expr)
+                                        + " instead.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { order->base.loc }) }));
                 throw SemanticAbort();
             }
         }
         if (pad_expr) {
-            if (!ASRUtils::is_array(ASRUtils::expr_type(pad_expr))){
-                diag.add(Diagnostic("reshape accepts arrays for `pad` argument, found " +
-                    ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(pad_expr), pad_expr) +
-                    " instead.", Level::Error, Stage::Semantic, {Label("", {pad->base.loc})}));
+            if (!ASRUtils::is_array(ASRUtils::expr_type(pad_expr))) {
+                diag.add(Diagnostic("reshape accepts arrays for `pad` argument, found "
+                                        + ASRUtils::type_to_str_fortran_expr(
+                                            ASRUtils::expr_type(pad_expr), pad_expr)
+                                        + " instead.",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { pad->base.loc }) }));
                 throw SemanticAbort();
-            } else if ( (ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(pad_expr), pad_expr) != ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array))||
-            (ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(pad_expr)) != ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(array))) ){
-                diag.add(Diagnostic("`pad` argument of reshape intrinsic must have same type and kind as `source` argument, found pad type " +
-                    ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(pad_expr), pad_expr) + " and kind " + std::to_string(ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(pad_expr)))
-                     + " source type " + ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array) + " and kind " + std::to_string(ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(array))) +
-                    " instead.", Level::Error, Stage::Semantic, {Label("", {pad->base.loc})}));
+            } else if ((ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(pad_expr), pad_expr)
+                        != ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array))
+                       || (ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(pad_expr))
+                           != ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(array)))) {
+                diag.add(Diagnostic(
+                    "`pad` argument of reshape intrinsic must have same type and kind as `source` argument, found pad type "
+                        + ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(pad_expr),
+                                                             pad_expr)
+                        + " and kind "
+                        + std::to_string(
+                            ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(pad_expr)))
+                        + " source type "
+                        + ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array)
+                        + " and kind "
+                        + std::to_string(
+                            ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(array)))
+                        + " instead.",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { pad->base.loc }) }));
                 throw SemanticAbort();
             }
         }
         if (ASRUtils::is_assumed_rank_array(ASRUtils::expr_type(array))) {
             ASR::Variable_t* var = ASRUtils::EXPR2VAR(array);
             if (assumed_rank_arrays.find(var->m_name) == assumed_rank_arrays.end()) {
-                diag.add(Diagnostic("Assumed rank arrays cannot be used as `source` argument to reshape intrinsic",
-                                    Level::Error, Stage::Semantic, {Label("", {array->base.loc})}));
+                diag.add(Diagnostic(
+                    "Assumed rank arrays cannot be used as `source` argument to reshape intrinsic",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { array->base.loc }) }));
                 throw SemanticAbort();
             } else {
                 int rank = assumed_rank_arrays[var->m_name];
-                ASR::ttype_t* array_type = ASRUtils::create_array_type_with_empty_dims(al, rank, 
-                                                ASRUtils::extract_type(ASRUtils::expr_type(array)));
+                ASR::ttype_t* array_type = ASRUtils::create_array_type_with_empty_dims(
+                    al, rank, ASRUtils::extract_type(ASRUtils::expr_type(array)));
                 array = ASRUtils::EXPR(ASRUtils::make_ArrayPhysicalCast_t_util(
-                    al, array->base.loc, array, ASR::array_physical_typeType::AssumedRankArray,
-                    ASR::array_physical_typeType::DescriptorArray, array_type, nullptr
-                ));
+                    al,
+                    array->base.loc,
+                    array,
+                    ASR::array_physical_typeType::AssumedRankArray,
+                    ASR::array_physical_typeType::DescriptorArray,
+                    array_type,
+                    nullptr));
             }
         }
-        ASR::array_physical_typeType array_physical_type = ASRUtils::extract_physical_type(
-                                                            ASRUtils::expr_type(array));
+        ASR::array_physical_typeType array_physical_type
+            = ASRUtils::extract_physical_type(ASRUtils::expr_type(array));
         ASR::ttype_t* shape_type = ASRUtils::expr_type(newshape);
-        ASR::array_physical_typeType shape_physical_type = ASRUtils::extract_physical_type(shape_type);
-        if (shape_physical_type != ASR::array_physical_typeType::FixedSizeArray){
+        ASR::array_physical_typeType shape_physical_type
+            = ASRUtils::extract_physical_type(shape_type);
+        if (shape_physical_type != ASR::array_physical_typeType::FixedSizeArray) {
             diag.add(Diagnostic("`shape` array in reshape intrinsic should be of constant size",
-                            Level::Error, Stage::Semantic, {Label("not a constant size array", {newshape->base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("not a constant size array", { newshape->base.loc }) }));
             throw SemanticAbort();
         }
         // the size (i.e. number of elements) of 'newshape' array determines
         // the dimension size of 'ArrayReshape'
-        ASR::Array_t* newshape_array_type = ASR::down_cast<ASR::Array_t>(ASRUtils::expr_type(newshape));
+        ASR::Array_t* newshape_array_type
+            = ASR::down_cast<ASR::Array_t>(ASRUtils::expr_type(newshape));
         LCOMPILERS_ASSERT_MSG(newshape_array_type->n_dims == 1, "newshape must be a 1D array");
-        size_t newshape_dims = ASR::down_cast<ASR::IntegerConstant_t>(newshape_array_type->m_dims[0].m_length)->m_n;
+        size_t newshape_dims
+            = ASR::down_cast<ASR::IntegerConstant_t>(newshape_array_type->m_dims[0].m_length)->m_n;
         ASR::ttype_t* arr_element_type = ASRUtils::extract_type(ASRUtils::expr_type(array));
 
-        ASR::ttype_t* reshape_ttype = ASRUtils::TYPE(ASR::make_Array_t(al, arr_element_type->base.loc, arr_element_type,
-                                                    nullptr, newshape_dims, ASR::array_physical_typeType::FixedSizeArray));
+        ASR::ttype_t* reshape_ttype
+            = ASRUtils::TYPE(ASR::make_Array_t(al,
+                                               arr_element_type->base.loc,
+                                               arr_element_type,
+                                               nullptr,
+                                               newshape_dims,
+                                               ASR::array_physical_typeType::FixedSizeArray));
 
         size_t n_dims_array_reshape = ASRUtils::extract_n_dims_from_ttype(reshape_ttype);
 
@@ -7986,8 +9734,8 @@ public:
         dims.reserve(al, n_dims_array_reshape);
 
         Location loc = newshape->base.loc;
-        if (ASR::is_a<ASR::ArrayConstructor_t>(*newshape) &&
-            ASR::down_cast<ASR::ArrayConstructor_t>(newshape)->m_value != nullptr) {
+        if (ASR::is_a<ASR::ArrayConstructor_t>(*newshape)
+            && ASR::down_cast<ASR::ArrayConstructor_t>(newshape)->m_value != nullptr) {
             newshape = ASR::down_cast<ASR::ArrayConstructor_t>(newshape)->m_value;
         }
 
@@ -7997,7 +9745,7 @@ public:
             ASR::ArrayConstant_t* const_newshape = ASR::down_cast<ASR::ArrayConstant_t>(newshape);
             ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4));
             int new_shape_size = 1;
-            for (size_t i=0; i < n_dims_array_reshape; i++) {
+            for (size_t i = 0; i < n_dims_array_reshape; i++) {
                 ASR::dimension_t dim;
                 dim.loc = loc;
                 dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1, int_type));
@@ -8006,131 +9754,177 @@ public:
                 new_shape_size *= ASR::down_cast<ASR::IntegerConstant_t>(dim.m_length)->m_n;
             }
             int64_t array_size = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(array));
-            if (array_size != -1 &&  new_shape_size > array_size) {
-                if (!pad){
-                    diag.add(Diagnostic("reshape accepts `source` array with size greater than or equal to size specified by `shape` array",
-                                        Level::Error, Stage::Semantic, {Label("`shape` specifies size of " +
-                                        std::to_string(new_shape_size) + " which exceeds the `source` array size of " +
-                                        std::to_string(array_size), {x.base.base.loc})}));
+            if (array_size != -1 && new_shape_size > array_size) {
+                if (!pad) {
+                    diag.add(Diagnostic(
+                        "reshape accepts `source` array with size greater than or equal to size specified by `shape` array",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("`shape` specifies size of " + std::to_string(new_shape_size)
+                                    + " which exceeds the `source` array size of "
+                                    + std::to_string(array_size),
+                                { x.base.base.loc }) }));
                     throw SemanticAbort();
-                } else if ( ASR::is_a<ASR::ArrayConstant_t>(*pad_expr) ) {
-                    if ( ASR::is_a<ASR::ArrayConstant_t>(*array) ) {
+                } else if (ASR::is_a<ASR::ArrayConstant_t>(*pad_expr)) {
+                    if (ASR::is_a<ASR::ArrayConstant_t>(*array)) {
                         ASR::ttype_t* a_type = ASRUtils::expr_type(array);
                         a_type = ASRUtils::type_get_past_pointer(a_type);
                         ASR::Array_t* a_type_ = ASR::down_cast<ASR::Array_t>(a_type);
                         Vec<ASR::expr_t*> elements;
                         elements.reserve(al, array_size);
-                        ASR::ArrayConstant_t* const_array = ASR::down_cast<ASR::ArrayConstant_t>(array);
-                        ASR::ArrayConstant_t* const_pad = ASR::down_cast<ASR::ArrayConstant_t>(pad_expr);
+                        ASR::ArrayConstant_t* const_array
+                            = ASR::down_cast<ASR::ArrayConstant_t>(array);
+                        ASR::ArrayConstant_t* const_pad
+                            = ASR::down_cast<ASR::ArrayConstant_t>(pad_expr);
                         for (int i = 0; i < array_size; i++) {
-                            elements.push_back(al, ASRUtils::fetch_ArrayConstant_value(al, const_array, i));
+                            elements.push_back(
+                                al, ASRUtils::fetch_ArrayConstant_value(al, const_array, i));
                         }
                         int64_t diff = new_shape_size - array_size;
-                        int pad_size = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(pad_expr));
+                        int pad_size
+                            = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(pad_expr));
                         for (int i = 0; i < diff; i++) {
-                            elements.push_back(al, ASRUtils::fetch_ArrayConstant_value(al, const_pad, i % pad_size));
+                            elements.push_back(
+                                al,
+                                ASRUtils::fetch_ArrayConstant_value(al, const_pad, i % pad_size));
                         }
                         size_t curr_idx = elements.size();
-                        ASR::ttype_t* new_type = ASRUtils::TYPE(
-                            ASR::make_Array_t(al, a_type_->base.base.loc, a_type_->m_type, dims.p, dims.n,
-                                            a_type_->m_physical_type)
-                        );
-                        void *data = ASRUtils::set_ArrayConstant_data(elements.p, curr_idx, a_type_->m_type);
-                        int64_t n_data = curr_idx * ASRUtils::extract_kind_from_ttype_t(a_type_->m_type);
+                        ASR::ttype_t* new_type
+                            = ASRUtils::TYPE(ASR::make_Array_t(al,
+                                                               a_type_->base.base.loc,
+                                                               a_type_->m_type,
+                                                               dims.p,
+                                                               dims.n,
+                                                               a_type_->m_physical_type));
+                        void* data = ASRUtils::set_ArrayConstant_data(
+                            elements.p, curr_idx, a_type_->m_type);
+                        int64_t n_data
+                            = curr_idx * ASRUtils::extract_kind_from_ttype_t(a_type_->m_type);
                         if (ASRUtils::is_character(*a_type_->m_type)) {
                             int64_t len;
-                            if(!ASRUtils::extract_value(ASR::down_cast<ASR::String_t>(a_type_->m_type)->m_len, len)){LCOMPILERS_ASSERT(false);}
+                            if (!ASRUtils::extract_value(
+                                    ASR::down_cast<ASR::String_t>(a_type_->m_type)->m_len, len)) {
+                                LCOMPILERS_ASSERT(false);
+                            }
                             n_data = curr_idx * len;
                         }
-                        array = ASRUtils::EXPR(
-                            ASR::make_ArrayConstant_t(al, loc, n_data, data, new_type,
-                                                    ASR::arraystorageType::ColMajor)
-                        );
+                        array = ASRUtils::EXPR(ASR::make_ArrayConstant_t(
+                            al, loc, n_data, data, new_type, ASR::arraystorageType::ColMajor));
                     }
                 }
             }
-            if (order_expr && ASR::is_a<ASR::ArrayConstant_t>(*order_expr)){
-                ASR::ArrayConstant_t* const_order = ASR::down_cast<ASR::ArrayConstant_t>(order_expr);
+            if (order_expr && ASR::is_a<ASR::ArrayConstant_t>(*order_expr)) {
+                ASR::ArrayConstant_t* const_order
+                    = ASR::down_cast<ASR::ArrayConstant_t>(order_expr);
                 std::vector<int> elements;
                 int64_t n = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(order_expr));
-                for (int64_t i=0; i <  n; i++) {
-                    if (ASR::is_a<ASR::IntegerConstant_t>(*ASRUtils::fetch_ArrayConstant_value(al, const_order, i))){
-                        elements.push_back(ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_order, i))->m_n);
+                for (int64_t i = 0; i < n; i++) {
+                    if (ASR::is_a<ASR::IntegerConstant_t>(
+                            *ASRUtils::fetch_ArrayConstant_value(al, const_order, i))) {
+                        elements.push_back(
+                            ASR::down_cast<ASR::IntegerConstant_t>(
+                                ASRUtils::fetch_ArrayConstant_value(al, const_order, i))
+                                ->m_n);
                     } else {
                         diag.add(Diagnostic("reshape accepts `order` array with integer elements",
-                                            Level::Error, Stage::Semantic, {Label("", {order->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { order->base.loc }) }));
                         throw SemanticAbort();
                     }
                 }
                 std::set<int> unique_elements(elements.begin(), elements.end());
-                for (int i=1; i<=n; i++){
-                    if (unique_elements.find(i) == unique_elements.end()){
-                        diag.add(Diagnostic("reshape accepts `order` array as a permutation of elements from 1 to " + std::to_string(n),
-                                            Level::Error, Stage::Semantic, {Label("", {order->base.loc})}));
+                for (int i = 1; i <= n; i++) {
+                    if (unique_elements.find(i) == unique_elements.end()) {
+                        diag.add(Diagnostic(
+                            "reshape accepts `order` array as a permutation of elements from 1 to "
+                                + std::to_string(n),
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { order->base.loc }) }));
                         throw SemanticAbort();
                     }
                 }
-                if (ASR::is_a<ASR::ArrayConstant_t>(*array) && ASR::is_a<ASR::ArrayConstant_t>(*newshape)){
+                if (ASR::is_a<ASR::ArrayConstant_t>(*array)
+                    && ASR::is_a<ASR::ArrayConstant_t>(*newshape)) {
                     ASR::ttype_t* a_type = ASRUtils::expr_type(array);
                     a_type = ASRUtils::type_get_past_pointer(a_type);
                     ASR::Array_t* a_type_ = ASR::down_cast<ASR::Array_t>(a_type);
                     Vec<ASR::expr_t*> elements_;
                     elements_.reserve(al, array_size);
                     ASR::ArrayConstant_t* const_array = ASR::down_cast<ASR::ArrayConstant_t>(array);
-                    ASR::ArrayConstant_t* const_shape = ASR::down_cast<ASR::ArrayConstant_t>(newshape);
-                    int64_t array_size = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(array));
+                    ASR::ArrayConstant_t* const_shape
+                        = ASR::down_cast<ASR::ArrayConstant_t>(newshape);
+                    int64_t array_size
+                        = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(array));
                     std::map<int, int> index_map;
-                    for (int i=0; i<array_size; i++){
+                    for (int i = 0; i < array_size; i++) {
                         int temp = i;
                         std::vector<int> d(n, 0);
-                        for (int j=0; j<n; j++){
-                            int dim = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_order, j))->m_n - 1;
-                            int shape_dim = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_shape, dim))->m_n;
+                        for (int j = 0; j < n; j++) {
+                            int dim = ASR::down_cast<ASR::IntegerConstant_t>(
+                                          ASRUtils::fetch_ArrayConstant_value(al, const_order, j))
+                                          ->m_n
+                                      - 1;
+                            int shape_dim
+                                = ASR::down_cast<ASR::IntegerConstant_t>(
+                                      ASRUtils::fetch_ArrayConstant_value(al, const_shape, dim))
+                                      ->m_n;
                             d[j] = temp % shape_dim;
                             temp = temp / shape_dim;
                         }
                         std::vector<int> I(n, 0);
-                        for(int j=0; j<n; j++){
-                            int order_ = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_order, j))->m_n - 1;
+                        for (int j = 0; j < n; j++) {
+                            int order_
+                                = ASR::down_cast<ASR::IntegerConstant_t>(
+                                      ASRUtils::fetch_ArrayConstant_value(al, const_order, j))
+                                      ->m_n
+                                  - 1;
                             I[order_] = d[j];
                         }
 
                         int R = 0, stride = 1;
-                        for (int j=0; j<n; j++){
+                        for (int j = 0; j < n; j++) {
                             R += I[j] * stride;
-                            stride *= ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_shape, j))->m_n;
+                            stride *= ASR::down_cast<ASR::IntegerConstant_t>(
+                                          ASRUtils::fetch_ArrayConstant_value(al, const_shape, j))
+                                          ->m_n;
                         }
                         index_map[R] = i;
                     }
-                    for (int i=0; i<array_size; i++){
-                        elements_.push_back(al, ASRUtils::fetch_ArrayConstant_value(al, const_array, index_map[i]));
+                    for (int i = 0; i < array_size; i++) {
+                        elements_.push_back(
+                            al, ASRUtils::fetch_ArrayConstant_value(al, const_array, index_map[i]));
                     }
 
                     size_t curr_idx = elements_.size();
-                    ASR::ttype_t* new_type = ASRUtils::TYPE(
-                        ASR::make_Array_t(al, a_type_->base.base.loc, a_type_->m_type, dims.p, dims.n,
-                                        a_type_->m_physical_type)
-                    );
-                    void *data = ASRUtils::set_ArrayConstant_data(elements_.p, curr_idx, a_type_->m_type);
-                    int64_t n_data = curr_idx * ASRUtils::extract_kind_from_ttype_t(a_type_->m_type);
+                    ASR::ttype_t* new_type
+                        = ASRUtils::TYPE(ASR::make_Array_t(al,
+                                                           a_type_->base.base.loc,
+                                                           a_type_->m_type,
+                                                           dims.p,
+                                                           dims.n,
+                                                           a_type_->m_physical_type));
+                    void* data
+                        = ASRUtils::set_ArrayConstant_data(elements_.p, curr_idx, a_type_->m_type);
+                    int64_t n_data
+                        = curr_idx * ASRUtils::extract_kind_from_ttype_t(a_type_->m_type);
                     if (ASRUtils::is_character(*a_type_->m_type)) {
                         int64_t len;
-                        if(!ASRUtils::extract_value(
-                            ASR::down_cast<ASR::String_t>(a_type_->m_type)->m_len, len)){
+                        if (!ASRUtils::extract_value(
+                                ASR::down_cast<ASR::String_t>(a_type_->m_type)->m_len, len)) {
                             LCOMPILERS_ASSERT_MSG(false, "String length should be a constant");
                         }
                         n_data = curr_idx * len;
                     }
-                    array = ASRUtils::EXPR(
-                        ASR::make_ArrayConstant_t(al, loc, n_data, data, new_type,
-                                                ASR::arraystorageType::ColMajor)
-                    );
+                    array = ASRUtils::EXPR(ASR::make_ArrayConstant_t(
+                        al, loc, n_data, data, new_type, ASR::arraystorageType::ColMajor));
                 }
             }
         } else {
             // otherwise empty dimensions
             dims.reserve(al, n_dims_array_reshape);
-            for (size_t i=0; i < n_dims_array_reshape; i++) {
+            for (size_t i = 0; i < n_dims_array_reshape; i++) {
                 ASR::dimension_t dim;
                 dim.loc = loc;
                 dim.m_start = nullptr;
@@ -8139,11 +9933,14 @@ public:
             }
         }
 
-        reshape_ttype = ASRUtils::duplicate_type(al, reshape_ttype, &dims, array_physical_type, true);
+        reshape_ttype
+            = ASRUtils::duplicate_type(al, reshape_ttype, &dims, array_physical_type, true);
         newshape = ASRUtils::cast_to_descriptor(al, newshape);
-        // Compile time value is same as the "source" ArrayConstant with multi-dimensional type instead of 1-D
+        // Compile time value is same as the "source" ArrayConstant with multi-dimensional type
+        // instead of 1-D
         ASR::expr_t* value = nullptr;
-        if (ASR::is_a<ASR::ArrayConstant_t>(*array) && ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::get_past_array_physical_cast(newshape))) {
+        if (ASR::is_a<ASR::ArrayConstant_t>(*array)
+            && ASR::is_a<ASR::ArrayConstant_t>(*ASRUtils::get_past_array_physical_cast(newshape))) {
             ASRUtils::ExprStmtDuplicator dup(al);
             value = dup.duplicate_expr(array);
             ASR::down_cast<ASR::ArrayConstant_t>(value)->m_type = reshape_ttype;
@@ -8151,11 +9948,14 @@ public:
         return ASR::make_ArrayReshape_t(al, x.base.base.loc, array, newshape, reshape_ttype, value);
     }
 
-    ASR::asr_t* create_ArrayIsContiguous(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_ArrayIsContiguous(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_args != 1 || x.n_keywords > 0) {
-            diag.add(Diagnostic("is_contiguous expects exactly one array argument, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("is_contiguous expects exactly one array argument, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
@@ -8163,22 +9963,29 @@ public:
         this->visit_expr(*source);
         ASR::expr_t* array = ASRUtils::EXPR(tmp);
         if (!ASRUtils::is_array(ASRUtils::expr_type(array))) {
-            diag.add(Diagnostic("is_contiguous expects an array argument, found " +
-                                ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array) + " instead.",
-                                Level::Error, Stage::Semantic, {Label("", {array->base.loc})}));
+            diag.add(Diagnostic(
+                "is_contiguous expects an array argument, found "
+                    + ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(array), array)
+                    + " instead.",
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { array->base.loc }) }));
             throw SemanticAbort();
         }
 
-        ASR::ttype_t* a_type = ASRUtils::TYPE(ASR::make_Logical_t(
-                                            al, x.base.base.loc, compiler_options.po.default_integer_kind));
+        ASR::ttype_t* a_type = ASRUtils::TYPE(
+            ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
         return ASR::make_ArrayIsContiguous_t(al, x.base.base.loc, array, a_type, nullptr);
     }
 
-    ASR::asr_t* create_unsigned_const(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_unsigned_const(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_args != 1 || x.n_keywords > 0) {
-            diag.add(Diagnostic("_lfortran_unsigned expects exactly one argument, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("_lfortran_unsigned expects exactly one argument, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
 
             throw SemanticAbort();
         }
@@ -8189,25 +9996,34 @@ public:
         ASR::ttype_t* type = ASRUtils::expr_type(arg);
 
         if (ASR::is_a<ASR::Integer_t>(*type)) {
-            return ASRUtils::make_Cast_t_value(al, x.base.base.loc, arg, 
-                                ASR::cast_kindType::IntegerToUnsignedInteger, ASRUtils::TYPE(
-                                ASR::make_UnsignedInteger_t(al, x.base.base.loc, 4)));
+            return ASRUtils::make_Cast_t_value(
+                al,
+                x.base.base.loc,
+                arg,
+                ASR::cast_kindType::IntegerToUnsignedInteger,
+                ASRUtils::TYPE(ASR::make_UnsignedInteger_t(al, x.base.base.loc, 4)));
         } else if (ASR::is_a<ASR::UnsignedInteger_t>(*type)) {
             return (ASR::asr_t*) arg;
         } else {
-            std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(arg), arg);
-            diag.add(Diagnostic("Argument of type '" + arg_type_str + "' for _lfortran_unsigned is not supported yet",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            std::string arg_type_str
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(arg), arg);
+            diag.add(Diagnostic("Argument of type '" + arg_type_str
+                                    + "' for _lfortran_unsigned is not supported yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-
     }
 
-    ASR::asr_t* create_Len(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_Len(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_args != 1 || x.n_keywords > 0) {
-            diag.add(Diagnostic("_lfortran_len expects exactly one argument, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("_lfortran_len expects exactly one argument, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
 
             throw SemanticAbort();
         }
@@ -8216,93 +10032,127 @@ public:
         this->visit_expr(*source);
         ASR::expr_t* arg = ASRUtils::EXPR(tmp);
 
-        if (ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(arg))) 
-            return ASR::make_ListLen_t(al, x.base.base.loc, arg, 
-                                 ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)), nullptr);
+        if (ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(arg)))
+            return ASR::make_ListLen_t(al,
+                                       x.base.base.loc,
+                                       arg,
+                                       ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)),
+                                       nullptr);
         else if (ASR::is_a<ASR::Set_t>(*ASRUtils::expr_type(arg)))
-            return ASR::make_SetLen_t(al, x.base.base.loc, arg, 
-                                 ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)), nullptr);
+            return ASR::make_SetLen_t(al,
+                                      x.base.base.loc,
+                                      arg,
+                                      ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)),
+                                      nullptr);
         else if (ASR::is_a<ASR::Dict_t>(*ASRUtils::expr_type(arg)))
-            return ASR::make_DictLen_t(al, x.base.base.loc, arg, 
-                                 ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)), nullptr);
+            return ASR::make_DictLen_t(al,
+                                       x.base.base.loc,
+                                       arg,
+                                       ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)),
+                                       nullptr);
         else {
-            std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(arg), arg);
-            diag.add(Diagnostic("Argument of type '" + arg_type_str + "' for _lfortran_len has not been implemented yet",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            std::string arg_type_str
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(arg), arg);
+            diag.add(Diagnostic("Argument of type '" + arg_type_str
+                                    + "' for _lfortran_len has not been implemented yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
-    ASR::asr_t* create_GetItem(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_GetItem(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_args != 2 || x.n_keywords > 0) {
-            diag.add(Diagnostic("_lfortran_get_item expects exactly two arguments, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("_lfortran_get_item expects exactly two arguments, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
 
             throw SemanticAbort();
         }
-        
-        Vec<ASR::expr_t *> args;
+
+        Vec<ASR::expr_t*> args;
         args.reserve(al, 2);
 
-        for (int i=0;i<2;i++){
+        for (int i = 0; i < 2; i++) {
             AST::expr_t* source = x.m_args[i].m_end;
             this->visit_expr(*source);
             args.push_back(al, ASRUtils::EXPR(tmp));
-        }   
+        }
 
         if (ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-
             if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(args[1]))) {
-                std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), args[1]);
+                std::string arg_type_str
+                    = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), args[1]);
                 diag.add(Diagnostic("Index of a list must be an integer not '" + arg_type_str + "'",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
 
                 throw SemanticAbort();
             }
 
-            ASR::expr_t *index = ASRUtils::EXPR(tmp);
+            ASR::expr_t* index = ASRUtils::EXPR(tmp);
             ASR::expr_t* val = ASRUtils::expr_value(index);
             if (val && ASR::is_a<ASR::IntegerConstant_t>(*val)) {
                 if (ASR::down_cast<ASR::IntegerConstant_t>(val)->m_n < 0) {
                     // Replace `x[-1]` to `x[len(x)+(-1)]`
-                    ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(
-                                                    al, x.base.base.loc, 4));
-                    ASR::expr_t *list_len = ASRUtils::EXPR(ASR::make_ListLen_t(
-                                al, x.base.base.loc, args[0], int_type, nullptr));
-                    ASR::expr_t *neg_idx = ASRUtils::expr_value(index);
-                    index = ASRUtils::EXPR(ASR::make_IntegerBinOp_t(al, x.base.base.loc,
-                        list_len, ASR::binopType::Add, neg_idx, int_type, nullptr));
-                }
-            }
-            return ASR::make_ListItem_t(al, x.base.base.loc, args[0], index,
-                                        ASRUtils::get_contained_type(ASRUtils::expr_type(args[0])), nullptr);
+                    ASR::ttype_t* int_type
+                        = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
+                    ASR::expr_t* list_len = ASRUtils::EXPR(
+                        ASR::make_ListLen_t(al, x.base.base.loc, args[0], int_type, nullptr));
+                    ASR::expr_t* neg_idx = ASRUtils::expr_value(index);
+                    index = ASRUtils::EXPR(ASR::make_IntegerBinOp_t(al,
+                                                                    x.base.base.loc,
+                                                                    list_len,
+                                                                    ASR::binopType::Add,
+                                                                    neg_idx,
+                                                                    int_type,
+                                                                    nullptr));
+                }
+            }
+            return ASR::make_ListItem_t(al,
+                                        x.base.base.loc,
+                                        args[0],
+                                        index,
+                                        ASRUtils::get_contained_type(ASRUtils::expr_type(args[0])),
+                                        nullptr);
         } else if (ASR::is_a<ASR::Dict_t>(*ASRUtils::expr_type(args[0]))) {
             ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(ASRUtils::expr_type(args[0]));
             ASR::ttype_t* key_type = dict_type->m_key_type;
-            if (!ASRUtils::check_equal_type(ASRUtils::expr_type(args[1]), key_type, nullptr, nullptr)) {
-                std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(key_type, nullptr);
-                std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
+            if (!ASRUtils::check_equal_type(
+                    ASRUtils::expr_type(args[1]), key_type, nullptr, nullptr)) {
+                std::string contained_type_str
+                    = ASRUtils::type_to_str_fortran_expr(key_type, nullptr);
+                std::string arg_type_str
+                    = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
                 diag.add(Diagnostic(
                     "Type mismatch in '_lfortran_get_item', the key types must be compatible",
-                    Level::Error, Stage::Semantic, {
-                        Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                + contained_type_str + "')",
+                            { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
 
-            return ASR::make_DictItem_t(al, x.base.base.loc, args[0], args[1], nullptr, dict_type->m_value_type, nullptr);
+            return ASR::make_DictItem_t(
+                al, x.base.base.loc, args[0], args[1], nullptr, dict_type->m_value_type, nullptr);
         } else if (ASR::is_a<ASR::Tuple_t>(*ASRUtils::expr_type(args[0]))) {
-
             ASR::expr_t *value = ASRUtils::expr_value(args[1]), *index_expr = args[1];
-            ASR::Tuple_t *tuple_type = ASR::down_cast<ASR::Tuple_t>(ASRUtils::expr_type(args[0]));
+            ASR::Tuple_t* tuple_type = ASR::down_cast<ASR::Tuple_t>(ASRUtils::expr_type(args[0]));
             int index;
 
             if (!value) {
-                std::string type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
+                std::string type_str
+                    = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
                 diag.add(Diagnostic("Runtime indexing with type '" + type_str + "' is not possible",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
 
                 throw SemanticAbort();
             }
@@ -8310,155 +10160,193 @@ public:
 
             if (!ASR::is_a<ASR::IntegerConstant_t>(*value)) {
                 diag.add(Diagnostic("Tuple indices must be of constant integers",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
 
                 throw SemanticAbort();
             }
 
 
             index = ASR::down_cast<ASR::IntegerConstant_t>(value)->m_n;
-            int tuple_size =  tuple_type->n_type;
+            int tuple_size = tuple_type->n_type;
             if (index < 0) {
                 index = tuple_size + index;
-                ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, value->base.loc, 4));
-                index_expr = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
-                    al, value->base.loc, index, int_type));
+                ASR::ttype_t* int_type
+                    = ASRUtils::TYPE(ASR::make_Integer_t(al, value->base.loc, 4));
+                index_expr = ASRUtils::EXPR(
+                    ASR::make_IntegerConstant_t(al, value->base.loc, index, int_type));
             }
             if (index >= tuple_size || index < 0) {
                 diag.add(Diagnostic("Tuple index out of bounds",
-                                    Level::Error, Stage::Semantic, {Label("", {value->base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { value->base.loc }) }));
 
                 throw SemanticAbort();
             }
 
 
-            return ASR::make_TupleItem_t(al, x.base.base.loc, args[0], index_expr, tuple_type->m_type[index], nullptr);
+            return ASR::make_TupleItem_t(
+                al, x.base.base.loc, args[0], index_expr, tuple_type->m_type[index], nullptr);
         } else {
-            std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
-            diag.add(Diagnostic("Argument of type '" + arg_type_str + "' for _lfortran_get_item has not been implemented yet",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            std::string arg_type_str
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
+            diag.add(Diagnostic("Argument of type '" + arg_type_str
+                                    + "' for _lfortran_get_item has not been implemented yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
-    ASR::asr_t* create_Pop(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_Pop(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_args != 2 || x.n_keywords > 0) {
-            diag.add(Diagnostic("_lfortran_pop expects exactly two arguments, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("_lfortran_pop expects exactly two arguments, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
 
             throw SemanticAbort();
         }
-        
-        Vec<ASR::expr_t *> args;
+
+        Vec<ASR::expr_t*> args;
         args.reserve(al, 2);
 
-        for (int i=0;i<2;i++){
+        for (int i = 0; i < 2; i++) {
             AST::expr_t* source = x.m_args[i].m_end;
             this->visit_expr(*source);
             args.push_back(al, ASRUtils::EXPR(tmp));
-        }   
+        }
 
         if (ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(args[0]))) {
-
             if (!ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(args[1]))) {
-                std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
+                std::string arg_type_str
+                    = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
                 diag.add(Diagnostic("Index of a list must be an integer not '" + arg_type_str + "'",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
 
                 throw SemanticAbort();
             }
 
-            ASR::expr_t *index = ASRUtils::EXPR(tmp);
+            ASR::expr_t* index = ASRUtils::EXPR(tmp);
             ASR::expr_t* val = ASRUtils::expr_value(index);
             if (val && ASR::is_a<ASR::IntegerConstant_t>(*val)) {
                 if (ASR::down_cast<ASR::IntegerConstant_t>(val)->m_n < 0) {
                     // Replace `x[-1]` to `x[len(x)+(-1)]`
-                    ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(
-                                                    al, x.base.base.loc, 4));
-                    ASR::expr_t *list_len = ASRUtils::EXPR(ASR::make_ListLen_t(
-                                al, x.base.base.loc, args[0], int_type, nullptr));
-                    ASR::expr_t *neg_idx = ASRUtils::expr_value(index);
-                    index = ASRUtils::EXPR(ASR::make_IntegerBinOp_t(al, x.base.base.loc,
-                        list_len, ASR::binopType::Add, neg_idx, int_type, nullptr));
-                }
-            }
-
-            ASRUtils::create_intrinsic_function create_function =
-                ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("list.pop");
+                    ASR::ttype_t* int_type
+                        = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
+                    ASR::expr_t* list_len = ASRUtils::EXPR(
+                        ASR::make_ListLen_t(al, x.base.base.loc, args[0], int_type, nullptr));
+                    ASR::expr_t* neg_idx = ASRUtils::expr_value(index);
+                    index = ASRUtils::EXPR(ASR::make_IntegerBinOp_t(al,
+                                                                    x.base.base.loc,
+                                                                    list_len,
+                                                                    ASR::binopType::Add,
+                                                                    neg_idx,
+                                                                    int_type,
+                                                                    nullptr));
+                }
+            }
+
+            ASRUtils::create_intrinsic_function create_function
+                = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("list.pop");
             return create_function(al, x.base.base.loc, args, diag);
         } else if (ASR::is_a<ASR::Dict_t>(*ASRUtils::expr_type(args[0]))) {
             ASR::Dict_t* dict_type = ASR::down_cast<ASR::Dict_t>(ASRUtils::expr_type(args[0]));
             ASR::ttype_t* key_type = dict_type->m_key_type;
-            if (!ASRUtils::check_equal_type(ASRUtils::expr_type(args[1]), key_type, nullptr, nullptr)) {
-                std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(key_type, nullptr);
-                std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
+            if (!ASRUtils::check_equal_type(
+                    ASRUtils::expr_type(args[1]), key_type, nullptr, nullptr)) {
+                std::string contained_type_str
+                    = ASRUtils::type_to_str_fortran_expr(key_type, nullptr);
+                std::string arg_type_str
+                    = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[1]), nullptr);
                 diag.add(Diagnostic(
                     "Type mismatch in '_lfortran_get_item', the key types must be compatible",
-                    Level::Error, Stage::Semantic, {
-                        Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.base.base.loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                + contained_type_str + "')",
+                            { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
 
-            return ASR::make_DictPop_t(al, x.base.base.loc, args[0], args[1], dict_type->m_value_type, nullptr);
+            return ASR::make_DictPop_t(
+                al, x.base.base.loc, args[0], args[1], dict_type->m_value_type, nullptr);
         } else {
-            std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
-            diag.add(Diagnostic("Argument of type '" + arg_type_str + "' for _lfortran_pop has not been implemented yet",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            std::string arg_type_str
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(args[0]), nullptr);
+            diag.add(Diagnostic("Argument of type '" + arg_type_str
+                                    + "' for _lfortran_pop has not been implemented yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
 
-    ASR::asr_t* create_Concat(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_Concat(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0) {
             diag.add(Diagnostic("_lfortran_concat expects no keyword arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
         }
 
         if (x.n_args < 2) {
-            diag.add(Diagnostic("_lfortran_concat expects atleast two arguments, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
+            diag.add(Diagnostic("_lfortran_concat expects atleast two arguments, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
 
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
         }
-         
-        ASR::expr_t* left = nullptr, *right = nullptr;
+
+        ASR::expr_t *left = nullptr, *right = nullptr;
 
         AST::expr_t* source = x.m_args[0].m_end;
         this->visit_expr(*source);
         left = ASRUtils::EXPR(tmp);
 
         if (ASR::is_a<ASR::List_t>(*ASRUtils::expr_type(left))) {
-            ASR::ttype_t* list_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(left)), *right_type;
-            for (size_t i=1;i<x.n_args;i++){
+            ASR::ttype_t *list_el_type = ASRUtils::get_contained_type(ASRUtils::expr_type(left)),
+                         *right_type;
+            for (size_t i = 1; i < x.n_args; i++) {
                 source = x.m_args[i].m_end;
                 this->visit_expr(*source);
                 right = ASRUtils::EXPR(tmp);
                 right_type = ASRUtils::get_contained_type(ASRUtils::expr_type(right));
 
                 if (!ASRUtils::check_equal_type(list_el_type, right_type, nullptr, nullptr)) {
-                    std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(list_el_type, nullptr);
-                    std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(right_type, nullptr);
+                    std::string contained_type_str
+                        = ASRUtils::type_to_str_fortran_expr(list_el_type, nullptr);
+                    std::string arg_type_str
+                        = ASRUtils::type_to_str_fortran_expr(right_type, nullptr);
                     diag.add(Diagnostic(
                         "Type mismatch in _lfortran_concat, the list types must be compatible",
-                        Level::Error, Stage::Semantic, {
-                            Label("Types mismatch (found '" + 
-                        arg_type_str + "', expected '" + contained_type_str +  "')",{x.m_args[1].loc})
-                        }));
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                    + contained_type_str + "')",
+                                { x.m_args[1].loc }) }));
                     throw SemanticAbort();
                 }
 
-                left = ASRUtils::EXPR(ASR::make_ListConcat_t(al, x.base.base.loc, 
-                            left, right, ASRUtils::expr_type(right), nullptr));
-            }   
+                left = ASRUtils::EXPR(ASR::make_ListConcat_t(
+                    al, x.base.base.loc, left, right, ASRUtils::expr_type(right), nullptr));
+            }
 
-            return (ASR::asr_t*)left;
+            return (ASR::asr_t*) left;
         } else if (ASR::is_a<ASR::Tuple_t>(*ASRUtils::expr_type(left))) {
-            ASR::ttype_t* left_type = ASRUtils::expr_type(left), *right_type;
-            for (size_t i=1;i<x.n_args;i++){
+            ASR::ttype_t *left_type = ASRUtils::expr_type(left), *right_type;
+            for (size_t i = 1; i < x.n_args; i++) {
                 source = x.m_args[i].m_end;
                 this->visit_expr(*source);
                 right = ASRUtils::EXPR(tmp);
@@ -8469,41 +10357,51 @@ public:
                 ASR::Tuple_t* tuple_type_right = ASR::down_cast<ASR::Tuple_t>(right_type);
                 tuple_type_vec.reserve(al, tuple_type_left->n_type + tuple_type_right->n_type);
 
-                for (size_t j=0; j<tuple_type_left->n_type; j++) 
+                for (size_t j = 0; j < tuple_type_left->n_type; j++)
                     tuple_type_vec.push_back(al, tuple_type_left->m_type[j]);
-                
-                for (size_t j=0; j<tuple_type_right->n_type; j++) 
+
+                for (size_t j = 0; j < tuple_type_right->n_type; j++)
                     tuple_type_vec.push_back(al, tuple_type_right->m_type[j]);
-                
-                ASR::ttype_t *tuple_type = ASRUtils::TYPE(ASR::make_Tuple_t(al, x.base.base.loc,
-                                            tuple_type_vec.p, tuple_type_vec.n));
-                left = ASRUtils::EXPR(ASR::make_TupleConcat_t(al, x.base.base.loc, left, right, tuple_type, nullptr));
+
+                ASR::ttype_t* tuple_type = ASRUtils::TYPE(
+                    ASR::make_Tuple_t(al, x.base.base.loc, tuple_type_vec.p, tuple_type_vec.n));
+                left = ASRUtils::EXPR(
+                    ASR::make_TupleConcat_t(al, x.base.base.loc, left, right, tuple_type, nullptr));
                 left_type = tuple_type;
-            }   
+            }
 
-            return (ASR::asr_t*)left;
+            return (ASR::asr_t*) left;
         } else {
-            std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(left), nullptr);
-            diag.add(Diagnostic("Argument of type '" + arg_type_str + "' for _lfortran_get_item has not been implemented yet",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            std::string arg_type_str
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(left), nullptr);
+            diag.add(Diagnostic("Argument of type '" + arg_type_str
+                                    + "' for _lfortran_get_item has not been implemented yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
-    ASR::asr_t* create_Eq(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_Eq(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0) {
             diag.add(Diagnostic("_lfortran_eq expects no keyword arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
         }
 
         if (x.n_args != 2) {
-            diag.add(Diagnostic("_lfortran_eq expects exactly two arguments, got " +
-                                std::to_string(x.n_args) + " arguments instead.",
+            diag.add(Diagnostic("_lfortran_eq expects exactly two arguments, got "
+                                    + std::to_string(x.n_args) + " arguments instead.",
 
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
         }
-         
-        ASR::expr_t* left = nullptr, *right = nullptr;
+
+        ASR::expr_t *left = nullptr, *right = nullptr;
 
         AST::expr_t* source = x.m_args[0].m_end;
         this->visit_expr(*source);
@@ -8511,161 +10409,202 @@ public:
         source = x.m_args[1].m_end;
         this->visit_expr(*source);
         right = ASRUtils::EXPR(tmp);
-        ASR::ttype_t* left_type = ASRUtils::expr_type(left), *right_type = ASRUtils::expr_type(right);
+        ASR::ttype_t *left_type = ASRUtils::expr_type(left),
+                     *right_type = ASRUtils::expr_type(right);
 
 
         if (!ASRUtils::check_equal_type(left_type, right_type, left, right)) {
-                std::string left_type_str = ASRUtils::type_to_str_python_expr(left_type, left);
-                std::string right_type_str = ASRUtils::type_to_str_python_expr(right_type, right);
-                diag.add(Diagnostic(
-                    "Type mismatch in _lfortran_eq, the types must be compatible",
-                    Level::Error, Stage::Semantic, {
-                        Label("Types mismatch '" + 
-                    left_type_str + "' and '" + right_type_str +  "'",{x.base.base.loc})
-                    }));
-                throw SemanticAbort();
+            std::string left_type_str = ASRUtils::type_to_str_python_expr(left_type, left);
+            std::string right_type_str = ASRUtils::type_to_str_python_expr(right_type, right);
+            diag.add(Diagnostic(
+                "Type mismatch in _lfortran_eq, the types must be compatible",
+                Level::Error,
+                Stage::Semantic,
+                { Label("Types mismatch '" + left_type_str + "' and '" + right_type_str + "'",
+                        { x.base.base.loc }) }));
+            throw SemanticAbort();
         }
 
         if (ASR::is_a<ASR::Tuple_t>(*left_type))
-            return ASR::make_TupleCompare_t(al, x.base.base.loc, left, ASR::cmpopType::Eq, right,
-                                            ASRUtils::TYPE(ASR::make_Logical_t(al, x.base.base.loc, 4)), nullptr);
+            return ASR::make_TupleCompare_t(
+                al,
+                x.base.base.loc,
+                left,
+                ASR::cmpopType::Eq,
+                right,
+                ASRUtils::TYPE(ASR::make_Logical_t(al, x.base.base.loc, 4)),
+                nullptr);
         else {
             std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(left_type, nullptr);
-            diag.add(Diagnostic("Argument of type '" + arg_type_str + "' for _lfortran_get_item has not been implemented yet",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("Argument of type '" + arg_type_str
+                                    + "' for _lfortran_get_item has not been implemented yet",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
     }
 
-    ASR::asr_t* create_ListConstant(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_ListConstant(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0) {
             diag.add(Diagnostic("_lfortran_list_constant expects no keyword arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         if (x.n_args == 0) {
             diag.add(Diagnostic("As of now _lfortran_list_constant expects atleast one argument",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
-            
-        
+
         AST::expr_t* source = nullptr;
-        ASR::ttype_t *contained_type = nullptr;
-        Vec<ASR::expr_t *> args;
+        ASR::ttype_t* contained_type = nullptr;
+        Vec<ASR::expr_t*> args;
         args.reserve(al, 1);
-        
 
-        for (size_t i=0;i<x.n_args;i++) {
+
+        for (size_t i = 0; i < x.n_args; i++) {
             source = x.m_args[i].m_end;
             this->visit_expr(*source);
             ASR::expr_t* arg = ASRUtils::EXPR(tmp);
             args.push_back(al, arg);
-            ASR::ttype_t *arg_type = ASRUtils::expr_type(arg);
+            ASR::ttype_t* arg_type = ASRUtils::expr_type(arg);
 
 
-            if (contained_type && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-                std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+            if (contained_type
+                && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
+                std::string contained_type_str
+                    = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
                 std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
                 diag.add(Diagnostic(
                     "Type mismatch in _lfortran_list_constant, the types must be compatible",
-                    Level::Error, Stage::Semantic, {
-                        Label("Types mismatch (found '" + 
-                    arg_type_str + "', expected '" + contained_type_str +  "')",{arg->base.loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                + contained_type_str + "')",
+                            { arg->base.loc }) }));
                 throw SemanticAbort();
             } else if (!contained_type) {
                 contained_type = arg_type;
             }
         }
 
-        if (ASRUtils::is_descriptorString(contained_type) && !ASRUtils::is_deferredLength_string(contained_type)) {
-            contained_type = ASRUtils::TYPE(ASR::make_Allocatable_t(al, x.base.base.loc, ASRUtils::TYPE(
-                                                ASR::make_String_t(al, x.base.base.loc, 1, nullptr, 
-                                                        ASR::string_length_kindType::DeferredLength,
-                                                        ASR::string_physical_typeType::DescriptorString))));
+        if (ASRUtils::is_descriptorString(contained_type)
+            && !ASRUtils::is_deferredLength_string(contained_type)) {
+            contained_type = ASRUtils::TYPE(
+                ASR::make_Allocatable_t(al,
+                                        x.base.base.loc,
+                                        ASRUtils::TYPE(ASR::make_String_t(
+                                            al,
+                                            x.base.base.loc,
+                                            1,
+                                            nullptr,
+                                            ASR::string_length_kindType::DeferredLength,
+                                            ASR::string_physical_typeType::DescriptorString))));
         }
 
 
-        return ASR::make_ListConstant_t(al, x.base.base.loc, args.p, args.n, 
-                                        ASRUtils::TYPE(ASR::make_List_t(al, x.base.base.loc, contained_type)));
+        return ASR::make_ListConstant_t(
+            al,
+            x.base.base.loc,
+            args.p,
+            args.n,
+            ASRUtils::TYPE(ASR::make_List_t(al, x.base.base.loc, contained_type)));
     }
 
-    ASR::asr_t* create_ListCount(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_ListCount(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0 || x.n_args != 2) {
             diag.add(Diagnostic("_lfortran_list_count expects exactly two arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-            
-        
+
+
         AST::expr_t* source = x.m_args[0].m_end;
         this->visit_expr(*source);
         ASR::expr_t* list = ASRUtils::EXPR(tmp);
-        ASR::ttype_t *contained_type = ASRUtils::get_contained_type(ASRUtils::expr_type(list));
-        
+        ASR::ttype_t* contained_type = ASRUtils::get_contained_type(ASRUtils::expr_type(list));
+
         source = x.m_args[1].m_end;
         this->visit_expr(*source);
         ASR::expr_t* arg = ASRUtils::EXPR(tmp);
-        ASR::ttype_t *arg_type = ASRUtils::expr_type(arg);
+        ASR::ttype_t* arg_type = ASRUtils::expr_type(arg);
 
 
-        if (contained_type && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-            std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+        if (contained_type
+            && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
+            std::string contained_type_str
+                = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
             std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
-            diag.add(Diagnostic(
-                "Type mismatch in _lfortran_list_constant, the types must be compatible",
-                Level::Error, Stage::Semantic, {
-                    Label("Types mismatch (found '" + 
-                arg_type_str + "', expected '" + contained_type_str +  "')",{arg->base.loc})
-                }));
+            diag.add(
+                Diagnostic("Type mismatch in _lfortran_list_constant, the types must be compatible",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                       + contained_type_str + "')",
+                                   { arg->base.loc }) }));
             throw SemanticAbort();
-        }         
+        }
 
 
         return ASR::make_ListCount_t(al, x.base.base.loc, list, arg, arg_type, nullptr);
     }
 
-    ASR::asr_t* create_SetConstant(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_SetConstant(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0) {
             diag.add(Diagnostic("_lfortran_set_constant expects no keyword arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         if (x.n_args == 0) {
             diag.add(Diagnostic("_lfortran_set_constant expects at least one argument",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
-            
-        
+
         AST::expr_t* source = nullptr;
-        ASR::ttype_t *contained_type = nullptr;
-        Vec<ASR::expr_t *> args;
+        ASR::ttype_t* contained_type = nullptr;
+        Vec<ASR::expr_t*> args;
         args.reserve(al, 1);
-        
 
-        for (size_t i=0;i<x.n_args;i++) {
+
+        for (size_t i = 0; i < x.n_args; i++) {
             source = x.m_args[i].m_end;
             this->visit_expr(*source);
             ASR::expr_t* arg = ASRUtils::EXPR(tmp);
             args.push_back(al, arg);
-            ASR::ttype_t *arg_type = ASRUtils::expr_type(arg);
+            ASR::ttype_t* arg_type = ASRUtils::expr_type(arg);
 
 
-            if (contained_type && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-                std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+            if (contained_type
+                && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
+                std::string contained_type_str
+                    = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
                 std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
                 diag.add(Diagnostic(
                     "Type mismatch in _lfortran_set_constant, the types must be compatible",
-                    Level::Error, Stage::Semantic, {
-                        Label("Types mismatch (found '" + 
-                    arg_type_str + "', expected '" + contained_type_str +  "')",{arg->base.loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                + contained_type_str + "')",
+                            { arg->base.loc }) }));
                 throw SemanticAbort();
             } else if (!contained_type) {
                 contained_type = arg_type;
@@ -8673,129 +10612,175 @@ public:
         }
 
 
-        return ASR::make_SetConstant_t(al, x.base.base.loc, args.p, args.n, 
-                                        ASRUtils::TYPE(ASR::make_Set_t(al, x.base.base.loc, contained_type)));
+        return ASR::make_SetConstant_t(
+            al,
+            x.base.base.loc,
+            args.p,
+            args.n,
+            ASRUtils::TYPE(ASR::make_Set_t(al, x.base.base.loc, contained_type)));
     }
-    
-    ASR::asr_t* create_DictConstant(const AST::FuncCallOrArray_t& x) {
+
+    ASR::asr_t* create_DictConstant(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0) {
             diag.add(Diagnostic("_lfortran_dict_constant expects no keyword arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         if (x.n_args == 0) {
             diag.add(Diagnostic("As of now _lfortran_dict_constant expects atleast two argument",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         if (x.n_args % 2 == 1) {
-            diag.add(Diagnostic("As of now _lfortran_dict_constant expects and even number of arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(
+                Diagnostic("As of now _lfortran_dict_constant expects and even number of arguments",
+                           Level::Error,
+                           Stage::Semantic,
+                           { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
-            
-        
+
         AST::expr_t* source = nullptr;
-        std::pair<ASR::ttype_t*, ASR::ttype_t*> type = {nullptr, nullptr};
-        Vec<ASR::expr_t *> keys;
+        std::pair<ASR::ttype_t*, ASR::ttype_t*> type = { nullptr, nullptr };
+        Vec<ASR::expr_t*> keys;
         keys.reserve(al, 1);
-        
-        Vec<ASR::expr_t *> values;
+
+        Vec<ASR::expr_t*> values;
         values.reserve(al, 1);
 
-        for (size_t i=0;i<x.n_args;i++) {
-            ASR::ttype_t *contained_type = i%2 == 0? type.first : type.second;
+        for (size_t i = 0; i < x.n_args; i++) {
+            ASR::ttype_t* contained_type = i % 2 == 0 ? type.first : type.second;
 
             source = x.m_args[i].m_end;
             this->visit_expr(*source);
             ASR::expr_t* arg = ASRUtils::EXPR(tmp);
-            if (i%2 == 0)
+            if (i % 2 == 0)
                 keys.push_back(al, arg);
-            else 
+            else
                 values.push_back(al, arg);
-            ASR::ttype_t *arg_type = ASRUtils::expr_type(arg);
+            ASR::ttype_t* arg_type = ASRUtils::expr_type(arg);
 
 
-            if (contained_type && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
-                std::string contained_type_str = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
+            if (contained_type
+                && !ASRUtils::check_equal_type(contained_type, arg_type, nullptr, nullptr)) {
+                std::string contained_type_str
+                    = ASRUtils::type_to_str_fortran_expr(contained_type, nullptr);
                 std::string arg_type_str = ASRUtils::type_to_str_fortran_expr(arg_type, nullptr);
                 diag.add(Diagnostic(
                     "Type mismatch in _lfortran_list_constant, the types must be compatible",
-                    Level::Error, Stage::Semantic, {
-                        Label("Types mismatch (found '" + 
-                    arg_type_str + "', expected '" + contained_type_str +  "')",{arg->base.loc})
-                    }));
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("Types mismatch (found '" + arg_type_str + "', expected '"
+                                + contained_type_str + "')",
+                            { arg->base.loc }) }));
                 throw SemanticAbort();
             } else if (!contained_type) {
                 contained_type = arg_type;
-                if (i%2 == 0) type.first = arg_type;
-                else type.second = arg_type;
-            }
-        }
-
-        if (ASRUtils::is_descriptorString(type.first) && !ASRUtils::is_deferredLength_string(type.first)) {
-            type.first = ASRUtils::TYPE(ASR::make_Allocatable_t(al, x.base.base.loc, ASRUtils::TYPE(
-                                                ASR::make_String_t(al, x.base.base.loc, 1, nullptr, 
-                                                        ASR::string_length_kindType::DeferredLength,
-                                                        ASR::string_physical_typeType::DescriptorString))));
-        }
-
-        if (ASRUtils::is_descriptorString(type.second) && !ASRUtils::is_deferredLength_string(type.second)) {
-            type.second = ASRUtils::TYPE(ASR::make_Allocatable_t(al, x.base.base.loc, ASRUtils::TYPE(
-                                                ASR::make_String_t(al, x.base.base.loc, 1, nullptr, 
-                                                        ASR::string_length_kindType::DeferredLength,
-                                                        ASR::string_physical_typeType::DescriptorString))));
-        }
-
-        return ASR::make_DictConstant_t(al, x.base.base.loc, keys.p, keys.n, values.p, values.n, ASRUtils::TYPE(
-            ASR::make_Dict_t(al, x.base.base.loc, type.first, type.second)));
-    }
-
-    ASR::asr_t* create_TupleConstant(const AST::FuncCallOrArray_t& x) {
+                if (i % 2 == 0)
+                    type.first = arg_type;
+                else
+                    type.second = arg_type;
+            }
+        }
+
+        if (ASRUtils::is_descriptorString(type.first)
+            && !ASRUtils::is_deferredLength_string(type.first)) {
+            type.first = ASRUtils::TYPE(
+                ASR::make_Allocatable_t(al,
+                                        x.base.base.loc,
+                                        ASRUtils::TYPE(ASR::make_String_t(
+                                            al,
+                                            x.base.base.loc,
+                                            1,
+                                            nullptr,
+                                            ASR::string_length_kindType::DeferredLength,
+                                            ASR::string_physical_typeType::DescriptorString))));
+        }
+
+        if (ASRUtils::is_descriptorString(type.second)
+            && !ASRUtils::is_deferredLength_string(type.second)) {
+            type.second = ASRUtils::TYPE(
+                ASR::make_Allocatable_t(al,
+                                        x.base.base.loc,
+                                        ASRUtils::TYPE(ASR::make_String_t(
+                                            al,
+                                            x.base.base.loc,
+                                            1,
+                                            nullptr,
+                                            ASR::string_length_kindType::DeferredLength,
+                                            ASR::string_physical_typeType::DescriptorString))));
+        }
+
+        return ASR::make_DictConstant_t(
+            al,
+            x.base.base.loc,
+            keys.p,
+            keys.n,
+            values.p,
+            values.n,
+            ASRUtils::TYPE(ASR::make_Dict_t(al, x.base.base.loc, type.first, type.second)));
+    }
+
+    ASR::asr_t* create_TupleConstant(const AST::FuncCallOrArray_t& x)
+    {
         if (x.n_keywords > 0) {
             diag.add(Diagnostic("_lfortran_tuple_constant expects no keyword arguments",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         if (x.n_args == 0) {
             diag.add(Diagnostic("As of now _lfortran_tuple_constant expects atleast one argument",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
-            
+
         AST::expr_t* source = nullptr;
-        Vec<ASR::expr_t *> args;
+        Vec<ASR::expr_t*> args;
         args.reserve(al, 1);
-        
-        Vec<ASR::ttype_t *> type_vec;
+
+        Vec<ASR::ttype_t*> type_vec;
         type_vec.reserve(al, 1);
 
-        for (size_t i=0;i<x.n_args;i++) {
+        for (size_t i = 0; i < x.n_args; i++) {
             source = x.m_args[i].m_end;
             this->visit_expr(*source);
             ASR::expr_t* arg = ASRUtils::EXPR(tmp);
             args.push_back(al, arg);
 
-            ASR::ttype_t *arg_type = ASRUtils::expr_type(arg);
+            ASR::ttype_t* arg_type = ASRUtils::expr_type(arg);
             type_vec.push_back(al, arg_type);
         }
 
 
-        return ASR::make_TupleConstant_t(al, x.base.base.loc, args.p, args.n, 
-                                        ASRUtils::TYPE(ASR::make_Tuple_t(al, x.base.base.loc, 
-                                                                         type_vec.p, type_vec.n)));
+        return ASR::make_TupleConstant_t(
+            al,
+            x.base.base.loc,
+            args.p,
+            args.n,
+            ASRUtils::TYPE(ASR::make_Tuple_t(al, x.base.base.loc, type_vec.p, type_vec.n)));
     }
 
-    ASR::asr_t* create_CastToStr(const AST::FuncCallOrArray_t& x){
-        if(x.n_keywords > 0 || x.n_args != 1) throw LCompilersException("Unexpected arguments");
+    ASR::asr_t* create_CastToStr(const AST::FuncCallOrArray_t& x)
+    {
+        if (x.n_keywords > 0 || x.n_args != 1)
+            throw LCompilersException("Unexpected arguments");
 
         /* Visit Argument */
-        ASR::expr_t* argument {};
+        ASR::expr_t* argument{};
         {
             AST::BaseVisitor<Derived>::visit_expr(*(x.m_args[0].m_end));
             argument = ASRUtils::EXPR(tmp);
@@ -8804,83 +10789,75 @@ public:
 
         /* Set `cast_kind` + `compile_time_value` (If Exist) */
         int cast_kind = INT32_MAX;
-        std::string compile_time_value {};
+        std::string compile_time_value{};
 
-        switch (ASRUtils::expr_type(argument)->type)
-        {
+        switch (ASRUtils::expr_type(argument)->type) {
             case ASR::Integer:
                 cast_kind = ASR::cast_kindType::IntegerToString;
-                if(ASRUtils::is_value_constant(argument)){ // Set value
-                    int64_t i_val {};
+                if (ASRUtils::is_value_constant(argument)) {  // Set value
+                    int64_t i_val{};
                     ASRUtils::extract_value_(ASRUtils::expr_value(argument), i_val);
                     compile_time_value = std::to_string(i_val);
                 }
-            break;
+                break;
             case ASR::Real:
                 cast_kind = ASR::cast_kindType::RealToString;
-                if(ASRUtils::is_value_constant(argument)){ // Set value
-                    double d_val {};
+                if (ASRUtils::is_value_constant(argument)) {  // Set value
+                    double d_val{};
                     ASRUtils::extract_value_(ASRUtils::expr_value(argument), d_val);
                     compile_time_value = std::to_string(d_val);
                 }
-            break;
+                break;
             default:
                 throw LCompilersException("Unhandled case");
-            break;
+                break;
         }
 
         /* Set Value Expression + Set string type */
-        ASR::expr_t*  value    {};
-        ASR::ttype_t* str_type {};
+        ASR::expr_t* value{};
+        ASR::ttype_t* str_type{};
 
-        if(!compile_time_value.empty()){
+        if (!compile_time_value.empty()) {
             ASRUtils::ASRBuilder b(al, x.base.base.loc);
 
             Str c_style_string;
             c_style_string.from_str_view(compile_time_value);
             value = b.StringConstant(
                 c_style_string.c_str(al),
-                b.String(
-                    b.i64(compile_time_value.size()),
-                    ASR::ExpressionLength));
+                b.String(b.i64(compile_time_value.size()), ASR::ExpressionLength));
 
-            str_type = b.String(
-                b.i64(compile_time_value.size()),
-                ASR::ExpressionLength);
+            str_type = b.String(b.i64(compile_time_value.size()), ASR::ExpressionLength);
         } else {
             value = nullptr;
 
-            str_type = 
-                ASRUtils::ASRBuilder(al, x.base.base.loc)
-                    .String(nullptr, ASR::DeferredLength);
+            str_type
+                = ASRUtils::ASRBuilder(al, x.base.base.loc).String(nullptr, ASR::DeferredLength);
         }
 
         /* Create Cast + Return it */
         return ASR::make_Cast_t(
-            al, x.base.base.loc,
-            argument,
-            (ASR::cast_kindType)cast_kind, 
-            str_type,
-            value);
+            al, x.base.base.loc, argument, (ASR::cast_kindType) cast_kind, str_type, value);
     }
 
-    ASR::asr_t* create_StrOrd(const AST::FuncCallOrArray_t& x){
-        if(x.n_keywords > 0 || x.n_args != 1) throw LCompilersException("_lfortran_ord expects exactly one argument");
+    ASR::asr_t* create_StrOrd(const AST::FuncCallOrArray_t& x)
+    {
+        if (x.n_keywords > 0 || x.n_args != 1)
+            throw LCompilersException("_lfortran_ord expects exactly one argument");
 
         /* Visit Argument */
-        ASR::expr_t* argument {};
+        ASR::expr_t* argument{};
         {
             AST::BaseVisitor<Derived>::visit_expr(*(x.m_args[0].m_end));
             argument = ASRUtils::EXPR(tmp);
             tmp = nullptr;
         }
 
-        ASR::ttype_t *type = ASRUtils::expr_type(argument);
-        ASR::ttype_t *to_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
-        ASR::expr_t *value = nullptr;
+        ASR::ttype_t* type = ASRUtils::expr_type(argument);
+        ASR::ttype_t* to_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4));
+        ASR::expr_t* value = nullptr;
         if (!ASRUtils::is_character(*type)) {
-            diag.add(Diagnostic("_lfortran_ord expects a string type",
-                                Level::Error, Stage::Semantic, {}));
+            diag.add(Diagnostic(
+                "_lfortran_ord expects a string type", Level::Error, Stage::Semantic, {}));
             throw SemanticAbort();
         }
 
@@ -8888,7 +10865,9 @@ public:
             char* c = ASR::down_cast<ASR::StringConstant_t>(ASRUtils::expr_value(argument))->m_s;
             if (std::string(c).size() != 1) {
                 diag.add(Diagnostic("_lfortran_ord is only supported for `str` of length 1",
-                                    Level::Error, Stage::Semantic, {}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    {}));
                 throw SemanticAbort();
             }
             value = ASR::down_cast<ASR::expr_t>(
@@ -8896,33 +10875,35 @@ public:
         }
         return ASR::make_StringOrd_t(al, x.base.base.loc, argument, to_type, value);
     }
-    
 
-    ASR::asr_t* create_BitCast(const AST::FuncCallOrArray_t& x) {
+
+    ASR::asr_t* create_BitCast(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"source", "mold", "size"};
+        std::vector<std::string> kwarg_names = { "source", "mold", "size" };
         handle_intrinsic_node_args(x, args, kwarg_names, 2, 3, "transfer");
         ASR::expr_t *source = args[0], *mold = args[1], *size = args[2];
-        if( size && !ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(size)) ) {
+        if (size && !ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(size))) {
             diag.add(Diagnostic("size argument to `transfer` intrinsic must "
                                 "be of Integer type.",
-                                Level::Error, Stage::Semantic, {Label("", {size->base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { size->base.loc }) }));
             throw SemanticAbort();
         }
         Vec<ASR::dimension_t> new_dims;
         new_dims.reserve(al, 1);
-        if( size ) {
+        if (size) {
             ASR::expr_t* one = ASRUtils::EXPR(
-                ASR::make_IntegerConstant_t(al, x.base.base.loc, 1,
-                    ASRUtils::expr_type(size)));
+                ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, ASRUtils::expr_type(size)));
             ASR::dimension_t size_dim;
             size_dim.loc = size->base.loc;
             size_dim.m_start = one;
             size_dim.m_length = size;
             new_dims.push_back(al, size_dim);
         } else {
-            if( ASR::is_a<ASR::ArrayConstant_t>(*mold) ||
-                ASRUtils::is_array(ASRUtils::expr_type(mold)) ) {
+            if (ASR::is_a<ASR::ArrayConstant_t>(*mold)
+                || ASRUtils::is_array(ASRUtils::expr_type(mold))) {
                 // Calculate resulting array size from source and mold byte sizes
                 ASR::ttype_t* src_type = ASRUtils::type_get_past_allocatable(
                     ASRUtils::type_get_past_pointer(ASRUtils::expr_type(source)));
@@ -8930,108 +10911,127 @@ public:
                 int64_t src_bytes = ASRUtils::extract_kind_from_ttype_t(src_elem);
                 // If compile time size known, assign mold for better memory usage
                 // Else, mold-size is set to default(64) for runtime-sized sources
-                if( ASRUtils::is_array(src_type) ) {
+                if (ASRUtils::is_array(src_type)) {
                     int64_t n_elem = ASRUtils::get_fixed_size_of_array(src_type);
                     src_bytes = (n_elem > 0 && src_bytes > 0) ? n_elem * src_bytes : -1;
-                } else if( ASR::is_a<ASR::String_t>(*src_type) ) {
+                } else if (ASR::is_a<ASR::String_t>(*src_type)) {
                     // For scalar strings: use string length as mold size
                     ASR::String_t* str_type = ASR::down_cast<ASR::String_t>(src_type);
-                    if( str_type->m_len && ASRUtils::expr_value(str_type->m_len) ) {
+                    if (str_type->m_len && ASRUtils::expr_value(str_type->m_len)) {
                         src_bytes = ASR::down_cast<ASR::IntegerConstant_t>(
-                            ASRUtils::expr_value(str_type->m_len))->m_n;
+                                        ASRUtils::expr_value(str_type->m_len))
+                                        ->m_n;
                     } else {
-                        src_bytes = -1; // Runtime-sized string
+                        src_bytes = -1;  // Runtime-sized string
                     }
                 }
-                int64_t result_size = 64; // Fallback for runtime-sized sources
-                if( src_bytes > 0 ) {
+                int64_t result_size = 64;  // Fallback for runtime-sized sources
+                if (src_bytes > 0) {
                     ASR::ttype_t* mold_elem_type = ASRUtils::type_get_past_array(
                         ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(mold)));
                     int mold_bytes = ASRUtils::extract_kind_from_ttype_t(mold_elem_type);
                     // For character types: mold_bytes = kind * length
-                    if( ASR::is_a<ASR::String_t>(*mold_elem_type) ) {
-                        ASR::String_t* mold_str_type = ASR::down_cast<ASR::String_t>(mold_elem_type);
-                        if( mold_str_type->m_len && ASRUtils::expr_value(mold_str_type->m_len) ) {
+                    if (ASR::is_a<ASR::String_t>(*mold_elem_type)) {
+                        ASR::String_t* mold_str_type
+                            = ASR::down_cast<ASR::String_t>(mold_elem_type);
+                        if (mold_str_type->m_len && ASRUtils::expr_value(mold_str_type->m_len)) {
                             int64_t str_len = ASR::down_cast<ASR::IntegerConstant_t>(
-                                ASRUtils::expr_value(mold_str_type->m_len))->m_n;
+                                                  ASRUtils::expr_value(mold_str_type->m_len))
+                                                  ->m_n;
                             mold_bytes = mold_bytes * str_len;
                         } else {
-                            mold_bytes = -1; // Runtime-sized string
+                            mold_bytes = -1;  // Runtime-sized string
                         }
                     }
-                    if( mold_bytes > 0 ) {
+                    if (mold_bytes > 0) {
                         result_size = (src_bytes + mold_bytes - 1) / mold_bytes;
                     }
                 }
 
-                ASR::ttype_t *int_type = ASRUtils::TYPE(ASR::make_Integer_t(
+                ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(
                     al, x.base.base.loc, compiler_options.po.default_integer_kind));
                 ASR::dimension_t size_dim;
                 size_dim.loc = x.base.base.loc;
-                size_dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
-                    al, x.base.base.loc, 1, int_type));
-                size_dim.m_length = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
-                    al, x.base.base.loc, result_size, int_type));
+                size_dim.m_start
+                    = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, int_type));
+                size_dim.m_length = ASRUtils::EXPR(
+                    ASR::make_IntegerConstant_t(al, x.base.base.loc, result_size, int_type));
                 new_dims.push_back(al, size_dim);
             }
         }
-        ASR::ttype_t* type = ASRUtils::type_get_past_allocatable(ASRUtils::duplicate_type(al, ASRUtils::expr_type(mold), &new_dims));
+        ASR::ttype_t* type = ASRUtils::type_get_past_allocatable(
+            ASRUtils::duplicate_type(al, ASRUtils::expr_type(mold), &new_dims));
         ASR::expr_t *transfer_value = nullptr, *source_value = ASRUtils::expr_value(source),
-            *mold_value = ASRUtils::expr_value(mold), *size_value = nullptr;
-        if(size) size_value = ASRUtils::expr_value(size);
+                    *mold_value = ASRUtils::expr_value(mold), *size_value = nullptr;
+        if (size)
+            size_value = ASRUtils::expr_value(size);
 
         if (source_value && mold_value) {
             std::vector<uint8_t> source_bits;
             if (ASR::is_a<ASR::IntegerConstant_t>(*source_value)) {
                 int64_t val = ASR::down_cast<ASR::IntegerConstant_t>(source_value)->m_n;
                 source_bits.assign(reinterpret_cast<uint8_t*>(&val),
-                                reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                   reinterpret_cast<uint8_t*>(&val) + sizeof(val));
             } else if (ASR::is_a<ASR::RealConstant_t>(*source_value)) {
                 if (ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(mold)) == 4) {
                     float val = ASR::down_cast<ASR::RealConstant_t>(source_value)->m_r;
                     source_bits.assign(reinterpret_cast<uint8_t*>(&val),
-                                    reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                       reinterpret_cast<uint8_t*>(&val) + sizeof(val));
                 } else {
                     double val = ASR::down_cast<ASR::RealConstant_t>(source_value)->m_r;
                     source_bits.assign(reinterpret_cast<uint8_t*>(&val),
-                                    reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                       reinterpret_cast<uint8_t*>(&val) + sizeof(val));
                 }
-            } else if (ASRUtils::is_array(ASRUtils::expr_type(source)) && ASRUtils::is_value_constant(source_value)) {
-                ASR::ArrayConstant_t* const_source = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(source_value));
+            } else if (ASRUtils::is_array(ASRUtils::expr_type(source))
+                       && ASRUtils::is_value_constant(source_value)) {
+                ASR::ArrayConstant_t* const_source
+                    = ASR::down_cast<ASR::ArrayConstant_t>(ASRUtils::expr_value(source_value));
                 ASR::ttype_t* source_type = ASRUtils::expr_type(source_value);
                 int kind = ASRUtils::extract_kind_from_ttype_t(source_type);
                 size_t n_elements = ASRUtils::get_fixed_size_of_array(source_type);
 
                 if (ASRUtils::is_integer(*source_type)) {
                     if (kind == 4) {
-                        for (size_t i=0; i < n_elements; i++) {
-                            int32_t val = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_source, i))->m_n;
+                        for (size_t i = 0; i < n_elements; i++) {
+                            int32_t val
+                                = ASR::down_cast<ASR::IntegerConstant_t>(
+                                      ASRUtils::fetch_ArrayConstant_value(al, const_source, i))
+                                      ->m_n;
                             source_bits.insert(source_bits.end(),
-                                reinterpret_cast<uint8_t*>(&val),
-                                reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                               reinterpret_cast<uint8_t*>(&val),
+                                               reinterpret_cast<uint8_t*>(&val) + sizeof(val));
                         }
                     } else {
-                        for (size_t i=0; i < n_elements; i++) {
-                            int64_t val = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_source, i))->m_n;
+                        for (size_t i = 0; i < n_elements; i++) {
+                            int64_t val
+                                = ASR::down_cast<ASR::IntegerConstant_t>(
+                                      ASRUtils::fetch_ArrayConstant_value(al, const_source, i))
+                                      ->m_n;
                             source_bits.insert(source_bits.end(),
-                                reinterpret_cast<uint8_t*>(&val),
-                                reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                               reinterpret_cast<uint8_t*>(&val),
+                                               reinterpret_cast<uint8_t*>(&val) + sizeof(val));
                         }
                     }
                 } else if (ASRUtils::is_real(*source_type)) {
                     if (kind == 4) {
-                        for (size_t i=0; i < n_elements; i++) {
-                            float val = ASR::down_cast<ASR::RealConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_source, i))->m_r;
+                        for (size_t i = 0; i < n_elements; i++) {
+                            float val
+                                = ASR::down_cast<ASR::RealConstant_t>(
+                                      ASRUtils::fetch_ArrayConstant_value(al, const_source, i))
+                                      ->m_r;
                             source_bits.insert(source_bits.end(),
-                                reinterpret_cast<uint8_t*>(&val),
-                                reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                               reinterpret_cast<uint8_t*>(&val),
+                                               reinterpret_cast<uint8_t*>(&val) + sizeof(val));
                         }
                     } else {
-                        for (size_t i=0; i < n_elements; i++) {
-                            double val = ASR::down_cast<ASR::RealConstant_t>(ASRUtils::fetch_ArrayConstant_value(al, const_source, i))->m_r;
+                        for (size_t i = 0; i < n_elements; i++) {
+                            double val
+                                = ASR::down_cast<ASR::RealConstant_t>(
+                                      ASRUtils::fetch_ArrayConstant_value(al, const_source, i))
+                                      ->m_r;
                             source_bits.insert(source_bits.end(),
-                                reinterpret_cast<uint8_t*>(&val),
-                                reinterpret_cast<uint8_t*>(&val) + sizeof(val));
+                                               reinterpret_cast<uint8_t*>(&val),
+                                               reinterpret_cast<uint8_t*>(&val) + sizeof(val));
                         }
                     }
                 }
@@ -9052,108 +11052,124 @@ public:
                 } else if (ASR::is_a<ASR::Logical_t>(*type)) {
                     target_size = ASR::down_cast<ASR::Logical_t>(type)->m_kind;
                 } else if (ASR::is_a<ASR::String_t>(*type)) {
-                    int len = -1; ASRUtils::extract_value(ASR::down_cast<ASR::String_t>(type)->m_len, len);
+                    int len = -1;
+                    ASRUtils::extract_value(ASR::down_cast<ASR::String_t>(type)->m_len, len);
                     target_size = len;
                 }
             }
             std::vector<uint8_t> result_bits(source_bits.begin(),
-                                            source_bits.begin() + std::min(source_bits.size(), target_size));
+                                             source_bits.begin()
+                                                 + std::min(source_bits.size(), target_size));
 
             if (ASR::is_a<ASR::Integer_t>(*ASRUtils::expr_type(mold))) {
                 int64_t new_value = 0;
-                std::memcpy(&new_value, result_bits.data(), std::min(sizeof(new_value), result_bits.size()));
-                transfer_value = ASRUtils::EXPR(
-                    ASR::make_IntegerConstant_t(al, x.base.base.loc, new_value, ASRUtils::expr_type(mold)));
+                std::memcpy(&new_value,
+                            result_bits.data(),
+                            std::min(sizeof(new_value), result_bits.size()));
+                transfer_value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                    al, x.base.base.loc, new_value, ASRUtils::expr_type(mold)));
             } else if (ASR::is_a<ASR::Real_t>(*ASRUtils::expr_type(mold))) {
                 if (ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(mold)) == 8) {
                     double new_value = 0.0;
-                    std::memcpy(&new_value, result_bits.data(), std::min(sizeof(new_value), result_bits.size()));
-                    transfer_value = ASRUtils::EXPR(
-                        ASR::make_RealConstant_t(al, x.base.base.loc, new_value, ASRUtils::expr_type(mold)));
+                    std::memcpy(&new_value,
+                                result_bits.data(),
+                                std::min(sizeof(new_value), result_bits.size()));
+                    transfer_value = ASRUtils::EXPR(ASR::make_RealConstant_t(
+                        al, x.base.base.loc, new_value, ASRUtils::expr_type(mold)));
                 } else {
                     float new_value = 0.0;
-                    std::memcpy(&new_value, result_bits.data(), std::min(sizeof(new_value), result_bits.size()));
-                    transfer_value = ASRUtils::EXPR(
-                        ASR::make_RealConstant_t(al, x.base.base.loc, new_value, ASRUtils::expr_type(mold)));
+                    std::memcpy(&new_value,
+                                result_bits.data(),
+                                std::min(sizeof(new_value), result_bits.size()));
+                    transfer_value = ASRUtils::EXPR(ASR::make_RealConstant_t(
+                        al, x.base.base.loc, new_value, ASRUtils::expr_type(mold)));
                 }
             } else if (ASR::is_a<ASR::String_t>(*ASRUtils::expr_type(mold))) {
                 std::string new_value = "";
                 for (size_t i = 0; i < result_bits.size(); i++) {
                     new_value.push_back(result_bits[i]);
                 }
-                Str s; s.from_str_view(new_value);
-                transfer_value = ASRUtils::EXPR(
-                    ASR::make_StringConstant_t(al, mold->base.loc, s.c_str(al), ASRUtils::expr_type(mold)));
+                Str s;
+                s.from_str_view(new_value);
+                transfer_value = ASRUtils::EXPR(ASR::make_StringConstant_t(
+                    al, mold->base.loc, s.c_str(al), ASRUtils::expr_type(mold)));
             } else {
                 return ASR::make_BitCast_t(al, x.base.base.loc, source, mold, size, type, nullptr);
             }
         }
-        return ASR::make_BitCast_t(al, x.base.base.loc, source, mold,
-                                     size, type, transfer_value);
+        return ASR::make_BitCast_t(al, x.base.base.loc, source, mold, size, type, transfer_value);
     }
 
 
-    ASR::asr_t* create_NullPointerConstant(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_NullPointerConstant(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"mold"};
+        std::vector<std::string> kwarg_names = { "mold" };
         handle_intrinsic_node_args(x, args, kwarg_names, 0, 1, "null");
-        ASR::expr_t *mold_ = args[0];
+        ASR::expr_t* mold_ = args[0];
         ASR::ttype_t* null_ptr_type_ = nullptr;
-        if( mold_ ) {
+        if (mold_) {
             null_ptr_type_ = ASRUtils::expr_type(mold_);
         } else {
             LCOMPILERS_ASSERT(current_variable_type_ != nullptr);
             null_ptr_type_ = current_variable_type_;
         }
-        return ASR::make_PointerNullConstant_t(al, x.base.base.loc, null_ptr_type_, current_struct_type_var_expr);
+        return ASR::make_PointerNullConstant_t(
+            al, x.base.base.loc, null_ptr_type_, current_struct_type_var_expr);
     }
 
-    ASR::asr_t* create_Associated(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_Associated(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"pointer", "target"};
+        std::vector<std::string> kwarg_names = { "pointer", "target" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 2, "associated");
         ASR::expr_t *ptr_ = args[0], *tgt_ = args[1];
-        ASR::ttype_t* associated_type_ = ASRUtils::TYPE(ASR::make_Logical_t(
-                                            al, x.base.base.loc, compiler_options.po.default_integer_kind));
-        return ASR::make_PointerAssociated_t(al, x.base.base.loc, ptr_, tgt_, associated_type_, nullptr);
+        ASR::ttype_t* associated_type_ = ASRUtils::TYPE(
+            ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+        return ASR::make_PointerAssociated_t(
+            al, x.base.base.loc, ptr_, tgt_, associated_type_, nullptr);
     }
 
-    ASR::asr_t* create_Iachar(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_Iachar(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"C", "kind"};
+        std::vector<std::string> kwarg_names = { "C", "kind" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 2, "iachar");
         ASR::expr_t *arg = args[0], *kind = args[1];
         int64_t kind_value = handle_kind(kind);
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_value));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, kind_value));
         ASR::expr_t* iachar_value = nullptr;
         ASR::expr_t* arg_value = ASRUtils::expr_value(arg);
-        if( arg_value ) {
+        if (arg_value) {
             std::string arg_str;
             bool is_const_value = ASRUtils::is_value_constant(arg_value, arg_str);
-            if( is_const_value ) {
+            if (is_const_value) {
                 int64_t ascii_code = uint8_t(arg_str[0]);
-                iachar_value = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc,
-                                ascii_code, type));
+                iachar_value = ASRUtils::EXPR(
+                    ASR::make_IntegerConstant_t(al, x.base.base.loc, ascii_code, type));
             }
         }
         return ASR::make_Iachar_t(al, x.base.base.loc, arg, type, iachar_value);
     }
 
-    ASR::asr_t* create_Complex(const AST::FuncCallOrArray_t& x) {
-        const Location &loc = x.base.base.loc;
+    ASR::asr_t* create_Complex(const AST::FuncCallOrArray_t& x)
+    {
+        const Location& loc = x.base.base.loc;
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"x", "y"};
+        std::vector<std::string> kwarg_names = { "x", "y" };
         handle_intrinsic_node_args(x, args, kwarg_names, 2, 2, "complex");
 
-        ASR::ttype_t *arg_type0 = ASRUtils::expr_type(args[0]);
-        ASR::ttype_t *arg_type1 = ASRUtils::expr_type(args[1]);
-        if(!((is_integer(*arg_type0) && is_integer(*arg_type1))
-            || (is_real(*arg_type0) && is_real(*arg_type1))
-            || (is_integer(*arg_type0) && is_real(*arg_type1))
-            || (is_real(*arg_type0) && is_integer(*arg_type1)))) {
+        ASR::ttype_t* arg_type0 = ASRUtils::expr_type(args[0]);
+        ASR::ttype_t* arg_type1 = ASRUtils::expr_type(args[1]);
+        if (!((is_integer(*arg_type0) && is_integer(*arg_type1))
+              || (is_real(*arg_type0) && is_real(*arg_type1))
+              || (is_integer(*arg_type0) && is_real(*arg_type1))
+              || (is_real(*arg_type0) && is_integer(*arg_type1)))) {
             diag.add(Diagnostic("Unexpected args, Complex expects (int, int) or (real, real) "
-                "or (int, real) or (real, int) as arguments", Level::Error, Stage::Semantic, {
-                Label("", {loc})}));
+                                "or (int, real) or (real, int) as arguments",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
@@ -9162,8 +11178,9 @@ public:
         int max_ret_kind = 4;
         for (size_t i = 0; i < args.size(); i++) {
             if (ASRUtils::is_real(*ASRUtils::expr_type(args[i]))) {
-                max_ret_kind = std::max(max_ret_kind,
-                    ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args[i])));
+                max_ret_kind
+                    = std::max(max_ret_kind,
+                               ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args[i])));
             }
         }
         ASRUtils::set_kind_to_ttype_t(ret_type, max_ret_kind);
@@ -9184,54 +11201,59 @@ public:
         return ASR::make_ComplexConstructor_t(al, loc, re, im, ret_type, value);
     }
 
-    IntrinsicSignature get_intrinsic_signature(std::string& var_name) {
-        if( name2signature.find(var_name) == name2signature.end() ) {
+    IntrinsicSignature get_intrinsic_signature(std::string& var_name)
+    {
+        if (name2signature.find(var_name) == name2signature.end()) {
             return IntrinsicSignature({}, 1, 1);
         }
         return name2signature[var_name];
     }
 
-    bool is_intrinsic_registry_function(std::string var_name) {
+    bool is_intrinsic_registry_function(std::string var_name)
+    {
         bool is_specific_type_intrinsic = intrinsic_mapping.count(var_name);
-        if (intrinsic_procedures_as_asr_nodes.is_intrinsic_present_in_ASR(var_name) ||
-            intrinsic_procedures_as_asr_nodes.is_kind_based_selection_required(var_name) ||
-            ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function(var_name) ||
-            ASRUtils::IntrinsicArrayFunctionRegistry::is_intrinsic_function(var_name) ||
-            ASRUtils::IntrinsicImpureFunctionRegistry::is_intrinsic_function(var_name) ||
-            is_specific_type_intrinsic) {
+        if (intrinsic_procedures_as_asr_nodes.is_intrinsic_present_in_ASR(var_name)
+            || intrinsic_procedures_as_asr_nodes.is_kind_based_selection_required(var_name)
+            || ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function(var_name)
+            || ASRUtils::IntrinsicArrayFunctionRegistry::is_intrinsic_function(var_name)
+            || ASRUtils::IntrinsicImpureFunctionRegistry::is_intrinsic_function(var_name)
+            || is_specific_type_intrinsic) {
             return true;
         }
         return false;
     }
 
-    bool is_intrinsic_registry_subroutine( std::string var_name ) {
-        if ( ASRUtils::IntrinsicImpureSubroutineRegistry::is_intrinsic_subroutine(var_name) ) {
+    bool is_intrinsic_registry_subroutine(std::string var_name)
+    {
+        if (ASRUtils::IntrinsicImpureSubroutineRegistry::is_intrinsic_subroutine(var_name)) {
             return true;
         }
         return false;
     }
 
-    void fill_optional_kind_arg(std::string &name, Vec<ASR::expr_t*> &args) {
+    void fill_optional_kind_arg(std::string& name, Vec<ASR::expr_t*>& args)
+    {
         if (name == "aimag") {
             if (args.size() == 1) {
-                Location &loc = args[0]->base.loc;
+                Location& loc = args[0]->base.loc;
                 int kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args[0]));
-                ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, kind));
+                ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, kind));
                 ASRUtils::ASRBuilder b(al, loc);
                 args.push_back(al, b.i_t(kind, type));
             }
         }
     }
 
-    void scalar_kind_arg(std::string &name, Vec<ASR::expr_t*> &args) {
-        std::unordered_map<std::string, int> kind_arg_index_map = {
-            {"logical", 1}, {"storage_size", 1}, {"anint", 1}, {"nint", 1}, {"aint", 1},
-            {"floor", 1}, {"ceiling", 1}, {"aimag", 1}, {"maskl", 1}, {"maskr", 1},
-            {"ichar", 1}, {"char", 1}, {"achar", 1}, {"iachar", 1}, {"real", 1},
-            {"int", 1}, {"len_trim", 1}, {"len", 1}, {"shape", 1},
-            {"ieee_real", 1}, {"ieee_int", 2}, {"lbound", 2}, {"ubound", 2}, {"size", 2},
-            {"verify", 3}, {"index", 3}, {"scan", 3}, {"cmplx", 2}
-        };
+    void scalar_kind_arg(std::string& name, Vec<ASR::expr_t*>& args)
+    {
+        std::unordered_map<std::string, int> kind_arg_index_map
+            = { { "logical", 1 },  { "storage_size", 1 }, { "anint", 1 },   { "nint", 1 },
+                { "aint", 1 },     { "floor", 1 },        { "ceiling", 1 }, { "aimag", 1 },
+                { "maskl", 1 },    { "maskr", 1 },        { "ichar", 1 },   { "char", 1 },
+                { "achar", 1 },    { "iachar", 1 },       { "real", 1 },    { "int", 1 },
+                { "len_trim", 1 }, { "len", 1 },          { "shape", 1 },   { "ieee_real", 1 },
+                { "ieee_int", 2 }, { "lbound", 2 },       { "ubound", 2 },  { "size", 2 },
+                { "verify", 3 },   { "index", 3 },        { "scan", 3 },    { "cmplx", 2 } };
 
         auto it = kind_arg_index_map.find(name);
         if (it != kind_arg_index_map.end()) {
@@ -9239,29 +11261,26 @@ public:
 
             if (args[kind_arg_index]) {
                 if (ASRUtils::is_array(ASRUtils::expr_type(args[kind_arg_index]))) {
-                    diag.add(Diagnostic(
-                        "`kind` argument of `" + name + "` intrinsic must be a scalar",
-                        Level::Error, Stage::Semantic, {
-                            Label("", {args[kind_arg_index]->base.loc})
-                        }));
+                    diag.add(
+                        Diagnostic("`kind` argument of `" + name + "` intrinsic must be a scalar",
+                                   Level::Error,
+                                   Stage::Semantic,
+                                   { Label("", { args[kind_arg_index]->base.loc }) }));
                     throw SemanticAbort();
                 }
             }
         }
     }
 
-    void fill_optional_args(std::string intrinsic_name, Vec<ASR::expr_t*> &args, const Location &loc) {
-        ASR::ttype_t *int_type = ASRUtils::TYPE(
-                    ASR::make_Integer_t(al, loc, 4));
-        ASR::ttype_t *bool_type = ASRUtils::TYPE(
-                    ASR::make_Logical_t(al, loc, 4));
+    void fill_optional_args(std::string intrinsic_name,
+                            Vec<ASR::expr_t*>& args,
+                            const Location& loc)
+    {
+        ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4));
+        ASR::ttype_t* bool_type = ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4));
         if (intrinsic_name == "selected_real_kind") {
-            ASR::expr_t* zero = ASRUtils::EXPR(
-                ASR::make_IntegerConstant_t(al, loc, 0,
-                                                int_type));
-            ASR::expr_t* two = ASRUtils::EXPR(
-                ASR::make_IntegerConstant_t(al, loc, 2,
-                                                int_type));
+            ASR::expr_t* zero = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 0, int_type));
+            ASR::expr_t* two = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 2, int_type));
             if (args[0] == nullptr) {
                 args.p[0] = zero;
             }
@@ -9271,13 +11290,11 @@ public:
             if (args[2] == nullptr) {
                 args.p[2] = two;
             }
-        } else if (intrinsic_name == "verify" || intrinsic_name == "index" || intrinsic_name == "scan") {
-            ASR::ttype_t *bool_type = ASRUtils::TYPE(
-                    ASR::make_Logical_t(al, loc, 4));
-            ASR::expr_t* f = ASRUtils::EXPR(
-                ASR::make_LogicalConstant_t(al, loc, false, bool_type));
-            ASR::expr_t* four = ASRUtils::EXPR(
-                ASR::make_IntegerConstant_t(al, loc, 4, int_type));
+        } else if (intrinsic_name == "verify" || intrinsic_name == "index"
+                   || intrinsic_name == "scan") {
+            ASR::ttype_t* bool_type = ASRUtils::TYPE(ASR::make_Logical_t(al, loc, 4));
+            ASR::expr_t* f = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, loc, false, bool_type));
+            ASR::expr_t* four = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 4, int_type));
             if (args[2] == nullptr) {
                 args.p[2] = f;
             }
@@ -9286,145 +11303,180 @@ public:
             }
         } else if (intrinsic_name == "cmplx") {
             if (args[1] == nullptr && !is_complex(*ASRUtils::expr_type(args[0]))) {
-                ASR::ttype_t *real_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, 4));
-                ASR::expr_t* zero = ASRUtils::EXPR(
-                    ASR::make_RealConstant_t(al, loc, 0.0, real_type));
+                ASR::ttype_t* real_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, 4));
+                ASR::expr_t* zero
+                    = ASRUtils::EXPR(ASR::make_RealConstant_t(al, loc, 0.0, real_type));
                 args.p[1] = zero;
             }
             if (args[2] == nullptr) {
                 int kind = 4;
-                ASR::expr_t* val = ASRUtils::EXPR(
-                    ASR::make_IntegerConstant_t(al, loc, kind, int_type));
+                ASR::expr_t* val
+                    = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, kind, int_type));
                 args.p[2] = val;
             }
         } else if (intrinsic_name == "real") {
             if (args[1] == nullptr) {
                 if (is_complex(*ASRUtils::expr_type(args[0]))) {
                     int kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args[0]));
-                    ASR::expr_t* val = ASRUtils::EXPR(
-                        ASR::make_IntegerConstant_t(al, loc, kind, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, kind))));
+                    ASR::expr_t* val = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                        al, loc, kind, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, kind))));
                     args.p[1] = val;
                 }
             }
-        } else if (intrinsic_name == "ishftc"){
-            if(args[2] == nullptr){
+        } else if (intrinsic_name == "ishftc") {
+            if (args[2] == nullptr) {
                 int value;
                 int kind = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(args[0]));
-                value = kind*8;
-                ASR::expr_t* val = ASRUtils::EXPR(
-                    ASR::make_IntegerConstant_t(al, loc, value, int_type));
+                value = kind * 8;
+                ASR::expr_t* val
+                    = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, value, int_type));
                 args.p[2] = val;
             }
-        } else if (intrinsic_name == "out_of_range"){
-            if(args[2] == nullptr){
+        } else if (intrinsic_name == "out_of_range") {
+            if (args[2] == nullptr) {
                 bool value = false;
-                ASR::expr_t* val = ASRUtils::EXPR(
-                    ASR::make_LogicalConstant_t(al, loc, value, bool_type));
+                ASR::expr_t* val
+                    = ASRUtils::EXPR(ASR::make_LogicalConstant_t(al, loc, value, bool_type));
                 args.p[2] = val;
             }
         }
     }
 
-    void check_specific_type_intrinsics(std::string intrinsic_name, Vec<ASR::expr_t*> &args, const Location &loc) {
-        std::set<std::string>array_intrinsic_mapping_names = {"min0", "amin0", "min1", "amin1", "dmin1", "max0", "amax0", "max1", "amax1", "dmax1"};
+    void check_specific_type_intrinsics(std::string intrinsic_name,
+                                        Vec<ASR::expr_t*>& args,
+                                        const Location& loc)
+    {
+        std::set<std::string> array_intrinsic_mapping_names = { "min0",  "amin0", "min1",  "amin1",
+                                                                "dmin1", "max0",  "amax0", "max1",
+                                                                "amax1", "dmax1" };
         if (intrinsic_mapping.find(intrinsic_name) == intrinsic_mapping.end()) {
             return;
         }
 
         size_t arg_size = args.size();
-        if(intrinsic_name == "dint" || intrinsic_name == "dnint") {
+        if (intrinsic_name == "dint" || intrinsic_name == "dnint") {
             arg_size = 1;
             if (args[1]) {
                 diag.add(Diagnostic("Too many arguments to call `" + intrinsic_name + "`",
-                    Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         }
 
         for (size_t i = 0; i < arg_size; i++) {
             std::string argument_type = "";
-            if (array_intrinsic_mapping_names.find(intrinsic_name) != array_intrinsic_mapping_names.end()) {
+            if (array_intrinsic_mapping_names.find(intrinsic_name)
+                != array_intrinsic_mapping_names.end()) {
                 argument_type = intrinsic_mapping[intrinsic_name].second[0];
             } else {
-                if(i < intrinsic_mapping[intrinsic_name].second.size()){
+                if (i < intrinsic_mapping[intrinsic_name].second.size()) {
                     argument_type = intrinsic_mapping[intrinsic_name].second[i];
                 } else {
                     diag.add(Diagnostic("Too many arguments to call `" + intrinsic_name + "`",
-                        Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
             }
             if (argument_type == "int4") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     if (!is_integer(*arg_type)) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of integer type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name + " must be of integer type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
             } else if (argument_type == "real") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     if (!is_real(*arg_type)) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of real type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name + " must be of real type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
             } else if (argument_type == "real4") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     int kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                     if (!is_real(*arg_type) || kind != 4) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of single precision real type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name
+                                                + " must be of single precision real type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
             } else if (argument_type == "real8") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     int kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                     if (!is_real(*arg_type) || kind != 8) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of double precision real type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name
+                                                + " must be of double precision real type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
             } else if (argument_type == "complex") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     if (!is_complex(*arg_type)) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of complex type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name + " must be of complex type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
             } else if (argument_type == "complex4") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     int kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                     if (!is_complex(*arg_type) || kind != 4) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of single precision complex type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name
+                                                + " must be of single precision complex type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
             } else if (argument_type == "complex8") {
                 if (args[i] != nullptr) {
-                    ASR::ttype_t *arg_type = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
+                    ASR::ttype_t* arg_type
+                        = ASRUtils::type_get_past_array(ASRUtils::expr_type(args[i]));
                     int kind = ASRUtils::extract_kind_from_ttype_t(arg_type);
                     if (!is_complex(*arg_type) || kind != 8) {
-                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of " + intrinsic_name +
-                                            " must be of double precision complex type",
-                                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(Diagnostic("Argument " + std::to_string(i + 1) + " of "
+                                                + intrinsic_name
+                                                + " must be of double precision complex type",
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                 }
@@ -9432,25 +11484,32 @@ public:
         }
     }
 
-    void is_coarray_or_atomic(std::string intrinsic_name, const Location& loc){
+    void is_coarray_or_atomic(std::string intrinsic_name, const Location& loc)
+    {
         std::vector<std::string> coarray_intrinsics, atomic_intrinsics;
-        coarray_intrinsics = {"co_broadcast", "co_max", "co_min", "co_reduce", "co_sum", "lcobound", "ucobound", "failed_images",
-            "image_status", "get_team", "image_index", "num_images", "stopped_images", "team_number", "this_image", "coshape", "corank",
-            "event_query"};
-        atomic_intrinsics = {"atomic_add", "atomic_and", "atomic_cas", "atomic_define", "atomic_fetch_add", "atomic_fetch_and",
-            "atomic_fetch_or", "atomic_fetch_xor", "atomic_or", "atomic_ref", "atomic_xor"};
-        if (std::find(coarray_intrinsics.begin(), coarray_intrinsics.end(), intrinsic_name) != coarray_intrinsics.end()) {
-            diag.add(diag::Diagnostic(
-                    "Coarrays are not supported yet",
-                    diag::Level::Error, diag::Stage::Semantic, {
-                    diag::Label("", {loc})}));
+        coarray_intrinsics
+            = { "co_broadcast", "co_max",     "co_min",         "co_reduce",    "co_sum",
+                "lcobound",     "ucobound",   "failed_images",  "image_status", "get_team",
+                "image_index",  "num_images", "stopped_images", "team_number",  "this_image",
+                "coshape",      "corank",     "event_query" };
+        atomic_intrinsics
+            = { "atomic_add",       "atomic_and",       "atomic_cas",      "atomic_define",
+                "atomic_fetch_add", "atomic_fetch_and", "atomic_fetch_or", "atomic_fetch_xor",
+                "atomic_or",        "atomic_ref",       "atomic_xor" };
+        if (std::find(coarray_intrinsics.begin(), coarray_intrinsics.end(), intrinsic_name)
+            != coarray_intrinsics.end()) {
+            diag.add(diag::Diagnostic("Coarrays are not supported yet",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { loc }) }));
+            throw SemanticAbort();
+        } else if (std::find(atomic_intrinsics.begin(), atomic_intrinsics.end(), intrinsic_name)
+                   != atomic_intrinsics.end()) {
+            diag.add(diag::Diagnostic("Atomic operations are not supported yet",
+                                      diag::Level::Error,
+                                      diag::Stage::Semantic,
+                                      { diag::Label("", { loc }) }));
             throw SemanticAbort();
-        } else if (std::find(atomic_intrinsics.begin(), atomic_intrinsics.end(), intrinsic_name) != atomic_intrinsics.end()) {
-            diag.add(diag::Diagnostic(
-                "Atomic operations are not supported yet",
-                diag::Level::Error, diag::Stage::Semantic, {
-                    diag::Label("", {loc})}));
-                throw SemanticAbort();
         }
     }
 
@@ -9462,60 +11521,78 @@ public:
      * min([-1, 2, 3], 2, 5, [4, 4, 5], [5, -8, 7]) is broadcasted as:
      * [min(-1, 2, 5, 4, 5), min(2, 2, 5, 4, -8), min(3, 2, 5, 5, 7)]
      *
-    */
-    void compiletime_broadcast_elemental_intrinsic(
-        Vec<ASR::expr_t*> args,
-        ASR::ArrayConstant_t** result_array,
-        std::vector<int> array_indices_in_args,
-        ASRUtils::create_intrinsic_function create_func,
-        const Location& loc,
-        Allocator& al)
+     */
+    void compiletime_broadcast_elemental_intrinsic(Vec<ASR::expr_t*> args,
+                                                   ASR::ArrayConstant_t** result_array,
+                                                   std::vector<int> array_indices_in_args,
+                                                   ASRUtils::create_intrinsic_function create_func,
+                                                   const Location& loc,
+                                                   Allocator& al)
     {
         ASR::expr_t* first_arg_ = ASRUtils::expr_value(args[array_indices_in_args[0]]);
         size_t max_array_size = ASRUtils::get_fixed_size_of_array(ASRUtils::expr_type(first_arg_));
         ASR::ttype_t* array_type = ASRUtils::expr_type(first_arg_);
-        Vec<ASR::expr_t*> new_expr; new_expr.reserve(al, max_array_size);
+        Vec<ASR::expr_t*> new_expr;
+        new_expr.reserve(al, max_array_size);
 
         for (size_t i = 0; i < max_array_size; i++) {
             Vec<ASR::expr_t*> intrinsic_args;
             intrinsic_args.reserve(al, args.size());
 
             for (size_t j = 0; j < args.size(); j++) {
-                if (std::find(array_indices_in_args.begin(), array_indices_in_args.end(), j) != array_indices_in_args.end()) {
+                if (std::find(array_indices_in_args.begin(), array_indices_in_args.end(), j)
+                    != array_indices_in_args.end()) {
                     // Current argument is an array
 
                     ASR::expr_t* arg_ = ASRUtils::expr_value(args[j]);
                     ASR::ArrayConstant_t* array_arg = ASR::down_cast<ASR::ArrayConstant_t>(arg_);
-                    if (max_array_size != (size_t) ASRUtils::get_fixed_size_of_array(array_arg->m_type)) {
-                        diag.add(diag::Diagnostic("Different shape of arguments for broadcasting " +
-                            std::to_string(max_array_size) + " and " + std::to_string(ASRUtils::get_fixed_size_of_array(array_arg->m_type)),
-                            diag::Level::Error, diag::Stage::Semantic, {
-                            diag::Label("", {loc})}));
+                    if (max_array_size
+                        != (size_t) ASRUtils::get_fixed_size_of_array(array_arg->m_type)) {
+                        diag.add(
+                            diag::Diagnostic("Different shape of arguments for broadcasting "
+                                                 + std::to_string(max_array_size) + " and "
+                                                 + std::to_string(ASRUtils::get_fixed_size_of_array(
+                                                     array_arg->m_type)),
+                                             diag::Level::Error,
+                                             diag::Stage::Semantic,
+                                             { diag::Label("", { loc }) }));
                         throw SemanticAbort();
                     }
-                    intrinsic_args.push_back(al, ASRUtils::fetch_ArrayConstant_value(al, array_arg, i));
+                    intrinsic_args.push_back(al,
+                                             ASRUtils::fetch_ArrayConstant_value(al, array_arg, i));
                 } else {
                     // Current argument is a scalar, use as is
                     intrinsic_args.push_back(al, args[j]);
                 }
             }
             // Call the intrinsic function for the current combination of arguments
-            // result_array->m_args[i] = ASRUtils::expr_value(ASRUtils::EXPR(create_func(al, loc, intrinsic_args, diag)));
+            // result_array->m_args[i] = ASRUtils::expr_value(ASRUtils::EXPR(create_func(al, loc,
+            // intrinsic_args, diag)));
             if (create_func(al, loc, intrinsic_args, diag) == nullptr) {
                 throw SemanticAbort();
             }
-            ASR::expr_t* result = ASRUtils::expr_value(ASRUtils::EXPR(create_func(al, loc, intrinsic_args, diag)));
+            ASR::expr_t* result
+                = ASRUtils::expr_value(ASRUtils::EXPR(create_func(al, loc, intrinsic_args, diag)));
             array_type = ASRUtils::expr_type(result);
             new_expr.push_back(al, result);
             // ASRUtils::set_ArrayConstant_value(result_array, result, i);
         }
         ASR::Array_t* result_arr_type = ASR::down_cast<ASR::Array_t>((*result_array)->m_type);
-        (*result_array)->m_type = ASRUtils::make_Array_t_util(al, result_arr_type->base.base.loc,
-                                    array_type, result_arr_type->m_dims,
-                                    result_arr_type->n_dims, ASR::abiType::Source, false,
-                                    result_arr_type->m_physical_type);
-        ASR::expr_t* new_expr_ = ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al, (*result_array)->base.base.loc,
-                                    new_expr.p, new_expr.n, (*result_array)->m_type, (*result_array)->m_storage_format));
+        (*result_array)->m_type = ASRUtils::make_Array_t_util(al,
+                                                              result_arr_type->base.base.loc,
+                                                              array_type,
+                                                              result_arr_type->m_dims,
+                                                              result_arr_type->n_dims,
+                                                              ASR::abiType::Source,
+                                                              false,
+                                                              result_arr_type->m_physical_type);
+        ASR::expr_t* new_expr_ = ASRUtils::EXPR(
+            ASRUtils::make_ArrayConstructor_t_util(al,
+                                                   (*result_array)->base.base.loc,
+                                                   new_expr.p,
+                                                   new_expr.n,
+                                                   (*result_array)->m_type,
+                                                   (*result_array)->m_storage_format));
         if (ASR::is_a<ASR::ArrayConstant_t>(*new_expr_)) {
             (*result_array) = ASR::down_cast<ASR::ArrayConstant_t>(new_expr_);
         } else {
@@ -9523,7 +11600,8 @@ public:
         }
     }
 
-    std::vector<int> find_array_indices_in_args(const Vec<ASR::expr_t*>& args) {
+    std::vector<int> find_array_indices_in_args(const Vec<ASR::expr_t*>& args)
+    {
         std::vector<int> array_indices_in_args;
 
         for (size_t i = 0; i < args.size(); i++) {
@@ -9538,14 +11616,18 @@ public:
         return array_indices_in_args;
     }
 
-    ASR::expr_t* fetch_arrayconstant(ASR::expr_t* var_value) {
-        if (!var_value) return nullptr;
-        return ASR::is_a<ASR::ArrayConstant_t>(*var_value) ? var_value : ASR::is_a<ASR::Var_t>(*var_value) ?
-                fetch_arrayconstant(ASRUtils::EXPR2VAR(var_value)->m_value) : nullptr;
+    ASR::expr_t* fetch_arrayconstant(ASR::expr_t* var_value)
+    {
+        if (!var_value)
+            return nullptr;
+        return ASR::is_a<ASR::ArrayConstant_t>(*var_value) ? var_value
+               : ASR::is_a<ASR::Var_t>(*var_value)
+                   ? fetch_arrayconstant(ASRUtils::EXPR2VAR(var_value)->m_value)
+                   : nullptr;
     }
 
-    ASR::symbol_t* intrinsic_as_node(const AST::FuncCallOrArray_t &x,
-                                     bool& is_function) {
+    ASR::symbol_t* intrinsic_as_node(const AST::FuncCallOrArray_t& x, bool& is_function)
+    {
         std::string var_name = to_lower(x.m_func);
         if (ASR::asr_t* result = handle_intrinsics_dble_float_dfloat_shifta(x, al)) {
             is_function = false;
@@ -9554,137 +11636,166 @@ public:
         }
         std::string specific_var_name = var_name;
         bool is_specific_type_intrinsic = intrinsic_mapping.count(var_name);
-        if( is_intrinsic_registry_function(var_name)) {
+        if (is_intrinsic_registry_function(var_name)) {
             is_function = false;
             if (is_specific_type_intrinsic) {
                 specific_var_name = var_name;
                 var_name = intrinsic_mapping[var_name].first;
             }
-            if( ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function(var_name) ||
-                    ASRUtils::IntrinsicArrayFunctionRegistry::is_intrinsic_function(var_name) ) {
+            if (ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function(var_name)
+                || ASRUtils::IntrinsicArrayFunctionRegistry::is_intrinsic_function(var_name)) {
                 IntrinsicSignature signature = get_intrinsic_signature(var_name);
                 Vec<ASR::expr_t*> args;
                 bool signature_matched = false;
-                signature_matched = handle_intrinsic_node_args(
-                    x, args, signature.kwarg_names,
-                    signature.positional_args, signature.max_args,
-                    var_name, false);
+                signature_matched = handle_intrinsic_node_args(x,
+                                                               args,
+                                                               signature.kwarg_names,
+                                                               signature.positional_args,
+                                                               signature.max_args,
+                                                               var_name,
+                                                               false);
                 check_specific_type_intrinsics(specific_var_name, args, x.base.base.loc);
-                if( !signature_matched ) {
+                if (!signature_matched) {
                     diag.add(Diagnostic("No matching signature found for intrinsic " + var_name,
-                                        Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
-                if( ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function(var_name) ) {
-                    const bool are_all_args_evaluated { ASRUtils::all_args_evaluated(args, true) };
+                if (ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function(var_name)) {
+                    const bool are_all_args_evaluated{ ASRUtils::all_args_evaluated(args, true) };
                     fill_optional_kind_arg(var_name, args);
                     tmp = nullptr;
                     scalar_kind_arg(var_name, args);
-                    ASRUtils::create_intrinsic_function create_func =
-                        ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(var_name);
+                    ASRUtils::create_intrinsic_function create_func
+                        = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function(
+                            var_name);
 
                     std::vector<int> array_indices_in_args = find_array_indices_in_args(args);
-                    std::vector<std::string> inquiry_functions = {"epsilon", "radix", "range", "precision", "rank", "tiny", "huge", "bit_size", "new_line", "digits",
-                        "maxexponent", "minexponent", "storage_size", "kind", "is_contiguous", "loc"};
-                    if (are_all_args_evaluated &&
-                        (std::find(inquiry_functions.begin(), inquiry_functions.end(), var_name) == inquiry_functions.end()) &&
-                        !array_indices_in_args.empty())
-                    {
+                    std::vector<std::string> inquiry_functions
+                        = { "epsilon",      "radix",  "range",         "precision",
+                            "rank",         "tiny",   "huge",          "bit_size",
+                            "new_line",     "digits", "maxexponent",   "minexponent",
+                            "storage_size", "kind",   "is_contiguous", "loc" };
+                    if (are_all_args_evaluated
+                        && (std::find(inquiry_functions.begin(), inquiry_functions.end(), var_name)
+                            == inquiry_functions.end())
+                        && !array_indices_in_args.empty()) {
                         ASR::expr_t* arg = ASRUtils::expr_value(args[array_indices_in_args[0]]);
                         ASRUtils::ExprStmtDuplicator expr_duplicator(al);
                         ASR::expr_t* arg_ = expr_duplicator.duplicate_expr(arg);
-                        ASR::ArrayConstant_t* result_array = ASR::down_cast<ASR::ArrayConstant_t>(arg_);
-
-                        compiletime_broadcast_elemental_intrinsic(args, &result_array, array_indices_in_args, create_func, x.base.base.loc, al);;
+                        ASR::ArrayConstant_t* result_array
+                            = ASR::down_cast<ASR::ArrayConstant_t>(arg_);
+
+                        compiletime_broadcast_elemental_intrinsic(args,
+                                                                  &result_array,
+                                                                  array_indices_in_args,
+                                                                  create_func,
+                                                                  x.base.base.loc,
+                                                                  al);
+                        ;
                         tmp = (ASR::asr_t*) result_array;
                     } else {
                         tmp = create_func(al, x.base.base.loc, args, diag);
                     }
-                } else if ( ASRUtils::IntrinsicArrayFunctionRegistry::is_intrinsic_function(var_name) ) {
-                    if(var_name == "dot_product"){
+                } else if (ASRUtils::IntrinsicArrayFunctionRegistry::is_intrinsic_function(
+                               var_name)) {
+                    if (var_name == "dot_product") {
                         ASR::expr_t *matrix_a = args[0], *matrix_b = args[1];
-                        ASR::ttype_t *type_a = ASRUtils::expr_type(matrix_a);
-                        ASR::ttype_t *type_b = ASRUtils::expr_type(matrix_b);
-                        if((ASRUtils::is_real(*type_b) && ASRUtils::is_integer(*type_a)) ||
-                            (ASRUtils::is_complex(*type_b) && ASRUtils::is_integer(*type_a)) ||
-                            (ASRUtils::is_complex(*type_b) && ASRUtils::is_real(*type_a)) ){
-                            ImplicitCastRules::set_converted_value(al, x.base.base.loc, &matrix_a,
-                                            type_a, ASRUtils::type_get_past_allocatable(type_b), diag);
-                        } else if((ASRUtils::is_real(*type_a) && ASRUtils::is_integer(*type_b)) ||
-                                   (ASRUtils::is_complex(*type_a) && ASRUtils::is_integer(*type_b)) ||
-                                    (ASRUtils::is_complex(*type_a) && ASRUtils::is_real(*type_b)) ){
-                            ImplicitCastRules::set_converted_value(al, x.base.base.loc, &matrix_b,
-                                            type_b, ASRUtils::type_get_past_allocatable(type_a), diag);
+                        ASR::ttype_t* type_a = ASRUtils::expr_type(matrix_a);
+                        ASR::ttype_t* type_b = ASRUtils::expr_type(matrix_b);
+                        if ((ASRUtils::is_real(*type_b) && ASRUtils::is_integer(*type_a))
+                            || (ASRUtils::is_complex(*type_b) && ASRUtils::is_integer(*type_a))
+                            || (ASRUtils::is_complex(*type_b) && ASRUtils::is_real(*type_a))) {
+                            ImplicitCastRules::set_converted_value(
+                                al,
+                                x.base.base.loc,
+                                &matrix_a,
+                                type_a,
+                                ASRUtils::type_get_past_allocatable(type_b),
+                                diag);
+                        } else if ((ASRUtils::is_real(*type_a) && ASRUtils::is_integer(*type_b))
+                                   || (ASRUtils::is_complex(*type_a)
+                                       && ASRUtils::is_integer(*type_b))
+                                   || (ASRUtils::is_complex(*type_a)
+                                       && ASRUtils::is_real(*type_b))) {
+                            ImplicitCastRules::set_converted_value(
+                                al,
+                                x.base.base.loc,
+                                &matrix_b,
+                                type_b,
+                                ASRUtils::type_get_past_allocatable(type_a),
+                                diag);
                         }
                         args.p[0] = matrix_a;
                         args.p[1] = matrix_b;
                     }
-                    ASRUtils::create_intrinsic_function create_func =
-                        ASRUtils::IntrinsicArrayFunctionRegistry::get_create_function(var_name);
+                    ASRUtils::create_intrinsic_function create_func
+                        = ASRUtils::IntrinsicArrayFunctionRegistry::get_create_function(var_name);
                     tmp = create_func(al, x.base.base.loc, args, diag);
                 }
 
-            } else if( ASRUtils::IntrinsicImpureFunctionRegistry::is_intrinsic_function(var_name) ) {
+            } else if (ASRUtils::IntrinsicImpureFunctionRegistry::is_intrinsic_function(var_name)) {
                 Vec<ASR::expr_t*> args;
                 args.reserve(al, 1);
-                for( size_t i = 0; i < x.n_args; i++ ) {
+                for (size_t i = 0; i < x.n_args; i++) {
                     this->visit_expr(*x.m_args[i].m_end);
                     ASR::expr_t* expr_arg = ASRUtils::EXPR(tmp);
                     args.push_back(al, expr_arg);
                 }
-                ASRUtils::create_intrinsic_function create_func =
-                    ASRUtils::IntrinsicImpureFunctionRegistry::get_create_function(var_name);
+                ASRUtils::create_intrinsic_function create_func
+                    = ASRUtils::IntrinsicImpureFunctionRegistry::get_create_function(var_name);
                 tmp = create_func(al, x.base.base.loc, args, diag);
-            } else if( var_name == "size" ) {
+            } else if (var_name == "size") {
                 tmp = create_ArraySize(x);
-            } else if (var_name == "rank" ) {
+            } else if (var_name == "rank") {
                 tmp = create_ArrayRank(x);
-            } else if( var_name == "lbound" || var_name == "ubound" ) {
+            } else if (var_name == "lbound" || var_name == "ubound") {
                 tmp = create_ArrayBound(x, var_name);
-            } else if( var_name == "transfer" ) {
+            } else if (var_name == "transfer") {
                 tmp = create_BitCast(x);
-            } else if( var_name == "reshape" ) {
+            } else if (var_name == "reshape") {
                 tmp = create_ArrayReshape(x);
-            } else if( var_name == "iachar" ) {
+            } else if (var_name == "iachar") {
                 tmp = create_Iachar(x);
-            } else if( var_name == "len" ) {
+            } else if (var_name == "len") {
                 tmp = create_StringLen(x);
-            } else if( var_name == "null" ) {
+            } else if (var_name == "null") {
                 tmp = create_NullPointerConstant(x);
-            } else if( var_name == "associated" ) {
+            } else if (var_name == "associated") {
                 tmp = create_Associated(x);
-            } else if( var_name == "complex" ) {
+            } else if (var_name == "complex") {
                 tmp = create_Complex(x);
-            } else if( var_name == "is_contiguous" ) {
+            } else if (var_name == "is_contiguous") {
                 tmp = create_ArrayIsContiguous(x);
-            } else if( startswith(var_name, "_lfortran_") ) {
+            } else if (startswith(var_name, "_lfortran_")) {
                 // LFortran specific
-                
-                if ( var_name == "_lfortran_unsigned")
+
+                if (var_name == "_lfortran_unsigned")
                     tmp = create_unsigned_const(x);
-                else if ( var_name == "_lfortran_len")
+                else if (var_name == "_lfortran_len")
                     tmp = create_Len(x);
-                else if ( var_name == "_lfortran_get_item")
+                else if (var_name == "_lfortran_get_item")
                     tmp = create_GetItem(x);
-                else if ( var_name == "_lfortran_pop")
+                else if (var_name == "_lfortran_pop")
                     tmp = create_Pop(x);
-                else if ( var_name == "_lfortran_concat")
+                else if (var_name == "_lfortran_concat")
                     tmp = create_Concat(x);
-                else if ( var_name == "_lfortran_eq")
+                else if (var_name == "_lfortran_eq")
                     tmp = create_Eq(x);
-                else if ( var_name == "_lfortran_list_constant")
+                else if (var_name == "_lfortran_list_constant")
                     tmp = create_ListConstant(x);
-                else if ( var_name == "_lfortran_list_count")
+                else if (var_name == "_lfortran_list_count")
                     tmp = create_ListCount(x);
-                else if ( var_name == "_lfortran_set_constant")
+                else if (var_name == "_lfortran_set_constant")
                     tmp = create_SetConstant(x);
-                else if ( var_name == "_lfortran_dict_constant")
+                else if (var_name == "_lfortran_dict_constant")
                     tmp = create_DictConstant(x);
-                else if ( var_name == "_lfortran_tuple_constant")
+                else if (var_name == "_lfortran_tuple_constant")
                     tmp = create_TupleConstant(x);
-                else if (var_name == "_lfortran_str"){
+                else if (var_name == "_lfortran_str") {
                     tmp = create_CastToStr(x);
-                } else if (var_name == "_lfortran_ord"){
+                } else if (var_name == "_lfortran_ord") {
                     tmp = create_StrOrd(x);
                 }
             } else {
@@ -9698,47 +11809,53 @@ public:
         return resolve_intrinsic_function(x.base.base.loc, var_name);
     }
 
-    ASR::asr_t* create_PointerToCptr(const AST::FuncCallOrArray_t& x) {
+    ASR::asr_t* create_PointerToCptr(const AST::FuncCallOrArray_t& x)
+    {
         Vec<ASR::expr_t*> args;
-        std::vector<std::string> kwarg_names = {"X"};
+        std::vector<std::string> kwarg_names = { "X" };
         handle_intrinsic_node_args(x, args, kwarg_names, 1, 1, std::string("c_loc"));
-        ASR::expr_t *v_Var = args[0];
-        if( !ASR::is_a<ASR::GetPointer_t>(*v_Var) &&
-            !ASRUtils::is_pointer(ASRUtils::expr_type(v_Var)) ) {
-            ASR::ttype_t* ptr_type = ASRUtils::make_Pointer_t_util(al, x.base.base.loc,
+        ASR::expr_t* v_Var = args[0];
+        if (!ASR::is_a<ASR::GetPointer_t>(*v_Var)
+            && !ASRUtils::is_pointer(ASRUtils::expr_type(v_Var))) {
+            ASR::ttype_t* ptr_type = ASRUtils::make_Pointer_t_util(
+                al,
+                x.base.base.loc,
                 ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(v_Var)));
-            v_Var = ASRUtils::EXPR(ASR::make_GetPointer_t(al, x.base.base.loc,
-                            v_Var, ptr_type, nullptr));
+            v_Var = ASRUtils::EXPR(
+                ASR::make_GetPointer_t(al, x.base.base.loc, v_Var, ptr_type, nullptr));
         }
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_CPtr_t(al, x.base.base.loc));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_CPtr_t(al, x.base.base.loc));
         return ASR::make_PointerToCPtr_t(al, x.base.base.loc, v_Var, type, nullptr);
     }
 
-    ASR::asr_t* handle_intrinsic_float_dfloat(Allocator &al, Vec<ASR::call_arg_t> args,
-                                        const Location &loc, int kind) {
+    ASR::asr_t* handle_intrinsic_float_dfloat(Allocator& al,
+                                              Vec<ASR::call_arg_t> args,
+                                              const Location& loc,
+                                              int kind)
+    {
         ASR::expr_t *arg = nullptr, *value = nullptr;
-        ASR::ttype_t *type = nullptr;
+        ASR::ttype_t* type = nullptr;
         if (args.size() > 0) {
             arg = args[0].m_value;
             type = ASRUtils::expr_type(arg);
         }
-        ASR::ttype_t *to_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, kind));
+        ASR::ttype_t* to_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, kind));
         if (!arg) {
             return ASR::make_RealConstant_t(al, loc, 0.0, to_type);
         }
         if (ASRUtils::is_integer(*type)) {
             if (ASRUtils::expr_value(arg) != nullptr) {
-                double dval = ASR::down_cast<ASR::IntegerConstant_t>(
-                                        ASRUtils::expr_value(arg))->m_n;
-                value =  ASR::down_cast<ASR::expr_t>(make_RealConstant_t(al,
-                                loc, dval, to_type));
-            }
-            return (ASR::asr_t *)ASR::down_cast<ASR::expr_t>(ASR::make_Cast_t(
-                al, loc, arg, ASR::cast_kindType::IntegerToReal,
-                to_type, value));
+                double dval
+                    = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(arg))->m_n;
+                value = ASR::down_cast<ASR::expr_t>(make_RealConstant_t(al, loc, dval, to_type));
+            }
+            return (ASR::asr_t*) ASR::down_cast<ASR::expr_t>(
+                ASR::make_Cast_t(al, loc, arg, ASR::cast_kindType::IntegerToReal, to_type, value));
         } else {
             diag.add(Diagnostic("Argument of intrinsic must be an integer",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         // TODO: Make this work if the argument is, let's say, a class.
@@ -9748,20 +11865,19 @@ public:
     // special handling of 'dble', 'float', 'dfloat', 'shifta' intrinsics
     // maybe once those are moved to IntrinsicElementalFunction, this might
     // not be needed
-    ASR::asr_t* handle_intrinsics_dble_float_dfloat_shifta(
-        const AST::FuncCallOrArray_t &x,
-        Allocator &al
-    ) {
-        ASR::asr_t* asr_node { nullptr };
+    ASR::asr_t* handle_intrinsics_dble_float_dfloat_shifta(const AST::FuncCallOrArray_t& x,
+                                                           Allocator& al)
+    {
+        ASR::asr_t* asr_node{ nullptr };
         std::string var_name = to_lower(x.m_func);
         Vec<ASR::call_arg_t> args;
         if (var_name == "dble") {
             visit_expr_list(x.m_args, x.n_args, args);
             asr_node = handle_intrinsic_dble(al, args, x.base.base.loc);
-        } else if (var_name == "float" ) {
+        } else if (var_name == "float") {
             visit_expr_list(x.m_args, x.n_args, args);
             asr_node = handle_intrinsic_float_dfloat(al, args, x.base.base.loc, 4);
-        } else if (var_name == "dfloat" ) {
+        } else if (var_name == "dfloat") {
             visit_expr_list(x.m_args, x.n_args, args);
             asr_node = handle_intrinsic_float_dfloat(al, args, x.base.base.loc, 8);
         } else if (var_name == "shifta") {
@@ -9771,54 +11887,50 @@ public:
         return asr_node;
     }
 
-    ASR::asr_t* handle_intrinsic_dble(Allocator &al, Vec<ASR::call_arg_t> args,
-                                        const Location &loc) {
+    ASR::asr_t* handle_intrinsic_dble(Allocator& al, Vec<ASR::call_arg_t> args, const Location& loc)
+    {
         ASR::expr_t *arg = nullptr, *value = nullptr;
-        ASR::ttype_t *type = nullptr;
+        ASR::ttype_t* type = nullptr;
         if (args.size() > 0) {
             arg = args[0].m_value;
             type = ASRUtils::expr_type(arg);
         }
-        ASR::ttype_t *to_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, 8));
+        ASR::ttype_t* to_type = ASRUtils::TYPE(ASR::make_Real_t(al, loc, 8));
         if (!arg) {
             return ASR::make_RealConstant_t(al, loc, 0.0, to_type);
         }
         if (ASRUtils::is_integer(*type)) {
             if (ASRUtils::expr_value(arg) != nullptr) {
-                double dval = ASR::down_cast<ASR::IntegerConstant_t>(
-                                        ASRUtils::expr_value(arg))->m_n;
-                value =  ASR::down_cast<ASR::expr_t>(make_RealConstant_t(al,
-                                loc, dval, to_type));
-            }
-            return (ASR::asr_t *)ASR::down_cast<ASR::expr_t>(ASR::make_Cast_t(
-                al, loc, arg, ASR::cast_kindType::IntegerToReal,
-                to_type, value));
+                double dval
+                    = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(arg))->m_n;
+                value = ASR::down_cast<ASR::expr_t>(make_RealConstant_t(al, loc, dval, to_type));
+            }
+            return (ASR::asr_t*) ASR::down_cast<ASR::expr_t>(
+                ASR::make_Cast_t(al, loc, arg, ASR::cast_kindType::IntegerToReal, to_type, value));
         } else if (ASRUtils::is_logical(*type)) {
             if (ASRUtils::expr_value(arg) != nullptr) {
-                double dval = ASR::down_cast<ASR::LogicalConstant_t>(
-                                        ASRUtils::expr_value(arg))->m_value;
-                value =  ASR::down_cast<ASR::expr_t>(make_RealConstant_t(al,
-                                loc, dval, to_type));
-            }
-            return (ASR::asr_t *)ASR::down_cast<ASR::expr_t>(ASR::make_Cast_t(
-                al, loc, arg, ASR::cast_kindType::LogicalToReal,
-                to_type, value));
+                double dval
+                    = ASR::down_cast<ASR::LogicalConstant_t>(ASRUtils::expr_value(arg))->m_value;
+                value = ASR::down_cast<ASR::expr_t>(make_RealConstant_t(al, loc, dval, to_type));
+            }
+            return (ASR::asr_t*) ASR::down_cast<ASR::expr_t>(
+                ASR::make_Cast_t(al, loc, arg, ASR::cast_kindType::LogicalToReal, to_type, value));
         } else if (ASRUtils::is_real(*type)) {
             // float() always returns 64-bit floating point numbers.
             if (ASRUtils::extract_kind_from_ttype_t(type) != 8) {
-                return (ASR::asr_t *)ASR::down_cast<ASR::expr_t>(ASR::make_Cast_t(
-                    al, loc, arg, ASR::cast_kindType::RealToReal,
-                    to_type, value));
+                return (ASR::asr_t*) ASR::down_cast<ASR::expr_t>(
+                    ASR::make_Cast_t(al, loc, arg, ASR::cast_kindType::RealToReal, to_type, value));
             }
-            return (ASR::asr_t *)arg;
+            return (ASR::asr_t*) arg;
         } else if (ASRUtils::is_complex(*type)) {
-            return (ASR::asr_t *)ASR::down_cast<ASR::expr_t>(ASR::make_Cast_t(
-                    al, loc, arg, ASR::cast_kindType::ComplexToReal,
-                    to_type, value));
+            return (ASR::asr_t*) ASR::down_cast<ASR::expr_t>(
+                ASR::make_Cast_t(al, loc, arg, ASR::cast_kindType::ComplexToReal, to_type, value));
         } else {
             std::string stype = ASRUtils::type_to_str_fortran_expr(type, arg);
             diag.add(Diagnostic("Conversion of '" + stype + "' to float is not Implemented",
-                                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
         // TODO: Make this work if the argument is, let's say, a class.
@@ -9826,10 +11938,14 @@ public:
     }
 
     template <class Call>
-    void create_implicit_interface_function(const Call &x, std::string func_name, bool add_return, ASR::ttype_t* old_type) {
+    void create_implicit_interface_function(const Call& x,
+                                            std::string func_name,
+                                            bool add_return,
+                                            ASR::ttype_t* old_type)
+    {
         is_implicit_interface = true;
         implicit_interface_parent_scope = current_scope;
-        SymbolTable *parent_scope = current_scope;
+        SymbolTable* parent_scope = current_scope;
         current_scope = al.make_new<SymbolTable>(parent_scope);
 
         Vec<ASR::call_arg_t> c_args;
@@ -9838,26 +11954,32 @@ public:
         Vec<ASR::expr_t*> args;
         args.reserve(al, x.n_args);
         std::string sym_name = to_lower(func_name);
-        for (size_t i=0; i<x.n_args; i++) {
+        for (size_t i = 0; i < x.n_args; i++) {
             std::string arg_name = sym_name + "_arg_" + std::to_string(i);
             arg_name = to_lower(arg_name);
-            ASR::expr_t *var_expr = c_args[i].m_value;
-            ASR::symbol_t *v;
-            if (ASR::is_a<ASR::Var_t>(*var_expr) &&
-                    ASR::is_a<ASR::Function_t>(*ASR::down_cast<ASR::Var_t>(var_expr)->m_v)) {
+            ASR::expr_t* var_expr = c_args[i].m_value;
+            ASR::symbol_t* v;
+            if (ASR::is_a<ASR::Var_t>(*var_expr)
+                && ASR::is_a<ASR::Function_t>(*ASR::down_cast<ASR::Var_t>(var_expr)->m_v)) {
                 v = ASR::down_cast<ASR::Var_t>(var_expr)->m_v;
             } else {
-                ASR::ttype_t *var_type = ASRUtils::expr_type(var_expr);
+                ASR::ttype_t* var_type = ASRUtils::expr_type(var_expr);
                 if (ASRUtils::is_array(var_type)) {
                     // For arrays like A(n, m) we use A(*) in BindC, so that
                     // the C ABI is just a pointer
-                    ASR::Array_t* array_type = ASR::down_cast<ASR::Array_t>(
-                        ASRUtils::type_get_past_allocatable(ASRUtils::type_get_past_pointer(var_type))
-                    );
-                    var_type = ASRUtils::duplicate_type_with_empty_dims(al, var_type,
-                        ( array_type->m_physical_type == ASR::array_physical_typeType::UnboundedPointerArray ) ?
-                        array_type->m_physical_type : ASR::array_physical_typeType::PointerArray, true);
-                } else if (ASR::is_a<ASR::ArrayItem_t>(*var_expr) && compiler_options.legacy_array_sections) {
+                    ASR::Array_t* array_type
+                        = ASR::down_cast<ASR::Array_t>(ASRUtils::type_get_past_allocatable(
+                            ASRUtils::type_get_past_pointer(var_type)));
+                    var_type = ASRUtils::duplicate_type_with_empty_dims(
+                        al,
+                        var_type,
+                        (array_type->m_physical_type
+                         == ASR::array_physical_typeType::UnboundedPointerArray)
+                            ? array_type->m_physical_type
+                            : ASR::array_physical_typeType::PointerArray,
+                        true);
+                } else if (ASR::is_a<ASR::ArrayItem_t>(*var_expr)
+                           && compiler_options.legacy_array_sections) {
                     ASR::symbol_t* func_sym = parent_scope->resolve_symbol(func_name);
                     ASR::Function_t* func = nullptr;
                     if (func_sym) {
@@ -9866,60 +11988,94 @@ public:
                             func = ASR::down_cast<ASR::Function_t>(func_sym);
                         }
                     }
-                    if (func && func->n_args > 0 && func->n_args <= x.n_args &&
-                        ASRUtils::is_array(ASRUtils::expr_type(func->m_args[i]))) {
-                        ASR::ttype_t *expected_arg_type = ASRUtils::expr_type(func->m_args[i]);
-                        ASR::array_physical_typeType expected_phys = ASRUtils::extract_physical_type(expected_arg_type);
-                        var_type = ASRUtils::duplicate_type_with_empty_dims(al, expected_arg_type, expected_phys, true);
+                    if (func && func->n_args > 0 && func->n_args <= x.n_args
+                        && ASRUtils::is_array(ASRUtils::expr_type(func->m_args[i]))) {
+                        ASR::ttype_t* expected_arg_type = ASRUtils::expr_type(func->m_args[i]);
+                        ASR::array_physical_typeType expected_phys
+                            = ASRUtils::extract_physical_type(expected_arg_type);
+                        var_type = ASRUtils::duplicate_type_with_empty_dims(
+                            al, expected_arg_type, expected_phys, true);
                     }
                 }
                 SetChar variable_dependencies_vec;
                 variable_dependencies_vec.reserve(al, 1);
                 ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, var_type);
-                v = ASR::down_cast<ASR::symbol_t>(
-                    ASRUtils::make_Variable_t_util(al, x.base.base.loc,
-                    current_scope, s2c(al, arg_name), variable_dependencies_vec.p,
-                    variable_dependencies_vec.size(), ASRUtils::intent_unspecified,
-                    nullptr, nullptr, ASR::storage_typeType::Default, var_type, ASRUtils::get_struct_sym_from_struct_expr(var_expr),
-                    ASR::abiType::BindC, ASR::Public, ASR::presenceType::Required,
+                v = ASR::down_cast<ASR::symbol_t>(ASRUtils::make_Variable_t_util(
+                    al,
+                    x.base.base.loc,
+                    current_scope,
+                    s2c(al, arg_name),
+                    variable_dependencies_vec.p,
+                    variable_dependencies_vec.size(),
+                    ASRUtils::intent_unspecified,
+                    nullptr,
+                    nullptr,
+                    ASR::storage_typeType::Default,
+                    var_type,
+                    ASRUtils::get_struct_sym_from_struct_expr(var_expr),
+                    ASR::abiType::BindC,
+                    ASR::Public,
+                    ASR::presenceType::Required,
                     false));
                 current_scope->add_or_overwrite_symbol(arg_name, v);
             }
             LCOMPILERS_ASSERT(v != nullptr)
-            args.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc,
-                v)));
+            args.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, v)));
         }
-        ASR::ttype_t *type = old_type;
-        ASR::expr_t *to_return = nullptr;
+        ASR::ttype_t* type = old_type;
+        ASR::expr_t* to_return = nullptr;
         if (add_return) {
             std::string return_var_name = sym_name + "_return_var_name";
             SetChar variable_dependencies_vec;
             variable_dependencies_vec.reserve(al, 1);
             ASRUtils::collect_variable_dependencies(al, variable_dependencies_vec, type);
-            ASR::asr_t *return_var = ASRUtils::make_Variable_t_util(al, x.base.base.loc,
-                current_scope, s2c(al, return_var_name), variable_dependencies_vec.p,
-                variable_dependencies_vec.size(), ASRUtils::intent_return_var,
-                nullptr, nullptr, ASR::storage_typeType::Default, type, nullptr,
-                ASR::abiType::BindC, ASR::Public, ASR::presenceType::Required,
-                false);
+            ASR::asr_t* return_var
+                = ASRUtils::make_Variable_t_util(al,
+                                                 x.base.base.loc,
+                                                 current_scope,
+                                                 s2c(al, return_var_name),
+                                                 variable_dependencies_vec.p,
+                                                 variable_dependencies_vec.size(),
+                                                 ASRUtils::intent_return_var,
+                                                 nullptr,
+                                                 nullptr,
+                                                 ASR::storage_typeType::Default,
+                                                 type,
+                                                 nullptr,
+                                                 ASR::abiType::BindC,
+                                                 ASR::Public,
+                                                 ASR::presenceType::Required,
+                                                 false);
             current_scope->add_symbol(return_var_name, ASR::down_cast<ASR::symbol_t>(return_var));
-            to_return = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc,
-                ASR::down_cast<ASR::symbol_t>(return_var)));
-        }
-
-        tmp = ASRUtils::make_Function_t_util(
-            al, x.base.base.loc,
-            /* a_symtab */ current_scope,
-            /* a_name */ s2c(al, sym_name),
-            nullptr, 0,
-            /* a_args */ args.p,
-            /* n_args */ args.size(),
-            /* a_body */ nullptr,
-            /* n_body */ 0,
-            /* a_return_var */ to_return,
-            ASR::abiType::BindC, ASR::accessType::Public, ASR::deftypeType::Interface,
-            nullptr, false, false, false, false, false, nullptr, 0,
-            false, false, false);
+            to_return = ASRUtils::EXPR(
+                ASR::make_Var_t(al, x.base.base.loc, ASR::down_cast<ASR::symbol_t>(return_var)));
+        }
+
+        tmp = ASRUtils::make_Function_t_util(al,
+                                             x.base.base.loc,
+                                             /* a_symtab */ current_scope,
+                                             /* a_name */ s2c(al, sym_name),
+                                             nullptr,
+                                             0,
+                                             /* a_args */ args.p,
+                                             /* n_args */ args.size(),
+                                             /* a_body */ nullptr,
+                                             /* n_body */ 0,
+                                             /* a_return_var */ to_return,
+                                             ASR::abiType::BindC,
+                                             ASR::accessType::Public,
+                                             ASR::deftypeType::Interface,
+                                             nullptr,
+                                             false,
+                                             false,
+                                             false,
+                                             false,
+                                             false,
+                                             nullptr,
+                                             0,
+                                             false,
+                                             false,
+                                             false);
         parent_scope->add_or_overwrite_symbol(sym_name, ASR::down_cast<ASR::symbol_t>(tmp));
         current_scope = parent_scope;
 
@@ -9927,7 +12083,8 @@ public:
         implicit_interface_parent_scope = nullptr;
     }
 
-    void visit_DataImpliedDo(const AST::DataImpliedDo_t& x) {
+    void visit_DataImpliedDo(const AST::DataImpliedDo_t& x)
+    {
         Vec<ASR::expr_t*> a_values_vec;
         ASR::expr_t *a_start, *a_end, *a_increment;
         a_start = a_end = a_increment = nullptr;
@@ -9936,12 +12093,11 @@ public:
         Vec<ASR::ttype_t*> type_tuple;
         type_tuple.reserve(al, 1);
         bool unique_type = true;
-        for( size_t i = 0; i < x.n_object_list; i++ ) {
+        for (size_t i = 0; i < x.n_object_list; i++) {
             this->visit_expr(*(x.m_object_list[i]));
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
-            ASR::ttype_t* type_ = ASRUtils::type_get_past_allocatable(
-                ASRUtils::expr_type(expr));
-            if( type == nullptr ) {
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
+            ASR::ttype_t* type_ = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(expr));
+            if (type == nullptr) {
                 type = type_;
             } else {
                 if (!unique_type || !ASRUtils::types_equal(type_, type, expr, expr)) {
@@ -9956,7 +12112,7 @@ public:
         a_start = ASRUtils::EXPR(tmp);
         this->visit_expr(*(x.m_end));
         a_end = ASRUtils::EXPR(tmp);
-        if( x.m_increment != nullptr ) {
+        if (x.m_increment != nullptr) {
             this->visit_expr(*(x.m_increment));
             a_increment = ASRUtils::EXPR(tmp);
         }
@@ -9965,64 +12121,89 @@ public:
 
         ASR::symbol_t* a_sym = current_scope->resolve_symbol(to_lower(x.m_var));
         if (a_sym == nullptr) {
-            diag.add(Diagnostic("The implied do loop variable '" +
-                to_lower(x.m_var) + "' is not declared",
-                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("The implied do loop variable '" + to_lower(x.m_var)
+                                    + "' is not declared",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         ASR::expr_t* a_var = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, a_sym));
-        if( !unique_type ) {
-            type = ASRUtils::TYPE(ASR::make_Tuple_t(al, x.base.base.loc, type_tuple.p, type_tuple.size()));
-        }
-        tmp = ASR::make_ImpliedDoLoop_t(al, x.base.base.loc, a_values, n_values,
-                                        a_var, a_start, a_end, a_increment,
-                                        type, nullptr);
-    }
-
-    bool contains_loop_vars(ASR::expr_t* expr, std::vector<ASR::symbol_t*>& loop_vars) {
-
-        class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValuesVisitor> {
-            public:
+        if (!unique_type) {
+            type = ASRUtils::TYPE(
+                ASR::make_Tuple_t(al, x.base.base.loc, type_tuple.p, type_tuple.size()));
+        }
+        tmp = ASR::make_ImpliedDoLoop_t(al,
+                                        x.base.base.loc,
+                                        a_values,
+                                        n_values,
+                                        a_var,
+                                        a_start,
+                                        a_end,
+                                        a_increment,
+                                        type,
+                                        nullptr);
+    }
+
+    bool contains_loop_vars(ASR::expr_t* expr, std::vector<ASR::symbol_t*>& loop_vars)
+    {
+        class ImpliedDoLoopValuesVisitor : public ASR::BaseWalkVisitor<ImpliedDoLoopValuesVisitor>
+        {
+        public:
             std::vector<ASR::symbol_t*>& loop_vars;
-            bool &contain_loop_vars;
+            bool& contain_loop_vars;
 
-            ImpliedDoLoopValuesVisitor(std::vector<ASR::symbol_t*>& loop_vars, bool &contain_loop_vars) :
-                loop_vars(loop_vars), contain_loop_vars(contain_loop_vars) {}
+            ImpliedDoLoopValuesVisitor(std::vector<ASR::symbol_t*>& loop_vars,
+                                       bool& contain_loop_vars)
+                : loop_vars(loop_vars)
+                , contain_loop_vars(contain_loop_vars)
+            {
+            }
 
-            void visit_Var(const ASR::Var_t &x) {
+            void visit_Var(const ASR::Var_t& x)
+            {
                 ASR::symbol_t* sym = x.m_v;
                 if (std::find(loop_vars.begin(), loop_vars.end(), sym) != loop_vars.end()) {
                     contain_loop_vars &= true;
                     return;
                 }
-                ASR::Variable_t* var = ASR::down_cast<ASR::Variable_t>(
-                                            ASRUtils::symbol_get_past_external(sym));
+                ASR::Variable_t* var
+                    = ASR::down_cast<ASR::Variable_t>(ASRUtils::symbol_get_past_external(sym));
                 contain_loop_vars &= ASRUtils::is_value_constant(var->m_value);
                 return;
             }
 
-            void visit_IntegerBinOp(const ASR::IntegerBinOp_t &x) {
+            void visit_IntegerBinOp(const ASR::IntegerBinOp_t& x)
+            {
                 this->visit_expr(*x.m_left);
-                if (!contain_loop_vars) return;
+                if (!contain_loop_vars)
+                    return;
                 this->visit_expr(*x.m_right);
-                if (!contain_loop_vars) return;
+                if (!contain_loop_vars)
+                    return;
             }
 
-            void visit_RealBinOp(const ASR::RealBinOp_t &x) {
+            void visit_RealBinOp(const ASR::RealBinOp_t& x)
+            {
                 this->visit_expr(*x.m_left);
-                if (!contain_loop_vars) return;
+                if (!contain_loop_vars)
+                    return;
                 this->visit_expr(*x.m_right);
-                if (!contain_loop_vars) return;
+                if (!contain_loop_vars)
+                    return;
             }
 
-            void visit_IntrinsicElementalFunction(const ASR::IntrinsicElementalFunction_t &x) {
+            void visit_IntrinsicElementalFunction(const ASR::IntrinsicElementalFunction_t& x)
+            {
                 for (size_t i = 0; i < x.n_args; i++) {
                     this->visit_expr(*x.m_args[i]);
-                    if (!contain_loop_vars) return;
+                    if (!contain_loop_vars)
+                        return;
                 }
             }
 
-            void visit_IntrinsicArrayFunction(const ASR::IntrinsicArrayFunction_t &/*x*/) {
+            void visit_IntrinsicArrayFunction(const ASR::IntrinsicArrayFunction_t& /*x*/)
+            {
                 // TODO: will have to handle this
                 contain_loop_vars = false;
             }
@@ -10034,17 +12215,23 @@ public:
         return contain_loop_vars;
     }
 
-    bool is_compiletime_implied_do_loop(ASR::ImpliedDoLoop_t* idl, std::vector<ASR::symbol_t*>& loop_vars) {
-        if ((!ASRUtils::is_value_constant(idl->m_start) && !contains_loop_vars(idl->m_start, loop_vars)) ||
-            (!ASRUtils::is_value_constant(idl->m_end) && !contains_loop_vars(idl->m_end, loop_vars)) ||
-            (idl->m_increment != nullptr && !ASRUtils::is_value_constant(idl->m_increment) && !contains_loop_vars(idl->m_increment, loop_vars))) {
+    bool is_compiletime_implied_do_loop(ASR::ImpliedDoLoop_t* idl,
+                                        std::vector<ASR::symbol_t*>& loop_vars)
+    {
+        if ((!ASRUtils::is_value_constant(idl->m_start)
+             && !contains_loop_vars(idl->m_start, loop_vars))
+            || (!ASRUtils::is_value_constant(idl->m_end)
+                && !contains_loop_vars(idl->m_end, loop_vars))
+            || (idl->m_increment != nullptr && !ASRUtils::is_value_constant(idl->m_increment)
+                && !contains_loop_vars(idl->m_increment, loop_vars))) {
             return false;
         }
 
         for (size_t i = 0; i < idl->n_values; i++) {
             ASR::expr_t* expr = idl->m_values[i];
             if (ASR::is_a<ASR::ImpliedDoLoop_t>(*expr)) {
-                if (!is_compiletime_implied_do_loop(ASR::down_cast<ASR::ImpliedDoLoop_t>(expr), loop_vars)) {
+                if (!is_compiletime_implied_do_loop(ASR::down_cast<ASR::ImpliedDoLoop_t>(expr),
+                                                    loop_vars)) {
                     return false;
                 }
             }
@@ -10058,37 +12245,47 @@ public:
         return true;
     }
 
-    void fetch_implied_do_loop_variables(ASR::ImpliedDoLoop_t* idl, std::vector<ASR::symbol_t*>& loop_vars) {
+    void fetch_implied_do_loop_variables(ASR::ImpliedDoLoop_t* idl,
+                                         std::vector<ASR::symbol_t*>& loop_vars)
+    {
         ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(idl->m_var);
         loop_vars.push_back(var->m_v);
         for (size_t i = 0; i < idl->n_values; i++) {
             ASR::expr_t* expr = idl->m_values[i];
             if (ASR::is_a<ASR::ImpliedDoLoop_t>(*expr)) {
-                fetch_implied_do_loop_variables(ASR::down_cast<ASR::ImpliedDoLoop_t>(expr), loop_vars);
+                fetch_implied_do_loop_variables(ASR::down_cast<ASR::ImpliedDoLoop_t>(expr),
+                                                loop_vars);
             }
         }
         return;
     }
 
-    template<typename T>
-    T get_constant_value(ASR::expr_t* expr, ImpliedDoLoopValuesVisitor& visitor) {
+    template <typename T>
+    T get_constant_value(ASR::expr_t* expr, ImpliedDoLoopValuesVisitor& visitor)
+    {
         visitor.value = nullptr;
         visitor.visit_expr(*expr);
         T res;
-        if constexpr (std::is_same_v<T,bool>) {
+        if constexpr (std::is_same_v<T, bool>) {
             res = ASR::down_cast<ASR::LogicalConstant_t>(visitor.value)->m_value;
-        } else if constexpr (std::is_same_v<T,int>) {
+        } else if constexpr (std::is_same_v<T, int>) {
             res = ASR::down_cast<ASR::IntegerConstant_t>(visitor.value)->m_n;
-        } else if constexpr (std::is_same_v<T,float> || std::is_same_v<T,double>) {
+        } else if constexpr (std::is_same_v<T, float> || std::is_same_v<T, double>) {
             res = ASR::down_cast<ASR::RealConstant_t>(visitor.value)->m_r;
-        } else if constexpr (std::is_same_v<T,char*>) {
+        } else if constexpr (std::is_same_v<T, char*>) {
             res = ASR::down_cast<ASR::StringConstant_t>(visitor.value)->m_s;
         }
         return res;
     }
 
-    template<typename T>
-    void populate_compiletime_array_for_idl(ASR::ImpliedDoLoop_t* idl, Vec<T> &array, std::vector<ASR::symbol_t*> &loop_vars, std::vector<int> &loop_indices, int &curr_nesting_level, int &itr) {
+    template <typename T>
+    void populate_compiletime_array_for_idl(ASR::ImpliedDoLoop_t* idl,
+                                            Vec<T>& array,
+                                            std::vector<ASR::symbol_t*>& loop_vars,
+                                            std::vector<int>& loop_indices,
+                                            int& curr_nesting_level,
+                                            int& itr)
+    {
         /*
         (j, (i * j, i=1, 3), j=1, 2)
         gets translated via cpp code
@@ -10104,7 +12301,8 @@ public:
             }
         }
         */
-        ImpliedDoLoopValuesVisitor index_bound_visitor(al, loop_vars, loop_indices, nullptr, idl->m_type, diag);
+        ImpliedDoLoopValuesVisitor index_bound_visitor(
+            al, loop_vars, loop_indices, nullptr, idl->m_type, diag);
         int end;
         if (ASRUtils::expr_value(idl->m_end)) {
             end = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(idl->m_end))->m_n;
@@ -10120,7 +12318,9 @@ public:
         int increment;
         if (idl->m_increment) {
             if (ASRUtils::expr_value(idl->m_increment)) {
-                increment = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(idl->m_increment))->m_n;
+                increment
+                    = ASR::down_cast<ASR::IntegerConstant_t>(ASRUtils::expr_value(idl->m_increment))
+                          ->m_n;
             } else {
                 increment = get_constant_value<int>(idl->m_increment, index_bound_visitor);
             }
@@ -10128,14 +12328,21 @@ public:
             increment = 1;
         }
 
-        for ( int j = start; j <= end; j += increment ) {
+        for (int j = start; j <= end; j += increment) {
             loop_indices[curr_nesting_level] = j;
-            for ( size_t i = 0; i < idl->n_values; i++ ) {
+            for (size_t i = 0; i < idl->n_values; i++) {
                 if (ASR::is_a<ASR::ImpliedDoLoop_t>(*idl->m_values[i])) {
                     curr_nesting_level++;
-                    populate_compiletime_array_for_idl(ASR::down_cast<ASR::ImpliedDoLoop_t>(idl->m_values[i]), array, loop_vars, loop_indices, curr_nesting_level, itr);
+                    populate_compiletime_array_for_idl(
+                        ASR::down_cast<ASR::ImpliedDoLoop_t>(idl->m_values[i]),
+                        array,
+                        loop_vars,
+                        loop_indices,
+                        curr_nesting_level,
+                        itr);
                 } else {
-                    ImpliedDoLoopValuesVisitor visitor(al, loop_vars, loop_indices, nullptr, idl->m_type, diag);
+                    ImpliedDoLoopValuesVisitor visitor(
+                        al, loop_vars, loop_indices, nullptr, idl->m_type, diag);
                     array.push_back(al, get_constant_value<T>(idl->m_values[i], visitor));
                     itr++;
                 }
@@ -10144,7 +12351,8 @@ public:
         curr_nesting_level--;
     }
 
-    void visit_ImpliedDoLoop(const AST::ImpliedDoLoop_t& x) {
+    void visit_ImpliedDoLoop(const AST::ImpliedDoLoop_t& x)
+    {
         idl_nesting_level++;
         Vec<ASR::expr_t*> a_values_vec;
         ASR::expr_t *a_start, *a_end, *a_increment;
@@ -10154,12 +12362,11 @@ public:
         Vec<ASR::ttype_t*> type_tuple;
         type_tuple.reserve(al, 1);
         bool unique_type = true;
-        for( size_t i = 0; i < x.n_values; i++ ) {
+        for (size_t i = 0; i < x.n_values; i++) {
             this->visit_expr(*(x.m_values[i]));
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
-            ASR::ttype_t* type_ = ASRUtils::type_get_past_allocatable(
-                ASRUtils::expr_type(expr));
-            if( type == nullptr ) {
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
+            ASR::ttype_t* type_ = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(expr));
+            if (type == nullptr) {
                 type = type_;
             } else {
                 if (!unique_type || !ASRUtils::types_equal(type_, type, expr, expr)) {
@@ -10174,7 +12381,7 @@ public:
         a_start = ASRUtils::EXPR(tmp);
         this->visit_expr(*(x.m_end));
         a_end = ASRUtils::EXPR(tmp);
-        if( x.m_increment != nullptr ) {
+        if (x.m_increment != nullptr) {
             this->visit_expr(*(x.m_increment));
             a_increment = ASRUtils::EXPR(tmp);
         }
@@ -10183,22 +12390,33 @@ public:
 
         ASR::symbol_t* a_sym = current_scope->resolve_symbol(to_lower(x.m_var));
         if (a_sym == nullptr) {
-            diag.add(Diagnostic("The implied do loop variable '" +
-                to_lower(x.m_var) + "' is not declared",
-                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("The implied do loop variable '" + to_lower(x.m_var)
+                                    + "' is not declared",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         ASR::expr_t* a_var = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, a_sym));
-        if( !unique_type ) {
-            type = ASRUtils::TYPE(ASR::make_Tuple_t(al, x.base.base.loc, type_tuple.p, type_tuple.size()));
-        }
-        tmp = ASR::make_ImpliedDoLoop_t(al, x.base.base.loc, a_values, n_values,
-                                        a_var, a_start, a_end, a_increment,
-                                        type, nullptr);
+        if (!unique_type) {
+            type = ASRUtils::TYPE(
+                ASR::make_Tuple_t(al, x.base.base.loc, type_tuple.p, type_tuple.size()));
+        }
+        tmp = ASR::make_ImpliedDoLoop_t(al,
+                                        x.base.base.loc,
+                                        a_values,
+                                        n_values,
+                                        a_var,
+                                        a_start,
+                                        a_end,
+                                        a_increment,
+                                        type,
+                                        nullptr);
         ASR::ImpliedDoLoop_t* idl = (ASR::ImpliedDoLoop_t*) tmp;
 
         // fetch loop variables
-        std::vector<ASR::symbol_t*> loop_vars; fetch_implied_do_loop_variables(idl, loop_vars);
+        std::vector<ASR::symbol_t*> loop_vars;
+        fetch_implied_do_loop_variables(idl, loop_vars);
         if (is_body_visitor) {
             idl_nesting_level--;
             return;
@@ -10207,78 +12425,110 @@ public:
         bool is_compiletime = is_compiletime_implied_do_loop(idl, loop_vars);
 
         if (is_compiletime && idl_nesting_level == 1) {
-            std::vector<int> loop_indices; // fill it with all zero
+            std::vector<int> loop_indices;  // fill it with all zero
             for (size_t i = 0; i < loop_vars.size(); i++) {
                 loop_indices.push_back(0);
             }
 
-            void *data = nullptr;
+            void* data = nullptr;
             int itr = 0, curr_nesting_level = 0;
             // TODO: handle multiple types
             // populate compiletime array
             if (ASRUtils::is_integer(*type)) {
-                Vec<int> array; array.reserve(al, 1);
-                populate_compiletime_array_for_idl(idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
+                Vec<int> array;
+                array.reserve(al, 1);
+                populate_compiletime_array_for_idl(
+                    idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
                 data = &array.p[0];
             } else if (ASRUtils::is_logical(*type)) {
-                Vec<bool> array; array.reserve(al, 1);
-                populate_compiletime_array_for_idl(idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
+                Vec<bool> array;
+                array.reserve(al, 1);
+                populate_compiletime_array_for_idl(
+                    idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
                 data = &array.p[0];
             } else if (ASRUtils::is_real(*type)) {
                 int kind = ASRUtils::extract_kind_from_ttype_t(type);
 
                 if (kind == 4) {
-                    Vec<float> array; array.reserve(al, 1);
-                    populate_compiletime_array_for_idl(idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
+                    Vec<float> array;
+                    array.reserve(al, 1);
+                    populate_compiletime_array_for_idl(
+                        idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
                     data = &array.p[0];
                 } else if (kind == 8) {
-                    Vec<double> array; array.reserve(al, 1);
-                    populate_compiletime_array_for_idl(idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
+                    Vec<double> array;
+                    array.reserve(al, 1);
+                    populate_compiletime_array_for_idl(
+                        idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
                     data = &array.p[0];
                 } else {
-                    diag.add(Diagnostic("Unsupported kind for real type in compiletime evaluation of implied do loop",
-                                        Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                    diag.add(Diagnostic(
+                        "Unsupported kind for real type in compiletime evaluation of implied do loop",
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             }
             // Add Support for Character Type in Implied Do Loop
-            else if (ASRUtils::is_character(*type)){
-                Vec<char*> array; array.reserve(al, 1);
-                populate_compiletime_array_for_idl(idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
-                //Get length of Do-Loop Character Type
+            else if (ASRUtils::is_character(*type)) {
+                Vec<char*> array;
+                array.reserve(al, 1);
+                populate_compiletime_array_for_idl(
+                    idl, array, loop_vars, loop_indices, curr_nesting_level, itr);
+                // Get length of Do-Loop Character Type
                 int len = -1;
                 ASRUtils::extract_value(
                     ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(type))->m_len, len);
                 char* char_data = new char[len * itr + 1];
                 for (int i = 0; i < itr; i++) {
                     for (int j = 0; j < len; j++) {
-                        char_data[i*len + j] = array.p[i][j];
+                        char_data[i * len + j] = array.p[i][j];
                     }
                 }
                 char_data[len * itr] = '\0';
                 data = (void*) char_data;
             }
             if (data != nullptr) {
-                Vec<ASR::dimension_t> dims; dims.reserve(al, 1);
-                ASR::dimension_t dim; dim.loc = x.base.base.loc;
-                dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, 1, ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4))));
-                dim.m_length = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, itr, ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4))));
+                Vec<ASR::dimension_t> dims;
+                dims.reserve(al, 1);
+                ASR::dimension_t dim;
+                dim.loc = x.base.base.loc;
+                dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                    al,
+                    x.base.base.loc,
+                    1,
+                    ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4))));
+                dim.m_length = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                    al,
+                    x.base.base.loc,
+                    itr,
+                    ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4))));
                 dims.push_back(al, dim);
-                ASR::array_physical_typeType physical_type = ASR::array_physical_typeType::FixedSizeArray;
+                ASR::array_physical_typeType physical_type
+                    = ASR::array_physical_typeType::FixedSizeArray;
                 if (ASRUtils::is_character(*type)) {
                     physical_type = ASR::array_physical_typeType::PointerArray;
                 }
-                ASR::ttype_t* array_type = ASRUtils::TYPE(ASR::make_Array_t(al, x.base.base.loc, type, dims.p, dims.n, physical_type));
+                ASR::ttype_t* array_type = ASRUtils::TYPE(
+                    ASR::make_Array_t(al, x.base.base.loc, type, dims.p, dims.n, physical_type));
                 int64_t n_data = itr * ASRUtils::extract_kind_from_ttype_t(type);
                 if (ASRUtils::is_character(*type)) {
                     int len;
-                    if(!ASRUtils::extract_value(ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(type))->m_len, len)){
+                    if (!ASRUtils::extract_value(
+                            ASR::down_cast<ASR::String_t>(ASRUtils::extract_type(type))->m_len,
+                            len)) {
                         LCOMPILERS_ASSERT(false);
                     }
                     n_data = itr * len;
                 }
-                ASR::expr_t* value = ASRUtils::EXPR(ASR::make_ArrayConstant_t(al, x.base.base.loc, n_data, data,
-                        array_type, ASR::arraystorageType::ColMajor));
+                ASR::expr_t* value
+                    = ASRUtils::EXPR(ASR::make_ArrayConstant_t(al,
+                                                               x.base.base.loc,
+                                                               n_data,
+                                                               data,
+                                                               array_type,
+                                                               ASR::arraystorageType::ColMajor));
                 idl->m_value = value;
                 tmp = (ASR::asr_t*) idl;
             }
@@ -10286,60 +12536,78 @@ public:
         idl_nesting_level--;
     }
 
-    ASR::asr_t* create_Shifta(const Location &loc, Vec<ASR::call_arg_t> args) {
+    ASR::asr_t* create_Shifta(const Location& loc, Vec<ASR::call_arg_t> args)
+    {
         /*
             shifta(n, w):
             This is arithmetic shift right by w bits.
             Represent using BinOp, with left = n, right = w, op = BitRShift
         */
-        ASR::expr_t *n = args[0].m_value;
-        ASR::expr_t *w = args[1].m_value;
+        ASR::expr_t* n = args[0].m_value;
+        ASR::expr_t* w = args[1].m_value;
 
         ASR::ttype_t* n_type = ASRUtils::expr_type(n);
         ASR::ttype_t* w_type = ASRUtils::expr_type(w);
 
         if (!ASRUtils::check_equal_type(n_type, w_type, nullptr, nullptr)) {
             if (ASRUtils::is_integer(*n_type) && ASRUtils::is_integer(*w_type)) {
-                w = ASRUtils::EXPR(ASR::make_Cast_t(al, loc, w, ASR::cast_kindType::IntegerToInteger, n_type, nullptr));
+                w = ASRUtils::EXPR(ASR::make_Cast_t(
+                    al, loc, w, ASR::cast_kindType::IntegerToInteger, n_type, nullptr));
             }
         }
 
-        return ASRUtils::make_Binop_util(al, loc, ASR::binopType::BitRShift,
-                            n, w, n_type);
+        return ASRUtils::make_Binop_util(al, loc, ASR::binopType::BitRShift, n, w, n_type);
     }
 
-    void visit_FuncCallOrArray(const AST::FuncCallOrArray_t &x) {
+    void visit_FuncCallOrArray(const AST::FuncCallOrArray_t& x)
+    {
         std::string var_name = to_lower(x.m_func);
         if (x.n_temp_args > 0) {
-            ASR::symbol_t *owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
-            var_name = handle_templated(x.m_func, ASR::is_a<ASR::Template_t>(*ASRUtils::get_asr_owner(owner_sym)),
-                x.m_temp_args, x.n_temp_args, x.base.base.loc);
-        }
-        SymbolTable *scope = current_scope;
-        ASR::symbol_t *v = nullptr;
-        ASR::expr_t *v_expr = nullptr;
+            ASR::symbol_t* owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
+            var_name
+                = handle_templated(x.m_func,
+                                   ASR::is_a<ASR::Template_t>(*ASRUtils::get_asr_owner(owner_sym)),
+                                   x.m_temp_args,
+                                   x.n_temp_args,
+                                   x.base.base.loc);
+        }
+        SymbolTable* scope = current_scope;
+        ASR::symbol_t* v = nullptr;
+        ASR::expr_t* v_expr = nullptr;
         bool is_external_procedure = check_is_external(var_name);
         bool is_explicit_intrinsic = check_is_explicit_intrinsic(var_name);
         // If this is a type bound procedure (in a class) it won't be in the
         // main symbol table. Need to check n_member.
         if (x.n_member >= 1) {
-            if (x.n_member ==  1) {
+            if (x.n_member == 1) {
                 if (x.m_member[0].n_args > 0) {
-                    ASR::symbol_t *v1 = current_scope->resolve_symbol(to_lower(x.m_member[0].m_name));
-                    ASR::symbol_t *f2 = ASRUtils::symbol_get_past_external(v1);
-                    tmp = create_ArrayRef(x.base.base.loc, x.m_member[0].m_args, x.m_member[0].n_args, nullptr, 0, nullptr, v1, f2);
+                    ASR::symbol_t* v1
+                        = current_scope->resolve_symbol(to_lower(x.m_member[0].m_name));
+                    ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(v1);
+                    tmp = create_ArrayRef(x.base.base.loc,
+                                          x.m_member[0].m_args,
+                                          x.m_member[0].n_args,
+                                          nullptr,
+                                          0,
+                                          nullptr,
+                                          v1,
+                                          f2);
                 } else {
                     tmp = resolve_variable(x.base.base.loc, to_lower(x.m_member[0].m_name));
                 }
                 tmp = (ASR::asr_t*) replace_with_common_block_variables(ASRUtils::EXPR(tmp));
             } else {
-                visit_NameUtil(x.m_member, x.n_member - 1,
-                    x.m_member[x.n_member - 1].m_name, x.base.base.loc);
+                visit_NameUtil(
+                    x.m_member, x.n_member - 1, x.m_member[x.n_member - 1].m_name, x.base.base.loc);
             }
             v_expr = ASRUtils::EXPR(tmp);
-            v = resolve_deriv_type_proc(x.base.base.loc, var_name,
-                    to_lower(x.m_member[x.n_member - 1].m_name), v_expr,
-                    ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)), scope);
+            v = resolve_deriv_type_proc(
+                x.base.base.loc,
+                var_name,
+                to_lower(x.m_member[x.n_member - 1].m_name),
+                v_expr,
+                ASRUtils::type_get_past_pointer(ASRUtils::expr_type(v_expr)),
+                scope);
             v = ASRUtils::import_class_procedure(al, x.base.base.loc, v, current_scope);
         } else {
             // for a GenericProcedure and a derived type with the same name,
@@ -10354,69 +12622,80 @@ public:
         if (!v || (v && (is_external_procedure || is_explicit_intrinsic))) {
             ASR::symbol_t* external_sym = is_external_procedure ? v : nullptr;
             bool is_function = true;
-            if ( !is_external_procedure ) {
+            if (!is_external_procedure) {
                 v = intrinsic_as_node(x, is_function);
             }
-            if( !is_function ) {
+            if (!is_function) {
                 return;
             }
-            if (compiler_options.implicit_interface && is_function && ( !v || (v && is_external_procedure))) {
+            if (compiler_options.implicit_interface && is_function
+                && (!v || (v && is_external_procedure))) {
                 // Function Call is not defined in this case.
                 // We need to create an interface and add the Function into
                 // the symbol table.
                 // Currently using real*8 as the return type.
-                ASR::ttype_t* type = external_sym ? ASRUtils::symbol_type(external_sym) :
-                                    ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, 8));
+                ASR::ttype_t* type = external_sym
+                                         ? ASRUtils::symbol_type(external_sym)
+                                         : ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, 8));
                 std::string var_name_first_letter = to_lower(std::string(1, var_name[0]));
                 implicit_dictionary = implicit_mapping[get_hash(current_scope->asr_owner)];
-                if ( !external_sym && compiler_options.implicit_typing &&
-                     implicit_dictionary.find(var_name_first_letter) != implicit_dictionary.end() ) {
+                if (!external_sym && compiler_options.implicit_typing
+                    && implicit_dictionary.find(var_name_first_letter)
+                           != implicit_dictionary.end()) {
                     type = implicit_dictionary[var_name_first_letter];
                 }
                 create_implicit_interface_function(x, var_name, true, type);
                 v = current_scope->resolve_symbol(var_name);
-                LCOMPILERS_ASSERT(v!=nullptr);
-                // check if external sym is updated, or: say if signature of external_sym and original_sym are different
-                if (v && external_sym && is_external_procedure && ASRUtils::is_external_sym_changed(v, external_sym)) {
+                LCOMPILERS_ASSERT(v != nullptr);
+                // check if external sym is updated, or: say if signature of external_sym and
+                // original_sym are different
+                if (v && external_sym && is_external_procedure
+                    && ASRUtils::is_external_sym_changed(v, external_sym)) {
                     changed_external_function_symbol[ASRUtils::symbol_name(v)] = v;
                 }
                 // remove from external_procedures_mapping
                 if (v && is_external_procedure) {
                     erase_from_external_mapping(var_name);
                 }
-                ASRUtils::update_call_args(al, current_scope, compiler_options.implicit_interface, changed_external_function_symbol);
+                ASRUtils::update_call_args(al,
+                                           current_scope,
+                                           compiler_options.implicit_interface,
+                                           changed_external_function_symbol);
             }
         }
         // if v is a function which has null pointer return type, give error
-        if (ASR::is_a<ASR::Function_t>(*v)){
+        if (ASR::is_a<ASR::Function_t>(*v)) {
             ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(v);
-            if (func->m_return_var == nullptr){
+            if (func->m_return_var == nullptr) {
                 diag.add(Diagnostic("Subroutine `" + var_name + "` called as a function",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
-        if (( ASR::is_a<ASR::Variable_t>(*v) || is_external_procedure )
+        if ((ASR::is_a<ASR::Variable_t>(*v) || is_external_procedure)
             && (!ASRUtils::is_array(ASRUtils::symbol_type(v)))
             && (!ASRUtils::is_character(*ASRUtils::symbol_type(v)))) {
-            if (intrinsic_procedures.is_intrinsic(var_name) || is_intrinsic_registry_function(var_name)) {
+            if (intrinsic_procedures.is_intrinsic(var_name)
+                || is_intrinsic_registry_function(var_name)) {
                 if (compiler_options.implicit_interface) {
                     bool is_function = true;
-                    if ( !is_external_procedure ) {
+                    if (!is_external_procedure) {
                         v = intrinsic_as_node(x, is_function);
                     }
-                    if( !is_function ) {
+                    if (!is_function) {
                         return;
                     }
                 } else {
                     diag.semantic_error_label(
-                            var_name + " was declared as a variable, it can't be called as a function",
-                            {x.base.base.loc},
-                            "help: use the compiler option \"--implicit-interface\" to use intrinsic functions"
-                        );
+                        var_name + " was declared as a variable, it can't be called as a function",
+                        { x.base.base.loc },
+                        "help: use the compiler option \"--implicit-interface\" to use intrinsic functions");
                     throw SemanticAbort();
                 }
-            } else if (compiler_options.implicit_interface && !ASRUtils::is_symbol_procedure_variable(v)) {
+            } else if (compiler_options.implicit_interface
+                       && !ASRUtils::is_symbol_procedure_variable(v)) {
                 bool is_function = true;
                 // NOTE: ideally this shouldn't be needed, this is only to handle
                 // 'dble', 'shifta', 'float', 'dfloat', which aren't currently
@@ -10440,7 +12719,7 @@ public:
                     current_scope->erase_symbol(var_name);
                 } else {
                     ASR::symbol_t* sym_ = current_scope->get_symbol(var_name);
-                    while(!sym_) {
+                    while (!sym_) {
                         sym_scope = sym_scope->parent;
                         sym_ = sym_scope->get_symbol(var_name);
                     }
@@ -10448,27 +12727,33 @@ public:
                 ASR::ttype_t* old_type = ASRUtils::symbol_type(v);
                 create_implicit_interface_function(x, var_name, true, old_type);
                 v = current_scope->resolve_symbol(var_name);
-                LCOMPILERS_ASSERT(v!=nullptr);
+                LCOMPILERS_ASSERT(v != nullptr);
                 if (!in_current_scope && is_external_procedure) {
                     SymbolTable* temp_scope = current_scope;
                     current_scope = sym_scope;
                     create_implicit_interface_function(x, var_name, true, old_type);
                     current_scope = temp_scope;
-                    LCOMPILERS_ASSERT(sym_scope->resolve_symbol(var_name)!=nullptr);
+                    LCOMPILERS_ASSERT(sym_scope->resolve_symbol(var_name) != nullptr);
                 }
 
                 // erase from external_procedures_mapping
                 erase_from_external_mapping(var_name);
-                ASRUtils::update_call_args(al, current_scope, compiler_options.implicit_interface, changed_external_function_symbol);
+                ASRUtils::update_call_args(al,
+                                           current_scope,
+                                           compiler_options.implicit_interface,
+                                           changed_external_function_symbol);
 
                 // Update arguments if the symbol belonged to a function
                 if (current_scope->asr_owner) {
-                    ASR::symbol_t* asr_owner_sym = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
+                    ASR::symbol_t* asr_owner_sym
+                        = ASR::down_cast<ASR::symbol_t>(current_scope->asr_owner);
                     if (ASR::is_a<ASR::Function_t>(*asr_owner_sym)) {
-                        ASR::Function_t *current_function = ASR::down_cast<ASR::Function_t>(asr_owner_sym);
+                        ASR::Function_t* current_function
+                            = ASR::down_cast<ASR::Function_t>(asr_owner_sym);
                         for (size_t i = 0; i < current_function->n_args; i++) {
                             if (ASR::is_a<ASR::Var_t>(*current_function->m_args[i])) {
-                                ASR::Var_t* var = ASR::down_cast<ASR::Var_t>(current_function->m_args[i]);
+                                ASR::Var_t* var
+                                    = ASR::down_cast<ASR::Var_t>(current_function->m_args[i]);
                                 if (std::string(ASRUtils::symbol_name(var->m_v)) == var_name) {
                                     var->m_v = v;
                                 }
@@ -10482,21 +12767,26 @@ public:
             /*
                 Case: ./integration_tests/external_01.f90
                 We have `enorm` declared outside current_scope. Check if it is a function
-                and if it is, then we need to remove template function `enorm` from current scope and external procedures.
+                and if it is, then we need to remove template function `enorm` from current scope
+               and external procedures.
             */
             ASR::symbol_t* v2 = current_scope->parent->resolve_symbol(var_name);
             if (ASR::is_a<ASR::Function_t>(*v2)) {
                 current_scope->erase_symbol(var_name);
                 erase_from_external_mapping(var_name);
-                ASRUtils::update_call_args(al, current_scope, compiler_options.implicit_interface, changed_external_function_symbol);
+                ASRUtils::update_call_args(al,
+                                           current_scope,
+                                           compiler_options.implicit_interface,
+                                           changed_external_function_symbol);
                 v = v2;
             }
         }
-        ASR::symbol_t *f2 = ASRUtils::symbol_get_past_external(v);
+        ASR::symbol_t* f2 = ASRUtils::symbol_get_past_external(v);
         if (ASR::is_a<ASR::Function_t>(*f2)) {
-            ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(f2);
+            ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f2);
             if (ASRUtils::is_intrinsic_procedure(f)) {
-                if (intrinsic_module_procedures_as_asr_nodes.find(var_name) != intrinsic_module_procedures_as_asr_nodes.end()) {
+                if (intrinsic_module_procedures_as_asr_nodes.find(var_name)
+                    != intrinsic_module_procedures_as_asr_nodes.end()) {
                     if (var_name == "c_loc") {
                         tmp = create_PointerToCptr(x);
                     } else if (var_name == "c_associated") {
@@ -10510,10 +12800,9 @@ public:
                 }
             }
         }
-        if (ASR::is_a<ASR::Function_t>(*f2) ||
-            ASR::is_a<ASR::GenericProcedure_t>(*f2) ||
-            (ASR::is_a<ASR::Variable_t>(*f2) &&
-            ASR::is_a<ASR::FunctionType_t>(*ASRUtils::symbol_type(f2))) ) {
+        if (ASR::is_a<ASR::Function_t>(*f2) || ASR::is_a<ASR::GenericProcedure_t>(*f2)
+            || (ASR::is_a<ASR::Variable_t>(*f2)
+                && ASR::is_a<ASR::FunctionType_t>(*ASRUtils::symbol_type(f2)))) {
             if (ASRUtils::is_intrinsic_symbol(f2)) {
                 // Here we handle all intrinsic functions that are implemented
                 // in Fortran, but have different interface (API), e.g.,
@@ -10541,7 +12830,9 @@ public:
                         return;
                     } else {
                         diag.add(Diagnostic("Argument of `not` intrinsic must be INTEGER",
-                                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 }
@@ -10555,20 +12846,27 @@ public:
                 v_expr_call_arg.loc = v_expr->base.loc;
                 v_expr_call_arg.m_value = v_expr;
                 args_with_mdt.push_back(al, v_expr_call_arg);
-                for( size_t i = 0; i < args.size(); i++ ) {
+                for (size_t i = 0; i < args.size(); i++) {
                     args_with_mdt.push_back(al, args[i]);
                 }
             }
             if (x.n_keywords > 0) {
                 if (ASR::is_a<ASR::Function_t>(*f2)) {
-                    ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(f2);
+                    ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f2);
                     diag::Diagnostics diags;
-                    visit_kwargs(args, x.m_keywords, x.n_keywords,
-                        f->m_args, f->n_args, x.base.base.loc, f,
-                        diags, x.n_member);
-                    if( diags.has_error() ) {
+                    visit_kwargs(args,
+                                 x.m_keywords,
+                                 x.n_keywords,
+                                 f->m_args,
+                                 f->n_args,
+                                 x.base.base.loc,
+                                 f,
+                                 diags,
+                                 x.n_member);
+                    if (diags.has_error()) {
                         diag.diagnostics.insert(diag.diagnostics.end(),
-                            diags.diagnostics.begin(), diags.diagnostics.end());
+                                                diags.diagnostics.begin(),
+                                                diags.diagnostics.end());
                         throw SemanticAbort();
                     }
                 } else {
@@ -10577,31 +12875,44 @@ public:
                     bool function_found = false;
                     bool is_nopass = false;
                     bool is_class_procedure = false;
-                    for( int i = 0; i < (int) gp->n_procs; i++ ) {
+                    for (int i = 0; i < (int) gp->n_procs; i++) {
                         ASR::symbol_t* f4 = ASRUtils::symbol_get_past_external(gp->m_procs[i]);
-                        if( !ASR::is_a<ASR::Function_t>(*f4) && !ASR::is_a<ASR::StructMethodDeclaration_t>(*f4) ) {
-                            diag.add(Diagnostic(std::string(ASRUtils::symbol_name(f4)) +
-                            " is not a function.",
-                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                        if (!ASR::is_a<ASR::Function_t>(*f4)
+                            && !ASR::is_a<ASR::StructMethodDeclaration_t>(*f4)) {
+                            diag.add(Diagnostic(std::string(ASRUtils::symbol_name(f4))
+                                                    + " is not a function.",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                         if (ASR::is_a<ASR::StructMethodDeclaration_t>(*f4)) {
-                            ASR::StructMethodDeclaration_t* f5 = ASR::down_cast<ASR::StructMethodDeclaration_t>(f4);
+                            ASR::StructMethodDeclaration_t* f5
+                                = ASR::down_cast<ASR::StructMethodDeclaration_t>(f4);
                             f4 = f5->m_proc;
                             is_nopass = f5->m_is_nopass;
                             is_class_procedure = true;
                         }
-                        ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(f4);
+                        ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f4);
                         diag::Diagnostics diags;
 
                         Vec<ASR::call_arg_t> args_copy;
-                        args_copy.reserve(al, args.size() + x.n_keywords + (is_class_procedure && !is_nopass ? 1 : 0));
-                        for( size_t j = 0; j < args.size(); j++ ) {
+                        args_copy.reserve(al,
+                                          args.size() + x.n_keywords
+                                              + (is_class_procedure && !is_nopass ? 1 : 0));
+                        for (size_t j = 0; j < args.size(); j++) {
                             args_copy.push_back(al, args[j]);
                         }
-                        visit_kwargs(args_copy, x.m_keywords, x.n_keywords,
-                            f->m_args, f->n_args, x.base.base.loc, f,
-                            diags, x.n_member, is_nopass);
+                        visit_kwargs(args_copy,
+                                     x.m_keywords,
+                                     x.n_keywords,
+                                     f->m_args,
+                                     f->n_args,
+                                     x.base.base.loc,
+                                     f,
+                                     diags,
+                                     x.n_member,
+                                     is_nopass);
                         // Add 'this' if type-bound and not nopass
                         if (is_class_procedure && !is_nopass && x.n_member >= 1) {
                             ASR::call_arg_t this_arg;
@@ -10609,77 +12920,90 @@ public:
                             this_arg.m_value = v_expr;
                             args_copy.push_front(al, this_arg);
                         }
-                        if( diags.has_error() ) {
-                            continue ;
+                        if (diags.has_error()) {
+                            continue;
                         }
-                        int idx = ASRUtils::select_generic_procedure(args_copy, *gp, x.base.base.loc,
-                                        [&](const std::string &msg, const Location &loc) {
-                                                diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                                                throw SemanticAbort();
-                                            },
-                                        false);
-                        if( idx == i ) {
+                        int idx = ASRUtils::select_generic_procedure(
+                            args_copy,
+                            *gp,
+                            x.base.base.loc,
+                            [&](const std::string& msg, const Location& loc) {
+                                diag.add(Diagnostic(
+                                    msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                                throw SemanticAbort();
+                            },
+                            false);
+                        if (idx == i) {
                             function_found = true;
                             args.n = 0;
-                            args.from_pointer_n_copy(al, args_copy.p , args_copy.size() );
+                            args.from_pointer_n_copy(al, args_copy.p, args_copy.size());
                             args_with_mdt.n = 0;
-                            args_with_mdt.from_pointer_n_copy(al, args_copy.p , args_copy.size() );
+                            args_with_mdt.from_pointer_n_copy(al, args_copy.p, args_copy.size());
                             break;
                         }
                     }
-                    if( !function_found ) {
+                    if (!function_found) {
                         // First check if default structConstructor is there
                         ASR::symbol_t* struct_sym = ASRUtils::symbol_get_past_external(
                             current_scope->resolve_symbol(var_name));
-                        if (struct_sym &&
-                                ASR::is_a<ASR::Struct_t>(*struct_sym)) {
-                            tmp = create_DerivedTypeConstructor(x.base.base.loc, x.m_args, x.n_args,
-                                                    x.m_keywords, x.n_keywords, struct_sym);
+                        if (struct_sym && ASR::is_a<ASR::Struct_t>(*struct_sym)) {
+                            tmp = create_DerivedTypeConstructor(x.base.base.loc,
+                                                                x.m_args,
+                                                                x.n_args,
+                                                                x.m_keywords,
+                                                                x.n_keywords,
+                                                                struct_sym);
                             return;
                         }
                         bool is_function = true;
                         v = intrinsic_as_node(x, is_function);
-                        if( !is_function ) {
-                            return ;
+                        if (!is_function) {
+                            return;
                         }
                     }
-                    if( v == nullptr ) {
-                        diag.add(Diagnostic("Unable to find a function to bind for generic procedure call, " + std::string(gp->m_name),
-                                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                    if (v == nullptr) {
+                        diag.add(Diagnostic(
+                            "Unable to find a function to bind for generic procedure call, "
+                                + std::string(gp->m_name),
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 }
             }
             if (ASR::is_a<ASR::Function_t>(*f2) && !ASRUtils::is_intrinsic_symbol(f2)) {
-                ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(f2);
+                ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f2);
                 // check type mismatch (only function in templates)
                 if (is_template) {
                     for (size_t i = 0; i < f->n_args; i++) {
-                        ASR::expr_t *dest = f->m_args[i];
-                        ASR::expr_t *source = args.p[i].m_value;
+                        ASR::expr_t* dest = f->m_args[i];
+                        ASR::expr_t* source = args.p[i].m_value;
 
-                        ASR::ttype_t *dest_type = ASRUtils::expr_type(dest);
-                        ASR::ttype_t *source_type = ASRUtils::expr_type(source);
+                        ASR::ttype_t* dest_type = ASRUtils::expr_type(dest);
+                        ASR::ttype_t* source_type = ASRUtils::expr_type(source);
 
                         if (!ASRUtils::check_equal_type(dest_type, source_type, dest, source)) {
                             std::string dtype = ASRUtils::type_to_str_fortran_expr(dest_type, dest);
-                            std::string stype = ASRUtils::type_to_str_fortran_expr(source_type, source);
+                            std::string stype
+                                = ASRUtils::type_to_str_fortran_expr(source_type, source);
                             diag.add(Diagnostic(
-                                "Type mismatch in function call, the function expects '" + dtype + "' but '" + stype + "' was provided",
-                                Level::Error, Stage::Semantic, {
-                                    Label("type '" + dtype + "' expected, but '" + stype + "' provided",
-                                            {source->base.loc}),
-                                    Label("function definition has parameter type '" + dtype + "'",
-                                            {dest->base.loc})
-                                })
-                            );
+                                "Type mismatch in function call, the function expects '" + dtype
+                                    + "' but '" + stype + "' was provided",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("type '" + dtype + "' expected, but '" + stype
+                                            + "' provided",
+                                        { source->base.loc }),
+                                  Label("function definition has parameter type '" + dtype + "'",
+                                        { dest->base.loc }) }));
                             throw SemanticAbort();
                         }
                     }
                 }
             }
             if (ASR::is_a<ASR::Function_t>(*f2) && !ASRUtils::is_intrinsic_symbol(f2)) {
-                ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(f2);
+                ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(f2);
                 ASRUtils::check_simple_intent_mismatch<SemanticAbort>(diag, f, args);
             }
             if (x.n_member >= 1) {
@@ -10689,33 +13013,47 @@ public:
             }
         } else {
             switch (f2->type) {
-            case(ASR::symbolType::Variable): {
-                // TODO: Make create_StringRef for character (non-array) variables.
-                tmp = create_ArrayRef(x.base.base.loc, x.m_args, x.n_args,
-                                      x.m_subargs, x.n_subargs, v_expr, v, f2);
-                break;
-            }
-            case(ASR::symbolType::Struct): {
-                tmp = create_DerivedTypeConstructor(x.base.base.loc, x.m_args, x.n_args,
-                                                    x.m_keywords, x.n_keywords, v);
-                break;
-            }
-            case(ASR::symbolType::StructMethodDeclaration):
-                tmp = create_StructMethodDeclaration(x.base.base.loc, x.m_args, x.n_args,
-                                x.m_keywords, x.n_keywords, x.n_member, v, v_expr);
-                break;
-            default: {
-                diag.add(Diagnostic("Symbol '" + var_name
-                            + "' is not a function or an array",
-                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
-                throw SemanticAbort();
+                case (ASR::symbolType::Variable): {
+                    // TODO: Make create_StringRef for character (non-array) variables.
+                    tmp = create_ArrayRef(x.base.base.loc,
+                                          x.m_args,
+                                          x.n_args,
+                                          x.m_subargs,
+                                          x.n_subargs,
+                                          v_expr,
+                                          v,
+                                          f2);
+                    break;
+                }
+                case (ASR::symbolType::Struct): {
+                    tmp = create_DerivedTypeConstructor(
+                        x.base.base.loc, x.m_args, x.n_args, x.m_keywords, x.n_keywords, v);
+                    break;
+                }
+                case (ASR::symbolType::StructMethodDeclaration):
+                    tmp = create_StructMethodDeclaration(x.base.base.loc,
+                                                         x.m_args,
+                                                         x.n_args,
+                                                         x.m_keywords,
+                                                         x.n_keywords,
+                                                         x.n_member,
+                                                         v,
+                                                         v_expr);
+                    break;
+                default: {
+                    diag.add(Diagnostic("Symbol '" + var_name + "' is not a function or an array",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
+                    throw SemanticAbort();
                 }
             }
         }
     }
 
-    void check_global_procedure_and_enable_separate_compilation(SymbolTable *parent_scope) {
-        if ( parent_scope->parent != nullptr ) {
+    void check_global_procedure_and_enable_separate_compilation(SymbolTable* parent_scope)
+    {
+        if (parent_scope->parent != nullptr) {
             return;
         }
         compiler_options.generate_code_for_global_procedures = true;
@@ -10724,64 +13062,80 @@ public:
     }
 
 
-    ASR::symbol_t* resolve_intrinsic_function(const Location &loc, const std::string &remote_sym) {
+    ASR::symbol_t* resolve_intrinsic_function(const Location& loc, const std::string& remote_sym)
+    {
         if (!intrinsic_procedures.is_intrinsic(remote_sym)) {
             if (compiler_options.implicit_interface) {
                 return nullptr;
             } else {
                 is_coarray_or_atomic(remote_sym, loc);
-                diag.add(Diagnostic("Function '" + remote_sym + "' not found"
-                    " (not user defined nor intrinsic)",
-                    Level::Error, Stage::Semantic, {Label("", {loc})}));
+                diag.add(Diagnostic("Function '" + remote_sym
+                                        + "' not found"
+                                          " (not user defined nor intrinsic)",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         }
         std::string module_name = intrinsic_procedures.get_module(remote_sym, loc, diag);
 
-        SymbolTable *tu_symtab = ASRUtils::get_tu_symtab(current_scope);
+        SymbolTable* tu_symtab = ASRUtils::get_tu_symtab(current_scope);
         std::set<std::string> empty_set;
-        ASR::Module_t *m = ASRUtils::load_module(al, tu_symtab, module_name,
-                loc, true, empty_set, compiler_options.po, true,
-                [&](const std::string &msg, const Location &loc) {
-                        diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                        throw SemanticAbort();
-                    }, lm, compiler_options.separate_compilation
-                );
+        ASR::Module_t* m = ASRUtils::load_module(
+            al,
+            tu_symtab,
+            module_name,
+            loc,
+            true,
+            empty_set,
+            compiler_options.po,
+            true,
+            [&](const std::string& msg, const Location& loc) {
+                diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                throw SemanticAbort();
+            },
+            lm,
+            compiler_options.separate_compilation);
 
-        ASR::symbol_t *t = m->m_symtab->resolve_symbol(remote_sym);
+        ASR::symbol_t* t = m->m_symtab->resolve_symbol(remote_sym);
         if (!t) {
-            diag.add(Diagnostic("The symbol '" + remote_sym
-                + "' not found in the module '" + module_name + "'",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+            diag.add(Diagnostic("The symbol '" + remote_sym + "' not found in the module '"
+                                    + module_name + "'",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
-        } else if (! (ASR::is_a<ASR::GenericProcedure_t>(*t)
-                    || ASR::is_a<ASR::Function_t>(*t)
-                    )) {
-            diag.add(Diagnostic("The symbol '" + remote_sym
-                + "' found in the module '" + module_name + "', "
-                + "but it is not a function, subroutine or a generic procedure.",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+        } else if (!(ASR::is_a<ASR::GenericProcedure_t>(*t) || ASR::is_a<ASR::Function_t>(*t))) {
+            diag.add(Diagnostic(
+                "The symbol '" + remote_sym + "' found in the module '" + module_name + "', "
+                    + "but it is not a function, subroutine or a generic procedure.",
+                Level::Error,
+                Stage::Semantic,
+                { Label("", { loc }) }));
             throw SemanticAbort();
         }
-        char *fn_name = ASRUtils::symbol_name(t);
-        ASR::asr_t *fn = ASR::make_ExternalSymbol_t(
-            al, t->base.loc,
-            /* a_symtab */ current_scope,
-            /* a_name */ fn_name,
-            t,
-            m->m_name, nullptr, 0, fn_name,
-            ASR::accessType::Private
-            );
+        char* fn_name = ASRUtils::symbol_name(t);
+        ASR::asr_t* fn = ASR::make_ExternalSymbol_t(al,
+                                                    t->base.loc,
+                                                    /* a_symtab */ current_scope,
+                                                    /* a_name */ fn_name,
+                                                    t,
+                                                    m->m_name,
+                                                    nullptr,
+                                                    0,
+                                                    fn_name,
+                                                    ASR::accessType::Private);
         std::string sym = fn_name;
 
         current_scope->add_or_overwrite_symbol(sym, ASR::down_cast<ASR::symbol_t>(fn));
-        ASR::symbol_t *v = ASR::down_cast<ASR::symbol_t>(fn);
+        ASR::symbol_t* v = ASR::down_cast<ASR::symbol_t>(fn);
         if (current_module) {
             // We are in body visitor
             // Add the module `m` to current module dependencies
             SetChar vec;
-            vec.from_pointer_n_copy(al, current_module->m_dependencies,
-                        current_module->n_dependencies);
+            vec.from_pointer_n_copy(
+                al, current_module->m_dependencies, current_module->n_dependencies);
             vec.push_back(al, m->m_name);
             current_module->m_dependencies = vec.p;
             current_module->n_dependencies = vec.size();
@@ -10793,23 +13147,28 @@ public:
         return v;
     }
 
-    bool is_integer(ASR::ttype_t &t) {
+    bool is_integer(ASR::ttype_t& t)
+    {
         return ASR::is_a<ASR::Integer_t>(*ASRUtils::type_get_past_pointer(&t));
     }
 
-    bool is_real(ASR::ttype_t &t) {
+    bool is_real(ASR::ttype_t& t)
+    {
         return ASR::is_a<ASR::Real_t>(*ASRUtils::type_get_past_pointer(&t));
     }
 
-    bool is_complex(ASR::ttype_t &t) {
+    bool is_complex(ASR::ttype_t& t)
+    {
         return ASR::is_a<ASR::Complex_t>(*ASRUtils::type_get_past_pointer(&t));
     }
 
-    bool is_logical(ASR::ttype_t &t) {
+    bool is_logical(ASR::ttype_t& t)
+    {
         return ASR::is_a<ASR::Logical_t>(*ASRUtils::type_get_past_pointer(&t));
     }
 
-    bool assignment_types_agree(ASR::ttype_t *target, ASR::ttype_t *value) {
+    bool assignment_types_agree(ASR::ttype_t* target, ASR::ttype_t* value)
+    {
         // For now we will just check basic type mismatch
         if (target->type == value->type) {
             return true;
@@ -10823,8 +13182,9 @@ public:
         return false;
     }
 
-    template<typename T>
-    T perform_binop(T left_value, T right_value, ASR::binopType op) {
+    template <typename T>
+    T perform_binop(T left_value, T right_value, ASR::binopType op)
+    {
         T result;
         switch (op) {
             case ASR::Add:
@@ -10849,76 +13209,93 @@ public:
         return result;
     }
     // Creates a compile-time expression value for the Binop expression, if possible.
-    ASR::expr_t* visit_BinOp_helper(ASR::expr_t* left, ASR::expr_t* right, ASR::binopType op, const Location& loc, ASR::ttype_t* dest_type) {
+    ASR::expr_t* visit_BinOp_helper(ASR::expr_t* left,
+                                    ASR::expr_t* right,
+                                    ASR::binopType op,
+                                    const Location& loc,
+                                    ASR::ttype_t* dest_type)
+    {
         LCOMPILERS_ASSERT((left != nullptr) && (right != nullptr));
         if (ASR::is_a<ASR::RealConstant_t>(*left) && ASR::is_a<ASR::RealConstant_t>(*right)) {
             double left_value = ASR::down_cast<ASR::RealConstant_t>(left)->m_r;
             double right_value = ASR::down_cast<ASR::RealConstant_t>(right)->m_r;
-            return ASRUtils::EXPR(ASR::make_RealConstant_t(al, left->base.loc,
-            perform_binop(left_value, right_value, op), dest_type));
-        } else if (ASR::is_a<ASR::RealConstant_t>(*left) && ASR::is_a<ASR::IntegerConstant_t>(*right)){
+            return ASRUtils::EXPR(ASR::make_RealConstant_t(
+                al, left->base.loc, perform_binop(left_value, right_value, op), dest_type));
+        } else if (ASR::is_a<ASR::RealConstant_t>(*left)
+                   && ASR::is_a<ASR::IntegerConstant_t>(*right)) {
             LCOMPILERS_ASSERT(op == ASR::binopType::Pow);
             double left_value = ASR::down_cast<ASR::RealConstant_t>(left)->m_r;
             int64_t right_value = ASR::down_cast<ASR::IntegerConstant_t>(right)->m_n;
-            return ASRUtils::EXPR(ASR::make_RealConstant_t(al, left->base.loc,
-                    std::pow(left_value, right_value), dest_type));
-        } else if (ASR::is_a<ASR::IntegerConstant_t>(*left) && ASR::is_a<ASR::IntegerConstant_t>(*right)) {
+            return ASRUtils::EXPR(ASR::make_RealConstant_t(
+                al, left->base.loc, std::pow(left_value, right_value), dest_type));
+        } else if (ASR::is_a<ASR::IntegerConstant_t>(*left)
+                   && ASR::is_a<ASR::IntegerConstant_t>(*right)) {
             int64_t left_value = ASR::down_cast<ASR::IntegerConstant_t>(left)->m_n;
             int64_t right_value = ASR::down_cast<ASR::IntegerConstant_t>(right)->m_n;
 
             if (op == ASR::Div && right_value == 0) {
                 diag.add(Diagnostic(
-                    "Division by zero",
-                    Level::Error, Stage::Semantic, {
-                        Label("", {loc})
-                    })
-                );
+                    "Division by zero", Level::Error, Stage::Semantic, { Label("", { loc }) }));
                 throw SemanticAbort();
             }
 
-            return ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, left->base.loc,
-                    perform_binop(left_value, right_value, op), dest_type));
-        } else if (ASR::is_a<ASR::ComplexConstant_t>(*left) && ASR::is_a<ASR::ComplexConstant_t>(*right)) {
-            ASR::ComplexConstant_t *left_value
-                = ASR::down_cast<ASR::ComplexConstant_t>(
-                        ASRUtils::expr_value(left));
-            ASR::ComplexConstant_t *right_value
-                = ASR::down_cast<ASR::ComplexConstant_t>(
-                        ASRUtils::expr_value(right));
+            return ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                al, left->base.loc, perform_binop(left_value, right_value, op), dest_type));
+        } else if (ASR::is_a<ASR::ComplexConstant_t>(*left)
+                   && ASR::is_a<ASR::ComplexConstant_t>(*right)) {
+            ASR::ComplexConstant_t* left_value
+                = ASR::down_cast<ASR::ComplexConstant_t>(ASRUtils::expr_value(left));
+            ASR::ComplexConstant_t* right_value
+                = ASR::down_cast<ASR::ComplexConstant_t>(ASRUtils::expr_value(right));
             std::complex<double> left_value_(left_value->m_re, left_value->m_im);
             std::complex<double> right_value_(right_value->m_re, right_value->m_im);
             std::complex<double> result = perform_binop(left_value_, right_value_, op);
-            return ASRUtils::EXPR( ASR::make_ComplexConstant_t(al, loc,
-                    std::real(result), std::imag(result), dest_type));
+            return ASRUtils::EXPR(ASR::make_ComplexConstant_t(
+                al, loc, std::real(result), std::imag(result), dest_type));
         }
         return nullptr;
     }
 
-    ASR::expr_t* extract_value(ASR::expr_t* left_value, ASR::expr_t* right_value, ASR::binopType op, ASR::ttype_t* dest_type, const Location& loc) {
-        if (left_value && right_value &&
-            ASR::is_a<ASR::ArrayConstant_t>(*left_value) &&
-            ASR::is_a<ASR::ArrayConstant_t>(*right_value)) {
+    ASR::expr_t* extract_value(ASR::expr_t* left_value,
+                               ASR::expr_t* right_value,
+                               ASR::binopType op,
+                               ASR::ttype_t* dest_type,
+                               const Location& loc)
+    {
+        if (left_value && right_value && ASR::is_a<ASR::ArrayConstant_t>(*left_value)
+            && ASR::is_a<ASR::ArrayConstant_t>(*right_value)) {
             ASR::ArrayConstant_t* left_array = ASR::down_cast<ASR::ArrayConstant_t>(left_value);
             ASR::ArrayConstant_t* right_array = ASR::down_cast<ASR::ArrayConstant_t>(right_value);
 
-            Vec<ASR::expr_t*> values; values.reserve(al, ASRUtils::get_fixed_size_of_array(left_array->m_type));
+            Vec<ASR::expr_t*> values;
+            values.reserve(al, ASRUtils::get_fixed_size_of_array(left_array->m_type));
 
-            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(left_array->m_type); i++) {
-                values.push_back(al, visit_BinOp_helper(ASRUtils::fetch_ArrayConstant_value(al, left_array, i),
-                                ASRUtils::fetch_ArrayConstant_value(al, right_array, i), op, loc, ASRUtils::expr_type(ASRUtils::fetch_ArrayConstant_value(al, left_array, i))));
+            for (size_t i = 0; i < (size_t) ASRUtils::get_fixed_size_of_array(left_array->m_type);
+                 i++) {
+                values.push_back(
+                    al,
+                    visit_BinOp_helper(ASRUtils::fetch_ArrayConstant_value(al, left_array, i),
+                                       ASRUtils::fetch_ArrayConstant_value(al, right_array, i),
+                                       op,
+                                       loc,
+                                       ASRUtils::expr_type(ASRUtils::fetch_ArrayConstant_value(
+                                           al, left_array, i))));
             }
 
-            return ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(al, loc,
-                                    values.p, values.size(), dest_type,
-                                    ASR::arraystorageType::ColMajor));
+            return ASRUtils::EXPR(ASRUtils::make_ArrayConstructor_t_util(
+                al, loc, values.p, values.size(), dest_type, ASR::arraystorageType::ColMajor));
         }
         return nullptr;
     }
 
-    void visit_BinOp2(Allocator &al, const AST::BinOp_t &x,
-                    ASR::expr_t *&left, ASR::expr_t *&right,
-                    ASR::asr_t *&asr, std::string& intrinsic_op_name,
-                    SymbolTable* curr_scope) {
+    void visit_BinOp2(Allocator& al,
+                      const AST::BinOp_t& x,
+                      ASR::expr_t*& left,
+                      ASR::expr_t*& right,
+                      ASR::asr_t*& asr,
+                      std::string& intrinsic_op_name,
+                      SymbolTable* curr_scope)
+    {
         ASR::binopType op;
         switch (x.m_op) {
             case (AST::Add):
@@ -10944,123 +13321,177 @@ public:
         }
 
         // Cast LHS or RHS if necessary
-        ASR::ttype_t *left_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(left));
-        ASR::ttype_t *right_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(right));
-        ASR::expr_t *overloaded = nullptr;
-        if ( ASRUtils::use_overloaded(left, right, op,
-                    intrinsic_op_name, curr_scope, asr, al,
-                    x.base.base.loc, current_function_dependencies,
-                    current_module_dependencies,
-                    [&](const std::string &msg, const Location &loc)
-                    {
-                        diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                        throw SemanticAbort();
-                    }) ) {
+        ASR::ttype_t* left_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(left));
+        ASR::ttype_t* right_type = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(right));
+        ASR::expr_t* overloaded = nullptr;
+        if (ASRUtils::use_overloaded(
+                left,
+                right,
+                op,
+                intrinsic_op_name,
+                curr_scope,
+                asr,
+                al,
+                x.base.base.loc,
+                current_function_dependencies,
+                current_module_dependencies,
+                [&](const std::string& msg, const Location& loc) {
+                    diag.add(
+                        Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                    throw SemanticAbort();
+                })) {
             overloaded = ASRUtils::EXPR(asr);
         }
 
-        ASR::expr_t **conversion_cand = &left;
-        ASR::ttype_t *source_type = left_type;
-        ASR::ttype_t *dest_type = right_type;
+        ASR::expr_t** conversion_cand = &left;
+        ASR::ttype_t* source_type = left_type;
+        ASR::ttype_t* dest_type = right_type;
 
-        if( overloaded == nullptr ) {
-          if(!ASRUtils::is_type_parameter(*left_type) && !ASRUtils::is_type_parameter(*right_type)){
-              ImplicitCastRules::find_conversion_candidate(&left, &right, left_type,
-                                                      right_type, conversion_cand,
-                                                      &source_type, &dest_type);
-          }
-            if((op == ASR::binopType::Pow) &&
-                ASRUtils::is_real(*dest_type) &&
-                ASRUtils::is_integer(*right_type)){ // Don't cast exponent to preserve precision.
+        if (overloaded == nullptr) {
+            if (!ASRUtils::is_type_parameter(*left_type)
+                && !ASRUtils::is_type_parameter(*right_type)) {
+                ImplicitCastRules::find_conversion_candidate(&left,
+                                                             &right,
+                                                             left_type,
+                                                             right_type,
+                                                             conversion_cand,
+                                                             &source_type,
+                                                             &dest_type);
+            }
+            if ((op == ASR::binopType::Pow) && ASRUtils::is_real(*dest_type)
+                && ASRUtils::is_integer(
+                    *right_type)) {  // Don't cast exponent to preserve precision.
                 // Do nothing.
             } else {
-                ImplicitCastRules::set_converted_value(al, x.base.base.loc, conversion_cand,
-                                                    source_type, dest_type, diag);
+                ImplicitCastRules::set_converted_value(
+                    al, x.base.base.loc, conversion_cand, source_type, dest_type, diag);
             }
         }
 
-        if( (ASRUtils::is_array(right_type) || ASRUtils::is_array(left_type)) &&
-             !ASRUtils::is_array(dest_type) ) {
+        if ((ASRUtils::is_array(right_type) || ASRUtils::is_array(left_type))
+            && !ASRUtils::is_array(dest_type)) {
             ASR::dimension_t* m_dims = nullptr;
             size_t n_dims = 0;
-            if( ASRUtils::is_array(left_type) ) {
+            if (ASRUtils::is_array(left_type)) {
                 n_dims = ASRUtils::extract_dimensions_from_ttype(left_type, m_dims);
-            } else if( ASRUtils::is_array(right_type) ) {
+            } else if (ASRUtils::is_array(right_type)) {
                 n_dims = ASRUtils::extract_dimensions_from_ttype(right_type, m_dims);
             }
-            dest_type = ASRUtils::make_Array_t_util(al, dest_type->base.loc,
-                ASRUtils::type_get_past_pointer(dest_type), m_dims, n_dims);
-            if( ASR::is_a<ASR::Allocatable_t>(*left_type) || ASR::is_a<ASR::Allocatable_t>(*right_type) ) {
-                dest_type = ASRUtils::TYPE(ASRUtils::make_Allocatable_t_util(al, dest_type->base.loc, dest_type));
+            dest_type = ASRUtils::make_Array_t_util(al,
+                                                    dest_type->base.loc,
+                                                    ASRUtils::type_get_past_pointer(dest_type),
+                                                    m_dims,
+                                                    n_dims);
+            if (ASR::is_a<ASR::Allocatable_t>(*left_type)
+                || ASR::is_a<ASR::Allocatable_t>(*right_type)) {
+                dest_type = ASRUtils::TYPE(
+                    ASRUtils::make_Allocatable_t_util(al, dest_type->base.loc, dest_type));
             }
         }
-        if((op == ASR::binopType::Pow) &&
-            ASRUtils::is_real(*dest_type) &&
-            ASRUtils::is_integer(*right_type)) {
+        if ((op == ASR::binopType::Pow) && ASRUtils::is_real(*dest_type)
+            && ASRUtils::is_integer(*right_type)) {
             // Don't Check.
-        } else if (!ASRUtils::check_equal_type(ASRUtils::expr_type(left),
-                                    ASRUtils::expr_type(right), left, right) && overloaded == nullptr) {
+        } else if (!ASRUtils::check_equal_type(
+                       ASRUtils::expr_type(left), ASRUtils::expr_type(right), left, right)
+                   && overloaded == nullptr) {
             std::string ltype = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(left), left);
-            std::string rtype = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(right), right);
-            diag.add(Diagnostic(
-                "Type mismatch in binary operator, the types must be compatible",
-                Level::Error, Stage::Semantic, {
-                    Label("type mismatch (" + ltype + " and " + rtype + ")",
-                            {left->base.loc, right->base.loc})
-                })
-            );
+            std::string rtype
+                = ASRUtils::type_to_str_fortran_expr(ASRUtils::expr_type(right), right);
+            diag.add(Diagnostic("Type mismatch in binary operator, the types must be compatible",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("type mismatch (" + ltype + " and " + rtype + ")",
+                                        { left->base.loc, right->base.loc }) }));
             throw SemanticAbort();
         }
-        ASR::expr_t *value = nullptr;
+        ASR::expr_t* value = nullptr;
 
         if (ASRUtils::is_integer(*dest_type)) {
-
-            if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr ) {
-                value = visit_BinOp_helper(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, x.base.base.loc, dest_type);
+            if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr) {
+                value = visit_BinOp_helper(ASRUtils::expr_value(left),
+                                           ASRUtils::expr_value(right),
+                                           op,
+                                           x.base.base.loc,
+                                           dest_type);
             }
 
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, left, right);
-            value = value ? value : extract_value(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, dest_type, x.base.base.loc);
-            asr = ASR::make_IntegerBinOp_t(al, x.base.base.loc, left, op, right, ASRUtils::type_get_past_allocatable_pointer(dest_type), value);
+            value = value ? value
+                          : extract_value(ASRUtils::expr_value(left),
+                                          ASRUtils::expr_value(right),
+                                          op,
+                                          dest_type,
+                                          x.base.base.loc);
+            asr = ASR::make_IntegerBinOp_t(al,
+                                           x.base.base.loc,
+                                           left,
+                                           op,
+                                           right,
+                                           ASRUtils::type_get_past_allocatable_pointer(dest_type),
+                                           value);
 
         } else if (ASRUtils::is_unsigned_integer(*dest_type)) {
-
-            if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr ) {
-                value = visit_BinOp_helper(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, x.base.base.loc, dest_type);
+            if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr) {
+                value = visit_BinOp_helper(ASRUtils::expr_value(left),
+                                           ASRUtils::expr_value(right),
+                                           op,
+                                           x.base.base.loc,
+                                           dest_type);
             }
 
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, left, right);
-            value = value ? value : extract_value(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, dest_type, x.base.base.loc);
-            asr = ASR::make_UnsignedIntegerBinOp_t(al, x.base.base.loc, left, op, right, dest_type, value);
+            value = value ? value
+                          : extract_value(ASRUtils::expr_value(left),
+                                          ASRUtils::expr_value(right),
+                                          op,
+                                          dest_type,
+                                          x.base.base.loc);
+            asr = ASR::make_UnsignedIntegerBinOp_t(
+                al, x.base.base.loc, left, op, right, dest_type, value);
 
         } else if (ASRUtils::is_real(*dest_type)) {
-
             if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr) {
-                value = visit_BinOp_helper(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, x.base.base.loc, dest_type);
+                value = visit_BinOp_helper(ASRUtils::expr_value(left),
+                                           ASRUtils::expr_value(right),
+                                           op,
+                                           x.base.base.loc,
+                                           dest_type);
             }
 
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, left, right);
-            value = value ? value : extract_value(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, dest_type, x.base.base.loc);
+            value = value ? value
+                          : extract_value(ASRUtils::expr_value(left),
+                                          ASRUtils::expr_value(right),
+                                          op,
+                                          dest_type,
+                                          x.base.base.loc);
             asr = ASR::make_RealBinOp_t(al, x.base.base.loc, left, op, right, dest_type, value);
 
         } else if (ASRUtils::is_complex(*dest_type)) {
-
             if (ASRUtils::expr_value(left) != nullptr && ASRUtils::expr_value(right) != nullptr) {
-                value = visit_BinOp_helper(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, x.base.base.loc, dest_type);
+                value = visit_BinOp_helper(ASRUtils::expr_value(left),
+                                           ASRUtils::expr_value(right),
+                                           op,
+                                           x.base.base.loc,
+                                           dest_type);
             }
 
             ASRUtils::make_ArrayBroadcast_t_util(al, x.base.base.loc, left, right);
-            value = value ? value : extract_value(ASRUtils::expr_value(left), ASRUtils::expr_value(right), op, dest_type, x.base.base.loc);
+            value = value ? value
+                          : extract_value(ASRUtils::expr_value(left),
+                                          ASRUtils::expr_value(right),
+                                          op,
+                                          dest_type,
+                                          x.base.base.loc);
             asr = ASR::make_ComplexBinOp_t(al, x.base.base.loc, left, op, right, dest_type, value);
 
         } else if (ASRUtils::is_character(*dest_type)) {
-            diag.semantic_error_label(
-                            "Binary numeric operators cannot be used on strings",
-                            {x.base.base.loc},
-                            "help: use '//' for string concatenation"
-                        );
+            diag.semantic_error_label("Binary numeric operators cannot be used on strings",
+                                      { x.base.base.loc },
+                                      "help: use '//' for string concatenation");
             throw SemanticAbort();
-        } else if (ASRUtils::is_type_parameter(*left_type) || ASRUtils::is_type_parameter(*right_type)) {
+        } else if (ASRUtils::is_type_parameter(*left_type)
+                   || ASRUtils::is_type_parameter(*right_type)) {
             // if overloaded is not found, then reject
             if (overloaded == nullptr) {
                 std::string op_str = "+";
@@ -11082,36 +13513,49 @@ public:
                     default:
                         LCOMPILERS_ASSERT(false);
                 }
-            diag.add(Diagnostic("Operator `" + op_str + "` undefined for the types in the expression `" + ASRUtils::type_to_str_fortran_expr(left_type, left)
-                                + " " +  op_str + " " + ASRUtils::type_to_str_fortran_expr(right_type, right) + "`", Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                diag.add(Diagnostic(
+                    "Operator `" + op_str + "` undefined for the types in the expression `"
+                        + ASRUtils::type_to_str_fortran_expr(left_type, left) + " " + op_str + " "
+                        + ASRUtils::type_to_str_fortran_expr(right_type, right) + "`",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-        } else if( overloaded == nullptr ) {
+        } else if (overloaded == nullptr) {
             LCOMPILERS_ASSERT(false);
         }
 
         if (overloaded != nullptr) {
-            asr = ASR::make_OverloadedBinOp_t(al, x.base.base.loc, left, op, right, dest_type, value, overloaded);
+            asr = ASR::make_OverloadedBinOp_t(
+                al, x.base.base.loc, left, op, right, dest_type, value, overloaded);
         }
-
     }
 
     // TODO: extract commonality with visit_Instantiate
-    std::string handle_templated(std::string name, bool is_nested,
-            AST::decl_attribute_t** args, size_t n_args, const Location &loc) {
+    std::string handle_templated(std::string name,
+                                 bool is_nested,
+                                 AST::decl_attribute_t** args,
+                                 size_t n_args,
+                                 const Location& loc)
+    {
         std::string func_name = name;
 
-        ASR::symbol_t *sym0 = current_scope->resolve_symbol(func_name);
+        ASR::symbol_t* sym0 = current_scope->resolve_symbol(func_name);
         if (!sym0) {
-            diag.add(Diagnostic("Use of an unspecified templated function '" + func_name
-                + "'", Level::Error, Stage::Semantic, {Label("", {loc})}));
+            diag.add(Diagnostic("Use of an unspecified templated function '" + func_name + "'",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
-        ASR::symbol_t *sym = ASRUtils::symbol_get_past_external(sym0);
+        ASR::symbol_t* sym = ASRUtils::symbol_get_past_external(sym0);
         if (!ASR::is_a<ASR::Template_t>(*sym)) {
-            diag.add(Diagnostic("Cannot instantiate a non-templated function '" + func_name
-                + "'", Level::Error, Stage::Semantic, {Label("", {loc})}));
+            diag.add(Diagnostic("Cannot instantiate a non-templated function '" + func_name + "'",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
@@ -11119,27 +13563,41 @@ public:
 
         if (temp->n_args != n_args) {
             diag.add(Diagnostic("Number of templated function arguments don't match",
-                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
         std::map<std::string, std::pair<ASR::ttype_t*, ASR::symbol_t*>> type_subs;
         std::map<std::string, ASR::symbol_t*> symbol_subs;
 
-        for (size_t i=0; i<n_args; i++) {
+        for (size_t i = 0; i < n_args; i++) {
             std::string param = temp->m_args[i];
-            ASR::symbol_t *param_sym = temp->m_symtab->get_symbol(param);
+            ASR::symbol_t* param_sym = temp->m_symtab->get_symbol(param);
             if (AST::is_a<AST::AttrType_t>(*args[i])) {
                 // Handling types as instantiate's arguments
                 Vec<ASR::dimension_t> dims;
                 dims.reserve(al, 0);
-                ASR::symbol_t *type_declaration;
-                ASR::ttype_t *arg_type = determine_type(args[i]->base.loc, param,
-                    args[i], false, false, dims, nullptr, type_declaration, current_procedure_abi_type);
-                ASR::ttype_t *param_type = ASRUtils::symbol_type(param_sym);
+                ASR::symbol_t* type_declaration;
+                ASR::ttype_t* arg_type = determine_type(args[i]->base.loc,
+                                                        param,
+                                                        args[i],
+                                                        false,
+                                                        false,
+                                                        dims,
+                                                        nullptr,
+                                                        type_declaration,
+                                                        current_procedure_abi_type);
+                ASR::ttype_t* param_type = ASRUtils::symbol_type(param_sym);
                 if (!ASRUtils::is_type_parameter(*param_type)) {
-                    diag.add(Diagnostic("The type " + ASRUtils::type_to_str_fortran_symbol(arg_type, type_declaration) +
-                        " cannot be applied to non-type parameter " + param, Level::Error, Stage::Semantic, {Label("", {loc})}));
+                    diag.add(Diagnostic(
+                        "The type "
+                            + ASRUtils::type_to_str_fortran_symbol(arg_type, type_declaration)
+                            + " cannot be applied to non-type parameter " + param,
+                        Level::Error,
+                        Stage::Semantic,
+                        { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 type_subs[param].first = arg_type;
@@ -11147,34 +13605,40 @@ public:
                     type_subs[param].second = type_declaration;
                 }
             } else if (AST::is_a<AST::AttrNamelist_t>(*args[i])) {
-                AST::AttrNamelist_t *attr_name = AST::down_cast<AST::AttrNamelist_t>(args[i]);
+                AST::AttrNamelist_t* attr_name = AST::down_cast<AST::AttrNamelist_t>(args[i]);
                 std::string arg = to_lower(attr_name->m_name);
                 if (ASR::is_a<ASR::Function_t>(*param_sym)) {
                     // Handling functions passed as instantiate's arguments
-                    ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(param_sym);
-                    ASR::symbol_t *f_arg0 = current_scope->resolve_symbol(arg);
+                    ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(param_sym);
+                    ASR::symbol_t* f_arg0 = current_scope->resolve_symbol(arg);
                     if (!f_arg0) {
                         diag.add(Diagnostic("The function argument " + arg + " is not found",
-                            Level::Error, Stage::Semantic, {Label("", {args[i]->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { args[i]->base.loc }) }));
                         throw SemanticAbort();
                     }
-                    ASR::symbol_t *f_arg = ASRUtils::symbol_get_past_external(f_arg0);
+                    ASR::symbol_t* f_arg = ASRUtils::symbol_get_past_external(f_arg0);
                     if (!ASR::is_a<ASR::Function_t>(*f_arg)) {
                         diag.add(Diagnostic("The argument for " + param + " must be a function",
-                            Level::Error, Stage::Semantic, {Label("", {args[i]->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { args[i]->base.loc }) }));
                         throw SemanticAbort();
                     }
-                    check_restriction(type_subs,
-                        symbol_subs, f, f_arg0, loc, diag, []() { throw SemanticAbort(); });
+                    check_restriction(type_subs, symbol_subs, f, f_arg0, loc, diag, []() {
+                        throw SemanticAbort();
+                    });
                 } else {
-                    ASR::ttype_t *param_type = ASRUtils::symbol_type(param_sym);
+                    ASR::ttype_t* param_type = ASRUtils::symbol_type(param_sym);
                     if (ASRUtils::is_type_parameter(*param_type)) {
                         // Handling type parameters passed as instantiate's arguments
-                        ASR::symbol_t *arg_sym0 = current_scope->resolve_symbol(arg);
-                        ASR::symbol_t *arg_sym = ASRUtils::symbol_get_past_external(arg_sym0);
-                        ASR::ttype_t *arg_type = nullptr;
+                        ASR::symbol_t* arg_sym0 = current_scope->resolve_symbol(arg);
+                        ASR::symbol_t* arg_sym = ASRUtils::symbol_get_past_external(arg_sym0);
+                        ASR::ttype_t* arg_type = nullptr;
                         if (ASR::is_a<ASR::Struct_t>(*arg_sym)) {
-                            arg_type = ASRUtils::make_StructType_t_util(al, args[i]->base.loc, arg_sym0, true);
+                            arg_type = ASRUtils::make_StructType_t_util(
+                                al, args[i]->base.loc, arg_sym0, true);
                             type_subs[param].second = arg_sym0;
                         } else {
                             arg_type = ASRUtils::symbol_type(arg_sym);
@@ -11182,19 +13646,25 @@ public:
                         type_subs[param].first = ASRUtils::duplicate_type(al, arg_type);
                     } else {
                         // Handling local variables passed as instantiate's arguments
-                        ASR::symbol_t *arg_sym = current_scope->resolve_symbol(arg);
-                        ASR::ttype_t *arg_type = ASRUtils::symbol_type(arg_sym);
-                        if (!ASRUtils::check_equal_type(arg_type, param_type, ASRUtils::get_expr_from_sym(
-                            al, arg_sym), ASRUtils::get_expr_from_sym(al, param_sym))) {
-                            diag.add(Diagnostic("The type of " + arg + " does not match the type of " + param,
-                                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        ASR::symbol_t* arg_sym = current_scope->resolve_symbol(arg);
+                        ASR::ttype_t* arg_type = ASRUtils::symbol_type(arg_sym);
+                        if (!ASRUtils::check_equal_type(
+                                arg_type,
+                                param_type,
+                                ASRUtils::get_expr_from_sym(al, arg_sym),
+                                ASRUtils::get_expr_from_sym(al, param_sym))) {
+                            diag.add(Diagnostic("The type of " + arg
+                                                    + " does not match the type of " + param,
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { loc }) }));
                             throw SemanticAbort();
                         }
                         symbol_subs[param] = arg_sym;
                     }
                 }
             } else if (AST::is_a<AST::AttrIntrinsicOperator_t>(*args[i])) {
-                AST::AttrIntrinsicOperator_t *intrinsic_op
+                AST::AttrIntrinsicOperator_t* intrinsic_op
                     = AST::down_cast<AST::AttrIntrinsicOperator_t>(args[i]);
                 ASR::binopType binop = ASR::Add;
                 ASR::cmpopType cmpop = ASR::Eq;
@@ -11202,161 +13672,274 @@ public:
                 std::string op_name;
                 switch (intrinsic_op->m_op) {
                     case (AST::PLUS):
-                        is_binop = true; binop = ASR::Add; op_name = "~add"; break;
+                        is_binop = true;
+                        binop = ASR::Add;
+                        op_name = "~add";
+                        break;
                     case (AST::MINUS):
-                        is_binop = true; binop = ASR::Sub; op_name = "~sub"; break;
+                        is_binop = true;
+                        binop = ASR::Sub;
+                        op_name = "~sub";
+                        break;
                     case (AST::STAR):
-                        is_binop = true; binop = ASR::Mul; op_name = "~mul"; break;
+                        is_binop = true;
+                        binop = ASR::Mul;
+                        op_name = "~mul";
+                        break;
                     case (AST::DIV):
-                        is_binop = true; binop = ASR::Div; op_name = "~div"; break;
+                        is_binop = true;
+                        binop = ASR::Div;
+                        op_name = "~div";
+                        break;
                     case (AST::POW):
-                        is_binop = true; binop = ASR::Pow; op_name = "~pow"; break;
+                        is_binop = true;
+                        binop = ASR::Pow;
+                        op_name = "~pow";
+                        break;
                     case (AST::EQ):
-                        is_cmpop = true; cmpop = ASR::Eq; op_name = "~eq"; break;
+                        is_cmpop = true;
+                        cmpop = ASR::Eq;
+                        op_name = "~eq";
+                        break;
                     case (AST::NOTEQ):
-                        is_cmpop = true; cmpop = ASR::NotEq; op_name = "~neq"; break;
+                        is_cmpop = true;
+                        cmpop = ASR::NotEq;
+                        op_name = "~neq";
+                        break;
                     case (AST::LT):
-                        is_cmpop = true; cmpop = ASR::Lt; op_name = "~lt"; break;
+                        is_cmpop = true;
+                        cmpop = ASR::Lt;
+                        op_name = "~lt";
+                        break;
                     case (AST::LTE):
-                        is_cmpop = true; cmpop = ASR::LtE; op_name = "~lte"; break;
+                        is_cmpop = true;
+                        cmpop = ASR::LtE;
+                        op_name = "~lte";
+                        break;
                     case (AST::GT):
-                        is_cmpop = true; cmpop = ASR::Gt; op_name = "~gt"; break;
+                        is_cmpop = true;
+                        cmpop = ASR::Gt;
+                        op_name = "~gt";
+                        break;
                     case (AST::GTE):
-                        is_cmpop = true; cmpop = ASR::GtE; op_name = "~gte"; break;
+                        is_cmpop = true;
+                        cmpop = ASR::GtE;
+                        op_name = "~gte";
+                        break;
                     default:
                         diag.add(Diagnostic("Unsupported binary operator",
-                            Level::Error, Stage::Semantic, {Label("", {args[i]->base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { args[i]->base.loc }) }));
                         throw SemanticAbort();
                 }
 
                 bool is_overloaded;
                 if (is_binop) {
-                    is_overloaded = ASRUtils::is_op_overloaded(binop, op_name, current_scope, nullptr);
+                    is_overloaded
+                        = ASRUtils::is_op_overloaded(binop, op_name, current_scope, nullptr);
                 } else if (is_cmpop) {
-                    is_overloaded = ASRUtils::is_op_overloaded(cmpop, op_name, current_scope, nullptr);
+                    is_overloaded
+                        = ASRUtils::is_op_overloaded(cmpop, op_name, current_scope, nullptr);
                 } else {
                     throw LCompilersException("ICE: must be binop or cmop");
                 }
 
-                ASR::Function_t *f = ASR::down_cast<ASR::Function_t>(param_sym);
+                ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(param_sym);
                 std::string f_name = f->m_name;
                 bool found = false;
                 // check if an alias is defined for the operator
                 if (is_overloaded) {
                     ASR::symbol_t* sym = current_scope->resolve_symbol(op_name);
                     ASR::symbol_t* orig_sym = ASRUtils::symbol_get_past_external(sym);
-                    ASR::CustomOperator_t* gen_proc = ASR::down_cast<ASR::CustomOperator_t>(orig_sym);
+                    ASR::CustomOperator_t* gen_proc
+                        = ASR::down_cast<ASR::CustomOperator_t>(orig_sym);
                     for (size_t i = 0; i < gen_proc->n_procs && !found; i++) {
                         ASR::symbol_t* proc = gen_proc->m_procs[i];
-                        found = check_restriction(type_subs,
-                                    symbol_subs, f, proc, loc, diag,
-                                    []() { throw SemanticAbort(); }, false);
+                        found = check_restriction(
+                            type_subs,
+                            symbol_subs,
+                            f,
+                            proc,
+                            loc,
+                            diag,
+                            []() { throw SemanticAbort(); },
+                            false);
                     }
                 }
 
                 // if not found, then try to build a function for intrinsic operator
                 if (!found) {
                     if (f->n_args != 2) {
-                        diag.add(Diagnostic("The restriction " + f_name
-                            + " does not have 2 parameters", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        diag.add(
+                            Diagnostic("The restriction " + f_name + " does not have 2 parameters",
+                                       Level::Error,
+                                       Stage::Semantic,
+                                       { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
 
-                    ASR::ttype_t *left_type = ASRUtils::subs_expr_type(type_subs, f->m_args[0]);
-                    ASR::ttype_t *right_type = ASRUtils::subs_expr_type(type_subs, f->m_args[1]);
-                    ASR::ttype_t *ftype = ASRUtils::subs_expr_type(type_subs, f->m_return_var);
+                    ASR::ttype_t* left_type = ASRUtils::subs_expr_type(type_subs, f->m_args[0]);
+                    ASR::ttype_t* right_type = ASRUtils::subs_expr_type(type_subs, f->m_args[1]);
+                    ASR::ttype_t* ftype = ASRUtils::subs_expr_type(type_subs, f->m_return_var);
 
-                    SymbolTable *parent_scope = current_scope;
+                    SymbolTable* parent_scope = current_scope;
                     current_scope = al.make_new<SymbolTable>(parent_scope);
                     Vec<ASR::expr_t*> args;
                     args.reserve(al, 2);
-                    for (size_t i=0; i<2; i++) {
+                    for (size_t i = 0; i < 2; i++) {
                         std::string var_name = "arg" + std::to_string(i);
-                        ASR::asr_t *v = ASRUtils::make_Variable_t_util(al, loc, current_scope,
-                            s2c(al, var_name), nullptr, 0, ASR::intentType::In, nullptr,
-                            nullptr, ASR::storage_typeType::Default,
+                        ASR::asr_t* v = ASRUtils::make_Variable_t_util(
+                            al,
+                            loc,
+                            current_scope,
+                            s2c(al, var_name),
+                            nullptr,
+                            0,
+                            ASR::intentType::In,
+                            nullptr,
+                            nullptr,
+                            ASR::storage_typeType::Default,
                             (i == 0 ? ASRUtils::duplicate_type(al, left_type)
-                                : ASRUtils::duplicate_type(al, right_type)),
-                            nullptr, ASR::abiType::Source, ASR::accessType::Private,
-                            ASR::presenceType::Required, false);
+                                    : ASRUtils::duplicate_type(al, right_type)),
+                            nullptr,
+                            ASR::abiType::Source,
+                            ASR::accessType::Private,
+                            ASR::presenceType::Required,
+                            false);
                         current_scope->add_symbol(var_name, ASR::down_cast<ASR::symbol_t>(v));
-                        ASR::symbol_t *var = current_scope->get_symbol(var_name);
+                        ASR::symbol_t* var = current_scope->get_symbol(var_name);
                         args.push_back(al, ASRUtils::EXPR(ASR::make_Var_t(al, loc, var)));
                     }
 
                     std::string func_name = parent_scope->get_unique_name(op_name + "_intrinsic");
 
-                    ASR::ttype_t *return_type = nullptr;
-                    ASR::expr_t *value = nullptr;
-                    ASR::expr_t *left = ASRUtils::EXPR(ASR::make_Var_t(al, loc,
-                        current_scope->get_symbol("arg0")));
-                    ASR::expr_t *right = ASRUtils::EXPR(ASR::make_Var_t(al, loc,
-                        current_scope->get_symbol("arg1")));
+                    ASR::ttype_t* return_type = nullptr;
+                    ASR::expr_t* value = nullptr;
+                    ASR::expr_t* left = ASRUtils::EXPR(
+                        ASR::make_Var_t(al, loc, current_scope->get_symbol("arg0")));
+                    ASR::expr_t* right = ASRUtils::EXPR(
+                        ASR::make_Var_t(al, loc, current_scope->get_symbol("arg1")));
 
-                    ASR::expr_t **conversion_cand = &left;
-                    ASR::ttype_t *source_type = left_type;
-                    ASR::ttype_t *dest_type = right_type;
+                    ASR::expr_t** conversion_cand = &left;
+                    ASR::ttype_t* source_type = left_type;
+                    ASR::ttype_t* dest_type = right_type;
 
                     if (is_binop) {
-                        ImplicitCastRules::find_conversion_candidate(&left, &right, left_type,
-                                                                     right_type, conversion_cand,
-                                                                     &source_type, &dest_type);
-                        ImplicitCastRules::set_converted_value(al, loc, conversion_cand,
-                                                               source_type, dest_type, diag);
+                        ImplicitCastRules::find_conversion_candidate(&left,
+                                                                     &right,
+                                                                     left_type,
+                                                                     right_type,
+                                                                     conversion_cand,
+                                                                     &source_type,
+                                                                     &dest_type);
+                        ImplicitCastRules::set_converted_value(
+                            al, loc, conversion_cand, source_type, dest_type, diag);
                         return_type = ASRUtils::duplicate_type(al, ftype);
-                        value = ASRUtils::EXPR(ASRUtils::make_Binop_util(al, loc, binop, left, right, dest_type));
-                        if (!ASRUtils::check_equal_type(dest_type, return_type, f->m_args[1], f->m_return_var)) {
-                            diag.add(Diagnostic("Unapplicable types for intrinsic operator " + op_name,
-                                Level::Error, Stage::Semantic, {Label("", {loc})}));
+                        value = ASRUtils::EXPR(
+                            ASRUtils::make_Binop_util(al, loc, binop, left, right, dest_type));
+                        if (!ASRUtils::check_equal_type(
+                                dest_type, return_type, f->m_args[1], f->m_return_var)) {
+                            diag.add(
+                                Diagnostic("Unapplicable types for intrinsic operator " + op_name,
+                                           Level::Error,
+                                           Stage::Semantic,
+                                           { Label("", { loc }) }));
                             throw SemanticAbort();
                         }
                     } else {
-                        return_type = ASRUtils::TYPE(ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
-                        value = ASRUtils::EXPR(ASRUtils::make_Cmpop_util(al, loc, cmpop, left, right, left_type));
+                        return_type = ASRUtils::TYPE(
+                            ASR::make_Logical_t(al, loc, compiler_options.po.default_integer_kind));
+                        value = ASRUtils::EXPR(
+                            ASRUtils::make_Cmpop_util(al, loc, cmpop, left, right, left_type));
                     }
 
-                    ASR::asr_t *return_v = ASRUtils::make_Variable_t_util(al, loc,
-                        current_scope, s2c(al, "ret"), nullptr, 0,
-                        ASR::intentType::ReturnVar, nullptr, nullptr, ASR::storage_typeType::Default,
-                        return_type, ASRUtils::get_struct_sym_from_struct_expr(value), ASR::abiType::Source,
-                        ASR::accessType::Private, ASR::presenceType::Required, false);
+                    ASR::asr_t* return_v = ASRUtils::make_Variable_t_util(
+                        al,
+                        loc,
+                        current_scope,
+                        s2c(al, "ret"),
+                        nullptr,
+                        0,
+                        ASR::intentType::ReturnVar,
+                        nullptr,
+                        nullptr,
+                        ASR::storage_typeType::Default,
+                        return_type,
+                        ASRUtils::get_struct_sym_from_struct_expr(value),
+                        ASR::abiType::Source,
+                        ASR::accessType::Private,
+                        ASR::presenceType::Required,
+                        false);
                     current_scope->add_symbol("ret", ASR::down_cast<ASR::symbol_t>(return_v));
-                    ASR::expr_t *return_expr = ASRUtils::EXPR(ASR::make_Var_t(al, loc,
-                        current_scope->get_symbol("ret")));
+                    ASR::expr_t* return_expr = ASRUtils::EXPR(
+                        ASR::make_Var_t(al, loc, current_scope->get_symbol("ret")));
 
                     Vec<ASR::stmt_t*> body;
                     body.reserve(al, 1);
-                    ASR::symbol_t *return_sym = current_scope->get_symbol("ret");
-                    ASR::expr_t *target = ASRUtils::EXPR(ASR::make_Var_t(al, loc, return_sym));
+                    ASR::symbol_t* return_sym = current_scope->get_symbol("ret");
+                    ASR::expr_t* target = ASRUtils::EXPR(ASR::make_Var_t(al, loc, return_sym));
                     ASRUtils::make_ArrayBroadcast_t_util(al, loc, target, value);
-                    ASR::stmt_t *assignment = ASRUtils::STMT(ASRUtils::make_Assignment_t_util(al, loc,
-                        target, value, nullptr, compiler_options.po.realloc_lhs_arrays, false));
+                    ASR::stmt_t* assignment = ASRUtils::STMT(
+                        ASRUtils::make_Assignment_t_util(al,
+                                                         loc,
+                                                         target,
+                                                         value,
+                                                         nullptr,
+                                                         compiler_options.po.realloc_lhs_arrays,
+                                                         false));
                     body.push_back(al, assignment);
 
-                    ASR::asr_t *op_function = ASRUtils::make_Function_t_util(
-                        al, loc, current_scope, s2c(al, func_name),
-                        nullptr, 0, args.p, 2, body.p, 1, return_expr,
-                        ASR::abiType::Source, ASR::accessType::Public,
-                        ASR::deftypeType::Implementation, nullptr, false, true,
-                        false, false, false, nullptr, 0, false, false, true);
-                    ASR::symbol_t *op_sym = ASR::down_cast<ASR::symbol_t>(op_function);
+                    ASR::asr_t* op_function
+                        = ASRUtils::make_Function_t_util(al,
+                                                         loc,
+                                                         current_scope,
+                                                         s2c(al, func_name),
+                                                         nullptr,
+                                                         0,
+                                                         args.p,
+                                                         2,
+                                                         body.p,
+                                                         1,
+                                                         return_expr,
+                                                         ASR::abiType::Source,
+                                                         ASR::accessType::Public,
+                                                         ASR::deftypeType::Implementation,
+                                                         nullptr,
+                                                         false,
+                                                         true,
+                                                         false,
+                                                         false,
+                                                         false,
+                                                         nullptr,
+                                                         0,
+                                                         false,
+                                                         false,
+                                                         true);
+                    ASR::symbol_t* op_sym = ASR::down_cast<ASR::symbol_t>(op_function);
                     parent_scope->add_symbol(func_name, op_sym);
 
                     Vec<ASR::symbol_t*> symbols;
                     if (parent_scope->get_symbol(op_name) != nullptr) {
-                        ASR::CustomOperator_t *old_c = ASR::down_cast<ASR::CustomOperator_t>(
+                        ASR::CustomOperator_t* old_c = ASR::down_cast<ASR::CustomOperator_t>(
                             parent_scope->get_symbol(op_name));
                         symbols.reserve(al, old_c->n_procs + 1);
-                        for (size_t i=0; i<old_c->n_procs; i++) {
+                        for (size_t i = 0; i < old_c->n_procs; i++) {
                             symbols.push_back(al, old_c->m_procs[i]);
                         }
                     } else {
                         symbols.reserve(al, 1);
                     }
                     symbols.push_back(al, ASR::down_cast<ASR::symbol_t>(op_function));
-                    ASR::asr_t *c = ASR::make_CustomOperator_t(al, loc,
-                        parent_scope, s2c(al, op_name), symbols.p, symbols.size(), ASR::Public);
-                    parent_scope->add_or_overwrite_symbol(op_name, ASR::down_cast<ASR::symbol_t>(c));
+                    ASR::asr_t* c = ASR::make_CustomOperator_t(al,
+                                                               loc,
+                                                               parent_scope,
+                                                               s2c(al, op_name),
+                                                               symbols.p,
+                                                               symbols.size(),
+                                                               ASR::Public);
+                    parent_scope->add_or_overwrite_symbol(op_name,
+                                                          ASR::down_cast<ASR::symbol_t>(c));
 
                     current_scope = parent_scope;
                     symbol_subs[f->m_name] = op_sym;
@@ -11366,61 +13949,67 @@ public:
             }
         }
 
-        ASR::symbol_t *s = temp->m_symtab->resolve_symbol(func_name);
+        ASR::symbol_t* s = temp->m_symtab->resolve_symbol(func_name);
 
-        SymbolTable *target_scope = current_scope;
+        SymbolTable* target_scope = current_scope;
         if (is_nested) {
             target_scope = current_scope->parent;
         }
 
         std::string new_func_name = target_scope->get_unique_name("__instantiated_" + func_name);
 
-        ASR::symbol_t* new_s = instantiate_symbol(al, target_scope, type_subs, symbol_subs, new_func_name, s);
+        ASR::symbol_t* new_s
+            = instantiate_symbol(al, target_scope, type_subs, symbol_subs, new_func_name, s);
         instantiate_body(al, type_subs, symbol_subs, new_s, s);
 
         return new_func_name;
     }
 
-    void visit_BinOp(const AST::BinOp_t &x) {
+    void visit_BinOp(const AST::BinOp_t& x)
+    {
         if (AST::is_a<AST::BOZ_t>(*x.m_left) || AST::is_a<AST::BOZ_t>(*x.m_right)) {
             diag.add(Diagnostic("BOZ literal constant cannot be used in binary operations",
-                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         this->visit_expr(*x.m_left);
-        ASR::expr_t *left = ASRUtils::EXPR(tmp);
+        ASR::expr_t* left = ASRUtils::EXPR(tmp);
         this->visit_expr(*x.m_right);
-        ASR::expr_t *right = ASRUtils::EXPR(tmp);
+        ASR::expr_t* right = ASRUtils::EXPR(tmp);
         visit_BinOp2(al, x, left, right, tmp, binop2str[x.m_op], current_scope);
 
         if (ASR::is_a<ASR::IntegerBinOp_t>(*ASRUtils::EXPR(tmp))) {
-            ASR::IntegerBinOp_t *bin_op = ASR::down_cast<ASR::IntegerBinOp_t>(ASRUtils::EXPR(tmp));
-            ASR::expr_t *right_value = ASRUtils::expr_value(bin_op->m_right);
-            if (bin_op->m_op == ASR::Div && right_value != nullptr && ASR::is_a<ASR::IntegerConstant_t>(*right_value)) {
-                ASR::IntegerConstant_t *right_const = ASR::down_cast<ASR::IntegerConstant_t>(right_value);
+            ASR::IntegerBinOp_t* bin_op = ASR::down_cast<ASR::IntegerBinOp_t>(ASRUtils::EXPR(tmp));
+            ASR::expr_t* right_value = ASRUtils::expr_value(bin_op->m_right);
+            if (bin_op->m_op == ASR::Div && right_value != nullptr
+                && ASR::is_a<ASR::IntegerConstant_t>(*right_value)) {
+                ASR::IntegerConstant_t* right_const
+                    = ASR::down_cast<ASR::IntegerConstant_t>(right_value);
                 if (right_const->m_n == 0) {
-                    diag.add(Diagnostic(
-                        "Division by zero",
-                        Level::Error, Stage::Semantic, {
-                            Label("", {x.base.base.loc})
-                        })
-                    );
+                    diag.add(Diagnostic("Division by zero",
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             }
         }
     }
 
-    void visit_DefTOp(ASR::expr_t* first_operand, ASR::expr_t* second_operand, const std::string op, const Location loc) {
+    void visit_DefTOp(ASR::expr_t* first_operand,
+                      ASR::expr_t* second_operand,
+                      const std::string op,
+                      const Location loc)
+    {
         bool is_binary = (second_operand != nullptr);
 
-        ASR::Struct_t *first_struct = nullptr;
+        ASR::Struct_t* first_struct = nullptr;
         if (ASR::is_a<ASR::StructType_t>(*ASRUtils::expr_type(first_operand))) {
             first_struct = ASR::down_cast<ASR::Struct_t>(
-                ASRUtils::symbol_get_past_external(
-                    ASRUtils::symbol_get_past_external(ASRUtils::get_struct_sym_from_struct_expr(first_operand))
-                )
-            );
+                ASRUtils::symbol_get_past_external(ASRUtils::symbol_get_past_external(
+                    ASRUtils::get_struct_sym_from_struct_expr(first_operand))));
         }
 
         std::string new_op = op;
@@ -11435,18 +14024,20 @@ public:
         if (first_struct != nullptr && operator_sym == nullptr) {
             operator_sym = first_struct->m_symtab->resolve_symbol("~def_op~" + op);
             if (operator_sym == nullptr) {
-                diag.add(Diagnostic("`" + op
-                    + "` is not defined in the Struct: `" + first_struct->m_name
-                    + "`", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                diag.add(Diagnostic("`" + op + "` is not defined in the Struct: `"
+                                        + first_struct->m_name + "`",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { loc }) }));
                 throw SemanticAbort();
             }
         }
 
         if (operator_sym == nullptr) {
-            diag.add(Diagnostic(
-                "`" + op + "` is not defined or imported",
-                Level::Error, Stage::Semantic, {Label("", {loc})}
-            ));
+            diag.add(Diagnostic("`" + op + "` is not defined or imported",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { loc }) }));
             throw SemanticAbort();
         }
 
@@ -11472,14 +14063,18 @@ public:
                 throw SemanticAbort();
             }
 
-            ASR::Function_t* func = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(proc));
+            ASR::Function_t* func
+                = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(proc));
             if ((is_binary && func->n_args != 2) || (!is_binary && func->n_args != 1))
                 continue;
-            bool args_match = ASRUtils::check_equal_type(ASRUtils::expr_type(func->m_args[0]), left_type, func->m_args[0], first_operand);
+            bool args_match = ASRUtils::check_equal_type(
+                ASRUtils::expr_type(func->m_args[0]), left_type, func->m_args[0], first_operand);
             if (is_binary) {
                 args_match = args_match
                              && ASRUtils::check_equal_type(ASRUtils::expr_type(func->m_args[1]),
-                                                           right_type, func->m_args[1], second_operand);
+                                                           right_type,
+                                                           func->m_args[1],
+                                                           second_operand);
             }
             if (!args_match)
                 continue;
@@ -11508,10 +14103,17 @@ public:
                 if (proc_owner) {
                     module_name = ASRUtils::symbol_name(proc_owner);
                 }
-                a_name = ASR::down_cast<ASR::symbol_t>(ASR::make_ExternalSymbol_t(
-                    al, proc->base.loc, current_scope,
-                    s2c(al, matched_func_name), proc, s2c(al, module_name),
-                    nullptr, 0, s2c(al, std::string(func->m_name)), ASR::accessType::Public));
+                a_name = ASR::down_cast<ASR::symbol_t>(
+                    ASR::make_ExternalSymbol_t(al,
+                                               proc->base.loc,
+                                               current_scope,
+                                               s2c(al, matched_func_name),
+                                               proc,
+                                               s2c(al, module_name),
+                                               nullptr,
+                                               0,
+                                               s2c(al, std::string(func->m_name)),
+                                               ASR::accessType::Public));
                 current_scope->add_symbol(matched_func_name, a_name);
             }
             if (!a_name) {
@@ -11540,18 +14142,29 @@ public:
                 // return_type = ASRUtils::fix_scoped_type(al, type, current_scope);
             }
 
-            if (a_name && ASRUtils::symbol_parent_symtab(a_name)->get_counter()
-                        != current_scope->get_counter()) {
+            if (a_name
+                && ASRUtils::symbol_parent_symtab(a_name)->get_counter()
+                       != current_scope->get_counter()) {
                 ADD_ASR_DEPENDENCIES_WITH_NAME(current_scope,
-                                                a_name,
-                                                current_function_dependencies,
-                                                s2c(al, matched_func_name));
+                                               a_name,
+                                               current_function_dependencies,
+                                               s2c(al, matched_func_name));
             }
 
             ASRUtils::insert_module_dependency(a_name, al, current_module_dependencies);
             ASRUtils::set_absent_optional_arguments_to_null(a_args, func, al);
 
-            tmp = ASRUtils::make_FunctionCall_t_util(al, loc, a_name, op_sym, a_args.p, a_args.size(), return_type, nullptr, nullptr, current_scope, current_function_dependencies);
+            tmp = ASRUtils::make_FunctionCall_t_util(al,
+                                                     loc,
+                                                     a_name,
+                                                     op_sym,
+                                                     a_args.p,
+                                                     a_args.size(),
+                                                     return_type,
+                                                     nullptr,
+                                                     nullptr,
+                                                     current_scope,
+                                                     current_function_dependencies);
             matched = true;
             break;
         }
@@ -11566,7 +14179,8 @@ public:
         }
     }
 
-    void visit_DefUnaryOp(const AST::DefUnaryOp_t &x) {
+    void visit_DefUnaryOp(const AST::DefUnaryOp_t& x)
+    {
         this->visit_expr(*x.m_operand);
         ASR::expr_t* operand = ASRUtils::EXPR(tmp);
 
@@ -11574,58 +14188,73 @@ public:
         visit_DefTOp(operand, nullptr, op, x.base.base.loc);
     }
 
-    void visit_DefBinOp(const AST::DefBinOp_t &x) {
+    void visit_DefBinOp(const AST::DefBinOp_t& x)
+    {
         this->visit_expr(*x.m_left);
-        ASR::expr_t *left = ASRUtils::EXPR(tmp);
+        ASR::expr_t* left = ASRUtils::EXPR(tmp);
         this->visit_expr(*x.m_right);
-        ASR::expr_t *right = ASRUtils::EXPR(tmp);
+        ASR::expr_t* right = ASRUtils::EXPR(tmp);
 
         std::string op = std::string(x.m_op);
         visit_DefTOp(left, right, op, x.base.base.loc);
     }
 
-    void visit_BoolOp(const AST::BoolOp_t &x) {
+    void visit_BoolOp(const AST::BoolOp_t& x)
+    {
         this->visit_expr(*x.m_left);
-        ASR::expr_t *left = ASRUtils::EXPR(tmp);
+        ASR::expr_t* left = ASRUtils::EXPR(tmp);
         this->visit_expr(*x.m_right);
-        ASR::expr_t *right = ASRUtils::EXPR(tmp);
-        CommonVisitorMethods::visit_BoolOp(al, x, left, right, tmp, diag, boolop2str[x.m_op], current_scope, current_function_dependencies, current_module_dependencies);
-    }
-
-    void visit_StrOp(const AST::StrOp_t &x) {
+        ASR::expr_t* right = ASRUtils::EXPR(tmp);
+        CommonVisitorMethods::visit_BoolOp(al,
+                                           x,
+                                           left,
+                                           right,
+                                           tmp,
+                                           diag,
+                                           boolop2str[x.m_op],
+                                           current_scope,
+                                           current_function_dependencies,
+                                           current_module_dependencies);
+    }
+
+    void visit_StrOp(const AST::StrOp_t& x)
+    {
         this->visit_expr(*x.m_left);
-        ASR::expr_t *left = ASRUtils::EXPR(tmp);
+        ASR::expr_t* left = ASRUtils::EXPR(tmp);
         this->visit_expr(*x.m_right);
-        ASR::expr_t *right = ASRUtils::EXPR(tmp);
+        ASR::expr_t* right = ASRUtils::EXPR(tmp);
         std::string intrinsic_op_name = intrinsic2str[AST::intrinsicopType::CONCAT];
         LCOMPILERS_ASSERT(x.m_op == AST::Concat)
-        ASR::ttype_t *left_type_ = ASRUtils::expr_type(left);
-        ASR::ttype_t *right_type_ = ASRUtils::expr_type(right);
-        ASR::ttype_t *left_type = ASRUtils::type_get_past_array(
-            ASRUtils::type_get_past_allocatable(left_type_));
-        ASR::ttype_t *right_type = ASRUtils::type_get_past_array(
-            ASRUtils::type_get_past_allocatable(right_type_));
-
-        if( ASR::is_a<ASR::String_t>(*left_type) &&
-            ASR::is_a<ASR::String_t>(*right_type) ) { // CreateIntrinisc `stringConcat`
-            Vec<ASR::expr_t*> v; v.reserve(al, 1);
+        ASR::ttype_t* left_type_ = ASRUtils::expr_type(left);
+        ASR::ttype_t* right_type_ = ASRUtils::expr_type(right);
+        ASR::ttype_t* left_type
+            = ASRUtils::type_get_past_array(ASRUtils::type_get_past_allocatable(left_type_));
+        ASR::ttype_t* right_type
+            = ASRUtils::type_get_past_array(ASRUtils::type_get_past_allocatable(right_type_));
+
+        if (ASR::is_a<ASR::String_t>(*left_type)
+            && ASR::is_a<ASR::String_t>(*right_type)) {  // CreateIntrinisc `stringConcat`
+            Vec<ASR::expr_t*> v;
+            v.reserve(al, 1);
             v.push_back(al, left);
             v.push_back(al, right);
-            LCOMPILERS_ASSERT(ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function("stringconcat"))
-            tmp = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("stringconcat")(al, x.base.base.loc, v, diag);
+            LCOMPILERS_ASSERT(
+                ASRUtils::IntrinsicElementalFunctionRegistry::is_intrinsic_function("stringconcat"))
+            tmp = ASRUtils::IntrinsicElementalFunctionRegistry::get_create_function("stringconcat")(
+                al, x.base.base.loc, v, diag);
         } else {
             Vec<ASR::call_arg_t> args;
-            ASR::symbol_t* op_proc = resolve_custom_operator_proc(intrinsic_op_name, left, right, x, args);
+            ASR::symbol_t* op_proc
+                = resolve_custom_operator_proc(intrinsic_op_name, left, right, x, args);
 
             ASR::Function_t* func = nullptr;
             if (ASR::is_a<ASR::StructMethodDeclaration_t>(*op_proc)) {
-                ASR::StructMethodDeclaration_t* temp_struct_method =
-                    ASR::down_cast<ASR::StructMethodDeclaration_t>(op_proc);
+                ASR::StructMethodDeclaration_t* temp_struct_method
+                    = ASR::down_cast<ASR::StructMethodDeclaration_t>(op_proc);
                 func = ASR::down_cast<ASR::Function_t>(temp_struct_method->m_proc);
 
             } else {
-                func = ASR::down_cast<ASR::Function_t>(
-                    ASRUtils::symbol_get_past_external(op_proc));
+                func = ASR::down_cast<ASR::Function_t>(ASRUtils::symbol_get_past_external(op_proc));
             }
 
             ASR::ttype_t* return_type = ASRUtils::get_FunctionType(func)->m_return_var_type;
@@ -11638,237 +14267,297 @@ public:
                 func_name = mangled_name;
             }
             v = current_scope->resolve_symbol(func_name);
-            if( v == nullptr ) {
-                diag.add(Diagnostic("'" + func_name +
-                    "' not found in current scope", Level::Error, Stage::Semantic, {Label("", {v->base.loc})}));
+            if (v == nullptr) {
+                diag.add(Diagnostic("'" + func_name + "' not found in current scope",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { v->base.loc }) }));
                 throw SemanticAbort();
             }
             ADD_ASR_DEPENDENCIES(current_scope, v, current_function_dependencies);
             ASRUtils::insert_module_dependency(v, al, current_module_dependencies);
-            tmp = ASRUtils::make_FunctionCall_t_util(al, x.base.base.loc, v,
-                v, args.p, args.size(), return_type, nullptr, nullptr, current_scope, current_function_dependencies
-                );
-            tmp = ASR::make_OverloadedStringConcat_t(al, x.base.base.loc,
-                left, right, return_type, nullptr, ASRUtils::EXPR(tmp));
-        }
-    }
-
-    void visit_UnaryOp(const AST::UnaryOp_t &x) {
+            tmp = ASRUtils::make_FunctionCall_t_util(al,
+                                                     x.base.base.loc,
+                                                     v,
+                                                     v,
+                                                     args.p,
+                                                     args.size(),
+                                                     return_type,
+                                                     nullptr,
+                                                     nullptr,
+                                                     current_scope,
+                                                     current_function_dependencies);
+            tmp = ASR::make_OverloadedStringConcat_t(
+                al, x.base.base.loc, left, right, return_type, nullptr, ASRUtils::EXPR(tmp));
+        }
+    }
+
+    void visit_UnaryOp(const AST::UnaryOp_t& x)
+    {
         this->visit_expr(*x.m_operand);
-        ASR::expr_t *operand = ASRUtils::EXPR(tmp);
-        CommonVisitorMethods::visit_UnaryOp(al, x, operand, tmp,
-            current_scope, current_function_dependencies,
-            current_module_dependencies, diag);
+        ASR::expr_t* operand = ASRUtils::EXPR(tmp);
+        CommonVisitorMethods::visit_UnaryOp(al,
+                                            x,
+                                            operand,
+                                            tmp,
+                                            current_scope,
+                                            current_function_dependencies,
+                                            current_module_dependencies,
+                                            diag);
     }
 
-    void visit_Compare(const AST::Compare_t &x) {
+    void visit_Compare(const AST::Compare_t& x)
+    {
         this->visit_expr(*x.m_left);
-        ASR::expr_t *left = ASRUtils::EXPR(tmp);
+        ASR::expr_t* left = ASRUtils::EXPR(tmp);
         this->visit_expr(*x.m_right);
-        ASR::expr_t *right = ASRUtils::EXPR(tmp);
-        CommonVisitorMethods::visit_Compare(al, x, left, right, tmp,
-                                            cmpop2str[x.m_op], current_scope,
+        ASR::expr_t* right = ASRUtils::EXPR(tmp);
+        CommonVisitorMethods::visit_Compare(al,
+                                            x,
+                                            left,
+                                            right,
+                                            tmp,
+                                            cmpop2str[x.m_op],
+                                            current_scope,
                                             current_function_dependencies,
                                             current_module_dependencies,
-                                            compiler_options, diag);
+                                            compiler_options,
+                                            diag);
     }
 
-    void visit_Parenthesis(const AST::Parenthesis_t &x) {
+    void visit_Parenthesis(const AST::Parenthesis_t& x)
+    {
         this->visit_expr(*x.m_operand);
     }
 
-    void visit_Logical(const AST::Logical_t &x) {
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+    void visit_Logical(const AST::Logical_t& x)
+    {
+        ASR::ttype_t* type = ASRUtils::TYPE(
+            ASR::make_Logical_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
         tmp = ASR::make_LogicalConstant_t(al, x.base.base.loc, x.m_value, type);
     }
 
-    void visit_String(const AST::String_t &x) {
+    void visit_String(const AST::String_t& x)
+    {
         int s_len = strlen(x.m_s);
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_String_t(al, x.base.base.loc, 1, 
-            ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, s_len,
-                ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)))),
-            ASR::string_length_kindType::ExpressionLength,
-            ASR::string_physical_typeType::DescriptorString));
+        ASR::ttype_t* type = ASRUtils::TYPE(
+            ASR::make_String_t(al,
+                               x.base.base.loc,
+                               1,
+                               ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                                   al,
+                                   x.base.base.loc,
+                                   s_len,
+                                   ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4)))),
+                               ASR::string_length_kindType::ExpressionLength,
+                               ASR::string_physical_typeType::DescriptorString));
         tmp = ASR::make_StringConstant_t(al, x.base.base.loc, x.m_s, type);
     }
 
-    void visit_BOZ(const AST::BOZ_t& x) {
+    void visit_BOZ(const AST::BOZ_t& x)
+    {
         std::string s = std::string(x.m_s);
         int base = -1;
         ASR::integerbozType boz_type;
-        //Check if the argument string is correct BOZ Type
-        if( s[0] == 'b' || s[0] == 'B' ) {
+        // Check if the argument string is correct BOZ Type
+        if (s[0] == 'b' || s[0] == 'B') {
             boz_type = ASR::integerbozType::Binary;
             base = 2;
-        } else if( s[0] == 'z' || s[0] == 'Z' ) {
+        } else if (s[0] == 'z' || s[0] == 'Z') {
             boz_type = ASR::integerbozType::Hex;
             base = 16;
-        } else if( s[0] == 'o' || s[0] == 'O' ) {
+        } else if (s[0] == 'o' || s[0] == 'O') {
             boz_type = ASR::integerbozType::Octal;
             base = 8;
         } else {
             diag.add(Diagnostic(R"""(Only 'b', 'o' and 'z'
                                 are accepted as prefixes of
                                 BOZ literal constants.)""",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
         std::string boz_str = s.substr(2, s.size() - 2);
-        //Check if BOZ string has more than 64 Bits, else stoull Throws Error
-        //Truncate to Maximum allowed size, dropping most significant bits
-        if ((((s[0]=='b') || (s[0]=='B')) && (boz_str.size()> 65)) || 
-            (((s[0]=='o') || (s[0]=='O')) && (boz_str.size()> 22)) || 
-            (((s[0]=='z') || (s[0]=='Z')) && (boz_str.size()> 17))) {
-            std::string char_length = (s[0] == 'b' || s[0] == 'B') ? "64" : (s[0] == 'o' || s[0] == 'O') ? "21" : "16";
-            //Last character is single quote ', so we need to subtract 1 further from the length
+        // Check if BOZ string has more than 64 Bits, else stoull Throws Error
+        // Truncate to Maximum allowed size, dropping most significant bits
+        if ((((s[0] == 'b') || (s[0] == 'B')) && (boz_str.size() > 65))
+            || (((s[0] == 'o') || (s[0] == 'O')) && (boz_str.size() > 22))
+            || (((s[0] == 'z') || (s[0] == 'Z')) && (boz_str.size() > 17))) {
+            std::string char_length = (s[0] == 'b' || s[0] == 'B')   ? "64"
+                                      : (s[0] == 'o' || s[0] == 'O') ? "21"
+                                                                     : "16";
+            // Last character is single quote ', so we need to subtract 1 further from the length
             boz_str = boz_str.substr(boz_str.size() - std::stoi(char_length) - 1, boz_str.size());
-            diag.semantic_warning_label(
-                "BOZ literal constant with '" + std::string(1, s[0]) + 
-                "' prefix truncated to maximum " + char_length + " characters from left to fit data type",
-                {x.base.base.loc},
-                "BOZ truncation"
-            );
+            diag.semantic_warning_label("BOZ literal constant with '" + std::string(1, s[0])
+                                            + "' prefix truncated to maximum " + char_length
+                                            + " characters from left to fit data type",
+                                        { x.base.base.loc },
+                                        "BOZ truncation");
         }
         uint64_t boz_unsigned_int = std::stoull(boz_str, nullptr, base);
-        //If current_variable_type is Real Type, convert BOZ String to ASR::Real 
-        if ((current_variable_type_ != nullptr) && (ASR::is_a<ASR::Real_t>(*current_variable_type_)) ){
-            
+        // If current_variable_type is Real Type, convert BOZ String to ASR::Real
+        if ((current_variable_type_ != nullptr)
+            && (ASR::is_a<ASR::Real_t>(*current_variable_type_))) {
             // We need the smallest positive real value, and scale the bits accordingly
             double min_boz = std::numeric_limits<float>::denorm_min();
             // Scale the BOZ value: each bit represents smallest_subnormal
             double boz_double = static_cast<double>(boz_unsigned_int) * min_boz;
-            ASR::ttype_t* real_type = ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-            tmp = ASR::make_RealConstant_t(al, x.base.base.loc, boz_double,
-                    real_type);
+            ASR::ttype_t* real_type = ASRUtils::TYPE(
+                ASR::make_Real_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+            tmp = ASR::make_RealConstant_t(al, x.base.base.loc, boz_double, real_type);
         }
 
-        //If current_variable_type is Null or INT Type, default to INT 
-        else{            
+        // If current_variable_type is Null or INT Type, default to INT
+        else {
             int64_t boz_int = static_cast<int64_t>(boz_unsigned_int);
-            ASR::ttype_t* int_type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
-            tmp = ASR::make_IntegerConstant_t(al, x.base.base.loc, boz_int,
-                    int_type, boz_type);
+            ASR::ttype_t* int_type = ASRUtils::TYPE(
+                ASR::make_Integer_t(al, x.base.base.loc, compiler_options.po.default_integer_kind));
+            tmp = ASR::make_IntegerConstant_t(al, x.base.base.loc, boz_int, int_type, boz_type);
         }
     }
 
-    void visit_Num(const AST::Num_t &x) {
+    void visit_Num(const AST::Num_t& x)
+    {
         int ikind = compiler_options.po.default_integer_kind;
         if (x.m_kind) {
             ikind = std::atoi(x.m_kind);
             if (ikind == 0) {
                 std::string var_name = x.m_kind;
-                ASR::symbol_t *v = current_scope->resolve_symbol(to_lower(var_name));
+                ASR::symbol_t* v = current_scope->resolve_symbol(to_lower(var_name));
                 if (v) {
-                    const ASR::symbol_t *v3 = ASRUtils::symbol_get_past_external(v);
+                    const ASR::symbol_t* v3 = ASRUtils::symbol_get_past_external(v);
                     if (ASR::is_a<ASR::Variable_t>(*v3)) {
-                        ASR::Variable_t *v2 = ASR::down_cast<ASR::Variable_t>(v3);
+                        ASR::Variable_t* v2 = ASR::down_cast<ASR::Variable_t>(v3);
                         if (v2->m_value) {
                             if (ASR::is_a<ASR::IntegerConstant_t>(*v2->m_value)) {
                                 ikind = ASR::down_cast<ASR::IntegerConstant_t>(v2->m_value)->m_n;
                             } else {
-                                diag.add(Diagnostic("Variable '" + var_name + "' is constant but not an integer",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                diag.add(Diagnostic("Variable '" + var_name
+                                                        + "' is constant but not an integer",
+                                                    Level::Error,
+                                                    Stage::Semantic,
+                                                    { Label("", { x.base.base.loc }) }));
                                 throw SemanticAbort();
                             }
                         } else {
                             diag.add(Diagnostic("Variable '" + var_name + "' is not constant",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     } else {
                         diag.add(Diagnostic("Symbol '" + var_name + "' is not a variable",
-                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 } else {
                     diag.add(Diagnostic("Variable '" + var_name + "' not declared",
-                        Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             }
         }
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Integer_t(al,
-                x.base.base.loc, ikind));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, ikind));
         if (BigInt::is_int_ptr(x.m_n)) {
             std::string str_repr = BigInt::largeint_to_string(x.m_n);
-            if( !BigInt::is_int64(str_repr) ) {
+            if (!BigInt::is_int64(str_repr)) {
                 diag.add(Diagnostic("Integer constants larger than 2^64-1 are not implemented yet",
-                                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             int64_t m_n = std::stoll(str_repr);
-            tmp = ASR::make_IntegerConstant_t(al, x.base.base.loc,
-                                                m_n, type);
+            tmp = ASR::make_IntegerConstant_t(al, x.base.base.loc, m_n, type);
         } else {
             tmp = ASR::make_IntegerConstant_t(al, x.base.base.loc, x.m_n, type);
         }
     }
 
 
-    void visit_Real(const AST::Real_t &x) {
+    void visit_Real(const AST::Real_t& x)
+    {
         // First determine the kind into r_kind (e.g., 4 or 8)
         char* s_kind;
         int r_kind = ASRUtils::extract_kind_str(x.m_n, s_kind);
         if (r_kind == 0) {
             std::string var_name = to_lower(s_kind);
-            ASR::symbol_t *v = current_scope->resolve_symbol(var_name);
+            ASR::symbol_t* v = current_scope->resolve_symbol(var_name);
             if (v) {
-                const ASR::symbol_t *v3 = ASRUtils::symbol_get_past_external(v);
+                const ASR::symbol_t* v3 = ASRUtils::symbol_get_past_external(v);
                 if (ASR::is_a<ASR::Variable_t>(*v3)) {
-                    ASR::Variable_t *v2 = ASR::down_cast<ASR::Variable_t>(v3);
+                    ASR::Variable_t* v2 = ASR::down_cast<ASR::Variable_t>(v3);
                     if (v2->m_value) {
                         if (ASR::is_a<ASR::IntegerConstant_t>(*v2->m_value)) {
                             r_kind = ASR::down_cast<ASR::IntegerConstant_t>(v2->m_value)->m_n;
                         } else {
-                            diag.add(Diagnostic("Variable '" + var_name + "' is constant but not an integer",
-                                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                            diag.add(Diagnostic("Variable '" + var_name
+                                                    + "' is constant but not an integer",
+                                                Level::Error,
+                                                Stage::Semantic,
+                                                { Label("", { x.base.base.loc }) }));
                             throw SemanticAbort();
                         }
                     } else {
                         diag.add(Diagnostic("Variable '" + var_name + "' is not constant",
-                            Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                            Level::Error,
+                                            Stage::Semantic,
+                                            { Label("", { x.base.base.loc }) }));
                         throw SemanticAbort();
                     }
                 } else {
                     diag.add(Diagnostic("Symbol '" + var_name + "' is not a variable",
-                        Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                        Level::Error,
+                                        Stage::Semantic,
+                                        { Label("", { x.base.base.loc }) }));
                     throw SemanticAbort();
                 }
             } else {
                 diag.add(Diagnostic("Variable '" + var_name + "' not declared",
-                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
 
         // Now extract the number into this kind correctly
         double r = -1;
-        if ( r_kind == 4 ) {
+        if (r_kind == 4) {
             r = ASRUtils::extract_real_4(x.m_n);
-        } else if ( r_kind == 8 ) {
+        } else if (r_kind == 8) {
             r = ASRUtils::extract_real_8(x.m_n);
         } else {
             diag.add(Diagnostic("Kind not supported",
-                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, r_kind));
+        ASR::ttype_t* type = ASRUtils::TYPE(ASR::make_Real_t(al, x.base.base.loc, r_kind));
         tmp = ASR::make_RealConstant_t(al, x.base.base.loc, r, type);
     }
 
-    void visit_Complex(const AST::Complex_t &x) {
+    void visit_Complex(const AST::Complex_t& x)
+    {
         this->visit_expr(*x.m_re);
-        ASR::expr_t *re = ASRUtils::EXPR(tmp);
-        ASR::expr_t *re_value = ASRUtils::expr_value(re);
+        ASR::expr_t* re = ASRUtils::EXPR(tmp);
+        ASR::expr_t* re_value = ASRUtils::expr_value(re);
         int a_kind_r = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(re));
         this->visit_expr(*x.m_im);
-        ASR::expr_t *im = ASRUtils::EXPR(tmp);
-        ASR::expr_t *im_value = ASRUtils::expr_value(im);
+        ASR::expr_t* im = ASRUtils::EXPR(tmp);
+        ASR::expr_t* im_value = ASRUtils::expr_value(im);
         int a_kind_i = ASRUtils::extract_kind_from_ttype_t(ASRUtils::expr_type(im));
         // TODO: Add semantic checks what type are allowed
-        ASR::ttype_t *type = ASRUtils::TYPE(ASR::make_Complex_t(al, x.base.base.loc,
-                std::max(a_kind_r, a_kind_i)));
-        ASR::expr_t *value = nullptr;
+        ASR::ttype_t* type = ASRUtils::TYPE(
+            ASR::make_Complex_t(al, x.base.base.loc, std::max(a_kind_r, a_kind_i)));
+        ASR::expr_t* value = nullptr;
         if (re_value && im_value) {
             double re_double;
             if (ASR::is_a<ASR::RealConstant_t>(*re_value)) {
@@ -11876,8 +14565,11 @@ public:
             } else if (ASR::is_a<ASR::IntegerConstant_t>(*re_value)) {
                 re_double = ASR::down_cast<ASR::IntegerConstant_t>(re_value)->m_n;
             } else {
-                diag.add(Diagnostic("Argument `a` in a ComplexConstructor `(a,b)` must be either Real or Integer",
-                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                diag.add(Diagnostic(
+                    "Argument `a` in a ComplexConstructor `(a,b)` must be either Real or Integer",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
             double im_double;
@@ -11886,34 +14578,39 @@ public:
             } else if (ASR::is_a<ASR::IntegerConstant_t>(*im_value)) {
                 im_double = ASR::down_cast<ASR::IntegerConstant_t>(im_value)->m_n;
             } else {
-                diag.add(Diagnostic("Argument `b` in a ComplexConstructor `(a,b)` must be either Real or Integer",
-                    Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+                diag.add(Diagnostic(
+                    "Argument `b` in a ComplexConstructor `(a,b)` must be either Real or Integer",
+                    Level::Error,
+                    Stage::Semantic,
+                    { Label("", { x.base.base.loc }) }));
                 throw SemanticAbort();
             }
-            value = ASR::down_cast<ASR::expr_t>(ASR::make_ComplexConstant_t(al, x.base.base.loc, re_double, im_double, type));
+            value = ASR::down_cast<ASR::expr_t>(
+                ASR::make_ComplexConstant_t(al, x.base.base.loc, re_double, im_double, type));
         }
-        tmp = ASR::make_ComplexConstructor_t(al, x.base.base.loc,
-                re, im, type, value);
+        tmp = ASR::make_ComplexConstructor_t(al, x.base.base.loc, re, im, type, value);
     }
 
-    Vec<ASR::expr_t*> visit_expr_list(AST::fnarg_t *ast_list, size_t n) {
+    Vec<ASR::expr_t*> visit_expr_list(AST::fnarg_t* ast_list, size_t n)
+    {
         Vec<ASR::expr_t*> asr_list;
         asr_list.reserve(al, n);
-        for (size_t i=0; i<n; i++) {
+        for (size_t i = 0; i < n; i++) {
             LCOMPILERS_ASSERT(ast_list[i].m_end != nullptr);
             this->visit_expr(*ast_list[i].m_end);
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
             asr_list.push_back(al, expr);
         }
         return asr_list;
     }
 
-    void visit_expr_list(AST::fnarg_t *ast_list, size_t n, Vec<ASR::call_arg_t>& call_args) {
+    void visit_expr_list(AST::fnarg_t* ast_list, size_t n, Vec<ASR::call_arg_t>& call_args)
+    {
         call_args.reserve(al, n);
         for (size_t i = 0; i < n; i++) {
             LCOMPILERS_ASSERT(ast_list[i].m_end != nullptr);
             this->visit_expr(*ast_list[i].m_end);
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
             ASR::call_arg_t call_arg;
             call_arg.loc = expr->base.loc;
             call_arg.m_value = expr;
@@ -11921,16 +14618,16 @@ public:
         }
     }
 
-    std::vector<std::string> convert_fn_args_to_string(
-            ASR::expr_t **expr_list, size_t n) {
+    std::vector<std::string> convert_fn_args_to_string(ASR::expr_t** expr_list, size_t n)
+    {
         std::vector<std::string> result;
-        for (size_t i=0; i < n; i++) {
-            ASR::symbol_t* sym_i = ASRUtils::symbol_get_past_external(
-                ASR::down_cast<ASR::Var_t>(expr_list[i])->m_v);
-            if( ASR::is_a<ASR::Variable_t>(*sym_i) ) {
-                ASR::Variable_t *v = ASR::down_cast<ASR::Variable_t>(sym_i);
+        for (size_t i = 0; i < n; i++) {
+            ASR::symbol_t* sym_i
+                = ASRUtils::symbol_get_past_external(ASR::down_cast<ASR::Var_t>(expr_list[i])->m_v);
+            if (ASR::is_a<ASR::Variable_t>(*sym_i)) {
+                ASR::Variable_t* v = ASR::down_cast<ASR::Variable_t>(sym_i);
                 result.push_back(v->m_name);
-            } else if( ASR::is_a<ASR::Function_t>(*sym_i) ) {
+            } else if (ASR::is_a<ASR::Function_t>(*sym_i)) {
                 ASR::Function_t* f = ASR::down_cast<ASR::Function_t>(sym_i);
                 result.push_back(f->m_name);
             } else {
@@ -11941,37 +14638,43 @@ public:
     }
 
     template <typename T>
-    void visit_kwargs(Vec<ASR::call_arg_t>& args, AST::keyword_t *kwargs, size_t n,
-                ASR::expr_t **fn_args, size_t fn_n_args, const Location &loc, T* fn,
-                diag::Diagnostics& diag, size_t type_bound=0, bool is_nopass = false) {
+    void visit_kwargs(Vec<ASR::call_arg_t>& args,
+                      AST::keyword_t* kwargs,
+                      size_t n,
+                      ASR::expr_t** fn_args,
+                      size_t fn_n_args,
+                      const Location& loc,
+                      T* fn,
+                      diag::Diagnostics& diag,
+                      size_t type_bound = 0,
+                      bool is_nopass = false)
+    {
         int n_args = args.size();
         std::string fn_name = fn->m_name;
         if (is_nopass) {
             type_bound = 0;
         }
         bool is_method = (type_bound > 0);
-        if (n_args + (int)n > (int)fn_n_args) {
-            diag.semantic_error_label(
-                "Procedure '" + fn_name + "' accepts " + std::to_string(fn_n_args)
-                + " arguments, but " + std::to_string(n_args + n)
-                + " were provided",
-                {loc},
-                "incorrect number of arguments to '" + fn_name + "'"
-            );
+        if (n_args + (int) n > (int) fn_n_args) {
+            diag.semantic_error_label("Procedure '" + fn_name + "' accepts "
+                                          + std::to_string(fn_n_args) + " arguments, but "
+                                          + std::to_string(n_args + n) + " were provided",
+                                      { loc },
+                                      "incorrect number of arguments to '" + fn_name + "'");
             return;
         }
 
         std::vector<std::string> optional_args;
         std::vector<int> optional_args_idx;
-        for( auto itr = fn->m_symtab->get_scope().begin();
-             itr != fn->m_symtab->get_scope().end(); itr++ ) {
+        for (auto itr = fn->m_symtab->get_scope().begin(); itr != fn->m_symtab->get_scope().end();
+             itr++) {
             ASR::symbol_t* fn_sym = itr->second;
-            if( ASR::is_a<ASR::Variable_t>(*fn_sym) ) {
+            if (ASR::is_a<ASR::Variable_t>(*fn_sym)) {
                 ASR::Variable_t* fn_var = ASR::down_cast<ASR::Variable_t>(fn_sym);
-                if( fn_var->m_presence == ASR::presenceType::Optional ) {
+                if (fn_var->m_presence == ASR::presenceType::Optional) {
                     optional_args.push_back(itr->first);
-                    for( int i = 0; i < (int)fn_n_args; i++ ) {
-                        if( ASR::down_cast<ASR::Var_t>(fn_args[i])->m_v == fn_sym ) {
+                    for (int i = 0; i < (int) fn_n_args; i++) {
+                        if (ASR::down_cast<ASR::Var_t>(fn_args[i])->m_v == fn_sym) {
                             optional_args_idx.push_back(i - is_method);
                             break;
                         }
@@ -11983,79 +14686,80 @@ public:
         std::vector<std::string> fn_args2 = convert_fn_args_to_string(fn_args, fn_n_args);
 
         int offset = args.size();
-        for (int i = 0; i < (int)fn_n_args - offset - is_method; i++) {
+        for (int i = 0; i < (int) fn_n_args - offset - is_method; i++) {
             ASR::call_arg_t call_arg;
             call_arg.loc = loc;
             call_arg.m_value = nullptr;
             args.push_back(al, call_arg);
         }
 
-        for (int i = 0; i < (int)n; i++) {
+        for (int i = 0; i < (int) n; i++) {
             this->visit_expr(*kwargs[i].m_value);
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
             std::string name = to_lower(kwargs[i].m_arg);
             auto search = std::find(fn_args2.begin(), fn_args2.end(), name);
             if (search == fn_args2.end()) {
-                diag.semantic_error_label(
-                    "Keyword argument not found " + name,
-                    {loc},
-                    name + " is not a valid keyword argument.");
-                return ;
+                diag.semantic_error_label("Keyword argument not found " + name,
+                                          { loc },
+                                          name + " is not a valid keyword argument.");
+                return;
             }
 
-            int idx = std::distance(fn_args2.begin(), search) - (int)is_method;
+            int idx = std::distance(fn_args2.begin(), search) - (int) is_method;
             if (idx < n_args) {
-                diag.semantic_error_label(
-                    "Keyword argument '" + name + "' is already specified as a positional argument",
-                    {loc},
-                    "keyword argument '" + name + "' is already specified");
-                return ;
+                diag.semantic_error_label("Keyword argument '" + name
+                                              + "' is already specified as a positional argument",
+                                          { loc },
+                                          "keyword argument '" + name + "' is already specified");
+                return;
             }
             if (args[idx].m_value != nullptr) {
-                diag.semantic_error_label(
-                    "Keyword argument " + name + " is already specified",
-                    {loc},
-                    name + " keyword argument is already specified.");
-                return ;
+                diag.semantic_error_label("Keyword argument " + name + " is already specified",
+                                          { loc },
+                                          name + " keyword argument is already specified.");
+                return;
             }
             args.p[idx].loc = expr->base.loc;
             args.p[idx].m_value = expr;
         }
 
         // Ensure required arguments are provided, but skip optional ones
-        for (int i = 0; i < (int)args.size(); i++) {
+        for (int i = 0; i < (int) args.size(); i++) {
             if (args[i].m_value == nullptr) {
                 // Skip checking if the argument is optional
-                if (std::find(optional_args_idx.begin(), optional_args_idx.end(), i) != optional_args_idx.end()) {
+                if (std::find(optional_args_idx.begin(), optional_args_idx.end(), i)
+                    != optional_args_idx.end()) {
                     continue;
                 }
-                diag.semantic_error_label(
-                    "Argument was not specified",
-                    {loc},
-                    std::to_string(i) +
-                    "-th argument not specified for " + fn_name);
-                return ;
+                diag.semantic_error_label("Argument was not specified",
+                                          { loc },
+                                          std::to_string(i) + "-th argument not specified for "
+                                              + fn_name);
+                return;
             }
         }
     }
 
-    void visit_kwargs(Vec<ASR::call_arg_t>& args, AST::keyword_t *kwargs, size_t n,
-        const Location &loc, ASR::symbol_t* fn, diag::Diagnostics& diag) {
+    void visit_kwargs(Vec<ASR::call_arg_t>& args,
+                      AST::keyword_t* kwargs,
+                      size_t n,
+                      const Location& loc,
+                      ASR::symbol_t* fn,
+                      diag::Diagnostics& diag)
+    {
         fn = ASRUtils::symbol_get_past_external(fn);
         LCOMPILERS_ASSERT(ASR::is_a<ASR::Struct_t>(*fn));
         std::deque<std::string> constructor_args;
         std::deque<ASR::symbol_t*> constructor_arg_syms;
         ASR::Struct_t* fn_struct_type = ASR::down_cast<ASR::Struct_t>(fn);
-        while( fn_struct_type ) {
-            for( int i = (int) fn_struct_type->n_members - 1; i >= 0; i-- ) {
+        while (fn_struct_type) {
+            for (int i = (int) fn_struct_type->n_members - 1; i >= 0; i--) {
                 constructor_args.push_front(fn_struct_type->m_members[i]);
                 constructor_arg_syms.push_front(
-                    fn_struct_type->m_symtab->get_symbol(
-                        fn_struct_type->m_members[i]));
+                    fn_struct_type->m_symtab->get_symbol(fn_struct_type->m_members[i]));
             }
-            if( fn_struct_type->m_parent != nullptr ) {
-                ASR::symbol_t* fn_ = ASRUtils::symbol_get_past_external(
-                                        fn_struct_type->m_parent);
+            if (fn_struct_type->m_parent != nullptr) {
+                ASR::symbol_t* fn_ = ASRUtils::symbol_get_past_external(fn_struct_type->m_parent);
                 LCOMPILERS_ASSERT(ASR::is_a<ASR::Struct_t>(*fn_));
                 fn_struct_type = ASR::down_cast<ASR::Struct_t>(fn_);
             } else {
@@ -12064,7 +14768,7 @@ public:
         }
 
         int n_ = (int) constructor_args.size() - (int) args.size();
-        for( int i = 0; i < n_; i++ ) {
+        for (int i = 0; i < n_; i++) {
             ASR::call_arg_t empty_arg;
             Location loc;
             loc.first = 1, loc.last = 1;
@@ -12077,58 +14781,61 @@ public:
 
         for (size_t i = 0; i < n; i++) {
             this->visit_expr(*kwargs[i].m_value);
-            ASR::expr_t *expr = ASRUtils::EXPR(tmp);
+            ASR::expr_t* expr = ASRUtils::EXPR(tmp);
             std::string name = to_lower(kwargs[i].m_arg);
-            auto search = std::find(constructor_args.begin(),
-                                    constructor_args.end(), name);
+            auto search = std::find(constructor_args.begin(), constructor_args.end(), name);
             if (search == constructor_args.end()) {
-                diag.semantic_error_label(
-                    "Keyword argument not found",
-                    {loc},
-                    "'" + name + "'" + " keyword argument not found");
+                diag.semantic_error_label("Keyword argument not found",
+                                          { loc },
+                                          "'" + name + "'" + " keyword argument not found");
                 throw SemanticAbort();
             }
 
             size_t idx = std::distance(constructor_args.begin(), search);
             if (args[idx].m_value != nullptr) {
-                diag.semantic_error_label(
-                    "Keyword argument is already specified",
-                    {loc},
-                    "'" + name + "'" + + " keyword argument is already specified");
+                diag.semantic_error_label("Keyword argument is already specified",
+                                          { loc },
+                                          "'" + name + "'"
+                                              + +" keyword argument is already specified");
                 throw SemanticAbort();
             }
             args.p[idx].loc = expr->base.loc;
             args.p[idx].m_value = expr;
         }
 
-        // If value is not specified in args nor in keyword argument, set to default initializer if it exists
-        for( size_t i = 0; i < args.size(); i++ ) {
-            if( args[i].m_value == nullptr ) {
+        // If value is not specified in args nor in keyword argument, set to default initializer if
+        // it exists
+        for (size_t i = 0; i < args.size(); i++) {
+            if (args[i].m_value == nullptr) {
                 ASR::symbol_t* arg_sym = constructor_arg_syms[i];
                 LCOMPILERS_ASSERT(arg_sym != nullptr);
                 ASR::expr_t* default_init = nullptr;
                 bool is_default_needed = true;
-                if( ASR::is_a<ASR::Variable_t>(*arg_sym) ) {
+                if (ASR::is_a<ASR::Variable_t>(*arg_sym)) {
                     ASR::Variable_t* arg_var = ASR::down_cast<ASR::Variable_t>(arg_sym);
                     default_init = arg_var->m_value;
-                    if( ASRUtils::is_allocatable(arg_var->m_type) ) {
+                    if (ASRUtils::is_allocatable(arg_var->m_type)) {
                         is_default_needed = false;
                     }
                 }
-                if( default_init == nullptr && is_default_needed ) {
-                    diag.semantic_error_label(
-                        "Argument was not specified",
-                        {loc},
-                        "Argument '" + constructor_args[i] + "' not specified for " + ASRUtils::symbol_name(fn));
+                if (default_init == nullptr && is_default_needed) {
+                    diag.semantic_error_label("Argument was not specified",
+                                              { loc },
+                                              "Argument '" + constructor_args[i]
+                                                  + "' not specified for "
+                                                  + ASRUtils::symbol_name(fn));
                     throw SemanticAbort();
                 }
                 // Replace symbols in StructConstant to external symbols
                 if (default_init && ASR::is_a<ASR::StructConstant_t>(*default_init)) {
-                    ASR::StructConstant_t *st = ASR::down_cast<ASR::StructConstant_t>(default_init);
-                    ASR::symbol_t *ext_sym = current_scope->resolve_symbol(ASRUtils::symbol_name(st->m_dt_sym));
+                    ASR::StructConstant_t* st = ASR::down_cast<ASR::StructConstant_t>(default_init);
+                    ASR::symbol_t* ext_sym
+                        = current_scope->resolve_symbol(ASRUtils::symbol_name(st->m_dt_sym));
                     if (ASR::is_a<ASR::ExternalSymbol_t>(*ext_sym)) {
-                        ASR::ttype_t *type = ASRUtils::make_StructType_t_util(al, loc, ext_sym, true);
-                        default_init = ASRUtils::EXPR(ASR::make_StructConstant_t(al, loc, ext_sym, st->m_args, st->n_args, type));
+                        ASR::ttype_t* type
+                            = ASRUtils::make_StructType_t_util(al, loc, ext_sym, true);
+                        default_init = ASRUtils::EXPR(ASR::make_StructConstant_t(
+                            al, loc, ext_sym, st->m_args, st->n_args, type));
                     }
                 }
                 args.p[i].m_value = default_init;
@@ -12137,27 +14844,33 @@ public:
         }
 
         for (size_t i = 0; i < constructor_arg_syms.size(); i++) {
-            if( args[i].m_value != nullptr ) {
+            if (args[i].m_value != nullptr) {
                 ASR::symbol_t* member_sym = constructor_arg_syms[i];
-                ASR::ttype_t* member_type = ASRUtils::type_get_past_allocatable(
-                    ASRUtils::symbol_type(member_sym));
-                ASR::ttype_t* arg_type = ASRUtils::type_get_past_allocatable(
-                    ASRUtils::expr_type(args[i].m_value));
-                ImplicitCastRules::set_converted_value(al, loc,
-                    &args.p[i].m_value, arg_type, member_type, diag);
+                ASR::ttype_t* member_type
+                    = ASRUtils::type_get_past_allocatable(ASRUtils::symbol_type(member_sym));
+                ASR::ttype_t* arg_type
+                    = ASRUtils::type_get_past_allocatable(ASRUtils::expr_type(args[i].m_value));
+                ImplicitCastRules::set_converted_value(
+                    al, loc, &args.p[i].m_value, arg_type, member_type, diag);
             }
         }
-
     }
 
-    void visit_NameUtil(AST::struct_member_t* x_m_member, size_t x_n_member,
-                        char* x_m_id, const Location& loc) {
+    void visit_NameUtil(AST::struct_member_t* x_m_member,
+                        size_t x_n_member,
+                        char* x_m_id,
+                        const Location& loc)
+    {
         if (x_n_member == 0) {
             ASR::expr_t* expr = ASRUtils::EXPR(resolve_variable(loc, to_lower(x_m_id)));
-            if(x_m_member && x_m_member[0].m_args) {
-                expr = ASRUtils::EXPR(
-                    create_ArrayRef(loc, x_m_member[0].m_args, x_m_member[0].n_args,
-                    nullptr, 0, nullptr,
+            if (x_m_member && x_m_member[0].m_args) {
+                expr = ASRUtils::EXPR(create_ArrayRef(
+                    loc,
+                    x_m_member[0].m_args,
+                    x_m_member[0].n_args,
+                    nullptr,
+                    0,
+                    nullptr,
                     ASR::down_cast<ASR::Var_t>(expr)->m_v,
                     ASRUtils::symbol_get_past_external(ASR::down_cast<ASR::Var_t>(expr)->m_v)));
             }
@@ -12167,28 +14880,35 @@ public:
             // x_m_member[1].m_args ==> args of member of that derived type variable
             SymbolTable* scope = current_scope;
             tmp = (ASR::asr_t*) replace_with_common_block_variables(
-                ASRUtils::EXPR(this->resolve_variable2(loc, to_lower(x_m_id),
-                to_lower(x_m_member[0].m_name), scope, x_m_member[0].m_args,
-                x_m_member[0].n_args, x_m_member[1].m_args, x_m_member[1].n_args)));
+                ASRUtils::EXPR(this->resolve_variable2(loc,
+                                                       to_lower(x_m_id),
+                                                       to_lower(x_m_member[0].m_name),
+                                                       scope,
+                                                       x_m_member[0].m_args,
+                                                       x_m_member[0].n_args,
+                                                       x_m_member[1].m_args,
+                                                       x_m_member[1].n_args)));
         } else {
             SymbolTable* scope = current_scope;
             tmp = (ASR::asr_t*) replace_with_common_block_variables(
-                    ASRUtils::EXPR(this->resolve_variable2(loc,
-                    to_lower(x_m_member[1].m_name), to_lower(x_m_member[0].m_name), scope,
-                    x_m_member[0].m_args, x_m_member[0].n_args,
-                    x_m_member[1].m_args, x_m_member[1].n_args)));
-            bool is_tmp_array = ASRUtils::is_array(
-                ASRUtils::expr_type(ASRUtils::EXPR(tmp)));
+                ASRUtils::EXPR(this->resolve_variable2(loc,
+                                                       to_lower(x_m_member[1].m_name),
+                                                       to_lower(x_m_member[0].m_name),
+                                                       scope,
+                                                       x_m_member[0].m_args,
+                                                       x_m_member[0].n_args,
+                                                       x_m_member[1].m_args,
+                                                       x_m_member[1].n_args)));
+            bool is_tmp_array = ASRUtils::is_array(ASRUtils::expr_type(ASRUtils::EXPR(tmp)));
             ASR::StructInstanceMember_t* tmp2;
             std::uint32_t i;
-            for( i = 2; i < x_n_member; i++ ) {
-                tmp2 = (ASR::StructInstanceMember_t*) this->resolve_variable2(loc,
-                        to_lower(x_m_member[i].m_name), to_lower(x_m_member[i - 1].m_name),
-                        scope);
+            for (i = 2; i < x_n_member; i++) {
+                tmp2 = (ASR::StructInstanceMember_t*) this->resolve_variable2(
+                    loc, to_lower(x_m_member[i].m_name), to_lower(x_m_member[i - 1].m_name), scope);
                 ASR::ttype_t* tmp2_mem_type = tmp2->m_type;
-                ASR::symbol_t* tmp2_m_m_ext = ASRUtils::import_struct_instance_member(al,
-                                                    tmp2->m_m, current_scope);
-                if( is_tmp_array ) {
+                ASR::symbol_t* tmp2_m_m_ext
+                    = ASRUtils::import_struct_instance_member(al, tmp2->m_m, current_scope);
+                if (is_tmp_array) {
                     ASR::dimension_t* m_dims = nullptr;
                     int n_dims = ASRUtils::extract_dimensions_from_ttype(
                         ASRUtils::expr_type(ASRUtils::EXPR(tmp)), m_dims);
@@ -12200,26 +14920,31 @@ public:
                     al, loc, ASRUtils::EXPR(tmp), tmp2_m_m_ext, tmp2_mem_type, nullptr);
                 make_ArrayItem_from_struct_m_args(
                     x_m_member[i].m_args, x_m_member[i].n_args, ASRUtils::EXPR(tmp), tmp, loc);
-                if( ASR::is_a<ASR::ArraySection_t>(*ASRUtils::EXPR(tmp)) ) {
-                    if( is_tmp_array ) {
+                if (ASR::is_a<ASR::ArraySection_t>(*ASRUtils::EXPR(tmp))) {
+                    if (is_tmp_array) {
                         diag.add(Diagnostic(
-                            "The expression with derived types contains two or more arrays.", Level::Error, Stage::Semantic, {Label("", {loc})}));
+                            "The expression with derived types contains two or more arrays.",
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                     is_tmp_array = true;
                 }
             }
             i = x_n_member - 1;
-            tmp2 = (ASR::StructInstanceMember_t*) this->resolve_variable2(loc, to_lower(x_m_id),
-                        to_lower(x_m_member[i].m_name), scope);
+            tmp2 = (ASR::StructInstanceMember_t*) this->resolve_variable2(
+                loc, to_lower(x_m_id), to_lower(x_m_member[i].m_name), scope);
             ASR::ttype_t* tmp2_mem_type = tmp2->m_type;
-            ASR::symbol_t* tmp2_m_m_ext = ASRUtils::import_struct_instance_member(al, tmp2->m_m,
-                                            current_scope);
-            if( is_tmp_array ) {
-                if( ASRUtils::is_array(tmp2_mem_type) ) {
-                    diag.add(Diagnostic(
-                        "The expression with derived types contains two or more arrays.",
-                        Level::Error, Stage::Semantic, {Label("", {loc})}));
+            ASR::symbol_t* tmp2_m_m_ext
+                = ASRUtils::import_struct_instance_member(al, tmp2->m_m, current_scope);
+            if (is_tmp_array) {
+                if (ASRUtils::is_array(tmp2_mem_type)) {
+                    diag.add(
+                        Diagnostic("The expression with derived types contains two or more arrays.",
+                                   Level::Error,
+                                   Stage::Semantic,
+                                   { Label("", { loc }) }));
                     throw SemanticAbort();
                 }
                 ASR::dimension_t* m_dims = nullptr;
@@ -12229,51 +14954,61 @@ public:
                 m_dims_vec.from_pointer_n(m_dims, n_dims);
                 tmp2_mem_type = ASRUtils::duplicate_type(al, tmp2_mem_type, &m_dims_vec);
             }
-            tmp = ASR::make_StructInstanceMember_t(al, loc, ASRUtils::EXPR(tmp), tmp2_m_m_ext, tmp2_mem_type, nullptr);
+            tmp = ASR::make_StructInstanceMember_t(
+                al, loc, ASRUtils::EXPR(tmp), tmp2_m_m_ext, tmp2_mem_type, nullptr);
         }
         // Find array in the returning tmp expression. If found set tmp type to that array type.
         bool array_found = false;
-        ASR::ttype_t* array_type = nullptr; // will be set if only one single array is found. It'd be used to change the type of tmp.
+        ASR::ttype_t* array_type = nullptr;  // will be set if only one single array is found. It'd
+                                             // be used to change the type of tmp.
         ASR::asr_t* tmp_copy = tmp;
-        while(ASR::is_a<ASR::StructInstanceMember_t>(*ASRUtils::EXPR(tmp_copy)) ||
-            (ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp_copy)) &&
-             ASR::is_a<ASR::StructInstanceMember_t>(*(ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp_copy)))->m_v))){
+        while (ASR::is_a<ASR::StructInstanceMember_t>(*ASRUtils::EXPR(tmp_copy))
+               || (ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp_copy))
+                   && ASR::is_a<ASR::StructInstanceMember_t>(
+                       *(ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp_copy)))->m_v))) {
             ASR::StructInstanceMember_t* tmp2 = nullptr;
             bool check_m_m = true;
-            if(ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp_copy))){
-                tmp2 = ASR::down_cast<ASR::StructInstanceMember_t>(ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp_copy))->m_v);
+            if (ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp_copy))) {
+                tmp2 = ASR::down_cast<ASR::StructInstanceMember_t>(
+                    ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp_copy))->m_v);
                 check_m_m = false;
             } else if (ASR::is_a<ASR::StructInstanceMember_t>(*ASRUtils::EXPR(tmp_copy))) {
                 tmp2 = ASR::down_cast<ASR::StructInstanceMember_t>(ASRUtils::EXPR(tmp_copy));
             }
 
-            if(check_m_m){
-                ASR::ExternalSymbol_t* tmp2_m_m_ext = ASR::down_cast<ASR::ExternalSymbol_t>(tmp2->m_m);
-                if(ASR::is_a<ASR::Variable_t>(*(tmp2_m_m_ext->m_external)) &&
-                    ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable(ASRUtils::symbol_type(tmp2_m_m_ext->m_external)))){
-                    if(array_found){
+            if (check_m_m) {
+                ASR::ExternalSymbol_t* tmp2_m_m_ext
+                    = ASR::down_cast<ASR::ExternalSymbol_t>(tmp2->m_m);
+                if (ASR::is_a<ASR::Variable_t>(*(tmp2_m_m_ext->m_external))
+                    && ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable(
+                        ASRUtils::symbol_type(tmp2_m_m_ext->m_external)))) {
+                    if (array_found) {
                         diag.add(Diagnostic(
                             "The expression with derived types contains two or more arrays.",
-                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                     array_found = true;
-                    array_type = ASRUtils::duplicate_type(al,ASRUtils::symbol_type(tmp2->m_m));
+                    array_type = ASRUtils::duplicate_type(al, ASRUtils::symbol_type(tmp2->m_m));
                 }
             }
-            if(tmp2->m_v->type == ASR::exprType::Var){
+            if (tmp2->m_v->type == ASR::exprType::Var) {
                 ASR::ttype_t* var_type = ASRUtils::expr_type(tmp2->m_v);
-                if(ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable(var_type))){
-                    if(array_found){
+                if (ASR::is_a<ASR::Array_t>(*ASRUtils::type_get_past_allocatable(var_type))) {
+                    if (array_found) {
                         diag.add(Diagnostic(
                             "The expression with derived types contains two or more arrays.",
-                            Level::Error, Stage::Semantic, {Label("", {loc})}));
+                            Level::Error,
+                            Stage::Semantic,
+                            { Label("", { loc }) }));
                         throw SemanticAbort();
                     }
                     array_found = true;
-                    array_type = ASRUtils::duplicate_type(al,var_type);
+                    array_type = ASRUtils::duplicate_type(al, var_type);
                 }
-            } else if ( tmp2->m_v->type == ASR::exprType::ArraySection ) {
+            } else if (tmp2->m_v->type == ASR::exprType::ArraySection) {
                 ASR::ArraySection_t* array_section = ASR::down_cast<ASR::ArraySection_t>(tmp2->m_v);
 
                 Vec<ASR::dimension_t> dims;
@@ -12281,27 +15016,39 @@ public:
 
                 ASR::dimension_t dim;
                 dim.loc = loc;
-                dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, loc, 1, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4))));
-                dim.m_length = ASRUtils::compute_length_from_start_end(al, array_section->m_args->m_left, array_section->m_args->m_right);
+                dim.m_start = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                    al, loc, 1, ASRUtils::TYPE(ASR::make_Integer_t(al, loc, 4))));
+                dim.m_length = ASRUtils::compute_length_from_start_end(
+                    al, array_section->m_args->m_left, array_section->m_args->m_right);
                 dims.push_back(al, dim);
 
                 array_found = true;
-                array_type = ASRUtils::TYPE(ASR::make_Array_t(
-                    al, array_section->base.base.loc,
-                    tmp2->m_type, dims.p, dims.size(),
-                    ASRUtils::is_character(*tmp2->m_type)? ASR::PointerArray : ASR::FixedSizeArray));
-            }
-            tmp_copy = (ASR::asr_t*)(tmp2->m_v);
-        }
-        if(array_type){
-            if(ASR::is_a<ASR::StructInstanceMember_t>(*ASRUtils::EXPR(tmp))){
-                ASR::StructInstanceMember_t* tmp2 = ASR::down_cast<ASR::StructInstanceMember_t>(ASRUtils::EXPR(tmp));
-                if(ASR::is_a<ASR::Array_t>(*array_type)){
-                    (ASR::down_cast<ASR::Array_t>(array_type))->m_type = ASRUtils::type_get_past_array(tmp2->m_type);
+                array_type = ASRUtils::TYPE(ASR::make_Array_t(al,
+                                                              array_section->base.base.loc,
+                                                              tmp2->m_type,
+                                                              dims.p,
+                                                              dims.size(),
+                                                              ASRUtils::is_character(*tmp2->m_type)
+                                                                  ? ASR::PointerArray
+                                                                  : ASR::FixedSizeArray));
+            }
+            tmp_copy = (ASR::asr_t*) (tmp2->m_v);
+        }
+        if (array_type) {
+            if (ASR::is_a<ASR::StructInstanceMember_t>(*ASRUtils::EXPR(tmp))) {
+                ASR::StructInstanceMember_t* tmp2
+                    = ASR::down_cast<ASR::StructInstanceMember_t>(ASRUtils::EXPR(tmp));
+                if (ASR::is_a<ASR::Array_t>(*array_type)) {
+                    (ASR::down_cast<ASR::Array_t>(array_type))->m_type
+                        = ASRUtils::type_get_past_array(tmp2->m_type);
                     tmp2->m_type = array_type;
                 }
-                if(ASR::is_a<ASR::Allocatable_t>(*array_type)){
-                    ASR::down_cast<ASR::Array_t>((ASR::down_cast<ASR::Allocatable_t>(array_type))->m_type)->m_type = ASRUtils::type_get_past_array(ASRUtils::type_get_past_allocatable(tmp2->m_type));
+                if (ASR::is_a<ASR::Allocatable_t>(*array_type)) {
+                    ASR::down_cast<ASR::Array_t>(
+                        (ASR::down_cast<ASR::Allocatable_t>(array_type))->m_type)
+                        ->m_type
+                        = ASRUtils::type_get_past_array(
+                            ASRUtils::type_get_past_allocatable(tmp2->m_type));
                     if (ASRUtils::is_allocatable(ASRUtils::EXPR(tmp))) {
                         tmp2->m_type = array_type;
                     } else {
@@ -12311,116 +15058,147 @@ public:
 
             } else if (ASR::is_a<ASR::ArrayItem_t>(*ASRUtils::EXPR(tmp))) {
                 ASR::ArrayItem_t* tmp2 = ASR::down_cast<ASR::ArrayItem_t>(ASRUtils::EXPR(tmp));
-                if(ASR::is_a<ASR::Array_t>(*array_type)){
-                    (ASR::down_cast<ASR::Array_t>(array_type))->m_type = ASRUtils::type_get_past_array(tmp2->m_type);
+                if (ASR::is_a<ASR::Array_t>(*array_type)) {
+                    (ASR::down_cast<ASR::Array_t>(array_type))->m_type
+                        = ASRUtils::type_get_past_array(tmp2->m_type);
                     tmp2->m_type = array_type;
                 }
-                if(ASR::is_a<ASR::Allocatable_t>(*array_type)){
-                    ASR::down_cast<ASR::Array_t>((ASR::down_cast<ASR::Allocatable_t>(array_type))->m_type)->m_type = ASRUtils::type_get_past_array(ASRUtils::type_get_past_allocatable(tmp2->m_type));
+                if (ASR::is_a<ASR::Allocatable_t>(*array_type)) {
+                    ASR::down_cast<ASR::Array_t>(
+                        (ASR::down_cast<ASR::Allocatable_t>(array_type))->m_type)
+                        ->m_type
+                        = ASRUtils::type_get_past_array(
+                            ASRUtils::type_get_past_allocatable(tmp2->m_type));
                     tmp2->m_type = array_type;
                 }
             }
         }
     }
 
-    void visit_Name(const AST::Name_t &x) {
+    void visit_Name(const AST::Name_t& x)
+    {
         visit_NameUtil(x.m_member, x.n_member, x.m_id, x.base.base.loc);
     }
 
-    void determine_char_len_and_kind(const AST::kind_item_t* len_item, const AST::kind_item_t* kind_item,
-    AST::AttrType_t* type, AST::var_sym_t* var_sym, std::string& sym, ASR::String_t* str, bool is_argument, ASR::abiType abi) {
+    void determine_char_len_and_kind(const AST::kind_item_t* len_item,
+                                     const AST::kind_item_t* kind_item,
+                                     AST::AttrType_t* type,
+                                     AST::var_sym_t* var_sym,
+                                     std::string& sym,
+                                     ASR::String_t* str,
+                                     bool is_argument,
+                                     ASR::abiType abi)
+    {
         // Handle kind
-        if( kind_item &&
-            AST::is_a<AST::Name_t>(*kind_item->m_value) && 
-            std::string(AST::down_cast<AST::Name_t>(kind_item->m_value)->m_id) == "c_char" &&
-            is_argument &&
-            abi == ASR::BindC){
+        if (kind_item && AST::is_a<AST::Name_t>(*kind_item->m_value)
+            && std::string(AST::down_cast<AST::Name_t>(kind_item->m_value)->m_id) == "c_char"
+            && is_argument && abi == ASR::BindC) {
             str->m_physical_type = ASR::CChar;
         } else {
             str->m_physical_type = ASR::DescriptorString;
         }
         // Handle length
-        if(len_item){ // Standard Fortran Declaration. `character(len=10) :: str`
+        if (len_item) {  // Standard Fortran Declaration. `character(len=10) :: str`
             // Set length of the string -> [`:`, `*`, `expr`]
             switch (len_item->m_type) {
-                case (AST::kind_item_typeType::Value) : {
+                case (AST::kind_item_typeType::Value): {
                     LCOMPILERS_ASSERT(len_item->m_value != nullptr);
-                    if(is_funcCall_to_unresolved_genereicProcedure(len_item->m_value)){ // Postpone the evaluation
-                        postponed_genericProcedure_calls_vec.emplace_back(&str->m_len, current_scope,
-                        len_item->m_value, s2c(al, sym), [](ASR::expr_t* x){(void)x;});
-                    } else { // Evaluate normally
+                    if (is_funcCall_to_unresolved_genereicProcedure(
+                            len_item->m_value)) {  // Postpone the evaluation
+                        postponed_genericProcedure_calls_vec.emplace_back(
+                            &str->m_len,
+                            current_scope,
+                            len_item->m_value,
+                            s2c(al, sym),
+                            [](ASR::expr_t* x) { (void) x; });
+                    } else {  // Evaluate normally
                         _processing_char_len = true;
                         this->visit_expr(*len_item->m_value);
                         ASR::expr_t* len_expr = ASRUtils::EXPR(tmp);
-                        str->m_len = ASRUtils::is_const(len_expr) ? ASRUtils::expr_value(len_expr) : len_expr;
+                        str->m_len = ASRUtils::is_const(len_expr) ? ASRUtils::expr_value(len_expr)
+                                                                  : len_expr;
                         _processing_char_len = false;
                     }
                     str->m_len_kind = ASR::ExpressionLength;
                     break;
                 }
-                case (AST::kind_item_typeType::Star) : {
+                case (AST::kind_item_typeType::Star): {
                     LCOMPILERS_ASSERT(len_item->m_value == nullptr);
-                    str->m_len = nullptr; // If it's parameter variable, len will be set later.
+                    str->m_len = nullptr;  // If it's parameter variable, len will be set later.
                     str->m_len_kind = ASR::AssumedLength;
                     break;
                 }
-                case (AST::kind_item_typeType::Colon) : {
+                case (AST::kind_item_typeType::Colon): {
                     LCOMPILERS_ASSERT(len_item->m_value == nullptr);
                     str->m_len = nullptr;
                     str->m_len_kind = ASR::DeferredLength;
                     break;
                 }
-                default :{
+                default: {
                     throw LCompilersException("Character's len Not identified");
                 }
             }
-        } else if (type && var_sym) { // Old-Fortran-style Declaration
+        } else if (type && var_sym) {  // Old-Fortran-style Declaration
             // Set length of the string -> [None(default 1), `CHARACTER*(*)`, `CHARACTER :: s*(*)`]
-            if(type->m_sym == AST::DoubleAsterisk || var_sym->m_sym == AST::DoubleAsterisk){
+            if (type->m_sym == AST::DoubleAsterisk || var_sym->m_sym == AST::DoubleAsterisk) {
                 LCOMPILERS_ASSERT(!type->m_kind)
                 LCOMPILERS_ASSERT(!var_sym->m_length)
-                str->m_len = nullptr; // If it's parameter variable, len will be set later.
+                str->m_len = nullptr;  // If it's parameter variable, len will be set later.
                 str->m_len_kind = ASR::AssumedLength;
-            } else if(type->m_sym == AST::Asterisk){
+            } else if (type->m_sym == AST::Asterisk) {
                 throw LCompilersException("Unhandled case: `CHARACTER*(10)` OR `CHARACTER*(n)`");
-            } else if(var_sym->m_sym == AST::Asterisk){
+            } else if (var_sym->m_sym == AST::Asterisk) {
                 LCOMPILERS_ASSERT(var_sym->m_length != nullptr);
-                    if(is_funcCall_to_unresolved_genereicProcedure(var_sym->m_length)){ // Postpone the evaluation
-                        postponed_genericProcedure_calls_vec.emplace_back(&str->m_len, current_scope,
-                        var_sym->m_length, s2c(al, sym), [](ASR::expr_t* x){(void)x;});
-                    } else { // Evaluate normally
-                        _processing_char_len = true;
-                        this->visit_expr(*var_sym->m_length);
-                        ASR::expr_t* len_expr = ASRUtils::EXPR(tmp);
-                        str->m_len = ASRUtils::is_const(len_expr) ? ASRUtils::expr_value(len_expr) : len_expr;
-                        _processing_char_len = false;
-                    }
-                    str->m_len_kind = ASR::ExpressionLength;
-            } else {// Default len of "character :: x" is 1
-                str->m_len = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, type->base.base.loc, 1,
+                if (is_funcCall_to_unresolved_genereicProcedure(
+                        var_sym->m_length)) {  // Postpone the evaluation
+                    postponed_genericProcedure_calls_vec.emplace_back(
+                        &str->m_len,
+                        current_scope,
+                        var_sym->m_length,
+                        s2c(al, sym),
+                        [](ASR::expr_t* x) { (void) x; });
+                } else {  // Evaluate normally
+                    _processing_char_len = true;
+                    this->visit_expr(*var_sym->m_length);
+                    ASR::expr_t* len_expr = ASRUtils::EXPR(tmp);
+                    str->m_len
+                        = ASRUtils::is_const(len_expr) ? ASRUtils::expr_value(len_expr) : len_expr;
+                    _processing_char_len = false;
+                }
+                str->m_len_kind = ASR::ExpressionLength;
+            } else {  // Default len of "character :: x" is 1
+                str->m_len = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                    al,
+                    type->base.base.loc,
+                    1,
                     ASRUtils::TYPE(ASR::make_Integer_t(al, type->base.base.loc, 4))));
                 str->m_len_kind = ASR::string_length_kindType::ExpressionLength;
             }
-        } else { // Default len of "character :: x" is 1
-            str->m_len = ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, type->base.base.loc, 1,
+        } else {  // Default len of "character :: x" is 1
+            str->m_len = ASRUtils::EXPR(ASR::make_IntegerConstant_t(
+                al,
+                type->base.base.loc,
+                1,
                 ASRUtils::TYPE(ASR::make_Integer_t(al, type->base.base.loc, 4))));
             str->m_len_kind = ASR::string_length_kindType::ExpressionLength;
         }
 
-    // Check CChar length
-        if(str->m_physical_type == ASR::CChar){
+        // Check CChar length
+        if (str->m_physical_type == ASR::CChar) {
             int64_t len;
-            if( !ASRUtils::extract_value(str->m_len, len) || (len != 1) ){
-                diag.add(Diagnostic(
-                    "c_char should have a length of 1",
-                    Level::Error, Stage::Semantic, {Label("", {str->base.base.loc})}));
+            if (!ASRUtils::extract_value(str->m_len, len) || (len != 1)) {
+                diag.add(Diagnostic("c_char should have a length of 1",
+                                    Level::Error,
+                                    Stage::Semantic,
+                                    { Label("", { str->base.base.loc }) }));
                 throw SemanticAbort();
             }
         }
     }
 
     // check if the operator name need to be updated or not, and return it
-    std::string update_custom_op_name(const std::string &op) {
+    std::string update_custom_op_name(const std::string& op)
+    {
         // if operator name start with (contain) "~", it is already distinct so return it as it is
         if (op.find_first_of("~") != std::string::npos) {
             return op;
@@ -12430,8 +15208,12 @@ public:
         return "~~" + op;
     }
 
-    ASR::symbol_t* resolve_custom_operator_proc(const std::string& intrinsic_op_name, ASR::expr_t *left, ASR::expr_t *right,
-        const AST::StrOp_t &x, Vec<ASR::call_arg_t> &args) {
+    ASR::symbol_t* resolve_custom_operator_proc(const std::string& intrinsic_op_name,
+                                                ASR::expr_t* left,
+                                                ASR::expr_t* right,
+                                                const AST::StrOp_t& x,
+                                                Vec<ASR::call_arg_t>& args)
+    {
         ASR::symbol_t* sym = nullptr;
         ASR::symbol_t* left_symbol = nullptr;
         ASR::symbol_t* right_symbol = nullptr;
@@ -12451,7 +15233,7 @@ public:
         sym = current_scope->resolve_symbol(intrinsic_op_name);
         if (sym != nullptr) {
             // operator is defined outside both left and right symbols but inside current scope
-            ASR::symbol_t *op_proc = get_custom_op_proc(sym, args, x, false);
+            ASR::symbol_t* op_proc = get_custom_op_proc(sym, args, x, false);
             if (op_proc) {
                 return op_proc;
             }
@@ -12464,31 +15246,42 @@ public:
         ASR::symbol_t* struct_sym = left_symbol != nullptr ? left_symbol : right_symbol;
 
         if (struct_sym != nullptr) {
-            ASR::Struct_t* op_struct = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(struct_sym));
+            ASR::Struct_t* op_struct
+                = ASR::down_cast<ASR::Struct_t>(ASRUtils::symbol_get_past_external(struct_sym));
             sym = op_struct->m_symtab->resolve_symbol(intrinsic_op_name);
         }
 
         if (sym == nullptr) {
-            diag.add(Diagnostic(
-                "No custom operator exists for this expression",
-                Level::Error, Stage::Semantic, {Label("", {x.base.base.loc})}));
+            diag.add(Diagnostic("No custom operator exists for this expression",
+                                Level::Error,
+                                Stage::Semantic,
+                                { Label("", { x.base.base.loc }) }));
             throw SemanticAbort();
         }
 
         return get_custom_op_proc(sym, args, x, true);
     }
 
-    ASR::symbol_t* get_custom_op_proc(ASR::symbol_t *op_sym, Vec<ASR::call_arg_t>& args, const AST::StrOp_t &x, bool raise_error) {
-        LCOMPILERS_ASSERT(ASR::is_a<ASR::CustomOperator_t>(*ASRUtils::symbol_get_past_external(op_sym)));
-
-        ASR::CustomOperator_t* custom_op = ASR::down_cast<ASR::CustomOperator_t>(
-        ASRUtils::symbol_get_past_external(op_sym));
-
-        int i = ASRUtils::select_generic_procedure(args, *custom_op, x.base.base.loc,
-            [&](const std::string &msg, const Location &loc) {
-                    diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, {Label("", {loc})}));
-                    throw SemanticAbort();
-                }, raise_error);
+    ASR::symbol_t* get_custom_op_proc(ASR::symbol_t* op_sym,
+                                      Vec<ASR::call_arg_t>& args,
+                                      const AST::StrOp_t& x,
+                                      bool raise_error)
+    {
+        LCOMPILERS_ASSERT(
+            ASR::is_a<ASR::CustomOperator_t>(*ASRUtils::symbol_get_past_external(op_sym)));
+
+        ASR::CustomOperator_t* custom_op
+            = ASR::down_cast<ASR::CustomOperator_t>(ASRUtils::symbol_get_past_external(op_sym));
+
+        int i = ASRUtils::select_generic_procedure(
+            args,
+            *custom_op,
+            x.base.base.loc,
+            [&](const std::string& msg, const Location& loc) {
+                diag.add(Diagnostic(msg, Level::Error, Stage::Semantic, { Label("", { loc }) }));
+                throw SemanticAbort();
+            },
+            raise_error);
 
         if (i != -1) {
             return custom_op->m_procs[i];
@@ -12497,7 +15290,8 @@ public:
         return nullptr;
     }
 
-    ASR::symbol_t* resolve_struct_symbol(ASR::expr_t* x) {
+    ASR::symbol_t* resolve_struct_symbol(ASR::expr_t* x)
+    {
         if (x == nullptr)
             return nullptr;
 
@@ -12505,6 +15299,6 @@ public:
     }
 };
 
-} // namespace LCompilers::LFortran
+}  // namespace LCompilers::LFortran
 
 #endif /* LFORTRAN_SEMANTICS_AST_COMMON_VISITOR_H */
diff --git a/tests/errors/array_section_shape_mismatch_01.f90 b/tests/errors/array_section_shape_mismatch_01.f90
new file mode 100644
index 000000000..17cf4ca84
--- /dev/null
+++ b/tests/errors/array_section_shape_mismatch_01.f90
@@ -0,0 +1,5 @@
+program main
+    integer :: a(2), temp(2), i0
+    i0 = 1
+    a = temp(i0:i0)
+end program
