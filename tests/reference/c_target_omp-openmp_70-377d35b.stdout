#include <inttypes.h>

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <lfortran_intrinsics.h>


struct dimension_descriptor
{
    int32_t lower_bound, length, stride;
};

struct r32
{
    float *data;
    struct dimension_descriptor dims[32];
    int32_t n_dims;
    int32_t offset;
    bool is_allocated;
};




// Implementations
int main(int argc, char* argv[])
{
    _lpython_set_argv(argc, argv);
    int32_t __libasr_index_0_;
    int32_t __libasr_index_0_1;
    struct r32 a_value;
    struct r32* a = &a_value;
    float a_data[1000000];
    a->data = a_data;
    a->n_dims = 1;
    a->offset = 0;
    a->dims[0].lower_bound = 1;
    a->dims[0].length = 1000000;
    a->dims[0].stride = 1;
    struct r32 b_value;
    struct r32* b = &b_value;
    float b_data[1000000];
    b->data = b_data;
    b->n_dims = 1;
    b->offset = 0;
    b->dims[0].lower_bound = 1;
    b->dims[0].length = 1000000;
    b->dims[0].stride = 1;
    int32_t i;
    for (__libasr_index_0_=((int32_t)b->dims[1-1].lower_bound); __libasr_index_0_<=((int32_t) b->dims[1-1].length + b->dims[1-1].lower_bound - 1); __libasr_index_0_++) {
        b->data[(0 + (1 * (__libasr_index_0_ - 1)))] = (float)(5);
    }
    for (__libasr_index_0_1=((int32_t)a->dims[1-1].lower_bound); __libasr_index_0_1<=((int32_t) a->dims[1-1].length + a->dims[1-1].lower_bound - 1); __libasr_index_0_1++) {
        a->data[(0 + (1 * (__libasr_index_0_1 - 1)))] = (float)(0);
    }
#pragma omp target  map(tofrom: a->data[1:1000000]) map(tofrom: b->data[1:1000000])
#pragma omp teams 
#pragma omp distribute parallel for 
    for (i=1; i<=1000000; i++) {
        a->data[(0 + (1 * (i - 1)))] = (float)(i) + b->data[(0 + (1 * (i - 1)))]*(float)(340);
    }



    printf("%f%s%f\n", a->data[(0 + (1 * (5 - 1)))], " ", b->data[(0 + (1 * (5 - 1)))]);
    if (a->data[(0 + (1 * (5 - 1)))] != (float)(1705)) {
        fprintf(stderr, "ERROR STOP");
        exit(1);
    }
    if (b->data[(0 + (1 * (5 - 1)))] != (float)(5)) {
        fprintf(stderr, "ERROR STOP");
        exit(1);
    }
    return 0;
}
