# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 LFortran contributors
# This file is distributed under the same license as the LFortran package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: LFortran\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-08-18 00:30+0200\n"
"PO-Revision-Date: 2022-09-29 13:19+0000\n"
"Last-Translator: 左志华 <zuo.zhihua@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"fortran-lang/lfortran-docs/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14.1\n"
"Generated-By: Babel 2.10.3\n"

#: ../../doc/src/ast_and_asr.ipynb:9
msgid "Difference between an AST and ASR"
msgstr "AST 和 ASR 之间的区别"

#: ../../doc/src/ast_and_asr.ipynb:11
msgid "Let us take a simple Fortran code:"
msgstr "让我们看一个简单的 Fortran 代码："

#: ../../doc/src/ast_and_asr.ipynb:22
msgid "and look at how the AST and ASR looks like."
msgstr "看看 AST 和 ASR 的样子。"

#: ../../doc/src/ast_and_asr.ipynb:25 ../../doc/src/progress.md
msgid "AST"
msgstr "AST"

#: ../../doc/src/ast_and_asr.ipynb:76
msgid ""
"The AST does not have any semantic information, but has nodes to "
"represent declarations such as ``integer, intent(in) :: a``. Variables "
"such as ``a`` are represented by a ``Name`` node, and are not connected "
"to their declarations yet."
msgstr ""
"AST 没有任何语义信息，但具有表示声明的节点，例如 ``integer, intent(in) :: "
"a``。诸如 ``a`` 之类的变量由 ``Name`` 节点表示，并且尚未连接到它们的声明。"

#: ../../doc/src/ast_and_asr.ipynb:88 ../../doc/src/progress.md
msgid "ASR"
msgstr "ASR"

#: ../../doc/src/ast_and_asr.ipynb:139
msgid ""
"The ASR has all the semantic information (types, etc.), nodes like "
"``Function`` have a symbol table and do not have any declaration nodes. "
"Variables are simply pointers to the symbol table."
msgstr "ASR 有所有的语义信息（类型等），像 ``Function`` "
"这样的节点有一个符号表，没有任何声明节点。变量只是指向符号表的指针。"

#: ../../doc/src/ast_and_asr.ipynb:142
msgid "Discussion"
msgstr "讨论"

#: ../../doc/src/ast_and_asr.ipynb:144
msgid ""
"The above was a simple example. Things get more apparent for more "
"complicated examples, such as:"
msgstr "上面是一个简单的例子。对于更复杂的示例，事情变得更加明显，例如："

#: ../../doc/src/ast_and_asr.ipynb:160
msgid ""
"AST must represent all the ``use`` statements and the ``interface`` "
"block, and keep things semantically consistent."
msgstr "AST 必须代表所有的 ``use`` 语句和 ``interface`` 块，并保持语义一致。"

#: ../../doc/src/ast_and_asr.ipynb:162
msgid ""
"ASR, on the other hand, keeps track of the ``c_desc1_int32``, "
"``c_desc1_t`` and ``f2b_c_wrapper`` in the symbol table and it knows they"
" are defined in the ``gfort_interop`` module, and so ASR does not have "
"any of these declaration nodes."
msgstr ""
"另一方面，ASR 跟踪符号表中的 ``c_desc1_int32``、``c_desc1_t`` 和 "
"``f2b_c_wrapper``，并且知道它们是在 ``gfort_interop`` 模块中定义的，因此 ASR "
"没有任何这些声明节点。"

#: ../../doc/src/ast_and_asr.ipynb:164
msgid ""
"When converting from ASR to AST, LFortran will create all the appropriate"
" AST declaration nodes automatically and correctly."
msgstr "从 ASR 转换为 AST 时，LFortran 将自动且正确地创建所有适当的 AST 声明节点。"

#: ../../doc/src/contributing.md:1
msgid "Contributing"
msgstr "贡献"

#: ../../doc/src/contributing.md:3
msgid ""
"We welcome contributions from anyone, even if you are new to open source."
" It might sound daunting to contribute to a compiler at first, but please"
" do, it is not complicated. We will help you with any technical issues "
"and help improve your contribution so that it can be merged."
msgstr ""
"我们欢迎任何人的贡献，即使你是开源新手。起初为编译器做贡献可能听起来令人生畏"
"，但可以尝试去做，这并不复杂。我们将帮助你解决任何技术问题并帮助改进你的贡献"
"，以便将其合并。"

#: ../../doc/src/contributing.md:8
msgid "Basic Setup"
msgstr "基本设置"

#: ../../doc/src/contributing.md:10
msgid "To contribute, make sure your set up:"
msgstr "要做出贡献，请确保你的设置："

#: ../../doc/src/contributing.md:12
msgid "Your username + email"
msgstr "你的用户名 + 电子邮件"

#: ../../doc/src/contributing.md:13
msgid "Your `~/.gitconfig`"
msgstr "你的 `~/.gitconfig`"

#: ../../doc/src/contributing.md:14
msgid "Your shell prompt to display the current branch name"
msgstr "你的 shell 提示显示当前分支名称"

#: ../../doc/src/contributing.md:16
msgid "Fork LFortran"
msgstr "拉取分叉 LFortran"

#: ../../doc/src/contributing.md:18
msgid ""
"Step 1. Create a fork of the [project "
"repository](https://github.com/lfortran/lfortran)"
msgstr "步骤 1. 创建 [项目存储库](https://github.com/lfortran/lfortran) 的分支"

#: ../../doc/src/contributing.md:20
msgid ""
"Step 2. Set up your [SSH key](https://docs.github.com/en/authentication"
"/connecting-to-github-with-ssh) with GitHub"
msgstr ""
"步骤 2. 使用 GitHub 设置你的 [SSH 密钥](https://docs.github.com/en/"
"authentication/connecting-to-github-with-ssh)"

#: ../../doc/src/contributing.md:22
msgid ""
"Step 3. Clone the project repository from GitHub and set up your remote "
"repository"
msgstr "步骤 3. 从 GitHub 克隆项目存储库并设置你的远程存储库"

#: ../../doc/src/contributing.md:29
msgid ""
":fontawesome-solid-edit: `REMOTE_NAME` is the name of your remote "
"repository and could be any name you like, for example your first name."
msgstr ":fontawesome-solid-edit: `REMOTE_NAME` "
"是你的远程仓库的名字，可以是你喜欢的任何名字，例如你的名字。"

#: ../../doc/src/contributing.md:31
msgid ""
":fontawesome-solid-edit: `YOUR_GITHUB_ID` is your user ID on GitHub and "
"should be part of your account path."
msgstr ""
":fontawesome-solid-edit: `YOUR_GITHUB_ID` 是你在 GitHub 上的用户 "
"ID，应该是你帐户路径的一部分。"

#: ../../doc/src/contributing.md:33
msgid ""
"You can use `git remote -v` to check if the new remote is set up "
"correctly."
msgstr "你可以使用 `git remote -v` 检查新远程地址是否设置正确。"

#: ../../doc/src/contributing.md:35
msgid "Send a New Merge Request"
msgstr "发送新的合并请求"

#: ../../doc/src/contributing.md:37
msgid "Step 1. Create a new branch"
msgstr "步骤 1. 创建一个新分支"

#: ../../doc/src/contributing.md:42
msgid "Step 2. Make changes in relevant file(s)"
msgstr "步骤 2. 更改相关文件"

#: ../../doc/src/contributing.md:44
msgid "Step 3. Commit the changes:"
msgstr "步骤 3. 提交更改："

#: ../../doc/src/contributing.md:51
msgid ""
"[Here](https://chris.beams.io/posts/git-commit/) are some great tips on "
"writing good commit messages."
msgstr "[这里](https://chris.beams.io/posts/git-commit/) "
"是一些关于编写好的提交消息的好技巧。"

#: ../../doc/src/contributing.md:53
msgid "Step 4. Check to ensure that your changes look good"
msgstr "第 4 步：检查以确保你的更改看起来不错"

#: ../../doc/src/contributing.md:58
msgid "Step 5. Send the merge request"
msgstr "步骤 5. 发送合并请求"

#: ../../doc/src/contributing.md:64
msgid ""
"The command will push the new branch `fix1` into your remote repository "
"`REMOTE_NAME` that you created earlier. Additionally, it will also "
"display a link that you can click on to open the new merge request. After"
" clicking on the link, write a title and a concise description then click"
" the \"Create\" button. Yay you are now all set."
msgstr ""
"该命令会将新分支 `fix1` 推送到您之前创建的远程存储库 `REMOTE_NAME` 中。此外，"
"它还将显示一个链接，你可以单击该链接以打开新的合并请求。单击链接后，写下标题"
"和简明描述，然后单击 `创建` 按钮。是的，你现在一切就绪。"

#: ../../doc/src/contributing.md:66
msgid "Add New Features"
msgstr "添加新功能"

#: ../../doc/src/contributing.md:68
msgid ""
"The example below shows the steps it would take to create a caret binary "
"operator **^** which computes the average value of the two operands."
msgstr "下面的示例显示了创建插入符号二元运算符 **^** "
"所需的步骤，该运算符计算两个操作数的平均值。"

#: ../../doc/src/contributing.md:70
msgid "Create New Token(s)"
msgstr "创建新令牌"

#: ../../doc/src/contributing.md:72
msgid ""
"We extend the *tokenizer.re* as well as *parser.yy* to add the new token "
"**^**. We also tell LFortran how to print the new token in *parser.cpp*."
msgstr ""
"我们扩展了 *tokenizer.re* 和 *parser.yy* 以添加新的令牌 **^**。我们还告诉 "
"LFortran 如何在 *parser.cpp* 中打印新标记。"

#: ../../doc/src/contributing.md:75
msgid ":fontawesome-solid-code: *src/lfortran/parser/tokenizer.re*"
msgstr ":fontawesome-solid-code: *src/lfortran/parser/tokenizer.re*"

#: ../../doc/src/contributing.md:80
msgid ":fontawesome-solid-code: *src/lfortran/parser/parser.yy*"
msgstr ":fontawesome-solid-code: *src/lfortran/parser/parser.yy*"

#: ../../doc/src/contributing.md:85
msgid ":fontawesome-solid-code: *src/lfortran/parser/parser.cpp*"
msgstr ":fontawesome-solid-code: *src/lfortran/parser/parser.cpp*"

#: ../../doc/src/contributing.md:94
msgid "The added code is tested with `lfortran --show-tokens examples2/expr2.f90`"
msgstr "添加的代码使用 `lfortran --show-tokens examples2/expr2.f90` 进行测试"

#: ../../doc/src/contributing.md:96
msgid "Parse the New Token"
msgstr "解析新令牌"

#: ../../doc/src/contributing.md:98
msgid ""
"Now we have to parse the new operator. We add it to the AST by extending "
"the BinOp with a caret operator and modifying the *AST.asdl* file. Then "
"we add it in *parse.yy* to properly parse and generate the new AST in "
"*semantics.h*.Finally we extend *pickle.cpp* so that the new operator can"
" print itself."
msgstr ""
"现在我们必须解析 new 运算符。我们通过使用插入符运算符扩展 BinOp 并修改 *AST."
"asdl* 文件将其添加到 AST。然后我们将它添加到 *parse.yy* 中以正确解析并在 "
"*semantics.h* 中生成新的 AST。最后我们扩展 *pickle.cpp* "
"以便新的操作符可以打印自己。"

#: ../../doc/src/contributing.md:102
msgid ":fontawesome-solid-code:*grammar/AST.asdl*"
msgstr ":fontawesome-solid-code:*grammar/AST.asdl*"

#: ../../doc/src/contributing.md:107
msgid ":fontawesome-solid-code:*src/lfortran/parser/parser.yy*"
msgstr ":fontawesome-solid-code:*src/lfortran/parser/parser.yy*"

#: ../../doc/src/contributing.md:116
msgid ":fontawesome-solid-code:*src/lfortran/parser/semantics.h*"
msgstr ":fontawesome-solid-code:*src/lfortran/parser/semantics.h*"

#: ../../doc/src/contributing.md:121
msgid ":fontawesome-solid-code:*src/lfortran/pickle.cpp*"
msgstr ":fontawesome-solid-code:*src/lfortran/pickle.cpp*"

#: ../../doc/src/contributing.md:132
msgid "The section is tested with `lfortran --show-ast examples/expr2.f90`"
msgstr "该部分使用 `lfortran --show-ast examples/expr2.f90` 进行测试"

#: ../../doc/src/contributing.md:134
msgid "Implement the Semantics of the New Token"
msgstr "实现新令牌的语义"

#: ../../doc/src/contributing.md:136
msgid ""
"We first extend the ASR in *ASR.asdl* and add ^ as a BinOp operator "
"option."
msgstr "我们首先在 *ASR.asdl* 中扩展 ASR，并添加 ^ 作为 BinOp 运算符选项。"

#: ../../doc/src/contributing.md:138
msgid ":fontawesome-solid-code:*src/libasr/ASR.asdl*"
msgstr ":fontawesome-solid-code:*src/libasr/ASR.asdl*"

#: ../../doc/src/contributing.md:142
msgid ":fontawesome-solid-code:*src/lfortran/semantics/ast_common_visitor.h*"
msgstr ":fontawesome-solid-code:*src/lfortran/semantics/ast_common_visitor.h*"

#: ../../doc/src/contributing.md:179
msgid ""
"Then we transform it from AST to ASR by extending "
"*src/lfortran/semantics/ast_common_visitor.h*."
msgstr "然后我们通过扩展 *src/lfortran/semantics/ast_common_visitor.h* 将其从 AST "
"转换为 ASR。"

#: ../../doc/src/contributing.md:181
msgid ""
"We also add it into compile time evaluation triggered by expressions such"
" as `e = (2+3)^5` which is evaluated at compile time. An expression such "
"as `e = x^5` is evaluated at run time only."
msgstr ""
"我们还将它添加到由表达式触发的编译时评估中，例如在编译时评估的 `e = "
"(2+3)^5`。诸如`e = x^5`之类的表达式仅在运行时进行评估。"

#: ../../doc/src/contributing.md:183
msgid "The section is tested with `lfortran --show-asr examples/expr2.f90`"
msgstr "该部分使用 `lfortran --show-asr examples/expr2.f90` 进行测试"

#: ../../doc/src/contributing.md:184
msgid "Implement the New Token in LLVM"
msgstr "在 LLVM 中实现新令牌"

#: ../../doc/src/contributing.md:186
msgid ""
"To implement in LLVM, we extend the BinOp translation by handling the new"
" operator. We first add the two numbers then divide by two. :fontawesome-"
"solid-code:*src/lfortran/codegen/asr_to_llvm.cpp*"
msgstr ""
"为了在 LLVM 中实现，我们通过处理 new 运算符来扩展 BinOp "
"转换。我们首先将两个数字相加，然后除以 2。 :fontawesome-solid-code:*src/"
"lfortran/codegen/asr_to_llvm.cpp*"

#: ../../doc/src/contributing.md:217
msgid "The section is tested with `lfortran --show-llvm examples/expr2.f90`"
msgstr "该部分使用 `lfortran --show-llvm examples/expr2.f90` 进行测试"

#: ../../doc/src/contributing.md:219
msgid "Now when LLVM works, we can test the final executable by:"
msgstr "现在当 LLVM 工作时，我们可以通过以下方式测试最终的可执行文件："

#: ../../doc/src/contributing.md:224
msgid "And it should print 6."
msgstr "它应该打印 6。"

#: ../../doc/src/contributing.md:226
msgid "It also works interactively:"
msgstr "它还可以交互工作："

#: ../../doc/src/contributing.md:242
msgid "Reach Out"
msgstr "得到"

#: ../../doc/src/contributing.md:244
msgid ""
"If you have any questions or need help, please ask as at our "
"[mailinglist](https://groups.io/g/lfortran) or a "
"[chat](https://lfortran.zulipchat.com/)."
msgstr ""
"如果你有任何问题或需要帮助，请通过我们的 [mailinglist](https://groups.io/g/"
"lfortran) 或 [chat](https://lfortran.zulipchat.com/) 提问。"

#: ../../doc/src/contributing.md:248
msgid ""
"Please note that all participants of this project are expected to follow "
"our Code of Conduct. By participating in this project you agree to abide "
"by its terms. See "
"[CODE_OF_CONDUCT.md](https://github.com/lfortran/lfortran/blob/main/CODE_OF_CONDUCT.md)."
msgstr ""
"请注意，该项目的所有参与者都应遵守我们的行为准则。参与本项目即表示你同意遵守"
"其条款。请参阅 [CODE_OF_CONDUCT.md](https://github.com/lfortran/lfortran/"
"blob/main/CODE_OF_CONDUCT.md)。"

#: ../../doc/src/contributing.md:252
msgid ""
"By submitting a PR you agree to license your contribution under the "
"LFortran's BSD "
"[license](https://github.com/lfortran/lfortran/blob/main/LICENSE) unless "
"explicitly noted otherwise."
msgstr ""
"通过提交 PR，你同意根据 LFortran 的 BSD [许可](https://github.com/lfortran/"
"lfortran/blob/main/LICENSE) 许可你的贡献，除非另有明确说明。"

#: ../../doc/src/design.md:1
msgid "LFortran Design"
msgstr "LFortran Design"

#: ../../doc/src/design.md:3
msgid "High Level Overview"
msgstr "高级概述"

#: ../../doc/src/design.md:5 ../../doc/src/developer_tutorial.ipynb:16
msgid ""
"LFortran is structured around two independent modules, AST and ASR, both "
"of which are standalone (completely independent of the rest of LFortran) "
"and users are encouraged to use them independently for other applications"
" and build tools on top:"
msgstr ""
"LFortran 围绕两个独立的模块 AST 和 ASR 构建，这两个模块都是独立的（"
"完全独立于 LFortran "
"的其余部分），鼓励用户将它们独立用于其他应用程序并在其上构建工具："

#: ../../doc/src/design.md:10
msgid ""
"Abstract Syntax Tree (AST), module `lfortran.ast`: Represents any Fortran"
" source code, strictly based on syntax, no semantic is included. The AST "
"module can convert itself to Fortran source code."
msgstr ""
"抽象语法树 (AST)，模块 `lfortran.ast`：表示任何 Fortran "
"源代码，严格基于语法，不包含语义。 AST 模块可以将自身转换为 Fortran 源代码。"

#: ../../doc/src/design.md:14
msgid ""
"Abstract Semantic Representation (ASR), module `lfortran.asr`: Represents"
" a valid Fortran source code, all semantic is included. Invalid Fortran "
"code is not allowed (an error will be given). The ASR module can convert "
"itself to an AST."
msgstr ""
"抽象语义表示 (ASR)，模块 `lfortran.asr`：表示有效的 Fortran "
"源代码，包括所有语义。不允许使用无效的 Fortran 代码（将给出错误）。 ASR "
"模块可以将自身转换为 AST。"

#: ../../doc/src/design.md:19
msgid ""
"The LFortran compiler is then composed of the following independent "
"stages:"
msgstr "LFortran 编译器由以下独立阶段组成："

#: ../../doc/src/design.md:21
msgid "Parsing: converts Fortran source code to an AST"
msgstr "解析：将 Fortran 源代码转换为 AST"

#: ../../doc/src/design.md:22
msgid "Semantic: converts an AST to an ASR"
msgstr "语义：将 AST 转换为 ASR"

#: ../../doc/src/design.md:23
msgid ""
"High level optimizations: optimize ASR to a possibly faster/simpler ASR "
"(things like inlining functions, eliminating redundant expressions or "
"statements, etc.)"
msgstr "高级优化：将 ASR 优化为可能更快/更简单的 "
"ASR（内联函数、消除冗余表达式或语句等）"

#: ../../doc/src/design.md:26
msgid ""
"LLVM IR code generation and lower level optimizations: converts an ASR to"
" an LLVM IR. This stage also does all other optimizations that do not "
"produce an ASR, but still make sense to do before passing to LLVM IR."
msgstr ""
"LLVM IR 代码生成和较低级别的优化：将 ASR 转换为 LLVM IR。"
"此阶段还执行所有其他不产生 ASR，但在传递给 LLVM IR 之前仍然有意义的优化。"

#: ../../doc/src/design.md:29
msgid ""
"Machine code generation: LLVM then does all its optimizations and "
"generates machine code (such as a binary executable, a library, an object"
" file, or it is loaded and executed using JIT as part of the interactive "
"LFortran session or in a Jupyter kernel)."
msgstr ""
"机器代码生成：LLVM "
"然后进行所有优化并生成机器代码（例如二进制可执行文件、库、目标文件，或者使用 "
"JIT 作为交互式 LFortran 会话的一部分或在 Jupyter 内核中加载和执行）。"

#: ../../doc/src/design.md:34
msgid ""
"LFortran is structured as a library, and so one can for example use the "
"parser to obtain an AST and do something with it, or one can then use the"
" semantic analyzer to obtain ASR and do something with it. One can "
"generate the ASR directly (e.g., from SymPy) and then either convert to "
"AST and to a Fortran source code, or use LFortran to compile it to "
"machine code directly. In other words, one can use LFortran to easily "
"convert between the three equivalent representations:"
msgstr ""
"LFortran 被构造为一个库，因此可以使用解析器获取 AST 并对其进行处理，"
"或者然后可以使用语义分析器获取 ASR 并对其进行处理。可以直接生成 ASR（例如，"
"从 SymPy），然后转换为 AST 和 Fortran 源代码，或者使用 LFortran "
"直接将其编译为机器代码。换句话说，可以使用 LFortran "
"在三种等效表示之间轻松转换："

#: ../../doc/src/design.md:42
msgid "Fortran source code"
msgstr "Fortran 源代码"

#: ../../doc/src/design.md:43 ../../doc/src/developer_tutorial.ipynb:23
msgid "Abstract Syntax Tree (AST)"
msgstr "抽象语法树 (AST)"

#: ../../doc/src/design.md:44 ../../doc/src/developer_tutorial.ipynb:159
msgid "Abstract Semantic Representation (ASR)"
msgstr "抽象语义表示 (ASR)"

#: ../../doc/src/design.md:46
msgid "They are all equivalent in the following sense:"
msgstr "它们在以下意义上都是等价的："

#: ../../doc/src/design.md:48
msgid "Any ASR can always be converted to an equivalent AST"
msgstr "任何 ASR 始终可以转换为等效的 AST"

#: ../../doc/src/design.md:49
msgid "Any AST can always be converted to an equivalent Fortran source code"
msgstr "任何 AST 始终可以转换为等效的 Fortran 源代码"

#: ../../doc/src/design.md:50
msgid ""
"Any Fortran source code can always be either converted to an equivalent "
"AST or one gets a syntax error"
msgstr "任何 Fortran 源代码总是可以转换为等效的 AST 或出现语法错误"

#: ../../doc/src/design.md:52
msgid ""
"Any AST can always be either converted to an equivalent ASR or one gets a"
" semantic error"
msgstr "任何 AST 总是可以转换为等效的 ASR 或者出现语义错误"

#: ../../doc/src/design.md:55
msgid ""
"So when a conversion can be done, they are equivalent, and the conversion"
" can always be done unless the code is invalid."
msgstr "因此，当可以进行转换时，它们是等效的，并且除非代码无效，否则始终可以进行转换"
"。"

#: ../../doc/src/design.md:58
msgid "ASR Design Details"
msgstr "ASR 设计细节"

#: ../../doc/src/design.md:60
msgid "The ASR is designed to have the following features:"
msgstr "ASR 旨在具有以下功能："

#: ../../doc/src/design.md:62
msgid ""
"ASR is still semantically equivalent to the original Fortran code (it did"
" not lose any semantic information). ASR can be converted to AST, and AST"
" to Fortran source code which is functionally equivalent to the original."
msgstr ""
"ASR 在语义上仍然等同于原始 Fortran 代码（它没有丢失任何语义信息）。 ASR "
"可以转换为 AST，AST 可以转换为 Fortran 源代码，在功能上与原始代码相同。"

#: ../../doc/src/design.md:66
msgid ""
"ASR is as simple as possible: it does not contain any information that "
"could not be inferred from ASR."
msgstr "ASR 尽可能简单：它不包含任何无法从 ASR 推断出的信息。"

#: ../../doc/src/design.md:69
msgid ""
"The ASR C++ classes (down the road) are designed similarly to SymEngine: "
"they are constructed once and after that they are immutable. The "
"constructor checks in Debug more that all the requirements are met (e.g.,"
" that all Variables in a Function have a dummy argument set, that "
"explicit-shape arrays are not allocatable and all other Fortran "
"requirements to make it a valid code), but in Release mode it quickly "
"constructs the class without checks. Then there are builder classes that "
"construct the ASR C++ classes to meet requirements (checked in Debug "
"mode) and the builder gives an error message if a code is not a valid "
"Fortran code, and if it doesn't give an error message, then the ASR C++ "
"classes are constructed correctly. Thus by construction, the ASR classes "
"always contain valid Fortran code and the rest of LFortran can depend on "
"it."
msgstr ""
"ASR C++ 类（未来）的设计类似于 "
"SymEngine：它们被构造一次，之后它们是不可变的。构造函数在 Debug "
"中检查是否满足所有要求（例如，函数中的所有变量都有一个虚拟参数集，"
"显式形状数组不可分配以及所有其他 Fortran "
"要求使其成为有效代码），但在发布模式它无需检查即可快速构建类。然后是构建 ASR "
"C++ 类以满足要求的构建器类（在调试模式下检查），如果代码不是有效的 Fortran "
"代码，构建器会给出错误消息，如果它没有给出错误消息，则 ASR C++ "
"类构造正确。因此，通过构造，ASR 类总是包含有效的 Fortran 代码，而 LFortran "
"的其余部分可以依赖它。"

#: ../../doc/src/design.md:82
msgid "Notes:"
msgstr "注意："

#: ../../doc/src/design.md:84
msgid ""
"Information that is lost when parsing source to AST: whitespace, "
"multiline/single line if statement distinction, case sensitivity of "
"keywords."
msgstr "将源解析为 AST 时丢失的信息：空格、多行/单行 if "
"语句区分、关键字的区分大小写。"

#: ../../doc/src/design.md:87
msgid ""
"Information that is lost when going from AST to ASR: detailed syntax how "
"variables were defined and the order of type attributes (whether array "
"dimension is using the `dimension` attribute, or parentheses at the "
"variable; or how many variables there are per declaration line or their "
"order), as ASR only represents the aggregated type information in the "
"symbol table."
msgstr ""
"从 AST 到 ASR 时丢失的信息：如何定义变量的详细语法以及类型属性的顺序（"
"数组维度是否使用 `dimension` "
"属性，或变量处的括号；或每个声明行有多少个变量或它们的顺序），因为 ASR "
"仅表示符号表中的聚合类型信息。"

#: ../../doc/src/design.md:90
msgid ""
"ASR is the simplest way to generate Fortran code, as one does not have to"
" worry about the detailed syntax (as in AST) about how and where things "
"are declared. One specifies the symbol table for a module, then for each "
"symbol (functions, global variables, types, ...) one specifies the local "
"variables and if this is an interface then one needs to specify where one"
" can find an implementation, otherwise a body is supplied with "
"statements, those nodes are almost the same as in AST, except that each "
"variable is just a reference to a symbol in the symbol table (so by "
"construction one cannot have undefined variables). The symbol table for "
"each node such as Function or Module also references its parent (for "
"example a function references a module, a module references the global "
"scope)."
msgstr ""
"ASR 是生成 Fortran "
"代码的最简单方法，因为不必担心关于如何以及在何处声明事物的详细语法（如在 AST "
"中）。一个为模块指定符号表，然后为每个符号（函数、全局变量、类型……）指定局部"
"变量，如果这是一个接口，则需要指定在哪里可以找到实现，否则为body 提供了语句，"
"这些节点与 AST 中的几乎相同，除了每个变量只是对符号表中的符号的引用（因此通过"
"构造一个不能有未定义的变量）。每个节点（例如 Function 或 "
"Module）的符号表也引用其父节点（例如，函数引用模块，模块引用全局作用域）。"

#: ../../doc/src/design.md:102
msgid ""
"The ASR can be directly converted to an AST without gathering any other "
"information. And the AST directly to Fortran source code."
msgstr "ASR 可以直接转换为 AST，而无需收集任何其他信息。而AST直接转为Fortran源代码。"

#: ../../doc/src/design.md:105
msgid ""
"The ASR is always representing a semantically valid Fortran code.  This "
"is enforced by checks in the ASR C++ constructors (in Debug build). When "
"an ASR is used, one can assume it is valid."
msgstr ""
"ASR 始终表示语义上有效的 Fortran 代码。这是通过检查 ASR C++ "
"构造函数（在调试版本中）来强制执行的。当使用 ASR 时，可以假定它是有效的。"

#: ../../doc/src/design.md:109
msgid "Fortran 2008"
msgstr "Fortran 2008"

#: ../../doc/src/design.md:111
msgid ""
"Fortran 2008 [standard](https://j3-fortran.org/doc/year/10/10-007.pdf) "
"chapter 2 \"Fortran concepts\" specifies that Fortran code is a "
"collection of _program units_ (either all in one file, or in separate "
"files), where each _program unit_ is one of:"
msgstr ""
"Fortran 2008 [标准](https://j3-fortran.org/doc/year/10/10-007.pdf) 第 2 章“"
"Fortran 概念”指定 Fortran 代码是_程序单元_的集合（全部在一个文件中） "
"，或在单独的文件中），其中每个 _程序单元_ 是以下之一："

#: ../../doc/src/design.md:116 ../../doc/src/design.md:131
msgid "main program"
msgstr "主程序"

#: ../../doc/src/design.md:117 ../../doc/src/design.md:132
msgid "module or submodule"
msgstr "模块或子模块"

#: ../../doc/src/design.md:118 ../../doc/src/design.md:133
msgid "function or subroutine"
msgstr "函数或子程序"

#: ../../doc/src/design.md:120
msgid ""
"Note: It can also be a _block data_ program unit, that is used to provide"
" initial values for data objects in named _common blocks_, but we do not "
"recommend the use of _common blocks_ (use modules instead)."
msgstr ""
"注意：它也可以是_block data_程序单元，用于为命名的_common "
"blocks_中的数据对象提供初始值，但我们不建议使用_common blocks_（改用模块）。"

#: ../../doc/src/design.md:124
msgid "LFortran Extension"
msgstr "LFortran 扩展"

#: ../../doc/src/design.md:126
msgid ""
"We extend the Fortran language by introducing a _global scope_, which is "
"not only the list of _program units_ (as in F2008) but can also include "
"statements, declarations, use statements and expressions. We define "
"_global scope_ as a collection of the following items:"
msgstr ""
"我们通过引入_全局作用域_来扩展 Fortran 语言，它不仅是_程序单元_列表（如 "
"F2008 中），还可以包括语句、声明、使用语句和表达式。我们将_全局作用域_定义为"
"以下项目的集合："

#: ../../doc/src/design.md:134
msgid "use statement"
msgstr "使用声明"

#: ../../doc/src/design.md:135
msgid "declaration"
msgstr "声明"

#: ../../doc/src/design.md:136
msgid "statement"
msgstr "声明"

#: ../../doc/src/design.md:137
msgid "expression"
msgstr "表达"

#: ../../doc/src/design.md:139
msgid ""
"In addition, if a variable is not defined in an assignment statement "
"(such as `x = 5+3`) then the type of the variable is inferred from the "
"right hand side (e.g., `x` in `x = 5+3` would be of type `integer`, and "
"`y` in `y = 5._dp` would be of type `real(dp)`). This rule only applies "
"at the top level of _global scope_. Types must be fully specified inside "
"main programs, modules, functions and subroutines, just like in F2008."
msgstr ""
"此外，如果变量没有在赋值语句中定义（例如`x = "
"5+3`），则从右侧推断变量的类型（例如，`x` in `x = 5+3 ` 将是 `integer` 类型，"
"而 `y = 5._dp` 中的 `y` 将是 `real(dp)` 类型）。此规则仅适用于 _全局作用域_ "
"的顶层。类型必须在主程序、模块、函数和子程序中完全指定，就像在 F2008 中一样。"

#: ../../doc/src/design.md:146
msgid ""
"The _global scope_ has its own symbol table. The main program and "
"module/submodule do not see any symbols from this symbol table. But "
"functions, subroutines, statements and expressions at the top level of "
"_global scope_ use and operate on this symbol table."
msgstr ""
"_全局作用域_ 有自己的符号表。主程序和模块/子模块看不到此符号表中的任何符号。"
"但是_全局作用域_顶层的函数、子例程、语句和表达式使用和操作这个符号表。"

#: ../../doc/src/design.md:151
msgid ""
"The _global scope_ has the following symbols predefined in the symbol "
"table:"
msgstr "_全局作用域_ 在符号表中预定义了以下符号："

#: ../../doc/src/design.md:153
msgid ""
"the usual standard set of Fortran functions (such as `size`, `sin`, "
"`cos`, ...)"
msgstr "通常的标准 Fortran 函数集（例如 `size`、`sin`、`cos`...）"

#: ../../doc/src/design.md:155
msgid ""
"the `dp` double precision symbol, so that one can use `5._dp` for double "
"precision."
msgstr "`dp` 双精度符号，因此可以使用 `5._dp` 表示双精度。"

#: ../../doc/src/design.md:158
msgid ""
"Each item in the _global scope_ is interpreted as follows: main program "
"is compiled into an executable with the same name and executed; modules, "
"functions and subroutines are compiled and loaded; use statement and "
"declaration adds those symbols with the proper type into the _global "
"scope_ symbol table, but do not generate any code; statement is wrapped "
"into an anonymous subroutine with no arguments, compiled, loaded and "
"executed; expression is wrapped into an anonymous function with no "
"arguments returning the expression, compiled, loaded, executed and the "
"return value is returned to the user."
msgstr ""
"_全局作用域_中的每一项解释如下：主程序编译成同名可执行文件并执行；编译和加载"
"模块、函数和子程序； use 语句和声明将那些具有正确类型的符号添加到_全局作用域_"
"符号表中，但不生成任何代码；语句被包装到一个没有参数的匿名子例程中，编译、加"
"载和执行；表达式被包装到一个匿名函数中，没有参数返回表达式，编译、加载、执行"
"并将返回值返回给用户。"

#: ../../doc/src/design.md:168
msgid ""
"The _global scope_ is always interpreted, item by item, per the previous "
"paragraph. It is meant to allow interactive usage, experimentations and "
"writing simple scripts. Code in _global scope_ must be interpreted using "
"`lfortran`. For more complex (production) code it is recommended to turn "
"it into modules and programs (by wrapping loose statements into "
"subroutines or functions and by adding type declarations) and compile it "
"with `lfortran` or any other Fortran compiler."
msgstr ""
"_全局作用域_ "
"总是按照上一段逐项解释。它旨在允许交互式使用、实验和编写简单的脚本。 "
"_全局作用域_ 中的代码必须使用 `lfortran` 解释。对于更复杂的（生产）代码，建议"
"将其转换为模块和程序（通过将松散的语句包装成子例程或函数并添加类型声明）"
"并使用 `lfortran` 或任何其他 Fortran 编译器对其进行编译。"

#: ../../doc/src/design.md:176
msgid "Here are some examples of valid code in _global scope_:"
msgstr "以下是 _全局作用域_ 中的一些有效代码示例："

#: ../../doc/src/design.md:178
msgid "Example 1"
msgstr "示例 1"

#: ../../doc/src/design.md:185
msgid "Example 2"
msgstr "示例 2"

#: ../../doc/src/design.md:197
msgid "Example 3"
msgstr "示例 3"

#: ../../doc/src/design.md:209
msgid "Example 4"
msgstr "示例 4"

#: ../../doc/src/design.md:217
msgid "Design Considerations"
msgstr "设计注意事项"

#: ../../doc/src/design.md:219
msgid ""
"The LFortran extension of Fortran was chosen in a way so as to minimize "
"the number of changes. In particular, only the top level of the _global "
"scope_ has relaxed some of the Fortran rules (such as making specifying "
"types optional) so as to allow simple and quick interactive usage, but "
"inside functions, subroutines, modules or programs this relaxation does "
"not apply."
msgstr ""
"选择 Fortran 的 LFortran 扩展是为了尽量减少更改的数量。特别是，"
"只有_全局作用域_的顶层放宽了一些 Fortran 规则（例如使指定类型可选）以允许简单"
"快速的交互使用，但在函数、子例程、模块或程序内部，这种放宽并不适用."

#: ../../doc/src/design.md:225
msgid ""
"The number of changes were kept to minimum in order to make it "
"straightforward to turn code at _global scope_ into standard compliant "
"Fortran code using programs and modules, so that it can be compiled by "
"any Fortran compiler."
msgstr ""
"更改的数量保持在最低限度，"
"以便使用程序和模块将_全局作用域_中的代码直接转换为符合标准的 Fortran 代码，"
"以便任何 Fortran 编译器都可以编译它。"

#: ../../doc/src/developer_tutorial.ipynb:9
msgid "Developer Tutorial"
msgstr "开发者教程"

#: ../../doc/src/developer_tutorial.ipynb:11
msgid ""
"This is a tutorial for anybody who wants to either develop LFortran or "
"build tools on top."
msgstr "这是任何想要开发 LFortran 或构建工具的人的教程。"

#: ../../doc/src/developer_tutorial.ipynb:14
msgid "Introduction"
msgstr "入门"

#: ../../doc/src/developer_tutorial.ipynb:18
msgid ""
"Abstract Syntax Tree (AST): Represents any Fortran source code, strictly "
"based on syntax, no semantic is included. The AST module can convert "
"itself to Fortran source code."
msgstr "抽象语法树 (AST)：表示任何 Fortran 源代码，严格基于语法，不包含语义。 AST "
"模块可以将自身转换为 Fortran 源代码。"

#: ../../doc/src/developer_tutorial.ipynb:20
msgid ""
"Abstract Semantic Representation (ASR): Represents a valid Fortran source"
" code, all semantic is included. Invalid Fortran code is not allowed (an "
"error will be given). The ASR module can convert itself to an AST."
msgstr ""
"抽象语义表示 (ASR)：表示有效的 Fortran 源代码，包括所有语义。"
"不允许使用无效的 Fortran 代码（将给出错误）。 ASR 模块可以将自身转换为 AST。"

#: ../../doc/src/developer_tutorial.ipynb:25
msgid ""
"Fortran source code can be parsed into an AST using the ``src_to_ast()`` "
"function:"
msgstr "Fortran 源代码可以使用 ``src_to_ast()`` 函数解析为 AST："

#: ../../doc/src/developer_tutorial.ipynb:49
#, python-format
msgid "We can pretty print it using the ``%%showast`` magic:"
msgstr "我们可以使用 ``%%showast`` 魔法漂亮地打印它："

#: ../../doc/src/developer_tutorial.ipynb:98
#, python-format
msgid "We can convert AST to Fortran source code using ``%%showfmt``:"
msgstr "我们可以使用 ``%%showfmt`` 将 AST 转换为 Fortran 源代码："

#: ../../doc/src/developer_tutorial.ipynb:156
msgid ""
"All AST nodes and their arguments are described in `AST.asdl "
"<https://github.com/lfortran/lfortran/blob/master/grammar/AST.asdl>`__."
msgstr ""
"所有 AST 节点及其参数都在 `AST.asdl <https://github.com/lfortran/lfortran/"
"blob/master/grammar/AST.asdl>`__ 中描述。"

#: ../../doc/src/developer_tutorial.ipynb:170
#, python-format
msgid "We can pretty print using the ``%%showasr`` magic:"
msgstr "我们可以使用 ``%%showasr`` 魔法进行漂亮的打印："

#: ../../doc/src/developer_tutorial.ipynb:219
msgid ""
"All ASR nodes and their arguments are described in `ASR.asdl "
"<https://github.com/lfortran/lfortran/blob/master/src/libasr/ASR.asdl>`__."
msgstr ""
"所有 ASR 节点及其参数都在 `ASR.asdl <https://github.com/lfortran/lfortran/"
"blob/master/src/libasr/ASR.asdl>`__ 中描述。"

#: ../../doc/src/index.md:134
msgid "Getting started"
msgstr "开始"

#: ../../doc/src/index.md:141 ../../doc/src/progress.md:1
msgid "LFortran Development Status"
msgstr "LFortran 开发现状"

#: ../../doc/src/index.md:147
msgid "Developer's Guide"
msgstr "开发者指南"

#: ../../doc/src/index.md:156
msgid "LFortran Intrinsics"
msgstr "LFortran 内置函数"

#: ../../doc/src/index.md:1
msgid "LFortran Documentation"
msgstr "LFortran 文档"

#: ../../doc/src/index.md:3
msgid ""
"LFortran is a modern open-source (BSD licensed) interactive Fortran "
"compiler built on top of LLVM. It can execute user's code interactively "
"to allow exploratory work (much like Python, MATLAB or Julia) as well as "
"compile to binaries with the goal to run user's code on modern "
"architectures such as multi-core CPUs and GPUs."
msgstr ""
"LFortran 是建立在 LLVM 之上的现代开源（BSD 许可）交互式 Fortran "
"编译器。它可以交互地执行用户代码以允许探索性工作（很像 Python、MATLAB 或 "
"Julia），也可以编译为二进制文件，目标是在多核 CPU 和 GPU "
"等现代架构上运行用户代码。"

#: ../../doc/src/index.md:9
#, python-format
msgid ""
"Website: [https://lfortran.org/](https://lfortran.org/)   Main "
"repository: "
"[https://github.com/lfortran/lfortran](https://github.com/lfortran/lfortran)"
"   Try online using Binder: "
"[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gl/lfortran%2Fweb"
"%2Flfortran-binder/master?filepath=Demo.ipynb)"
msgstr ""
"网站：[https://lfortran.org/](https://lfortran.org/"
")；主存储库：[https://github.com/lfortran/lfortran](https://github.com/"
"lfortran/lfortran)；使用 Binder 在线尝试：[![Binder](https://mybinder.org/"
"badge_logo.svg)](https://mybinder.org/v2/gl/lfortran%2Fweb%2Flfortran-binder/"
"master?filepath=Demo.ipynb)"

#: ../../doc/src/index.md:9
msgid "Binder"
msgstr "Binder"

#: ../../doc/src/index.md:16
msgid "Feature Highlights"
msgstr "功能亮点"

#: ../../doc/src/index.md:18
msgid ""
"LFortran is in development, there are features that work today, and there"
" are features that are being implemented. You can also check out the "
"[Development Status](progress.md) section for more information on "
"features being supported and being worked on."
msgstr ""
"LFortran 正在开发中，有些功能现在可以使用，有些功能正在实现中。你还可以查看 ["
"Development Status](progress.md) "
"部分，了解有关被支持和正在开发的功能的更多信息。"

#: ../../doc/src/index.md:21
msgid "Works today"
msgstr "现有功能"

#: ../../doc/src/index.md:23
#, python-format
msgid ""
"**Interactive, Jupyter support**   LFortran can be used from Jupyter as a"
" Fortran kernel, allowing a   Python/Julia style rapid prototyping and "
"exploratory workflow   (see the "
"[static](https://nbviewer.jupyter.org/gist/certik/f1d28a486510810d824869ab0c491b1c)"
"   or   [interactive](https://mybinder.org/v2/gl/lfortran%2Fweb"
"%2Flfortran-binder/master?filepath=Demo.ipynb)   example notebook).   Or "
"it can be used from the command-line in an interactive prompt (REPL)."
msgstr ""
"**交互式，Jupyter 支持**：LFortran 可以在 Jupyter 中用作 Fortran 内核，允许 "
"Python/Julia 风格的快速原型设计和探索性工作流程（参见示例笔记： "
"[静态](https://nbviewer.jupyter.org/gist/certik/"
"f1d28a486510810d824869ab0c491b1c) 或 [交互](https://mybinder.org/v2/gl/"
"lfortran%2Fweb%2Flfortran-binder/master?filepath=Demo.ipynb)）。或者，"
"它可以在交互式提示 (REPL) 中的命令行中使用。"

#: ../../doc/src/index.md:32
msgid ""
"**Clean, modular design, usable as a library**   LFortran is structured "
"around two independent modules, AST and ASR, both of   which are "
"standalone (completely independent of the rest of LFortran) and   users "
"are encouraged to use them independently for other applications and   "
"build tools on top. See the [Design](design.md)   and [Developer "
"Tutorial](developer_tutorial.md) documents for more details."
msgstr ""
"**简洁、模块化设计，可用作库**：LFortran 围绕两个独立模块 AST 和 ASR "
"构建，这两个模块都是独立的（完全独立于 LFortran 的其余部分），鼓励用户将它们"
"独立用于其他应用程序并在上面构建工具。有关详细信息，请参阅 [Design](design."
"md) 和 [Developer Tutorial](developer_tutorial.md) 文档。"

#: ../../doc/src/index.md:39
msgid ""
"**Interoperation with GFortran**   LFortran can parse GFortran module "
"files into an ASR and generate a Fortran   wrapper that can be compiled "
"with any Fortran compiler and linked with the   original GFortran "
"compiled module."
msgstr ""
"**与 GFortran 的互操作**：LFortran 可以将 GFortran 模块文件解析为 ASR "
"并生成一个 Fortran 包装器，该包装器可以用任何 Fortran 编译器编译并与原 "
"GFortran 编译模块链接。"

#: ../../doc/src/index.md:44
msgid ""
"**Create executables**   It can create executables just like other "
"Fortran compilers."
msgstr "**创建可执行文件**：它可以像其他 Fortran 编译器一样创建可执行文件。"

#: ../../doc/src/index.md:47
msgid ""
"**Runs on Linux, Mac and Windows**   All three platforms are regularly "
"tested by our CI."
msgstr "**在 Linux、Mac 和 Windows 上运行**：所有三个平台都由我们的 CI 定期测试。"

#: ../../doc/src/index.md:51
msgid "Planned"
msgstr "计划"

#: ../../doc/src/index.md:53
msgid ""
"These features are under development, there is a link to the "
"corresponding issue so that you can track the progress by following it."
msgstr "已计划这些功能正在开发中，有对应议题的链接，方便大家关注跟踪进度。"

#: ../../doc/src/index.md:56
msgid ""
"**Native interoperation with other languages (and other Fortran "
"compilers)**   It can automatically call code written in other languages "
"(such as C or   Python) just by using the `use` statement, see   "
"[#44](https://gitlab.com/lfortran/lfortran/issues/44). It understands   "
"other Fortran compilers module files (one can just \"use\" them) and "
"their   ABI to link correctly (GFortran is supported, other compilers are"
" planned,   see [#56](https://gitlab.com/lfortran/lfortran/issues/56)), "
"which allows to   use LFortran with production codes today."
msgstr ""
"**与其他语言（以及其他 Fortran 编译器）的原生互操作**：只需使用 `use` "
"语句即可自动调用其他语言（如 C 或 Python）编写的代码，参见 "
"[#44](https://gitlab.com/lfortran/lfortran/issues/44)。它理解其他 Fortran "
"编译器模块文件（可以`use`它们）及其 ABI 以正确链接（支持 "
"GFortran，计划使用其它编译器，请参阅 [#56](https://gitlab.com/lfortran/"
"lfortran/问题/56)），它允许将 LFortran 与如今的生产代码一起使用。"

#: ../../doc/src/index.md:65
msgid ""
"**Modern hardware support**   Thanks to LLVM, the goal of LFortran is to "
"run on modern hardware and take   advantage of native Fortran language "
"constructs (such as `do concurrent`)   to run on multi-core CPUs and "
"GPUs, see   [#57](https://gitlab.com/lfortran/lfortran/issues/57)."
msgstr ""
"**现代硬件支持**：得益于 LLVM，LFortran 的目标是在现代硬件上运行，并利用原生 "
"Fortran 语言结构（例如 `do concurrent`）在多核 CPU 和 GPU 上运行，请参阅 [# "
"57](https://gitlab.com/lfortran/lfortran/issues/57)。"

#: ../../doc/src/index.md:71
msgid ""
"**Full Fortran 2018 support**   Currently only a subset of Fortran is "
"implemented, but the goal is to have   a full implementation of the "
"latest Fortran 2018 standard, see   "
"[#58](https://gitlab.com/lfortran/lfortran/issues/58)."
msgstr ""
"**完整的 Fortran 2018 支持**：目前只实现了 Fortran 的一个子集，"
"但目标是完整实现最新的 Fortran 2018 标准，请参阅 [#58](https://gitlab.com/"
"lfortran/lfortran/issue/58)。"

#: ../../doc/src/index.md:77
msgid ""
"Please vote on issues in our [issue "
"tracker](https://gitlab.com/lfortran/lfortran/issues) that you want us to"
" prioritize (feel free to create new ones if we are missing anything)."
msgstr ""
"请在我们的 [议题跟踪器](https://gitlab.com/lfortran/lfortran/issues) 中对你希"
"望我们优先考虑的问题进行投票（如果我们遗漏任何内容，请随时创建新问题）。"

#: ../../doc/src/index.md:81
msgid "Roadmap"
msgstr "路线图"

#: ../../doc/src/index.md:83
msgid "Here is our roadmap how to get all the planned features above implemented:"
msgstr "以下是我们如何实现上述所有计划功能的路线图："

#: ../../doc/src/index.md:85
msgid ""
"Port code generation to use ASR and pass all the current tests "
"([#74](https://gitlab.com/lfortran/lfortran/issues/74)). Remove the old "
"code generation and old semantics, that used to annotate the AST tree, "
"which was messy."
msgstr ""
"端口代码生成以使用 ASR 并通过所有当前测试 ([#74](https://gitlab.com/lfortran/"
"lfortran/issues/74))。删除用于注释 AST 树的旧代码生成和旧语义，这很混乱。"

#: ../../doc/src/index.md:89
msgid ""
"Get GFortran module files working with `use` module, both assumed-size "
"and assumed-shape arrays "
"([#52](https://gitlab.com/lfortran/lfortran/issues/52)). This will allow "
"right away to use production codes with LFortran."
msgstr ""
"获取使用 `use` 模块的 GFortran 模块文件，包括假定大小和假定形状数组 "
"([#52](https://gitlab.com/lfortran/lfortran/issues/52))。"
"这将允许立即将生产代码与 LFortran 一起使用。"

#: ../../doc/src/index.md:93
msgid "Do these at the same time:"
msgstr "同时做这些："

#: ../../doc/src/index.md:95
msgid ""
"a) Implement more Fortran features, until eventually full Fortran 2018 is"
"  supported ([#58](https://gitlab.com/lfortran/lfortran/issues/58))."
msgstr ""
"a) 实现更多 Fortran 功能，直到最终支持完整的 Fortran 2018 "
"([#58](https://gitlab.com/lfortran/lfortran/issues/58))。"

#: ../../doc/src/index.md:98
msgid ""
"b) Gradually move to C++ for robustness and speed  "
"([#70](https://gitlab.com/lfortran/lfortran/issues/70)).  The Python API "
"will not change (or only minimally), so the user experience  from Python "
"will not change."
msgstr ""
"b) 逐渐转向 C++ 以获得稳健性和速度（[#70](https://gitlab.com/lfortran/"
"lfortran/issues/70)）。 Python API 不会改变（或只有很小的改变），因此 Python "
"的用户体验不会改变。"

#: ../../doc/src/index.md:103
msgid ""
"c) Implement all the other cool features: `use` module for C and Python  "
"and automatic wrappers  "
"([#44](https://gitlab.com/lfortran/lfortran/issues/44)),  modern hardware"
" support  ([#57](https://gitlab.com/lfortran/lfortran/issues/57)),  "
"generating an older standard of Fortran  "
"([#72](https://gitlab.com/lfortran/lfortran/issues/72)),  Fortran doctest"
" feature  ([#73](https://gitlab.com/lfortran/lfortran/issues/73)),  SymPy"
" integration  ([#71](https://gitlab.com/lfortran/lfortran/issues/71)),  "
"language service for IDEs  "
"([#12](https://gitlab.com/lfortran/lfortran/issues/12)),  and other ideas"
" ([#29](https://gitlab.com/lfortran/lfortran/issues/29))."
msgstr ""
"c) 实现所有其他很酷的功能：用于 C 和 Python 的 `use` "
"模块和自动包装器（[#44](https://gitlab.com/lfortran/lfortran/issues/"
"44)）、现代硬件支持（[# 57](https://gitlab.com/lfortran/lfortran/issues/"
"57)）、生成较旧的 Fortran 标准（[#72](https://gitlab.com/lfortran/lfortran/"
"issues/72)）、Fortran doctest 功能（[#73](https://gitlab.com/lfortran/"
"lfortran/issues/73)）, SymPy 集成（[#71](https://gitlab.com/lfortran/"
"lfortran/issues/71)）、IDE 的语言服务（[#12](https://gitlab.com/lfortran/"
"lfortran/issues/12)）和其他想法（[#29](https://gitlab.com/lfortran/lfortran/"
"issues/29)）。"

#: ../../doc/src/index.md:118
msgid "The step 1. is an internal refactoring that will not take long."
msgstr "第 1 步是内部重构，不会花费很长时间。"

#: ../../doc/src/index.md:120
msgid ""
"The step 2. will allow LFortran to be used interactively with production "
"codes right away (the production code will get compiled with GFortran, "
"then one \"uses\" any module in LFortran and functions/subroutines can be"
" interactively called, the module itself can use any GFortran supported "
"feature, but the API must fit into the subset that LFortran understands "
"--- for large number of applications simple functions/subroutines with "
"array arguments are enough). This will make LFortran usable for first "
"users and one can always use GFortran temporarily until LFortran supports"
" the given feature. We expect to be finished with the step 2. by the end "
"of summer 2019, hopefully sooner."
msgstr ""
"第 2 步将允许 LFortran 立即与生产代码交互使用（生产代码将使用 GFortran "
"编译，然后“使用” LFortran 中的任何模块，并且可以交互调用函数/子例程，"
"模块本身可以使用任何 GFortran 支持的功能，但 API 必须适合 LFortran "
"理解的子集 —— 对于大量应用程序，带有数组参数的简单函数/子例程就足够了）。"
"这将使 LFortran 可供第一批用户使用，并且在 LFortran 支持给定功能之前，"
"始终可以临时使用 GFortran。我们预计在 2019 年夏末完成第 2 步，希望能更快。"

#: ../../doc/src/index.md:130
msgid ""
"Finally the step 3. will improve LFortran overall, allowing the first "
"users to contribute back, growing the community and making LFortran "
"gradually useful for more and more people."
msgstr "最后，第 3 步将整体改进 LFortran，允许第一批用户回馈，发展社区并使 LFortran "
"逐渐对越来越多的人有用。"

#: ../../doc/src/installation.md:1
msgid "Installation"
msgstr "安装"

#: ../../doc/src/installation.md:3
msgid "All the instructions below work on Linux, macOS and Windows."
msgstr "以下所有说明适用于 Linux、macOS 和 Windows。"

#: ../../doc/src/installation.md:5
msgid "Binaries"
msgstr "二进制文件"

#: ../../doc/src/installation.md:7
msgid ""
"The recommended way to install LFortran is using Conda. Install Conda for"
" example by installing the "
"[Miniconda](https://conda.io/en/latest/miniconda.html) installation by "
"following instructions there for your platform. Then create a new "
"environment (you can choose any name, here we chose `lf`) and activate "
"it:"
msgstr ""
"安装 LFortran 的推荐方法是使用 Conda。例如，按照你的平台的说明安装 "
"[Miniconda](https://conda.io/en/latest/miniconda.html)，安装 "
"Conda。然后创建一个新环境（你可以选择任何名称，这里我们选择了`lf`）并激活它："

#: ../../doc/src/installation.md:16
msgid "Then install LFortran by:"
msgstr "然后通过以下方式安装 LFortran："

#: ../../doc/src/installation.md:20
msgid ""
"Now the `lf` environment has the `lfortran` compiler available, you can "
"start the interactive prompt by executing `lfortran`, or see the command "
"line options using `lfortran -h`."
msgstr ""
"现在 `lf` 环境有 `lfortran` 编译器可用，你可以通过执行 `lfortran` "
"启动交互式提示，或使用 `lfortran -h` 查看命令行选项。"

#: ../../doc/src/installation.md:24
msgid ""
"The Jupyter kernel is automatically installed by the above command, so "
"after installing Jupyter itself:"
msgstr "Jupyter 内核是通过上面的命令自动安装的，所以在安装 Jupyter 本身之后："

#: ../../doc/src/installation.md:28
msgid "You can create a Fortran based Jupyter notebook by executing:"
msgstr "你可以通过执行以下命令来创建基于 Fortran 的 Jupyter 笔记本："

#: ../../doc/src/installation.md:32
msgid "and selecting `New->Fortran`."
msgstr "并选择 `New->Fortran`。"

#: ../../doc/src/installation.md:35
msgid "Build From a Source Tarball"
msgstr "从源代码构建"

#: ../../doc/src/installation.md:37
msgid ""
"This method is the recommended method if you just want to install "
"LFortran, either yourself or in a package manager (Spack, Conda, Debian, "
"etc.). The source tarball has all the generated files included and has "
"minimal dependencies."
msgstr ""
"如果你只想自己或在包管理器（Spack、Conda、Debian 等）中安装 "
"LFortran，建议使用此方法。源代码包含所有生成的文件，并且具有最小的依赖关系。"

#: ../../doc/src/installation.md:39
msgid "First we have to install dependencies, for example using Conda:"
msgstr "首先，我们必须安装依赖项，例如使用 Conda："

#: ../../doc/src/installation.md:44
msgid ""
"Then download a tarball from "
"[https://lfortran.org/download/](https://lfortran.org/download/), e.g.:"
msgstr ""
"然后从 [https://lfortran.org/download/](https://lfortran.org/download/) "
"下载源代码，例如："

#: ../../doc/src/installation.md:52
msgid "And build:"
msgstr "并构建："

#: ../../doc/src/installation.md:58
msgid "This will install the `lfortran` into the `inst/bin`."
msgstr "这会将 `lfortran` 安装到 `inst/bin` 中。"

#: ../../doc/src/installation.md:60
msgid "Build From Git"
msgstr "从 Git 构建"

#: ../../doc/src/installation.md:62
msgid ""
"We assume you have C++ compilers installed, as well as `git` and `wget`. "
"In Ubuntu, you can also install `binutils-dev` for stacktraces."
msgstr ""
"我们假设你安装了 C++ 编译器，以及 `git` 和 `wget`。在 Ubuntu 中，你还可以为 "
"stacktraces 安装 `binutils-dev`。"

#: ../../doc/src/installation.md:65
msgid ""
"If you do not have Conda installed, you can do so on Linux (and similarly"
" on other platforms):"
msgstr "如果你没有安装 Conda，你可以在 Linux 上安装（在其他平台上类似）："

#: ../../doc/src/installation.md:72
msgid "Then prepare the environment:"
msgstr "然后准备环境："

#: ../../doc/src/installation.md:77
msgid "Clone the LFortran git repository:"
msgstr "克隆 LFortran git 存储库："

#: ../../doc/src/installation.md:82
msgid ""
"Generate files that are needed for the build (this step depends on "
"`re2c`, `bison` and `python`):"
msgstr "生成构建所需的文件（此步骤取决于 `re2c`、`bison` 和 `python`）："

#: ../../doc/src/installation.md:86
msgid ""
"Now the process is the same as installing from the source tarball. For "
"example to build in Debug mode:"
msgstr "现在的过程与从源 tarball 安装相同。例如在 Debug 模式下构建:"

#: ../../doc/src/installation.md:92
msgid "Run tests:"
msgstr "运行测试:"

#: ../../doc/src/installation.md:97
msgid "Run an interactive prompt:"
msgstr "运行交互式提示符:"

#: ../../doc/src/installation.md:102
msgid "Build from Git on Windows with Visual Studio"
msgstr "在 Windows 上使用 Visual Studio 从 Git 构建"

#: ../../doc/src/installation.md:104
msgid ""
"Install Visual Studio (MSVC), for example the version 2022, you can "
"download the Community version for free from: "
"https://visualstudio.microsoft.com/downloads/."
msgstr ""
"安装 Visual Studio (MSVC)，例如 2022 "
"版本，可以免费下载社区版本：https://visualstudio.microsoft.com/downloads/ 。"

#: ../../doc/src/installation.md:107
msgid ""
"Install miniforge using the Windows installer from https://github.com"
"/conda-forge/miniforge."
msgstr ""
"使用来自 https://github.com/conda-forge/miniforge 的 Windows 安装程序安装 "
"miniforge。"

#: ../../doc/src/installation.md:109
msgid "Launch the Miniforge Prompt from the Desktop."
msgstr "从桌面上启动 Miniforge Prompt。"

#: ../../doc/src/installation.md:111
msgid "In the shell, initialize the MSVC compiler using:"
msgstr "在 shell 中，用以下方法初始化 MSVC 编译器:"

#: ../../doc/src/installation.md:117
msgid "You can optionally test that MSVC works by:"
msgstr "你可以选择通过以下方式测试 MSVC 是否工作:"

#: ../../doc/src/installation.md:122
msgid "Both commands must print help (several pages)."
msgstr "这两个命令都必须打印帮助信息（若干页）。"

#: ../../doc/src/installation.md:124
msgid "Now you can download and build LFortran:"
msgstr "现在你可以下载并建立 LFortran："

#: ../../doc/src/installation.md:134
msgid "If everything compiled, then you can use LFortran as follows:"
msgstr "如果一切都编译好了，那么你就可以使用 LFortran，如下所示:"

#: ../../doc/src/installation.md:140
msgid "And so on."
msgstr "等等 。"

#: ../../doc/src/installation.md:142
msgid ""
"Note: LFortran currently uses the MSVC's linker program (`link`), which "
"is only available when the MSVC bat script above is ran. If you forget to"
" activate it, LFortran's linking will fail."
msgstr ""
"注意：LFortran 目前使用 MSVC 的链接器程序（`link`），只有在运行上面的 MSVC "
"bat 脚本时才能使用。如果你忘记激活它，LFortran 的链接就会失败。"

#: ../../doc/src/installation.md:146
msgid ""
"Note: the miniforge shell seems to be running some version of `git-bash` "
"(although it is `cmd.exe`), which has some unix-like filesystem mounted "
"in `/usr` and several commands available such as `ls`, `which`, `git`, "
"`vim`.  For this reason the Conda build `environment_win.yml` contains "
"everything needed, including `git`."
msgstr ""
"注意：miniforge shell 似乎在运行某个版本的 `git-bash`（尽管它是`cmd.exe`），"
"它有一些类似 unix 的文件系统挂载在 "
"`/usr`，有几个命令可用，如`ls`、`which`、`git`、`vim`。 由于这个原因，Conda "
"构建的 `environment_win.yml` 包含了所有需要的东西，包括 `git`。"

#: ../../doc/src/installation.md:152
msgid "Build from Git on Windows with WSL"
msgstr "用 WSL 在 Windows上 从 Git 构建"

#: ../../doc/src/installation.md:153
msgid "In windows search \"turn windows features on or off\"."
msgstr "在 Windows 中搜索“打开或关闭 Windows 功能”。"

#: ../../doc/src/installation.md:154
msgid "Tick Windows subsystem for Linux."
msgstr "标记适用于Linux 的 Windows 子系统。"

#: ../../doc/src/installation.md:155
msgid "Press OK and restart computer."
msgstr "按“确定”并重新启动计算机。"

#: ../../doc/src/installation.md:156
msgid "Go to Microsoft store and download Ubuntu 20.04, and launch it."
msgstr "到微软商店下载 Ubuntu 20.04，并启动它。"

#: ../../doc/src/installation.md:157
msgid "Run the following commands."
msgstr "运行下列程序语句。"

#: ../../doc/src/installation.md:164
msgid "Now do the following to configure the path"
msgstr "现在做以下工作来配置路径"

#: ../../doc/src/installation.md:168
msgid "Then go to the bottom of the file and paste the following"
msgstr "然后转到文件底部，粘贴以下内容"

#: ../../doc/src/installation.md:172
msgid "Then press ctrl + O (save), Enter (confirm), ctrl + X (exit)"
msgstr "然后按 ctrl + O（保存），Enter（确认），ctrl + X（退出）"

#: ../../doc/src/installation.md:173
msgid "After that restart Ubuntu"
msgstr "之后，重新启动 Ubuntu"

#: ../../doc/src/installation.md:174
msgid "Run the following"
msgstr "运行以下内容"

#: ../../doc/src/installation.md:179
msgid "Restart Ubuntu again"
msgstr "再次重启 Ubuntu"

#: ../../doc/src/installation.md:187
msgid ""
"You can change the directory to a Windows location using `cd /mnt/[drive "
"letter]/[windows location]`."
msgstr "你可以使用 `cd /mnt/[drive letter]/[windows location]`将路径改为 Windows "
"位置。"

#: ../../doc/src/installation.md:188
msgid "e.g. `cd mnt/c/Users/name/source/repos/`"
msgstr "例如：`cd mnt/c/Users/name/source/repos/`"

#: ../../doc/src/installation.md:190
msgid "Now clone the LFortran git repository"
msgstr "现在克隆 LFortran 的 git 仓库"

#: ../../doc/src/installation.md:196
msgid "Run the following commands"
msgstr "运行以下命令"

#: ../../doc/src/installation.md:204
msgid "If everything compiles, you can use LFortran as follows"
msgstr "如果一切都能编译，你可以使用 LFortran，如下所示"

#: ../../doc/src/installation.md:210
msgid "Run an interactive prompt"
msgstr "运行交互式提示符"

#: ../../doc/src/installation.md:215
msgid "Run tests"
msgstr "运行测试"

#: ../../doc/src/installation.md:221
msgid "Enabling the Jupyter Kernel"
msgstr "启用 Jupyter 内核"

#: ../../doc/src/installation.md:223
msgid "To install the Jupyter kernel, install the following Conda packages also:"
msgstr "要安装 Jupyter 内核，还要安装以下 Conda 软件包:"

#: ../../doc/src/installation.md:227
msgid ""
"and enable the kernel by `-DWITH_XEUS=yes` and install into "
"`$CONDA_PREFIX`. For example:"
msgstr "并通过 `-DWITH_XEUS=yes` 启用内核，然后安装到 `$CONDA_PREFIX`。比如："

#: ../../doc/src/installation.md:239
msgid ""
"To use it, install Jupyter (`conda install jupyter`) and test that the "
"LFortran kernel was found:"
msgstr "要使用它，请安装 Jupyter（`conda install jupyter`）并测试是否找到 LFortran "
"内核:"

#: ../../doc/src/installation.md:244
msgid "Then launch a Jupyter notebook as follows:"
msgstr "然后启动 Jupyter notebook，如下所示:"

#: ../../doc/src/installation.md:248
msgid "Click `New->Fortran`. To launch a terminal jupyter LFortran console:"
msgstr "单击 `New - > Fortran`。启动 jupyter LFortran 终端控制台："

#: ../../doc/src/installation.md:254
msgid "Build From Git with Nix"
msgstr "使用 Nix 从 Git 构建"

#: ../../doc/src/installation.md:256
msgid ""
"One of the ways to ensure exact environment and dependencies is with "
"`nix`. This will ensure that system dependencies do not interfere with "
"the development environment. If you want, you can report bugs in a `nix-"
"shell` environment to make it easier for others to reproduce."
msgstr ""
"确保精确环境和依赖关系的方法之一是使用 "
"`nix`。这将确保系统的依赖性不会干扰到开发环境。如果你愿意，你可以在 `nix-"
"shell` 环境下报告 bug，以方便别人复制。"

#: ../../doc/src/installation.md:258
msgid "With Root"
msgstr "带有 root 权限"

#: ../../doc/src/installation.md:260
msgid ""
"We start by getting `nix`. The following multi-user installation will "
"work on any machine with a Linux distribution, MacOS or Windows (via "
"WSL):"
msgstr "我们从获得 `nix` 开始。下面的多用户安装将在任何装有 Linux 发行版、MacOS 或 "
"Windows（通过 WSL）的机器上工作："

#: ../../doc/src/installation.md:264
msgid "Without Root"
msgstr "不带有 root 权限"

#: ../../doc/src/installation.md:266
msgid ""
"If you would like to not provide `nix` with root access to your machine, "
"on Linux distributions we can use [nix-"
"portable](https://github.com/DavHau/nix-portable)."
msgstr ""
"如果你想不给`nix`提供机器的root权限，在Linux发行版上，我们可以使用 [nix-"
"portable](https://github.com/DavHau/nix-portable).。"

#: ../../doc/src/installation.md:270
msgid ""
"Now just prepend all `nix-shell` commands with `NP_RUNTIME=bwrap ./nix-"
"portable `. So:"
msgstr "现在只要在所有 `nix-shell `命令前加上 `NP_RUNTIME=bwrap . /nix-"
"portable`。所以："

#: ../../doc/src/installation.md:278
msgid "Development"
msgstr "开发"

#: ../../doc/src/installation.md:280
msgid "Now we can enter the development environment:"
msgstr "现在进入开发环境:"

#: ../../doc/src/installation.md:284
msgid ""
"The `--pure` flag ensures no system dependencies are used in the "
"environment."
msgstr "`--pure` 标志确保在环境中不使用系统依赖。"

#: ../../doc/src/installation.md:286
msgid "The build steps are the same as with the `ci`:"
msgstr "构建步骤与 `ci ` 相同:"

#: ../../doc/src/installation.md:292
msgid ""
"To change the compilation environment from `gcc` (default) to `clang` we "
"can use `--argstr`:"
msgstr "要把编译环境从 `gcc`（默认）改为 `clang`，我们可以使用 `--argstr`："

#: ../../doc/src/installation.md:297
msgid "Note About Dependencies"
msgstr "关于依赖性的说明"

#: ../../doc/src/installation.md:299
msgid ""
"End users (and distributions) are encouraged to use the tarball from "
"[https://lfortran.org/download/](https://lfortran.org/download/), which "
"only depends on LLVM, CMake and a C++ compiler."
msgstr ""
"我们鼓励终端用户（和发行版）使用来自 [https://lfortran.org/download/"
"](https://lfortran.org/download/"
")的tarball，它只依赖于LLVM、CMake和C++编译器。"

#: ../../doc/src/installation.md:303
msgid ""
"The tarball is generated automatically by our CI (continuous integration)"
" and contains some autogenerated files: the parser, the AST and ASR "
"nodes, which is generated by an ASDL translator (requires Python)."
msgstr ""
"这个 tarball 是由我们的 "
"CI（持续集成）自动生成的，包含一些自动生成的文件：解析器、AST 和 ASR 节点，"
"由 ASDL 翻译器生成（需要 Python）。"

#: ../../doc/src/installation.md:307
msgid "The instructions from git are to be used when developing LFortran itself."
msgstr "在开发 LFortran 本身时要使用来自 git 的指令。"

#: ../../doc/src/installation.md:309
msgid "Note for users who do not use Conda"
msgstr "不使用 Conda 的用户注意"

#: ../../doc/src/installation.md:311
msgid ""
"Following are the dependencies necessary for installing this repository "
"in development mode,"
msgstr "以下是在开发模式下安装此版本库的必要依赖，"

#: ../../doc/src/installation.md:314
msgid "[Bison - 3.5.1](https://ftp.gnu.org/gnu/bison/bison-3.5.1.tar.xz)"
msgstr "[Bison - 3.5.1](https://ftp.gnu.org/gnu/bison/bison-3.5.1.tar.xz)"

#: ../../doc/src/installation.md:315
msgid ""
"[LLVM - 11.0.1](https://github.com/llvm/llvm-"
"project/releases/download/llvmorg-11.0.1/llvm-11.0.1.src.tar.xz)"
msgstr ""
"[LLVM - 11.0.1](https://github.com/llvm/llvm-project/releases/download/"
"llvmorg-11.0.1/llvm-11.0.1.src.tar.xz)"

#: ../../doc/src/installation.md:316
msgid "[re2c - 2.0.3](https://re2c.org/install/install.html)"
msgstr "[re2c - 2.0.3](https://re2c.org/install/install.html)"

#: ../../doc/src/installation.md:317
msgid ""
"[binutils - "
"2.31.90](ftp://sourceware.org/pub/binutils/snapshots/binutils-2.31.90.tar.xz)"
" - Make sure that you should enable the required options related to this "
"dependency to build the dynamic libraries (the ones ending with `.so`)."
msgstr ""
"[binutils - 2.31.90](ftp://sourceware.org/pub/binutils/snapshots/binutils-2."
"31.90.tar.xz) —— 确保你应该启用与此依赖关系相关的必要选项来构建动态库（以 `."
"so` 结尾的库）。"

#: ../../doc/src/installation.md:319
msgid "Stacktraces"
msgstr "堆栈跟踪"

#: ../../doc/src/installation.md:321
msgid ""
"LFortran can print stacktraces when there is an unhandled exception, as "
"well as on any compiler error with the `--show-stacktrace` option. This "
"is very helpful for developing the compiler itself to see where in "
"LFortran the problem is. The stacktrace support is turned off by default,"
" to enable it, compile LFortran with the `-DWITH_STACKTRACE=yes` cmake "
"option after installing the prerequisites on each platform per the "
"instructions below."
msgstr ""
"LFortran 可以在出现未处理的异常时打印堆栈跟踪，也可以在任何编译器错误时使用 "
"`--show-stacktrace` 选项。这对开发编译器本身很有帮助，可以看到 LFortran 中的"
"问题所在。默认情况下，堆栈跟踪支持是关闭的，要启用它，需要在每个平台上按照下"
"面的说明安装先决条件后，用`-DWITH_STACKTRACE=yes` cmake 选项编译 LFortran。"

#: ../../doc/src/installation.md:328
msgid "Ubuntu"
msgstr "Ubuntu"

#: ../../doc/src/installation.md:330
msgid "In Ubuntu, `apt install binutils-dev`."
msgstr "在 Ubuntu 系统，`apt install binutils-dev`。"

#: ../../doc/src/installation.md:332
msgid "macOS"
msgstr "macOS"

#: ../../doc/src/installation.md:334
msgid ""
"If you use the default Clang compiler on macOS, then the stacktraces "
"should just work on both Intel and M1 based macOS (the CMake build system"
" automatically invokes the `dsymtuil` tool and our Python scripts to "
"store the debug information, see `src/bin/CMakeLists.txt` for more "
"details). If it does not work, please report a bug."
msgstr ""
"如果你在 macOS 上使用默认的 Clang 编译器，那么堆栈跟踪应该正好在基于 Intel "
"和 M1 的 macOS 上工作（CMake 构建系统自动调用 `dsymtuil` 工具和我们的 Python "
"脚本来存储调试信息，更多细节见 `src/bin/CMakeLists."
"txt`）。如果不能工作，请报告一个错误。"

#: ../../doc/src/installation.md:340
msgid ""
"If you do not like the default way, an alternative is to use bintutils. "
"For that, first install [Spack](https://spack.io/), then:"
msgstr "如果你不喜欢默认的方式，另一个选择是使用bintutils。为此，首先安装 "
"[Spack](https://spack.io/)，然后："

#: ../../doc/src/installation.md:347
msgid ""
"The last command will show a full path to the installed `binutils` "
"package. Add this path to your shell config file, e.g.:"
msgstr "最后一条命令将显示已安装的 `binutils` 软件包的完整路径。把这个路径添加到你的 "
"shell 配置文件中，例如："

#: ../../doc/src/installation.md:352
msgid ""
"and compile LFortran with the "
"`-DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH_LFORTRAN;$CONDA_PREFIX\"` cmake"
" option. The `$CONDA_PREFIX` is there if you install some other "
"dependencies (such as `llvm`) using Conda, otherwise you can remove it."
msgstr ""
"并使用 `-DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH_LFORTRAN;$CONDA_PREFIX\"` "
"cmake 选项编译 LFortran。`$CONDA_PREFIX` 是在你使用 Conda "
"安装了一些其他的依赖项（如 `llvm`）的情况下出现的，否则你可以把它删除。"

#: ../../doc/src/intrinsics/array.md:1
msgid "Array Intrinsic Functions"
msgstr "数组内置函数"

#: ../../doc/src/intrinsics/array/allocated.md:1
msgid "allocated(x): Status Check"
msgstr "allocated(x)：状态检查"

#: ../../doc/src/intrinsics/array/allocated.md:3
msgid "Logical status of an allocatable integer."
msgstr "可分配整数的逻辑状态。"

#: ../../doc/src/intrinsics/array/allocated.md:5
#: ../../doc/src/intrinsics/array/cshift.md:5
#: ../../doc/src/intrinsics/array/size.md:5
#: ../../doc/src/intrinsics/bit/bge.md:5 ../../doc/src/intrinsics/bit/bgt.md:5
#: ../../doc/src/intrinsics/bit/bit_size.md:5
#: ../../doc/src/intrinsics/bit/ble.md:5 ../../doc/src/intrinsics/bit/blt.md:5
#: ../../doc/src/intrinsics/bit/btest.md:5
#: ../../doc/src/intrinsics/bit/shiftl.md:5
#: ../../doc/src/intrinsics/bit/shiftr.md:5
#: ../../doc/src/intrinsics/character/achar.md:5
#: ../../doc/src/intrinsics/character/adjustl.md:5
#: ../../doc/src/intrinsics/character/adjustr.md:5
#: ../../doc/src/intrinsics/character/char.md:5
#: ../../doc/src/intrinsics/character/len_trim.md:5
#: ../../doc/src/intrinsics/character/lge.md:5
#: ../../doc/src/intrinsics/kind-type/kind.md:5
#: ../../doc/src/intrinsics/mathematical/acos.md:5
#: ../../doc/src/intrinsics/mathematical/acosh.md:5
#: ../../doc/src/intrinsics/mathematical/asin.md:5
#: ../../doc/src/intrinsics/mathematical/asinh.md:5
#: ../../doc/src/intrinsics/mathematical/atan.md:5
#: ../../doc/src/intrinsics/mathematical/atan2.md:5
#: ../../doc/src/intrinsics/mathematical/atanh.md:5
#: ../../doc/src/intrinsics/mathematical/fraction.md:5
#: ../../doc/src/intrinsics/misc/command_argument_count.md:5
#: ../../doc/src/intrinsics/misc/cpu_time.md:5
#: ../../doc/src/intrinsics/misc/date_and_time.md:5
#: ../../doc/src/intrinsics/misc/new_line.md:5
#: ../../doc/src/intrinsics/numeric/abs.md:5
#: ../../doc/src/intrinsics/numeric/aimag.md:5
#: ../../doc/src/intrinsics/numeric/aint.md:5
#: ../../doc/src/intrinsics/numeric/anint.md:5
#: ../../doc/src/intrinsics/numeric/ceiling.md:5
#: ../../doc/src/intrinsics/numeric/cmplx.md:5
#: ../../doc/src/intrinsics/numeric/conjg.md:5
#: ../../doc/src/intrinsics/numeric/digits.md:5
#: ../../doc/src/intrinsics/numeric/dim.md:5
#: ../../doc/src/intrinsics/numeric/epsilon.md:5
#: ../../doc/src/intrinsics/numeric/erf.md:5
#: ../../doc/src/intrinsics/numeric/erfc.md:5
#: ../../doc/src/intrinsics/numeric/exp.md:5
#: ../../doc/src/intrinsics/numeric/floor.md:5
#: ../../doc/src/intrinsics/numeric/gamma.md:5
#: ../../doc/src/intrinsics/numeric/mod.md:5
msgid "Declaration"
msgstr "声明"

#: ../../doc/src/intrinsics/array/allocated.md:7
#: ../../doc/src/intrinsics/array/cshift.md:7
#: ../../doc/src/intrinsics/array/size.md:7
#: ../../doc/src/intrinsics/bit/bge.md:7 ../../doc/src/intrinsics/bit/bgt.md:7
#: ../../doc/src/intrinsics/bit/bit_size.md:7
#: ../../doc/src/intrinsics/bit/ble.md:7 ../../doc/src/intrinsics/bit/blt.md:7
#: ../../doc/src/intrinsics/bit/btest.md:7
#: ../../doc/src/intrinsics/bit/shiftl.md:7
#: ../../doc/src/intrinsics/bit/shiftr.md:7
#: ../../doc/src/intrinsics/character/achar.md:7
#: ../../doc/src/intrinsics/character/adjustl.md:7
#: ../../doc/src/intrinsics/character/adjustr.md:7
#: ../../doc/src/intrinsics/character/char.md:7
#: ../../doc/src/intrinsics/character/len_trim.md:7
#: ../../doc/src/intrinsics/character/lge.md:8
#: ../../doc/src/intrinsics/kind-type/kind.md:7
#: ../../doc/src/intrinsics/mathematical/acos.md:7
#: ../../doc/src/intrinsics/mathematical/acosh.md:7
#: ../../doc/src/intrinsics/mathematical/asin.md:7
#: ../../doc/src/intrinsics/mathematical/asinh.md:7
#: ../../doc/src/intrinsics/mathematical/atan.md:7
#: ../../doc/src/intrinsics/mathematical/atan2.md:7
#: ../../doc/src/intrinsics/mathematical/atanh.md:7
#: ../../doc/src/intrinsics/mathematical/fraction.md:7
#: ../../doc/src/intrinsics/misc/command_argument_count.md:7
#: ../../doc/src/intrinsics/misc/cpu_time.md:7
#: ../../doc/src/intrinsics/misc/date_and_time.md:7
#: ../../doc/src/intrinsics/misc/new_line.md:7
#: ../../doc/src/intrinsics/numeric/abs.md:7
#: ../../doc/src/intrinsics/numeric/aimag.md:7
#: ../../doc/src/intrinsics/numeric/aint.md:7
#: ../../doc/src/intrinsics/numeric/anint.md:7
#: ../../doc/src/intrinsics/numeric/ceiling.md:7
#: ../../doc/src/intrinsics/numeric/cmplx.md:7
#: ../../doc/src/intrinsics/numeric/conjg.md:7
#: ../../doc/src/intrinsics/numeric/digits.md:7
#: ../../doc/src/intrinsics/numeric/dim.md:7
#: ../../doc/src/intrinsics/numeric/epsilon.md:7
#: ../../doc/src/intrinsics/numeric/erf.md:7
#: ../../doc/src/intrinsics/numeric/erfc.md:7
#: ../../doc/src/intrinsics/numeric/exp.md:7
#: ../../doc/src/intrinsics/numeric/floor.md:7
#: ../../doc/src/intrinsics/numeric/gamma.md:7
#: ../../doc/src/intrinsics/numeric/mod.md:7
msgid "Syntax"
msgstr "语法"

#: ../../doc/src/intrinsics/array/allocated.md:14
#: ../../doc/src/intrinsics/array/cshift.md:14
#: ../../doc/src/intrinsics/array/size.md:14
#: ../../doc/src/intrinsics/bit/bge.md:14
#: ../../doc/src/intrinsics/bit/bgt.md:14
#: ../../doc/src/intrinsics/bit/bit_size.md:14
#: ../../doc/src/intrinsics/bit/ble.md:14
#: ../../doc/src/intrinsics/bit/blt.md:14
#: ../../doc/src/intrinsics/bit/btest.md:14
#: ../../doc/src/intrinsics/bit/shiftl.md:14
#: ../../doc/src/intrinsics/bit/shiftr.md:14
#: ../../doc/src/intrinsics/character/achar.md:14
#: ../../doc/src/intrinsics/character/adjustl.md:14
#: ../../doc/src/intrinsics/character/adjustr.md:14
#: ../../doc/src/intrinsics/character/char.md:14
#: ../../doc/src/intrinsics/character/len_trim.md:14
#: ../../doc/src/intrinsics/character/lge.md:15
#: ../../doc/src/intrinsics/kind-type/kind.md:14
#: ../../doc/src/intrinsics/mathematical/acos.md:14
#: ../../doc/src/intrinsics/mathematical/acosh.md:14
#: ../../doc/src/intrinsics/mathematical/asin.md:14
#: ../../doc/src/intrinsics/mathematical/asinh.md:14
#: ../../doc/src/intrinsics/mathematical/atan.md:14
#: ../../doc/src/intrinsics/mathematical/atan2.md:13
#: ../../doc/src/intrinsics/mathematical/atanh.md:14
#: ../../doc/src/intrinsics/mathematical/fraction.md:13
#: ../../doc/src/intrinsics/misc/command_argument_count.md:14
#: ../../doc/src/intrinsics/misc/cpu_time.md:14
#: ../../doc/src/intrinsics/misc/date_and_time.md:14
#: ../../doc/src/intrinsics/misc/new_line.md:14
#: ../../doc/src/intrinsics/numeric/abs.md:15
#: ../../doc/src/intrinsics/numeric/aimag.md:15
#: ../../doc/src/intrinsics/numeric/aint.md:14
#: ../../doc/src/intrinsics/numeric/anint.md:14
#: ../../doc/src/intrinsics/numeric/ceiling.md:14
#: ../../doc/src/intrinsics/numeric/cmplx.md:16
#: ../../doc/src/intrinsics/numeric/conjg.md:15
#: ../../doc/src/intrinsics/numeric/digits.md:13
#: ../../doc/src/intrinsics/numeric/dim.md:13
#: ../../doc/src/intrinsics/numeric/epsilon.md:14
#: ../../doc/src/intrinsics/numeric/erf.md:14
#: ../../doc/src/intrinsics/numeric/erfc.md:14
#: ../../doc/src/intrinsics/numeric/exp.md:14
#: ../../doc/src/intrinsics/numeric/floor.md:14
#: ../../doc/src/intrinsics/numeric/gamma.md:14
#: ../../doc/src/intrinsics/numeric/mod.md:15
msgid "Arguments"
msgstr "参数"

#: ../../doc/src/intrinsics/array/allocated.md:16
msgid "`x` is an integer input parameter."
msgstr "`x` 是一个整数输入参数。"

#: ../../doc/src/intrinsics/array/allocated.md:18
#: ../../doc/src/intrinsics/array/cshift.md:22
#: ../../doc/src/intrinsics/array/size.md:22
#: ../../doc/src/intrinsics/bit/bge.md:18
#: ../../doc/src/intrinsics/bit/bgt.md:18
#: ../../doc/src/intrinsics/bit/bit_size.md:18
#: ../../doc/src/intrinsics/bit/ble.md:18
#: ../../doc/src/intrinsics/bit/blt.md:18
#: ../../doc/src/intrinsics/bit/btest.md:19
#: ../../doc/src/intrinsics/bit/shiftl.md:21
#: ../../doc/src/intrinsics/bit/shiftr.md:21
#: ../../doc/src/intrinsics/character/lge.md:23
#: ../../doc/src/intrinsics/kind-type/kind.md:19
#: ../../doc/src/intrinsics/mathematical/acos.md:18
#: ../../doc/src/intrinsics/mathematical/acosh.md:19
#: ../../doc/src/intrinsics/mathematical/asin.md:18
#: ../../doc/src/intrinsics/mathematical/asinh.md:19
#: ../../doc/src/intrinsics/mathematical/atan.md:18
#: ../../doc/src/intrinsics/mathematical/atan2.md:21
#: ../../doc/src/intrinsics/mathematical/atanh.md:19
#: ../../doc/src/intrinsics/mathematical/fraction.md:17
#: ../../doc/src/intrinsics/misc/command_argument_count.md:18
#: ../../doc/src/intrinsics/misc/cpu_time.md:18
#: ../../doc/src/intrinsics/misc/date_and_time.md:39
#: ../../doc/src/intrinsics/misc/new_line.md:19
#: ../../doc/src/intrinsics/numeric/abs.md:19
#: ../../doc/src/intrinsics/numeric/aimag.md:19
#: ../../doc/src/intrinsics/numeric/aint.md:20
#: ../../doc/src/intrinsics/numeric/anint.md:20
#: ../../doc/src/intrinsics/numeric/ceiling.md:18
#: ../../doc/src/intrinsics/numeric/cmplx.md:24
#: ../../doc/src/intrinsics/numeric/conjg.md:19
#: ../../doc/src/intrinsics/numeric/digits.md:17
#: ../../doc/src/intrinsics/numeric/dim.md:18
#: ../../doc/src/intrinsics/numeric/epsilon.md:18
#: ../../doc/src/intrinsics/numeric/erf.md:18
#: ../../doc/src/intrinsics/numeric/erfc.md:18
#: ../../doc/src/intrinsics/numeric/exp.md:18
#: ../../doc/src/intrinsics/numeric/floor.md:20
#: ../../doc/src/intrinsics/numeric/gamma.md:19
#: ../../doc/src/intrinsics/numeric/mod.md:22
msgid "Return values"
msgstr "返回值"

#: ../../doc/src/intrinsics/array/allocated.md:20
msgid ""
"The return value is a logical scalar with the default logical kind type "
"parameter."
msgstr "返回值是具有默认逻辑种类类型参数的逻辑标量。"

#: ../../doc/src/intrinsics/array/allocated.md:23
#: ../../doc/src/intrinsics/array/cshift.md:26
#: ../../doc/src/intrinsics/array/size.md:26
#: ../../doc/src/intrinsics/bit/bge.md:22
#: ../../doc/src/intrinsics/bit/bgt.md:22
#: ../../doc/src/intrinsics/bit/bit_size.md:22
#: ../../doc/src/intrinsics/bit/ble.md:22
#: ../../doc/src/intrinsics/bit/blt.md:22
#: ../../doc/src/intrinsics/bit/btest.md:23
#: ../../doc/src/intrinsics/bit/shiftl.md:25
#: ../../doc/src/intrinsics/bit/shiftr.md:25
#: ../../doc/src/intrinsics/character/achar.md:27
#: ../../doc/src/intrinsics/character/adjustl.md:23
#: ../../doc/src/intrinsics/character/adjustr.md:24
#: ../../doc/src/intrinsics/character/char.md:28
#: ../../doc/src/intrinsics/character/len_trim.md:22
#: ../../doc/src/intrinsics/character/lge.md:31
#: ../../doc/src/intrinsics/kind-type/kind.md:23
#: ../../doc/src/intrinsics/mathematical/acos.md:23
#: ../../doc/src/intrinsics/mathematical/acosh.md:24
#: ../../doc/src/intrinsics/mathematical/asin.md:23
#: ../../doc/src/intrinsics/mathematical/asinh.md:24
#: ../../doc/src/intrinsics/mathematical/atan.md:23
#: ../../doc/src/intrinsics/mathematical/atan2.md:27
#: ../../doc/src/intrinsics/mathematical/atanh.md:24
#: ../../doc/src/intrinsics/mathematical/fraction.md:22
#: ../../doc/src/intrinsics/misc/command_argument_count.md:22
#: ../../doc/src/intrinsics/misc/cpu_time.md:22
#: ../../doc/src/intrinsics/misc/date_and_time.md:43
#: ../../doc/src/intrinsics/misc/new_line.md:24
#: ../../doc/src/intrinsics/numeric/abs.md:24
#: ../../doc/src/intrinsics/numeric/aimag.md:23
#: ../../doc/src/intrinsics/numeric/aint.md:28
#: ../../doc/src/intrinsics/numeric/anint.md:27
#: ../../doc/src/intrinsics/numeric/ceiling.md:22
#: ../../doc/src/intrinsics/numeric/cmplx.md:30
#: ../../doc/src/intrinsics/numeric/conjg.md:23
#: ../../doc/src/intrinsics/numeric/digits.md:21
#: ../../doc/src/intrinsics/numeric/dim.md:22
#: ../../doc/src/intrinsics/numeric/epsilon.md:22
#: ../../doc/src/intrinsics/numeric/erf.md:23
#: ../../doc/src/intrinsics/numeric/erfc.md:23
#: ../../doc/src/intrinsics/numeric/exp.md:22
#: ../../doc/src/intrinsics/numeric/floor.md:28
#: ../../doc/src/intrinsics/numeric/gamma.md:23
#: ../../doc/src/intrinsics/numeric/mod.md:31 ../../doc/src/progress.md
msgid "Description"
msgstr "描述"

#: ../../doc/src/intrinsics/array/allocated.md:25
msgid ""
"`allocated(x)` checks the allocation status of a integer input parameter."
" It returns a logical value as `TRUE` if the input argument `x` is "
"allocated, `FALSE` otherwise."
msgstr "`allocated(x)` 检查整数输入参数的分配状态。 "
"如果分配了输入参数`x`，则返回逻辑值`TRUE`，否则返回`FALSE`。"

#: ../../doc/src/intrinsics/array/allocated.md:29
#: ../../doc/src/intrinsics/array/cshift.md:39
#: ../../doc/src/intrinsics/array/size.md:33
#: ../../doc/src/intrinsics/bit/bge.md:27
#: ../../doc/src/intrinsics/bit/bgt.md:27
#: ../../doc/src/intrinsics/bit/bit_size.md:27
#: ../../doc/src/intrinsics/bit/ble.md:27
#: ../../doc/src/intrinsics/bit/blt.md:27
#: ../../doc/src/intrinsics/bit/btest.md:32
#: ../../doc/src/intrinsics/bit/shiftl.md:32
#: ../../doc/src/intrinsics/bit/shiftr.md:32
#: ../../doc/src/intrinsics/character/achar.md:37
#: ../../doc/src/intrinsics/character/adjustl.md:28
#: ../../doc/src/intrinsics/character/adjustr.md:29
#: ../../doc/src/intrinsics/character/char.md:38
#: ../../doc/src/intrinsics/character/len_trim.md:27
#: ../../doc/src/intrinsics/character/lge.md:37
#: ../../doc/src/intrinsics/kind-type/kind.md:27
#: ../../doc/src/intrinsics/mathematical/acos.md:31
#: ../../doc/src/intrinsics/mathematical/acosh.md:43
#: ../../doc/src/intrinsics/mathematical/asin.md:31
#: ../../doc/src/intrinsics/mathematical/asinh.md:35
#: ../../doc/src/intrinsics/mathematical/atan.md:31
#: ../../doc/src/intrinsics/mathematical/atan2.md:53
#: ../../doc/src/intrinsics/mathematical/atanh.md:39
#: ../../doc/src/intrinsics/mathematical/fraction.md:30
#: ../../doc/src/intrinsics/misc/command_argument_count.md:27
#: ../../doc/src/intrinsics/misc/cpu_time.md:33
#: ../../doc/src/intrinsics/misc/date_and_time.md:53
#: ../../doc/src/intrinsics/misc/new_line.md:29
#: ../../doc/src/intrinsics/numeric/abs.md:35
#: ../../doc/src/intrinsics/numeric/aimag.md:33
#: ../../doc/src/intrinsics/numeric/aint.md:35
#: ../../doc/src/intrinsics/numeric/anint.md:38
#: ../../doc/src/intrinsics/numeric/ceiling.md:26
#: ../../doc/src/intrinsics/numeric/cmplx.md:47
#: ../../doc/src/intrinsics/numeric/conjg.md:33
#: ../../doc/src/intrinsics/numeric/digits.md:26
#: ../../doc/src/intrinsics/numeric/dim.md:27
#: ../../doc/src/intrinsics/numeric/epsilon.md:29
#: ../../doc/src/intrinsics/numeric/erf.md:33
#: ../../doc/src/intrinsics/numeric/erfc.md:36
#: ../../doc/src/intrinsics/numeric/exp.md:29
#: ../../doc/src/intrinsics/numeric/floor.md:33
#: ../../doc/src/intrinsics/numeric/gamma.md:38
#: ../../doc/src/intrinsics/numeric/mod.md:43
msgid "Types"
msgstr "类型"

#: ../../doc/src/intrinsics/array/allocated.md:31
#: ../../doc/src/intrinsics/array/size.md:35
#: ../../doc/src/intrinsics/character/achar.md:39
#: ../../doc/src/intrinsics/character/char.md:40
msgid "Supported argument type is integer."
msgstr "支持的参数类型是整型。"

#: ../../doc/src/intrinsics/array/allocated.md:46
#: ../../doc/src/intrinsics/array/cshift.md:43
#: ../../doc/src/intrinsics/array/size.md:37
#: ../../doc/src/intrinsics/bit/bge.md:49
#: ../../doc/src/intrinsics/bit/bgt.md:49
#: ../../doc/src/intrinsics/bit/bit_size.md:44
#: ../../doc/src/intrinsics/bit/ble.md:49
#: ../../doc/src/intrinsics/bit/blt.md:49
#: ../../doc/src/intrinsics/bit/btest.md:56
#: ../../doc/src/intrinsics/bit/shiftl.md:62
#: ../../doc/src/intrinsics/bit/shiftr.md:62
#: ../../doc/src/intrinsics/character/achar.md:53
#: ../../doc/src/intrinsics/character/adjustl.md:45
#: ../../doc/src/intrinsics/character/adjustr.md:46
#: ../../doc/src/intrinsics/character/char.md:53
#: ../../doc/src/intrinsics/character/len_trim.md:44
#: ../../doc/src/intrinsics/character/lge.md:59
#: ../../doc/src/intrinsics/kind-type/kind.md:59
#: ../../doc/src/intrinsics/mathematical/acos.md:60
#: ../../doc/src/intrinsics/mathematical/acosh.md:72
#: ../../doc/src/intrinsics/mathematical/asin.md:60
#: ../../doc/src/intrinsics/mathematical/asinh.md:64
#: ../../doc/src/intrinsics/mathematical/atan.md:60
#: ../../doc/src/intrinsics/mathematical/atan2.md:75
#: ../../doc/src/intrinsics/mathematical/atanh.md:68
#: ../../doc/src/intrinsics/mathematical/fraction.md:34
#: ../../doc/src/intrinsics/misc/command_argument_count.md:31
#: ../../doc/src/intrinsics/misc/cpu_time.md:44
#: ../../doc/src/intrinsics/misc/date_and_time.md:64
#: ../../doc/src/intrinsics/misc/new_line.md:40
#: ../../doc/src/intrinsics/numeric/abs.md:79
#: ../../doc/src/intrinsics/numeric/aimag.md:53
#: ../../doc/src/intrinsics/numeric/aint.md:39
#: ../../doc/src/intrinsics/numeric/anint.md:42
#: ../../doc/src/intrinsics/numeric/ceiling.md:46
#: ../../doc/src/intrinsics/numeric/cmplx.md:59
#: ../../doc/src/intrinsics/numeric/conjg.md:53
#: ../../doc/src/intrinsics/numeric/digits.md:30
#: ../../doc/src/intrinsics/numeric/dim.md:31
#: ../../doc/src/intrinsics/numeric/epsilon.md:49
#: ../../doc/src/intrinsics/numeric/erf.md:53
#: ../../doc/src/intrinsics/numeric/erfc.md:56
#: ../../doc/src/intrinsics/numeric/exp.md:57
#: ../../doc/src/intrinsics/numeric/floor.md:65
#: ../../doc/src/intrinsics/numeric/gamma.md:58
#: ../../doc/src/intrinsics/numeric/mod.md:80
msgid "Examples"
msgstr "示例"

#: ../../doc/src/intrinsics/array/allocated.md:59
#: ../../doc/src/intrinsics/array/cshift.md:55
#: ../../doc/src/intrinsics/array/size.md:48
#: ../../doc/src/intrinsics/mathematical/acos.md:76
#: ../../doc/src/intrinsics/mathematical/acosh.md:81
#: ../../doc/src/intrinsics/mathematical/asin.md:76
#: ../../doc/src/intrinsics/mathematical/asinh.md:73
#: ../../doc/src/intrinsics/mathematical/atan.md:76
#: ../../doc/src/intrinsics/mathematical/atan2.md:84
#: ../../doc/src/intrinsics/mathematical/atanh.md:77
#: ../../doc/src/intrinsics/mathematical/fraction.md:44
msgid "**Result**:"
msgstr "**结果**："

#: ../../doc/src/intrinsics/array/allocated.md:65
#: ../../doc/src/intrinsics/array/cshift.md:62
#: ../../doc/src/intrinsics/array/size.md:55
#: ../../doc/src/intrinsics/bit/bge.md:68
#: ../../doc/src/intrinsics/bit/bgt.md:66
#: ../../doc/src/intrinsics/bit/bit_size.md:61
#: ../../doc/src/intrinsics/bit/ble.md:68
#: ../../doc/src/intrinsics/bit/blt.md:66
#: ../../doc/src/intrinsics/bit/btest.md:71
#: ../../doc/src/intrinsics/bit/shiftl.md:80
#: ../../doc/src/intrinsics/bit/shiftr.md:80
#: ../../doc/src/intrinsics/character/achar.md:69
#: ../../doc/src/intrinsics/character/adjustl.md:62
#: ../../doc/src/intrinsics/character/adjustr.md:63
#: ../../doc/src/intrinsics/character/char.md:69
#: ../../doc/src/intrinsics/character/len_trim.md:63
#: ../../doc/src/intrinsics/character/lge.md:79
#: ../../doc/src/intrinsics/kind-type/kind.md:79
#: ../../doc/src/intrinsics/mathematical/acos.md:82
#: ../../doc/src/intrinsics/mathematical/acosh.md:86
#: ../../doc/src/intrinsics/mathematical/asin.md:82
#: ../../doc/src/intrinsics/mathematical/asinh.md:78
#: ../../doc/src/intrinsics/mathematical/atan.md:82
#: ../../doc/src/intrinsics/mathematical/atan2.md:90
#: ../../doc/src/intrinsics/mathematical/atanh.md:82
#: ../../doc/src/intrinsics/mathematical/fraction.md:50
#: ../../doc/src/intrinsics/misc/command_argument_count.md:47
#: ../../doc/src/intrinsics/misc/cpu_time.md:64
#: ../../doc/src/intrinsics/misc/date_and_time.md:90
#: ../../doc/src/intrinsics/misc/new_line.md:56
#: ../../doc/src/intrinsics/numeric/abs.md:96
#: ../../doc/src/intrinsics/numeric/aimag.md:68
#: ../../doc/src/intrinsics/numeric/aint.md:55
#: ../../doc/src/intrinsics/numeric/anint.md:58
#: ../../doc/src/intrinsics/numeric/ceiling.md:64
#: ../../doc/src/intrinsics/numeric/cmplx.md:74
#: ../../doc/src/intrinsics/numeric/conjg.md:68
#: ../../doc/src/intrinsics/numeric/digits.md:44
#: ../../doc/src/intrinsics/numeric/dim.md:47
#: ../../doc/src/intrinsics/numeric/epsilon.md:63
#: ../../doc/src/intrinsics/numeric/erf.md:67
#: ../../doc/src/intrinsics/numeric/erfc.md:70
#: ../../doc/src/intrinsics/numeric/exp.md:71
#: ../../doc/src/intrinsics/numeric/floor.md:83
#: ../../doc/src/intrinsics/numeric/gamma.md:74
#: ../../doc/src/intrinsics/numeric/mod.md:95
msgid "See Also"
msgstr "也可以看看"

#: ../../doc/src/intrinsics/array/cshift.md:1
msgid "cshift(A, shift [, dim]): Circular Shift"
msgstr "cshift(A, shift [, dim])：循环移位"

#: ../../doc/src/intrinsics/array/cshift.md:3
msgid "Circular shift elements of an array."
msgstr "数组元素的循环移位。"

#: ../../doc/src/intrinsics/array/cshift.md:16
#: ../../doc/src/intrinsics/array/size.md:16
msgid "`A` the input array of any type or rank."
msgstr "`A` 为任何类型或维度的输入数组。"

#: ../../doc/src/intrinsics/array/cshift.md:18
msgid "`shift` the input value of integer type."
msgstr "`shift` 为整型类型的输入值。"

#: ../../doc/src/intrinsics/array/cshift.md:20
msgid ""
"`dim` optional dimension, if present, `cshift` returns the result of this"
" dimension."
msgstr "`dim` 可选维度，如果存在，`cshift` 返回此维度的结果。"

#: ../../doc/src/intrinsics/array/cshift.md:24
msgid ""
"The return value is of input array type and rank as the `A` array input "
"argument."
msgstr "返回值与数组输入参数 `A` 的类型与维度相同。"

#: ../../doc/src/intrinsics/array/cshift.md:28
msgid ""
"**cshift(A, shift [, dim])** performs a circular shift on elements of `A`"
" array along the dimension of `dim`. Default value of `dim` is 1, used "
"when `dim` is not passed."
msgstr ""
"**cshift(A, shift [, dim])** 沿 `dim` 的维度对 `A` 数组的元素执行循环移位。"
"当 `dim` 未传递时使用，`dim` 的默认值为 1。"

#: ../../doc/src/intrinsics/array/cshift.md:32
msgid ""
"If the rank of array is 1, then all elements of array are shifted by "
"`shift` places. If rank is greater than one, then all complexte rank one "
"sections of array along the given dimension are shifted."
msgstr "如果数组的维度数为 1，则数组的所有元素都会移动 `shift` 位。如果维度数大于 "
"1，则沿给定维度的数组元素都被移动。"

#: ../../doc/src/intrinsics/array/cshift.md:36
msgid ""
"Elements shifted out one end of each rank one section are shifted back in"
" the other end."
msgstr "元素从每一列的一端移出，在另一端移回。"

#: ../../doc/src/intrinsics/array/cshift.md:41
msgid ""
"Supported argument type is array for `A` and integer for `shift` and "
"`dim`."
msgstr "支持的参数类型是 `A` 的数组和 `shift` 和 `dim` 的整数。"

#: ../../doc/src/intrinsics/array/size.md:1
msgid "size(x): Size of Array"
msgstr "size(x)：数组大小"

#: ../../doc/src/intrinsics/array/size.md:3
msgid "Returns the size of an array `x`."
msgstr "返回数组 `x` 的大小。"

#: ../../doc/src/intrinsics/array/size.md:18
msgid ""
"`dim` optional dimension, if present, `size` returns the size of this "
"dimension."
msgstr "`dim` 可选维度，如果存在，`size` 返回此维度的大小。"

#: ../../doc/src/intrinsics/array/size.md:20
msgid "`kind` optional the kind of the return value."
msgstr "`kind` 可选返回值的种类。"

#: ../../doc/src/intrinsics/array/size.md:24
msgid "`n` the size of an array (integer)."
msgstr "`n` 数组的大小（整型）。"

#: ../../doc/src/intrinsics/array/size.md:28
msgid ""
"The `size` intrinsic function returns the size of an array. It returns "
"the product of all dimensions, unless the `dim` argument is specified, in"
" which case it only returns the size of this particular dimension. The "
"`kind` argument can be used to specify the integer kind of the result."
msgstr ""
"`size` 内部函数返回数组的大小。它返回所有维度的乘积，除非指定了 `dim` "
"参数，在这种情况下，它只返回这个特定维度的大小。 `kind` "
"参数可用于指定结果的整数类型。"

#: ../../doc/src/intrinsics/array/size.md:57
msgid "[shape](), [reshape]()."
msgstr "[shape]()，[reshape]()。"

#: ../../doc/src/intrinsics/bit.md:1
msgid "Bit Intrinsic Functions"
msgstr "位操作内置函数"

#: ../../doc/src/intrinsics/bit/bge.md:1
msgid "bge(x, y): Bitwise Greater or Equal"
msgstr "bge(x, y)：按位大于或等于"

#: ../../doc/src/intrinsics/bit/bge.md:3
msgid "Bitwise greater than or equal to."
msgstr "按位大于或等于。"

#: ../../doc/src/intrinsics/bit/bge.md:16
#: ../../doc/src/intrinsics/bit/bgt.md:16
#: ../../doc/src/intrinsics/bit/ble.md:16
#: ../../doc/src/intrinsics/bit/blt.md:16
msgid "`x` and `y` are integer input values. Both input values are of same kind."
msgstr "`x` 和 `y` 是整数输入值。两个输入值是同一类型的。"

#: ../../doc/src/intrinsics/bit/bge.md:20
#: ../../doc/src/intrinsics/bit/bgt.md:20
#: ../../doc/src/intrinsics/bit/ble.md:20
#: ../../doc/src/intrinsics/bit/blt.md:20
msgid "The return value is of type logical and of the default kind."
msgstr "返回值是逻辑类型和默认类型。"

#: ../../doc/src/intrinsics/bit/bge.md:24
msgid ""
"`bge(x, y)` calculates if two integer input values is bitwise greater "
"than or equal to another."
msgstr "`bge(x, y)` 计算两个整数输入值是否按位大于或等于另一个。"

#: ../../doc/src/intrinsics/bit/bge.md:29
#: ../../doc/src/intrinsics/bit/bgt.md:29
#: ../../doc/src/intrinsics/bit/ble.md:29
#: ../../doc/src/intrinsics/bit/blt.md:29
#: ../../doc/src/intrinsics/bit/btest.md:34
msgid "Supported input types is integer of 32 bit and 64 bit size."
msgstr "支持的输入类型是 32 位和 64 位大小的整数。"

#: ../../doc/src/intrinsics/bit/bge.md:60
#: ../../doc/src/intrinsics/bit/bgt.md:59
#: ../../doc/src/intrinsics/bit/bit_size.md:54
#: ../../doc/src/intrinsics/bit/ble.md:60
#: ../../doc/src/intrinsics/bit/blt.md:59
#: ../../doc/src/intrinsics/bit/btest.md:65
#: ../../doc/src/intrinsics/bit/shiftl.md:74
#: ../../doc/src/intrinsics/bit/shiftr.md:74
#: ../../doc/src/intrinsics/character/achar.md:63
#: ../../doc/src/intrinsics/character/adjustl.md:56
#: ../../doc/src/intrinsics/character/adjustr.md:57
#: ../../doc/src/intrinsics/character/char.md:63
#: ../../doc/src/intrinsics/character/len_trim.md:57
#: ../../doc/src/intrinsics/character/lge.md:72
#: ../../doc/src/intrinsics/kind-type/kind.md:72
#: ../../doc/src/intrinsics/misc/command_argument_count.md:40
#: ../../doc/src/intrinsics/misc/cpu_time.md:57
#: ../../doc/src/intrinsics/misc/date_and_time.md:83
#: ../../doc/src/intrinsics/misc/new_line.md:49
#: ../../doc/src/intrinsics/numeric/abs.md:89
#: ../../doc/src/intrinsics/numeric/aimag.md:62
#: ../../doc/src/intrinsics/numeric/aint.md:48
#: ../../doc/src/intrinsics/numeric/anint.md:51
#: ../../doc/src/intrinsics/numeric/ceiling.md:57
#: ../../doc/src/intrinsics/numeric/cmplx.md:68
#: ../../doc/src/intrinsics/numeric/conjg.md:62
#: ../../doc/src/intrinsics/numeric/digits.md:38
#: ../../doc/src/intrinsics/numeric/dim.md:40
#: ../../doc/src/intrinsics/numeric/epsilon.md:57
#: ../../doc/src/intrinsics/numeric/erf.md:61
#: ../../doc/src/intrinsics/numeric/erfc.md:64
#: ../../doc/src/intrinsics/numeric/exp.md:65
#: ../../doc/src/intrinsics/numeric/floor.md:76
#: ../../doc/src/intrinsics/numeric/gamma.md:67
#: ../../doc/src/intrinsics/numeric/mod.md:89
msgid "**Result:**"
msgstr "**结果：**"

#: ../../doc/src/intrinsics/bit/bge.md:70
msgid "[bgt](bgt.md), [ble](ble.md), [blt](blt.md)."
msgstr "[bgt](bgt.md)，[ble](ble.md)，[blt](blt.md)。"

#: ../../doc/src/intrinsics/bit/bgt.md:1
msgid "bgt(x, y): Bitwise Greater Than"
msgstr "bgt(x, y)：按位大于"

#: ../../doc/src/intrinsics/bit/bgt.md:3
msgid "Bitwise greater than."
msgstr "按位大于。"

#: ../../doc/src/intrinsics/bit/bgt.md:24
msgid ""
"`bgt(x, y)` calculates if one integer input values is bitwise greater "
"than the other."
msgstr "`bgt(x, y)` 计算一个整数输入值是否按位大于另一个。"

#: ../../doc/src/intrinsics/bit/bgt.md:68
msgid "[bge](bge.md), [ble](ble.md), [blt](blt.md)."
msgstr "[bge](bge.md)，[ble](ble.md)，[blt](blt.md)。"

#: ../../doc/src/intrinsics/bit/bit_size.md:1
msgid "bit_size(x): Bit Size"
msgstr "bit_size(x): 位大小"

#: ../../doc/src/intrinsics/bit/bit_size.md:3
msgid "Bit size."
msgstr "位大小。"

#: ../../doc/src/intrinsics/bit/bit_size.md:16
msgid "`x` is integer input value."
msgstr "`x` 是整数输入值。"

#: ../../doc/src/intrinsics/bit/bit_size.md:20
#: ../../doc/src/intrinsics/numeric/digits.md:19
msgid "The return value is of type integer."
msgstr "返回值是整数类型。"

#: ../../doc/src/intrinsics/bit/bit_size.md:24
msgid ""
"`bit_size(x)` calculates the number of bits including sign bit of binary "
"representation of `x`."
msgstr "`bit_size(x)` 计算 `x` 的二进制表示的包括符号位在内的位数。"

#: ../../doc/src/intrinsics/bit/bit_size.md:29
msgid "Supported input types is integer."
msgstr "支持的输入类型是整数。"

#: ../../doc/src/intrinsics/bit/ble.md:1
msgid "bge(x, y): Bitwise Less or Equal"
msgstr "bge(x, y)：按位小于或等于"

#: ../../doc/src/intrinsics/bit/ble.md:3
msgid "Bitwise less than or equal to."
msgstr "按位小于或等于。"

#: ../../doc/src/intrinsics/bit/ble.md:24
msgid ""
"`ble(x, y)` calculates if one integer input values is bitwise less than "
"or equal to other."
msgstr "`ble(x, y)` 计算一个整数输入值是否按位小于或等于另一个。"

#: ../../doc/src/intrinsics/bit/ble.md:70
msgid "[bgt](bgt.md), [bge](bge.md), [blt](blt.md)."
msgstr "[bgt](bgt.md), [bge](bge.md), [blt](blt.md)."

#: ../../doc/src/intrinsics/bit/blt.md:1
msgid "blt(x, y): Bitwise Less Than"
msgstr "blt(x, y)：按位小于"

#: ../../doc/src/intrinsics/bit/blt.md:3
msgid "Bitwise less than."
msgstr "按位小于。"

#: ../../doc/src/intrinsics/bit/blt.md:24
msgid ""
"`blt(x, y)` calculates if one integer input values is bitwise less than "
"the other."
msgstr "`blt(x, y)` 计算一个整数输入值是否按位小于另一个。"

#: ../../doc/src/intrinsics/bit/blt.md:68
msgid "[bge](bge.md), [ble](ble.md), [bgt](bgt.md)."
msgstr "[bge](bge.md), [ble](ble.md)，[bgt](bgt.md)。"

#: ../../doc/src/intrinsics/bit/btest.md:1
msgid "btest(x, pos): Bit Test at Position"
msgstr "btest(x, pos)：位置位测试"

#: ../../doc/src/intrinsics/bit/btest.md:3
msgid "Bit test."
msgstr "位测试。"

#: ../../doc/src/intrinsics/bit/btest.md:16
msgid ""
"`x` and `pos` are integer input values. Both input values are of same "
"kind. `pos` represents position in `x`."
msgstr "`x` 和 `pos` 是整数输入值。 两个输入值是同一种类型。 `pos` 表示在 `x` "
"中的位置。"

#: ../../doc/src/intrinsics/bit/btest.md:21
msgid "The return value is of type logical."
msgstr "返回值是逻辑类型。"

#: ../../doc/src/intrinsics/bit/btest.md:25
msgid ""
"`btest(x, pos)` calculates if `pos` bit in input integer value `x` is "
"set. The counting of the bits starts at 0, at least significant bit (LSB)"
" i.e., the rightmost bit in `x`."
msgstr ""
"`btest(x, pos)` 计算输入整数值 `x` 中的 `pos` 位是否已设置。 位的计数从 0 "
"开始，至少是有效位 (LSB)，即“x”中的最右边位。"

#: ../../doc/src/intrinsics/bit/btest.md:29
msgid ""
"If `pos` less than 0 or greater than `bit_size()`, `btest(x, pos)` errors"
" with not allowed message."
msgstr "如果 `pos` 小于 0 或大于 `bit_size()`，则 `btest(x, pos)` "
"错误并显示不允许的消息。"

#: ../../doc/src/intrinsics/bit/shiftl.md:1
msgid "shiftl(x, shift): Shift Left"
msgstr "shiftl(x, shift)：左移"

#: ../../doc/src/intrinsics/bit/shiftl.md:3
msgid "Logical shift left function."
msgstr "逻辑左移函数。"

#: ../../doc/src/intrinsics/bit/shiftl.md:16
#: ../../doc/src/intrinsics/bit/shiftr.md:16
msgid "`x` is an integer input value."
msgstr "`x` 是一个整数输入值。"

#: ../../doc/src/intrinsics/bit/shiftl.md:18
#: ../../doc/src/intrinsics/bit/shiftr.md:18
msgid ""
"`shift` an unsigned integer value less than or equal to the bit size of "
"`x`. The possible values are 7, 31, and 63."
msgstr "`shift` 一个小于或等于 `x` 位大小的无符号整数值。 可能的值为 7、31 和 63。"

#: ../../doc/src/intrinsics/bit/shiftl.md:23
#: ../../doc/src/intrinsics/bit/shiftr.md:23
msgid "The return value is of type integer and of the same kind as `x`."
msgstr "返回值是整数类型，与 `x` 类型相同。"

#: ../../doc/src/intrinsics/bit/shiftl.md:27
msgid ""
"**shiftl(x, shift)** logically left shifts `x` by `shift` number of bits."
" `shiftl` shifts from LSB(**L**east **S**ignificant **B**it) to "
"MSB(**M**ost **S**ignificant **B**it). Bits shifted from the left end "
"i.e., MSB bits are lost. Zeroes are appended to the opposite right end."
msgstr ""
"**shiftl(x, shift)** 逻辑上将“x”左移“shift”位数。 `shiftl` 从 LSB(**L**east "
"**S**significant **B**it) 转换为 MSB(**M**ost **S**significant **B**it)。 "
"从左端移位的位，即 MSB 位丢失。 零被附加到相反的右端。"

#: ../../doc/src/intrinsics/bit/shiftl.md:34
#: ../../doc/src/intrinsics/bit/shiftr.md:34
msgid ""
"Supported types in unsigned integer value `x` and unsigned integer value "
"`shift` from (7, 31, 63) less than or equal to bit size of `x`."
msgstr "无符号整数值`x`和无符号整数值`shift`中支持的类型（7、31、63）小于或等于`x`的"
"位大小。"

#: ../../doc/src/intrinsics/bit/shiftl.md:82
msgid "[shiftr](shiftr.md)."
msgstr "[shiftr](shiftr.md)。"

#: ../../doc/src/intrinsics/bit/shiftr.md:1
msgid "shiftr(x, shift): Shift Right"
msgstr "shiftr(x, shift)：右移"

#: ../../doc/src/intrinsics/bit/shiftr.md:3
msgid "Logical shift right function."
msgstr "逻辑右移功能。"

#: ../../doc/src/intrinsics/bit/shiftr.md:27
msgid ""
"**shiftr(x, shift)** logically right shifts `x` by `shift` number of "
"bits. `shiftr` shifts from MSB(**M**ost **S**ignificant **B**it) to "
"LSB(**L**east **S**ignificant **B**it). Bits shifted from the right end "
"i.e., LSB bits are lost. Zeroes are appended to the opposite left end."
msgstr ""
"**shiftr(x, shift)** 将“x”逻辑右移“shift”位数。 `shiftr` 从 MSB(**M**ost "
"**S**significant **B**it) 转换为 LSB(**L**east **S**significant **B**it)。 "
"从右端移位的位，即 LSB 位丢失。 零被附加到相对的左端。"

#: ../../doc/src/intrinsics/bit/shiftr.md:82
msgid "[shiftl](shiftl.md)."
msgstr "[shiftl](shiftl.md)。"

#: ../../doc/src/intrinsics/character.md:1
msgid "Character Intrinsic Functions"
msgstr "字符内置函数"

#: ../../doc/src/intrinsics/character/achar.md:1
msgid "achar(x, kind): To Character in ASCII set."
msgstr "achar(x, kind): ASCII 集中的字符。"

#: ../../doc/src/intrinsics/character/achar.md:3
msgid "Character represented by in the ASCII character set."
msgstr "ASCII 字符集中由 表示的字符。"

#: ../../doc/src/intrinsics/character/achar.md:16
msgid ""
"`x`: the input value of integer type. `kind`: an optional input value of "
"type integer constant expression for initialization."
msgstr "`x`：整数类型的输入值。 `kind`：用于初始化的整数常量表达式类型的可选输入值。"

#: ../../doc/src/intrinsics/character/achar.md:20
#: ../../doc/src/intrinsics/character/adjustl.md:18
#: ../../doc/src/intrinsics/character/adjustr.md:18
#: ../../doc/src/intrinsics/character/char.md:21
#: ../../doc/src/intrinsics/character/len_trim.md:18
msgid "Return value"
msgstr "返回值"

#: ../../doc/src/intrinsics/character/achar.md:22
#: ../../doc/src/intrinsics/character/char.md:23
msgid "The return value is of type character of length 1."
msgstr "返回值是长度为 1 的字符类型。"

#: ../../doc/src/intrinsics/character/achar.md:24
#: ../../doc/src/intrinsics/character/char.md:25
msgid ""
"The return value is of kind `kind` if optional input value is passed, "
"otherwise the kind is default kind."
msgstr "如果传入可选输入值，则返回值为 kind `kind`，否则为默认 kind。"

#: ../../doc/src/intrinsics/character/achar.md:29
msgid ""
"**achar(x, kind)** returns the character represented by the ASCII "
"character set at `x` position."
msgstr "**achar(x, kind)** 返回由 ASCII 字符集在 `x` 位置表示的字符。"

#: ../../doc/src/intrinsics/character/achar.md:32
#: ../../doc/src/intrinsics/character/char.md:33
msgid ""
"If `x` is outside the ASCII character set integer value, i.e., if `x` is "
"not represented in the ASCII character set, the return value is "
"undefined."
msgstr "如果 `x` 在 ASCII 字符集整数值之外，即，如果 `x` 没有在 ASCII "
"字符集中表示，则返回值未定义。"

#: ../../doc/src/intrinsics/character/achar.md:35
#: ../../doc/src/intrinsics/character/char.md:36
msgid "It is a runtime builtin function."
msgstr "它是一个运行时内置函数。"

#: ../../doc/src/intrinsics/character/achar.md:71
#: ../../doc/src/intrinsics/character/adjustl.md:64
#: ../../doc/src/intrinsics/character/len_trim.md:65
msgid "[lge](lge.md)."
msgstr "[lge](lge.md)."

#: ../../doc/src/intrinsics/character/adjustl.md:1
msgid "adjustl(string): Left Adjust String"
msgstr "adjustl(string): 左调整字符串"

#: ../../doc/src/intrinsics/character/adjustl.md:3
msgid "Left adjust a string."
msgstr "左调整一个字符串。"

#: ../../doc/src/intrinsics/character/adjustl.md:16
#: ../../doc/src/intrinsics/character/adjustr.md:16
msgid "`string`: the input value must be of character type."
msgstr "`string`：输入值必须是字符类型。"

#: ../../doc/src/intrinsics/character/adjustl.md:20
msgid ""
"The return value is of type character and of the same kind as of input "
"value `string`, with leading spaces removed and same number of spaces "
"appended."
msgstr "返回值是字符类型，与输入值`string`的类型相同，删除了前导空格并附加了相同数量"
"的空格。"

#: ../../doc/src/intrinsics/character/adjustl.md:25
msgid ""
"**adjustl(string)** adjusts input string by removing any leading spaces "
"and appending same number of spaces."
msgstr "**adjustl(string)** "
"通过删除任何前导空格并附加相同数量的空格来调整输入字符串。"

#: ../../doc/src/intrinsics/character/adjustl.md:30
#: ../../doc/src/intrinsics/character/adjustr.md:31
msgid "Supported argument type is character."
msgstr "支持的参数类型是字符。"

#: ../../doc/src/intrinsics/character/adjustr.md:1
msgid "adjustr(string): Right Adjust String"
msgstr "调整器（字符串）：右调整字符串"

#: ../../doc/src/intrinsics/character/adjustr.md:3
msgid "Right adjust a string."
msgstr "右调整一个字符串。"

#: ../../doc/src/intrinsics/character/adjustr.md:20
msgid ""
"The return value is of type character and of the same kind as of input "
"value `string`, with trailing spaces removed and same number of spaces "
"added at the start."
msgstr "返回值是字符类型，与输入值`string`的类型相同，删除了尾随空格并在开头添加了相"
"同数量的空格。"

#: ../../doc/src/intrinsics/character/adjustr.md:26
msgid ""
"**adjustr(string)** adjusts input string by removing any trailing spaces "
"and adding same number of spaces at the start of the input string."
msgstr "**adjustr(string)** "
"通过删除任何尾随空格并在输入字符串的开头添加相同数量的空格来调整输入字符串。"

#: ../../doc/src/intrinsics/character/adjustr.md:65
msgid "[adjustl](adjustl.md)."
msgstr "[adjustl](adjustl.md)。"

#: ../../doc/src/intrinsics/character/char.md:1
msgid "char(x, [, kind]): Integer to Character"
msgstr "char(x, [, kind])：整数到字符"

#: ../../doc/src/intrinsics/character/char.md:3
msgid "Integer to character conversion."
msgstr "整数到字符的转换。"

#: ../../doc/src/intrinsics/character/char.md:16
msgid "`x`: the input value of integer type."
msgstr "`x`：整数类型的输入值。"

#: ../../doc/src/intrinsics/character/char.md:18
msgid ""
"`kind`: an optional input value of type integer constant expression for "
"initialization. This indicates the kind parameter of the result."
msgstr "`kind`：用于初始化的整数常量表达式类型的可选输入值。 这表示结果的种类参数。"

#: ../../doc/src/intrinsics/character/char.md:30
msgid ""
"**char(x)** returns the character represented by the ASCII character set "
"at `x` position."
msgstr "**char(x)** 返回由 ASCII 字符集在 `x` 位置表示的字符。"

#: ../../doc/src/intrinsics/character/char.md:71
msgid "[achar](achar.md), [iachar](iachar.md), [ichar](ichar.md)"
msgstr "[achar](achar.md)，[iachar](iachar.md)，[ichar](ichar.md)"

#: ../../doc/src/intrinsics/character/len_trim.md:1
msgid "len_trim(string): Length Ignoring Trailing Blanks"
msgstr "len_trim(string): 忽略尾随空格的长度"

#: ../../doc/src/intrinsics/character/len_trim.md:3
msgid "Length of a character string ignoring trailing blank character(s)."
msgstr "忽略尾随空白字符的字符串长度。"

#: ../../doc/src/intrinsics/character/len_trim.md:16
msgid "`string` the input value of character type."
msgstr "`string` 字符类型的输入值。"

#: ../../doc/src/intrinsics/character/len_trim.md:20
msgid "The return value is of type unsigned integer."
msgstr "返回值是无符号整数类型。"

#: ../../doc/src/intrinsics/character/len_trim.md:24
msgid ""
"**len_trim(string)** returns the length of the character argument without"
" including trailing blank character(s)."
msgstr "**len_trim(string)** 返回字符参数的长度，不包括尾随空白字符。"

#: ../../doc/src/intrinsics/character/len_trim.md:29
msgid "Supported argument type is character scalar."
msgstr "支持的参数类型是字符标量。"

#: ../../doc/src/intrinsics/character/lge.md:1
msgid "lge(x, y): Lexically Greater or Equal"
msgstr "lge(x, y)：词法上大于或等于"

#: ../../doc/src/intrinsics/character/lge.md:3
msgid "Lexically greater than or equal."
msgstr "词法上大于或等于。"

#: ../../doc/src/intrinsics/character/lge.md:17
msgid "`x` input value of type character."
msgstr "`x` 类型字符的输入值。"

#: ../../doc/src/intrinsics/character/lge.md:19
msgid "`y` input value of type character."
msgstr "`y` 类型字符的输入值。"

#: ../../doc/src/intrinsics/character/lge.md:21
msgid "`x` and `y` can be seen as string A and string B."
msgstr "`x` 和 `y` 可以看作是字符串 A 和字符串 B。"

#: ../../doc/src/intrinsics/character/lge.md:25
msgid "The return value is of logical `true` or `false` type."
msgstr "返回值是逻辑 `true` 或 `false` 类型。"

#: ../../doc/src/intrinsics/character/lge.md:27
msgid "`True` if `x` string is lexically greater than or equal to `y`."
msgstr "如果 `x` 字符串在词法上大于或等于 `y`，则为 `True`。"

#: ../../doc/src/intrinsics/character/lge.md:29
msgid "`False` if they are not."
msgstr "如果不是，则为`False`。"

#: ../../doc/src/intrinsics/character/lge.md:33
msgid ""
"**lge(x, y)** determines if input string `x` is lexically greater than or"
" equal to input string `y`. The two strings in comparison are interpreted"
" as containing ASCII character codes."
msgstr ""
"**lge(x, y)** 确定输入字符串 `x` 在词法上是否大于或等于输入字符串 `y`。 "
"比较的两个字符串被解释为包含 ASCII 字符代码。"

#: ../../doc/src/intrinsics/character/lge.md:39
msgid "Argument types should be of type character literal."
msgstr "参数类型应该是字符文字类型。"

#: ../../doc/src/intrinsics/character/lge.md:81
msgid "[len_trim](len_trim.md)."
msgstr "[len_trim](len_trim.md)."

#: ../../doc/src/intrinsics/kind-type.md:1
msgid "Kind Type Intrinsic Functions"
msgstr "种类类型内置函数"

#: ../../doc/src/intrinsics/kind-type/kind.md:1
msgid "kind(x): Kind of an Entity"
msgstr "kind(x)：实体的种类"

#: ../../doc/src/intrinsics/kind-type/kind.md:3
msgid "Kind of an entity."
msgstr "一种实体。"

#: ../../doc/src/intrinsics/kind-type/kind.md:16
msgid ""
"`x` the input value, can be logical, integer, real, complex, or "
"character. It may be a scalar or array valued i.e., any intrinsic type."
msgstr "`x` 输入值，可以是逻辑、整数、实数、复数或字符。 "
"它可以是标量或数组值，即任何内在类型。"

#: ../../doc/src/intrinsics/kind-type/kind.md:21
msgid "The return value is of integer type and of default integer kind."
msgstr "返回值是整数类型和默认整数类型。"

#: ../../doc/src/intrinsics/kind-type/kind.md:25
msgid "**kind(x)** returns the kind parameter of the input argument `x`."
msgstr "**kind(x)** 返回输入参数 `x` 的种类参数。"

#: ../../doc/src/intrinsics/kind-type/kind.md:29
msgid ""
"Supported argument types are logical, integer, real, complex, or "
"character."
msgstr "支持的参数类型是逻辑、整数、实数、复数或字符。"

#: ../../doc/src/intrinsics/kind-type/kind.md:81
#: ../../doc/src/intrinsics/misc/command_argument_count.md:16
#: ../../doc/src/intrinsics/misc/cpu_time.md:20
#: ../../doc/src/intrinsics/misc/date_and_time.md:41
#: ../../doc/src/intrinsics/misc/new_line.md:58
msgid "None."
msgstr "无。"

#: ../../doc/src/intrinsics/mathematical.md:1
msgid "Mathematical Intrinsic Functions"
msgstr "数学内置函数"

#: ../../doc/src/intrinsics/mathematical/acos.md:1
msgid "acos(x): Trigonometric Arc Cosine"
msgstr "acos(x)：三角反余弦"

#: ../../doc/src/intrinsics/mathematical/acos.md:3
msgid "Trigonometric arc cosine (inverse cosine) function."
msgstr "三角反余弦（反余弦）函数。"

#: ../../doc/src/intrinsics/mathematical/acos.md:16
#: ../../doc/src/intrinsics/mathematical/asin.md:16
#: ../../doc/src/intrinsics/mathematical/atan.md:16
msgid "`x` the input value, can be real or complex; less than or equal to 1."
msgstr "`x` 输入值，可以是实数或复数； 小于或等于 1。"

#: ../../doc/src/intrinsics/mathematical/acos.md:20
#: ../../doc/src/intrinsics/mathematical/acosh.md:21
#: ../../doc/src/intrinsics/mathematical/asin.md:20
#: ../../doc/src/intrinsics/mathematical/asinh.md:21
#: ../../doc/src/intrinsics/mathematical/atan.md:20
#: ../../doc/src/intrinsics/mathematical/atanh.md:21
msgid ""
"The returned value has the kind of the input value and TYPE may be real "
"or complex."
msgstr "返回值具有输入值的种类，TYPE 可能是实数或复数。"

#: ../../doc/src/intrinsics/mathematical/acos.md:25
msgid "**acos(x)** computes the arcsine of the argument **x**."
msgstr "**acos(x)** 计算参数 **x** 的反正弦值。"

#: ../../doc/src/intrinsics/mathematical/acos.md:27
msgid ""
"The arc cosine is the inverse function of the cosine function. It is "
"commonly used in trigonometry to find the angle when the lengths of the "
"hypotenuse and the base side  of a right triangle are known."
msgstr "反余弦是余弦函数的反函数。 "
"当已知直角三角形的斜边和底边的长度时，它通常用于三角学中以找到角度。"

#: ../../doc/src/intrinsics/mathematical/acos.md:33
#: ../../doc/src/intrinsics/mathematical/acosh.md:45
#: ../../doc/src/intrinsics/mathematical/asin.md:33
#: ../../doc/src/intrinsics/mathematical/asinh.md:37
#: ../../doc/src/intrinsics/mathematical/atan.md:33
#: ../../doc/src/intrinsics/mathematical/atanh.md:41
msgid "Supported argument types float, double, complex float, complex double."
msgstr "支持的参数类型 float、double、complex float、complex double。"

#: ../../doc/src/intrinsics/mathematical/acos.md:84
msgid "[asin](asin.md), [atan](atan.md)."
msgstr "[asin](asin.md)，[atan](atan.md)。"

#: ../../doc/src/intrinsics/mathematical/acosh.md:1
msgid "acosh(x): Inverse Hyperbolic Cosine"
msgstr "acosh(x)：反双曲余弦"

#: ../../doc/src/intrinsics/mathematical/acosh.md:3
msgid "Inverse hyperbolic cosine function."
msgstr "反双曲余弦函数。"

#: ../../doc/src/intrinsics/mathematical/acosh.md:16
#: ../../doc/src/intrinsics/mathematical/asinh.md:16
#: ../../doc/src/intrinsics/mathematical/atanh.md:16
msgid ""
"`x` the input value, can be real with value greater than or equal to 1 or"
" of type complex."
msgstr "`x` 输入值，可以是大于或等于 1 的实数，也可以是复数类型。"

#: ../../doc/src/intrinsics/mathematical/acosh.md:26
msgid "**acosh(x)** computes the inverse hyperbolic cosine function of **x**."
msgstr "**acosh(x)** 计算 **x** 的反双曲余弦函数。"

#: ../../doc/src/intrinsics/mathematical/acosh.md:28
#: ../../doc/src/intrinsics/mathematical/asinh.md:28
#: ../../doc/src/intrinsics/mathematical/atanh.md:28
msgid "The result type and kind are the same as input value `x`."
msgstr "结果类型和种类与输入值`x`相同。"

#: ../../doc/src/intrinsics/mathematical/acosh.md:30
msgid ""
"If the result is complex, the real part is non-negative, and the "
"imaginary part is expressed in radians and lients in the range"
msgstr "如果结果为复数，则实部为非负数，虚部以弧度和范围内的 lients 表示"

#: ../../doc/src/intrinsics/mathematical/acosh.md:33
msgid "$-\\pi <= img (acosh(x)) <= \\pi$"
msgstr "$-\\pi <= img (acosh(x)) <= \\pi$"

#: ../../doc/src/intrinsics/mathematical/acosh.md:35
msgid ""
"For real values $x$ in the domain $x > 1$, the inverse hyperbolic cosine "
"satisifies:"
msgstr "对于域 $x > 1$ 中的实数值 $x$，反双曲余弦满足："

#: ../../doc/src/intrinsics/mathematical/acosh.md:38
msgid "$cosh^{-1}(x) = \\log(x + \\sqrt{(x^2 - 1)})$"
msgstr "$cosh^{-1}(x) = \\log(x + \\sqrt{(x^2 - 1)})$"

#: ../../doc/src/intrinsics/mathematical/acosh.md:40
msgid ""
"For complex numbers $x = x + iy$, as well as real values in the domain "
"$-\\infty < z <= 1$, the call $acosh(z)$ returns complex results."
msgstr "对于复数 $x = x + iy$，以及域 $-\\infty < z <= 1$ 中的实数值，调用 $acosh(z)$"
" 返回复数结果。"

#: ../../doc/src/intrinsics/mathematical/acosh.md:88
msgid "[asinh](asinh.md), [atanh](atanh.md)."
msgstr "[asinh](asinh.md)，[atanh](atanh.md)。"

#: ../../doc/src/intrinsics/mathematical/asin.md:1
msgid "asin(x): Trigonometric Arcsine"
msgstr "asin(x)：三角反正弦"

#: ../../doc/src/intrinsics/mathematical/asin.md:3
msgid "Trigonometric arcsine function."
msgstr "三角反正弦函数。"

#: ../../doc/src/intrinsics/mathematical/asin.md:25
msgid "**asin(x)** computes the arcsine of the argument **x**."
msgstr "**asin(x)** 计算参数 **x** 的反正弦值。"

#: ../../doc/src/intrinsics/mathematical/asin.md:27
msgid ""
"The arcsine is the inverse function of the sine function. It is commonly "
"used in trigonometry to find the angle when the lengths of the hypotenuse"
" and the opposite side of a right triangle are known."
msgstr "反正弦是正弦函数的反函数。 "
"当已知直角三角形的斜边和对边的长度时，它通常用于三角学中以找到角度。"

#: ../../doc/src/intrinsics/mathematical/asin.md:84
msgid "[acos](acos.md), [atan](atan.md)."
msgstr "[acos](acos.md), [atan](atan.md)."

#: ../../doc/src/intrinsics/mathematical/asinh.md:1
msgid "asinh(x): Inverse Hyperbolic Arcsine"
msgstr "asinh(x)：反双曲反正弦"

#: ../../doc/src/intrinsics/mathematical/asinh.md:3
msgid "Inverse hyperbolic arcsine function."
msgstr "反双曲反正弦函数。"

#: ../../doc/src/intrinsics/mathematical/asinh.md:26
msgid "**asinh(x)** computes the inverse hyperbolic arcsine function of **x**."
msgstr "**asinh(x)** 计算 **x** 的反双曲反正弦函数。"

#: ../../doc/src/intrinsics/mathematical/asinh.md:30
msgid ""
"If the result is complex, the real part is non-negative, and the "
"imaginary part is expressed in radians and lies in the range"
msgstr "如果结果为复数，则实部为非负数，虚部以弧度表示，位于范围内"

#: ../../doc/src/intrinsics/mathematical/asinh.md:33
msgid "$\\frac{-\\pi}{2} <= aimag (asinh(x)) <= \\frac{\\pi}{2}$"
msgstr "$\\frac{-\\pi}{2} <= aimag (asinh(x)) <= \\frac{\\pi}{2}$"

#: ../../doc/src/intrinsics/mathematical/asinh.md:80
msgid "[acosh](acosh.md), [atanh](atanh.md)."
msgstr "[acosh](acosh.md), [atanh](atanh.md)."

#: ../../doc/src/intrinsics/mathematical/atan.md:1
msgid "atan(x): Trigonometric ArcTangent"
msgstr "atan(x)：三角函数 ArcTangent"

#: ../../doc/src/intrinsics/mathematical/atan.md:3
msgid "Trigonometric arctangent (inverse arctangent) function."
msgstr "三角反正切（反正切）函数。"

#: ../../doc/src/intrinsics/mathematical/atan.md:25
msgid "**atan(x)** computes the arctangent of the argument **x**."
msgstr "**atan(x)** 计算参数 **x** 的反正切。"

#: ../../doc/src/intrinsics/mathematical/atan.md:27
msgid ""
"The arc tangent is the inverse function of the arctangent function. It is"
" commonly used in trigonometry to find the angle when the lengths of the "
"opposite side of a right triangle and base are known, i.e., perpendicular"
" and base length."
msgstr "反正切是反正切函数的反函数。 当直角三角形的对边和底边的长度已知时，即垂直和底"
"边长度，它通常用于三角学中找到角度。"

#: ../../doc/src/intrinsics/mathematical/atan.md:84
msgid "[asin](asin.md), [acos](acos.md)."
msgstr "[asin](asin.md), [acos](acos.md)."

#: ../../doc/src/intrinsics/mathematical/atan2.md:1
msgid "atan2(y, x): ArcTangent"
msgstr "atan2(y, x)：反正切"

#: ../../doc/src/intrinsics/mathematical/atan2.md:3
msgid "Arctangent function or inverse tangent function."
msgstr "反正切函数或反正切函数。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:15
msgid "`y` the input value is the imaginary part of the complex expression"
msgstr "`y` 输入值是复数表达式的虚部"

#: ../../doc/src/intrinsics/mathematical/atan2.md:17
#: ../../doc/src/intrinsics/numeric/aimag.md:29
#: ../../doc/src/intrinsics/numeric/cmplx.md:43
msgid "$x + iy$"
msgstr "$x + iy$"

#: ../../doc/src/intrinsics/mathematical/atan2.md:19
msgid "`x` the input value, must be real part of the complex expression."
msgstr "`x` 输入值，必须是复数表达式的实部。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:23
msgid ""
"The returned value has the kind and TYPE as of the input value `y`. The "
"principal value of the argument function of the complex expression $x + "
"iy$ is returned."
msgstr "返回值具有与输入值 `y` 相同的种类和类型。 返回复杂表达式 $x + iy$ "
"的参数函数的主值。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:29
msgid ""
"**atan2(y, x)** computes the principal value of the argument function of "
"the complex expression $x + iy$. This is used to transform from cartesian"
" into polar coordinates and allows to determine the angle in the correct "
"quadrant."
msgstr ""
"**atan2(y, x)** 计算复数表达式 $x + iy$ 的参数函数的主值。 "
"这用于从笛卡尔坐标转换为极坐标，并允许确定正确象限中的角度。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:33
msgid "It is also represented as:"
msgstr "它也表示为："

#: ../../doc/src/intrinsics/mathematical/atan2.md:35
msgid "$tan^{-1}(\\frac{y}{x})$"
msgstr "$tan^{-1}(\\frac{y}{x})$"

#: ../../doc/src/intrinsics/mathematical/atan2.md:37
msgid "If `x` is nonzero, the result lies in the range:"
msgstr "如果 `x` 不为零，则结果位于以下范围内："

#: ../../doc/src/intrinsics/mathematical/atan2.md:39
msgid "$-\\pi <= atan(x) <= \\pi$"
msgstr "$-\\pi <= atan(x) <= \\pi$"

#: ../../doc/src/intrinsics/mathematical/atan2.md:41
msgid "The sign is positive if `y` is positive."
msgstr "如果`y`为正，则符号为正。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:43
msgid "If `y` is zero and `x` is strictly positive, then the result is 0."
msgstr "如果 `y` 为零且 `x` 严格为正，则结果为 0。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:45
msgid "If `x` is negative and `y` is positive zero, then the result is $\\pi$."
msgstr "如果 `x` 为负数且 `y` 为正零，则结果为 $\\pi$。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:47
msgid "If `x` is negative and `y` is negative zero, then the result is $-\\pi$."
msgstr "如果 `x` 为负且 `y` 为负零，则结果为 $-\\pi$。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:49
msgid "If `x` is zero, then the magnitude of the result is $\\frac{\\pi}{2}$."
msgstr "如果 `x` 为零，则结果的大小为 $\\frac{\\pi}{2}$。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:51
msgid "If `y` is negative real zero, the result is $\\frac{-\\pi}{2}$."
msgstr "如果 `y` 为负实零，则结果为 $\\frac{-\\pi}{2}$。"

#: ../../doc/src/intrinsics/mathematical/atan2.md:55
#: ../../doc/src/intrinsics/mathematical/fraction.md:32
msgid "Supported argument type is real."
msgstr "支持的参数类型是实数。"

#: ../../doc/src/intrinsics/mathematical/atanh.md:1
msgid "atanh(x): Inverse Hyperbolic Tangent"
msgstr "atanh(x)：反双曲正切"

#: ../../doc/src/intrinsics/mathematical/atanh.md:3
msgid "Inverse hyperbolic tangent function."
msgstr "反双曲正切函数。"

#: ../../doc/src/intrinsics/mathematical/atanh.md:26
msgid "**atanh(x)** computes the inverse hyperbolic tangent function of **x**."
msgstr "**atanh(x)** 计算 **x** 的反双曲正切函数。"

#: ../../doc/src/intrinsics/mathematical/atanh.md:30
msgid ""
"If the result is complex, the imaginary part is expressed in radians and "
"lies in the range"
msgstr "如果结果为复数，则虚部以弧度表示，位于范围内"

#: ../../doc/src/intrinsics/mathematical/atanh.md:33
msgid "$\\frac{-\\pi}{2} <= aimag (atanh(x)) <= \\frac{\\pi}{2}$"
msgstr "$\\frac{-\\pi}{2} <= aimag (atanh(x)) <= \\frac{\\pi}{2}$"

#: ../../doc/src/intrinsics/mathematical/atanh.md:35
msgid "If the result is real, it lies in the range"
msgstr "如果结果是实数，它位于范围内"

#: ../../doc/src/intrinsics/mathematical/atanh.md:37
msgid "$-1.0 < atanh(x) < 1.0$"
msgstr "$-1.0 < atanh(x) < 1.0$"

#: ../../doc/src/intrinsics/mathematical/atanh.md:84
msgid "[asinh](asinh.md), [acosh](acosh.md)."
msgstr "[asinh](asinh.md)，[acosh](acosh.md)。"

#: ../../doc/src/intrinsics/mathematical/fraction.md:1
msgid "fraction(x): Fractional Part in Model Representation"
msgstr "fraction(x)：模型表示中的小数部分"

#: ../../doc/src/intrinsics/mathematical/fraction.md:3
msgid "Fractional part of the model representation."
msgstr "模型表示的小数部分。"

#: ../../doc/src/intrinsics/mathematical/fraction.md:15
msgid "`x` the input value, must be real."
msgstr "`x` 输入值，必须是实数。"

#: ../../doc/src/intrinsics/mathematical/fraction.md:19
msgid ""
"The returned value has the kind of the input value. The fractional part "
"of the model representation of the input value is returned."
msgstr "返回值具有输入值的种类。 返回输入值的模型表示的小数部分。"

#: ../../doc/src/intrinsics/mathematical/fraction.md:24
msgid ""
"**fraction(x)** computes the fractional part of the model representation "
"of **x**."
msgstr "**fraction(x)** 计算 **x** 的模型表示的小数部分。"

#: ../../doc/src/intrinsics/mathematical/fraction.md:26
#: ../../doc/src/intrinsics/numeric/erf.md:29
#: ../../doc/src/intrinsics/numeric/erfc.md:29
msgid "It is calculated using:"
msgstr "它是使用以下方法计算的："

#: ../../doc/src/intrinsics/mathematical/fraction.md:28
msgid "$x * {radix(x)}^{(-exponent(x))}$"
msgstr "$x * {radix(x)}^{(-exponent(x))}$"

#: ../../doc/src/intrinsics/misc.md:1
msgid "Miscellaneous Intrinsic Functions"
msgstr "其他内置函数"

#: ../../doc/src/intrinsics/misc/command_argument_count.md:1
msgid "command_argument_count(): Number of Command Line Arguments"
msgstr "command_argument_count()：命令行参数的数量"

#: ../../doc/src/intrinsics/misc/command_argument_count.md:3
msgid "Get number of command line arguments."
msgstr "获取命令行参数的数量。"

#: ../../doc/src/intrinsics/misc/command_argument_count.md:20
msgid "The return value is of integer type and of default kind."
msgstr "返回值是整数类型和默认类型。"

#: ../../doc/src/intrinsics/misc/command_argument_count.md:24
msgid ""
"**command_argument_count()** returns the number of arguments passed on "
"the command line when the named program was invoked."
msgstr "**command_argument_count()** 返回调用指定程序时在命令行上传递的参数数量。"

#: ../../doc/src/intrinsics/misc/command_argument_count.md:29
msgid "Any."
msgstr "任意。"

#: ../../doc/src/intrinsics/misc/cpu_time.md:1
msgid "cpu_time(x): CPU Elapsed Time"
msgstr "cpu_time(x)：CPU 运行时间"

#: ../../doc/src/intrinsics/misc/cpu_time.md:3
msgid "CPU elapsed time in seconds."
msgstr "CPU 运行时间（以秒为单位）。"

#: ../../doc/src/intrinsics/misc/cpu_time.md:16
msgid "`x` the input value should be of type real with `intent(out)`."
msgstr "`x` 输入值应该是带有 `intent(out)` 的实数类型。"

#: ../../doc/src/intrinsics/misc/cpu_time.md:24
msgid ""
"**cpu_time(time)** returns a real value representing the elapsed CPU time"
" in seconds. If tine source is available, time will be reported with "
"microsecond resolution. If no time source is available, TIME is set to "
"-1.0."
msgstr ""
"**cpu_time(time)** 返回一个实数值，以秒为单位表示经过的 CPU 时间。 "
"如果齿源可用，时间将以微秒分辨率报告。 如果没有可用的时间源，则将 TIME "
"设置为 -1.0。"

#: ../../doc/src/intrinsics/misc/cpu_time.md:28
msgid "This is useful for testing segments of code to determine computation time."
msgstr "这对于测试代码段以确定计算时间很有用。"

#: ../../doc/src/intrinsics/misc/cpu_time.md:30
msgid ""
"For `cpu_time(time)` the absolute value is meaningless, only differences "
"between subsequent calls to this subroutine, as shown in the example "
"below, should be used."
msgstr "`cpu_time(time)` 的绝对值是没有意义的，只有后续调用这个子程序之间的差异，如下"
"例所示，应该被使用。"

#: ../../doc/src/intrinsics/misc/cpu_time.md:35
#: ../../doc/src/intrinsics/misc/date_and_time.md:55
msgid "Supported input parameter types is real with `intent(out)`."
msgstr "支持的输入参数类型为 `intent(out)` 和实数。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:1
msgid "date_and_time([date, time, zone, values]): Date and Time"
msgstr "date_and_time([date, time, zone, values])：日期和时间"

#: ../../doc/src/intrinsics/misc/date_and_time.md:3
msgid "Date and time subroutine."
msgstr "日期和时间子程序。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:16
msgid ""
"`date` the input value of character type, which has length 8 or larger. "
"It is of default kind. It is `intent(out)` and has form `ccyymmdd`."
msgstr ""
"`date` 字符类型的输入值，长度为 8 或更大。 它是默认类型。 它是 `intent(out)` "
"并且具有 `ccyymmdd` 的形式。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:19
msgid ""
"`time` the input value of character type, which has length 10 or larger. "
"It is of default kind. It is `intent(out)` and has form `hhmmss.sss`."
msgstr ""
"`time` 字符类型的输入值，长度为 10 或更大。 它是默认类型。 它是 `intent(out)`"
" 并且具有 `hhmmss.sss` 的形式。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:22
msgid ""
"`zone` the input value of character type, which has length 5 or larger. "
"It is of default kind. It is `intent(out)` and has from `(+-)hhmm`, "
"representing the difference with respect to Coordinates Universal Time "
"(UTC). Unavailable time and date parameters return blanks."
msgstr ""
"`zone` 字符类型的输入值，长度为 5 或更大。 它是默认类型。 它是 `intent(out)` "
"并且来自 `(+-)hhmm`，表示相对于坐标世界时 (UTC) 的差异。 "
"不可用的时间和日期参数返回空白。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:27
msgid ""
"`values` the input value of integer type, 8 bits. It is `intent(out)`. It"
" provides the following:"
msgstr "`values`整数类型的输入值，8位。 它是`intent(out)`。 它提供以下内容："

#: ../../doc/src/intrinsics/misc/date_and_time.md:30
msgid "`value(1)`: The year."
msgstr "`value(1)`：年份。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:31
msgid "`value(2)`: The month."
msgstr "`value(2)`：月份。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:32
msgid "`value(3)`: The day of the month."
msgstr "`value(3)`：一个月中的哪一天。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:33
msgid "`value(4)`: Time difference with UTC in minutes."
msgstr "`value(4)`：与 UTC 的时差，以分钟为单位。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:34
msgid "`value(5)`: The hour of the day."
msgstr "`value(5)`：一天中的小时。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:35
msgid "`value(6)`: The minutes of the hour."
msgstr "`value(6)`：小时的分钟数。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:36
msgid "`value(7)`: The seconds of the minutes."
msgstr "`value(7)`：分钟的秒数。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:37
msgid "`value(8)`: The milliseconds of the second."
msgstr "`value(8)`：秒的毫秒数。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:45
msgid ""
"**date_and_time([date, time, zone, values])** reports the corresponding "
"date and time information from the real time system clock."
msgstr "**date_and_time([date, time, zone, values])** "
"从实时系统时钟报告相应的日期和时间信息。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:48
msgid ""
"`date`, `time`, `zone`, `values` represents date, time, zone, and values"
"  as decribed in arguments above."
msgstr "`date`、`time`、`zone`、`values` 表示日期、时间、区域和值，如上述参数中所述。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:51
msgid "Unavailable or errorneous date and time parameters return blanks."
msgstr "不可用或错误的日期和时间参数返回空白。"

#: ../../doc/src/intrinsics/misc/date_and_time.md:92
msgid "[cpu_time](cpu_time.md)."
msgstr "[cpu_time](cpu_time.md)。"

#: ../../doc/src/intrinsics/misc/new_line.md:1
msgid "new_line(x): New Line Character"
msgstr "new_line(x)：换行符"

#: ../../doc/src/intrinsics/misc/new_line.md:3
msgid "New line character."
msgstr "换行符。"

#: ../../doc/src/intrinsics/misc/new_line.md:16
msgid ""
"The input parameter `x` must be of type character. It can be a scalar or "
"an array."
msgstr "输入参数 `x` 必须是字符类型。 它可以是标量或数组。"

#: ../../doc/src/intrinsics/misc/new_line.md:21
msgid ""
"The return value is a character of length one with the new line character"
" appended of the same kind as of `x`."
msgstr "返回值是一个长度为 1 的字符，并附加了与 `x` 相同类型的换行符。"

#: ../../doc/src/intrinsics/misc/new_line.md:26
msgid ""
"**new_line(x)** returns the new line character. The return value is the "
"ASCII newline character."
msgstr "**new_line(x)** 返回换行符。 返回值是 ASCII 换行符。"

#: ../../doc/src/intrinsics/misc/new_line.md:31
msgid "Supported input parameter types is character."
msgstr "支持的输入参数类型是字符。"

#: ../../doc/src/intrinsics/numeric.md:1
msgid "Numeric Intrinsic Functions"
msgstr "数值内置函数"

#: ../../doc/src/intrinsics/numeric/abs.md:1
msgid "abs(x): Absolute Value"
msgstr "abs(x)：绝对值"

#: ../../doc/src/intrinsics/numeric/abs.md:3
msgid "Absolute value."
msgstr "绝对值。"

#: ../../doc/src/intrinsics/numeric/abs.md:17
msgid "`x` the input value, can be integer, real, or complex."
msgstr "`x` 输入值，可以是整数、实数或复数。"

#: ../../doc/src/intrinsics/numeric/abs.md:21
msgid ""
"The return value is of type and kind same as of `x`. For complex input "
"value, return value is real."
msgstr "返回值的类型和种类与 `x` 相同。 对于复数输入值，返回值是实数。"

#: ../../doc/src/intrinsics/numeric/abs.md:26
msgid ""
"**abs(x)** calculates and returns absolute value of `x`. Result is "
"calculated using mathematical formula:"
msgstr "**abs(x)** 计算并返回 `x` 的绝对值。 结果使用数学公式计算："

#: ../../doc/src/intrinsics/numeric/abs.md:29
msgid "$|x|$"
msgstr "$|x|$"

#: ../../doc/src/intrinsics/numeric/abs.md:31
msgid "If `x` is complex, the result is calculated using mathematical formula:"
msgstr "如果 `x` 是复数，则使用数学公式计算结果："

#: ../../doc/src/intrinsics/numeric/abs.md:33
msgid "$\\sqrt{(x^2 + y^2)}$"
msgstr "$\\sqrt{(x^2 + y^2)}$"

#: ../../doc/src/intrinsics/numeric/abs.md:37
#: ../../doc/src/intrinsics/numeric/digits.md:28
#: ../../doc/src/intrinsics/numeric/dim.md:29
#: ../../doc/src/intrinsics/numeric/mod.md:45
msgid "Supported argument types are real and integer."
msgstr "支持的参数类型是实数和整数。"

#: ../../doc/src/intrinsics/numeric/abs.md:98
#: ../../doc/src/intrinsics/numeric/aimag.md:70
#: ../../doc/src/intrinsics/numeric/mod.md:97
msgid "[ceiling](ceiling.md), [floor](floor.md)."
msgstr "[ceiling](ceiling.md)，[floor](floor.md)。"

#: ../../doc/src/intrinsics/numeric/aimag.md:1
msgid "aimag(x): Imaginary Part"
msgstr "aimag(x)：虚部"

#: ../../doc/src/intrinsics/numeric/aimag.md:3
msgid "Imaginary part of complex number."
msgstr "复数的虚部。"

#: ../../doc/src/intrinsics/numeric/aimag.md:17
msgid "`x` the input value must be of complex type."
msgstr "`x` ，输入值必须是复合类型。"

#: ../../doc/src/intrinsics/numeric/aimag.md:21
msgid "The return value is imaginary part of type real and kind same as of `x`."
msgstr "返回值是类型为实数的虚数部分，种类与`x` 相同。"

#: ../../doc/src/intrinsics/numeric/aimag.md:25
msgid "**aimag(x)** returns the imaginary part of the input complex argument `x`."
msgstr "**aimag（x）** 返回输入复参数 `x` 的虚部。"

#: ../../doc/src/intrinsics/numeric/aimag.md:27
#: ../../doc/src/intrinsics/numeric/cmplx.md:41
#: ../../doc/src/intrinsics/numeric/conjg.md:27
msgid ""
"For `x` complex input value, the result is calculated using mathematical "
"formula:"
msgstr "对于 `x` 复数输入值，使用数学公式计算结果："

#: ../../doc/src/intrinsics/numeric/aimag.md:31
#: ../../doc/src/intrinsics/numeric/cmplx.md:45
#: ../../doc/src/intrinsics/numeric/conjg.md:31
msgid "$i$ the imaginary part is the result."
msgstr "$i$ 虚部是结果。"

#: ../../doc/src/intrinsics/numeric/aimag.md:35
msgid "Supported argument types are complex."
msgstr "支持的参数类型很复杂。"

#: ../../doc/src/intrinsics/numeric/aint.md:1
msgid "aint(x, [kind]): Truncate to a Whole Number"
msgstr "aint(x, [kind])：截断为整数"

#: ../../doc/src/intrinsics/numeric/aint.md:3
msgid "Truncate to a whole number."
msgstr "截断到一个整数。"

#: ../../doc/src/intrinsics/numeric/aint.md:16
#: ../../doc/src/intrinsics/numeric/anint.md:16
#: ../../doc/src/intrinsics/numeric/epsilon.md:16
#: ../../doc/src/intrinsics/numeric/erf.md:16
#: ../../doc/src/intrinsics/numeric/erfc.md:16
#: ../../doc/src/intrinsics/numeric/floor.md:16
msgid "`x` the input value must be of type real."
msgstr "`x` ，输入值必须是实数类型。"

#: ../../doc/src/intrinsics/numeric/aint.md:18
#: ../../doc/src/intrinsics/numeric/anint.md:18
msgid "`kind` the optional input parameter initialises the kind of the result."
msgstr "`kind` 可选的输入参数，初始化结果的种类。"

#: ../../doc/src/intrinsics/numeric/aint.md:22
#: ../../doc/src/intrinsics/numeric/anint.md:22
msgid ""
"The return value is of type integer(kind) if kind is passed as input "
"parameter. If not, default kind real is returned."
msgstr "如果 kind 作为输入参数传递，则返回值是 integer(kind) 类型。如果不是，"
"则返回默认类型 real。"

#: ../../doc/src/intrinsics/numeric/aint.md:25
msgid ""
"The return value is equal to or nearest largest whole number greater than"
" or equal to `x` not exceeding its magnitude."
msgstr "返回值等于或最接近大于或等于 `x` 且不超过其大小的最大整数。"

#: ../../doc/src/intrinsics/numeric/aint.md:30
msgid ""
"**aint(x)** returns the nearest largest whole number greater than or "
"equal to `x` not exceeding input value's magnitude."
msgstr "**aint(x)** 返回大于或等于 `x` 且不超过输入值大小的最接近的最大整数。"

#: ../../doc/src/intrinsics/numeric/aint.md:33
#: ../../doc/src/intrinsics/numeric/anint.md:36
msgid "The optional parameter `kind` specifies the kind of the result."
msgstr "可选参数 `kind` ，指定结果的种类。"

#: ../../doc/src/intrinsics/numeric/aint.md:37
#: ../../doc/src/intrinsics/numeric/anint.md:40
#: ../../doc/src/intrinsics/numeric/epsilon.md:31
#: ../../doc/src/intrinsics/numeric/erf.md:35
#: ../../doc/src/intrinsics/numeric/erfc.md:38
#: ../../doc/src/intrinsics/numeric/floor.md:35
#: ../../doc/src/intrinsics/numeric/gamma.md:40
msgid "Supported argument types is real."
msgstr "支持的参数类型是实数。"

#: ../../doc/src/intrinsics/numeric/aint.md:57
#: ../../doc/src/intrinsics/numeric/floor.md:85
msgid "[ceiling](ceiling.md), [mod](mod.md)."
msgstr "[ceiling](ceiling.md), [mod](mod.md)."

#: ../../doc/src/intrinsics/numeric/anint.md:1
msgid "anint(x, [kind]): Round to Nearest Whole Number"
msgstr "anint(x, [kind])：四舍五入到最近的整数"

#: ../../doc/src/intrinsics/numeric/anint.md:3
msgid "Round to nearest whole number."
msgstr "四舍五入到最近的整数。"

#: ../../doc/src/intrinsics/numeric/anint.md:25
msgid "The return value is equal to rounded whole number."
msgstr "返回值等于四舍五入的整数。"

#: ../../doc/src/intrinsics/numeric/anint.md:29
msgid "**anint(x)** calculates rounded value of input parameter `x`."
msgstr "**anint(x)** 计算输入参数 `x` 的舍入值。"

#: ../../doc/src/intrinsics/numeric/anint.md:31
msgid ""
"If `x` is less than or equal to 0 i.e., if `x` is negative or 0, "
"`anint(x)` returns `aint(x - 0.5)`."
msgstr "如果`x` 小于或等于0，即如果`x` 是负数或0，`anint(x)` 返回`aint(x - 0.5)` 。"

#: ../../doc/src/intrinsics/numeric/anint.md:34
msgid "If `x` is greater than 0, `anint(x)` returns `aint(x + 0.5)`."
msgstr "如果`x` 大于0，`anint(x)` 返回`aint(x + 0.5)` 。"

#: ../../doc/src/intrinsics/numeric/anint.md:60
msgid "[aint](aint.md)."
msgstr "[aint](aint.md)。"

#: ../../doc/src/intrinsics/numeric/ceiling.md:1
msgid "ceiling(x): Integer Ceiling"
msgstr "ceiling(x)：进一取整"

#: ../../doc/src/intrinsics/numeric/ceiling.md:3
msgid "Integer ceiling function"
msgstr "进一取整函数"

#: ../../doc/src/intrinsics/numeric/ceiling.md:16
msgid "The input value `x` may be of type real or integer."
msgstr "输入值 `x` 可以是实数或整数类型。"

#: ../../doc/src/intrinsics/numeric/ceiling.md:20
msgid "The return value is of type integer and nearest greater integer."
msgstr "返回值是整数类型和最接近它的更大整数。"

#: ../../doc/src/intrinsics/numeric/ceiling.md:24
msgid "**ceiling(x)** returns the least integer greater than or equal to `x`."
msgstr "**ceiling(x)** 返回大于或等于 `x` 的最小整数。"

#: ../../doc/src/intrinsics/numeric/ceiling.md:28
msgid "Supported input parameter types are integer and real."
msgstr "支持的输入参数类型是整数和实数。"

#: ../../doc/src/intrinsics/numeric/ceiling.md:66
msgid "[floor](floor.md), [mod](mod.md)."
msgstr "[floor](floor.md)，[mod](mod.md)。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:1
msgid "cmplx(x [, [, kind]]): Convert to Complex"
msgstr "cmplx(x [, [, kind]])：转换为复数"

#: ../../doc/src/intrinsics/numeric/cmplx.md:3
msgid "Conversion to complex type."
msgstr "转换为复数类型。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:14
msgid "`cmplx(x, y)` is one of the intrinsic present in ASR."
msgstr "`cmplx(x, y)` 是 ASR 中的内置函数之一。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:18
msgid ""
"`x` the input value must be of integer, real, or complex. `y` the "
"optional input value must be of type integer or real. It should be only "
"present in case `x` is not complex. `kind` the optional input value of "
"integer expression type for initialisation indicating the kind parameter "
"of the result."
msgstr ""
"`x` 输入值必须是整数、实数或复数。 `y` 可选输入值必须是整数或实数类型。"
"它应该只在 `x` 不是复数的情况下出现。 `kind` "
"用于初始化的整数表达式类型的可选输入值，指示结果的种类参数。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:26
msgid ""
"The return value is of complex type, with a kind defined by input `kind` "
"type specified. If the `kind` is not specified, the return value is of "
"default `kind` `complex` type."
msgstr "返回值是复数类型，类型由指定的输入`kind`类型定义。如果未指定 `kind`，"
"则返回值为默认 `kind` `complex` 类型。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:32
msgid ""
"**cmplx(x, [, y [, kind]])** converts the input value to complex "
"representation:"
msgstr "**cmplx(x, [, y [, kind]])** 将输入值转换为复数表示："

#: ../../doc/src/intrinsics/numeric/cmplx.md:34
msgid ""
"`x` to real component of complex number. if `y` is present, it is "
"converted to the imaginary component."
msgstr "`x` 为复数的实部。如果 `y` 存在，则将其转换为虚部。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:37
msgid "If `y` is not present, the imaginary component is set to 0.0."
msgstr "如果 `y` 不存在，则虚部设置为 0.0。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:39
msgid "If `x` is complex then `y` must not be present."
msgstr "如果 `x` 是复数，则 `y` 不能出现。"

#: ../../doc/src/intrinsics/numeric/cmplx.md:49
msgid "Supported argument types are integer, real, or complex."
msgstr "支持的参数类型是整数、实数或复数。"

#: ../../doc/src/intrinsics/numeric/conjg.md:1
msgid "conjg(x): Complex Conjugate"
msgstr "conjg(x)：复共轭"

#: ../../doc/src/intrinsics/numeric/conjg.md:3
msgid "Complex conjugate function."
msgstr "复共轭函数。"

#: ../../doc/src/intrinsics/numeric/conjg.md:17
msgid "`x` the input value must be of type complex."
msgstr "`x` 输入值必须是复数类型。"

#: ../../doc/src/intrinsics/numeric/conjg.md:21
msgid "The return value is of complex type."
msgstr "返回值是复数类型。"

#: ../../doc/src/intrinsics/numeric/conjg.md:25
msgid "**conjg(x)** converts the input value `x`  to its conjugate."
msgstr "**conjg(x)** 将输入值 `x` 转换为其复数共轭。"

#: ../../doc/src/intrinsics/numeric/conjg.md:29
msgid "$x + iy$ converted to $x - iy$"
msgstr "$x + iy$ 转换为 $x - iy$"

#: ../../doc/src/intrinsics/numeric/conjg.md:35
msgid "Supported argument types is complex."
msgstr "支持的参数类型是复数。"

#: ../../doc/src/intrinsics/numeric/digits.md:1
msgid "digits(x): Significant Binary Digits"
msgstr "digits(x)：有效二进制数字"

#: ../../doc/src/intrinsics/numeric/digits.md:3
msgid "Significant binary digits."
msgstr "有效的二进制数字。"

#: ../../doc/src/intrinsics/numeric/digits.md:15
msgid "`x` the input value must be of type real or integer."
msgstr "`x` 输入值必须是实数或整数类型。"

#: ../../doc/src/intrinsics/numeric/digits.md:23
msgid ""
"**digits(x)** returns the number of significant binary digits of the "
"internal mopdel representation of `x`."
msgstr "**digits(x)** 返回 `x` 的内部模型表示的有效二进制位数。"

#: ../../doc/src/intrinsics/numeric/dim.md:1
msgid "dim(x, y): Positive Difference or 0"
msgstr "dim(x, y)：正差或 0"

#: ../../doc/src/intrinsics/numeric/dim.md:3
msgid "Positive difference or 0."
msgstr "正差或 0。"

#: ../../doc/src/intrinsics/numeric/dim.md:15
msgid ""
"`x` the input value must be of type real or integer. `y` the input value "
"must of of the same type and kind as of `x`."
msgstr "`x` 输入值必须是实数或整数类型。 `y` 输入值的类型和种类必须与 `x` 相同。"

#: ../../doc/src/intrinsics/numeric/dim.md:20
msgid "The return value is of type integer or real."
msgstr "返回值是整数或实数类型。"

#: ../../doc/src/intrinsics/numeric/dim.md:24
msgid ""
"**dim(x)** computes the difference $x - y$, if the result is positive, "
"otherwise returns 0."
msgstr "**dim(x)** 计算 $x - y$ 的差值，如果结果为正，否则返回 0。"

#: ../../doc/src/intrinsics/numeric/epsilon.md:1
msgid "epsilon(x): Epsilon"
msgstr "epsilon(x)：ε 小量"

#: ../../doc/src/intrinsics/numeric/epsilon.md:3
msgid "Epsilon function."
msgstr "Epsilon 函数。"

#: ../../doc/src/intrinsics/numeric/epsilon.md:20
msgid "The return value is of same type as of the input argument."
msgstr "返回值与输入参数的类型相同。"

#: ../../doc/src/intrinsics/numeric/epsilon.md:24
msgid ""
"**epsilon(x)** computes the smallest number $\\epsilon$ of the same kind "
"as `x` following:"
msgstr "**epsilon(x)** 计算与 `x` 相同类型的最小数 $\\epsilon$，如下所示："

#: ../../doc/src/intrinsics/numeric/epsilon.md:27
msgid "$1 + \\epsilon > 1$"
msgstr "$1 + \\epsilon > 1$"

#: ../../doc/src/intrinsics/numeric/erf.md:1
msgid "erf(x): Error"
msgstr "erf(x)：误差函数"

#: ../../doc/src/intrinsics/numeric/erf.md:3
msgid "Error function."
msgstr "误差函数。"

#: ../../doc/src/intrinsics/numeric/erf.md:20
msgid ""
"The return value is of type real and of the same kind as of the input "
"parameter `x`."
msgstr "返回值是 real 类型，与输入参数 `x` 的类型相同。"

#: ../../doc/src/intrinsics/numeric/erf.md:25
#: ../../doc/src/intrinsics/numeric/erfc.md:25
msgid ""
"**erf(x)** computes the error function of `x`. The result lies in the "
"range:"
msgstr "**erf(x)** 计算 `x` 的误差函数。结果位于以下范围内："

#: ../../doc/src/intrinsics/numeric/erf.md:27
msgid "$-1 \\leq erf (x) \\leq 1$"
msgstr "$-1 \\leq erf (x) \\leq 1$"

#: ../../doc/src/intrinsics/numeric/erf.md:31
msgid "$\\frac{2}{\\sqrt\\pi}\\int_0^xe^{-t^2}dt$"
msgstr "$\\frac{2}{\\sqrt\\pi}\\int_0^xe^{-t^2}dt$"

#: ../../doc/src/intrinsics/numeric/erf.md:69
msgid "[erfc](erfc.md)."
msgstr "[erfc](erfc.md)."

#: ../../doc/src/intrinsics/numeric/erfc.md:1
msgid "erfc(x): Complementary Error"
msgstr "erfc(x)：互补误差"

#: ../../doc/src/intrinsics/numeric/erfc.md:3
msgid "Complementary error function."
msgstr "互补误差函数。"

#: ../../doc/src/intrinsics/numeric/erfc.md:20
msgid ""
"The return value is of type real and of the same kind as of the input "
"parameter `x`. `erfc(x)` returns $1 - erf(x)$."
msgstr "返回值是 real 类型，与输入参数 `x` 的类型相同。 `erfc(x)` 返回 $1 - erf(x)$。"

#: ../../doc/src/intrinsics/numeric/erfc.md:27
msgid "$0 \\leq erf (x) \\leq 2$"
msgstr "$0 \\leq erf (x) \\leq 2$"

#: ../../doc/src/intrinsics/numeric/erfc.md:31
msgid "$\\frac{2}{\\sqrt\\pi}\\int_{x}^{\\infty}e^{-t^2}dt$"
msgstr "$\\frac{2}{\\sqrt\\pi}\\int_{x}^{\\infty}e^{-t^2}dt$"

#: ../../doc/src/intrinsics/numeric/erfc.md:33
msgid ""
"It is used in instances when the large loss of relative accuracy occurs "
"if `erf(x)` is called for large `x` and the result is subtracted from 1."
msgstr "它用于在相对精度损失较大的情况下，如果为较大的 `x` 调用 `erf(x)` 并且从 1 "
"中减去结果。"

#: ../../doc/src/intrinsics/numeric/erfc.md:72
msgid "[erf](erf.md)."
msgstr "[erf](erf.md)."

#: ../../doc/src/intrinsics/numeric/exp.md:1
msgid "exp(x): Exponential"
msgstr "exp(x)：指数函数"

#: ../../doc/src/intrinsics/numeric/exp.md:3
msgid "Exponential function."
msgstr "指数函数。"

#: ../../doc/src/intrinsics/numeric/exp.md:16
msgid "`x` the input value must be of type real or complex."
msgstr "`x` 输入值必须是实数或复数类型。"

#: ../../doc/src/intrinsics/numeric/exp.md:20
msgid "The return value is of same type as of the input argument, `x`."
msgstr "返回值与输入参数 `x` 的类型相同。"

#: ../../doc/src/intrinsics/numeric/exp.md:24
msgid "**exp(x)** computes the base $e$ exponential of `x`, i.e., $e^x$."
msgstr "**exp(x)** 计算 `x` 的基本 $e$ 指数，即 $e^x$。"

#: ../../doc/src/intrinsics/numeric/exp.md:26
msgid ""
"If `x` is of type complex, its imaginary part is considered as a value in"
" radians."
msgstr "如果 `x` 是复数类型，它的虚部被认为是弧度值。"

#: ../../doc/src/intrinsics/numeric/exp.md:31
msgid "Supported argument types is real and complex."
msgstr "支持的参数类型是实数或复数。"

#: ../../doc/src/intrinsics/numeric/floor.md:1
msgid "floor(x, kind): Integer Floor"
msgstr "floor(x, kind)：去一取整"

#: ../../doc/src/intrinsics/numeric/floor.md:3
msgid "Integer floor function."
msgstr "去一取整函数。"

#: ../../doc/src/intrinsics/numeric/floor.md:18
msgid ""
"`kind` the optional input parameter must be a scalar integer constant "
"expression."
msgstr "`kind` 可选输入参数必须是一个标量整数常量表达式。"

#: ../../doc/src/intrinsics/numeric/floor.md:22
msgid ""
"The return value is of type integer(kind) if kind is passed as input "
"parameter. If not, default kind integer is returned."
msgstr "如果 kind 作为输入参数传递，则返回值是 integer(kind) "
"类型。如果不是，则返回默认类型整数。"

#: ../../doc/src/intrinsics/numeric/floor.md:25
msgid ""
"The return value is equal to or nearest greatest integer less than or "
"equal to `x`."
msgstr "返回值等于或最接近小于或等于 `x` 的最大整数。"

#: ../../doc/src/intrinsics/numeric/floor.md:30
msgid ""
"**floor(x)** returns the greatest integer less than or equal to x. It "
"returns an integer value unless spefically specified using second "
"optional paramter."
msgstr "**floor(x)** 返回小于或等于 x "
"的最大整数。它返回一个整数值，除非使用第二个可选参数特别指定。"

#: ../../doc/src/intrinsics/numeric/gamma.md:1
msgid "gamma(x): Gamma"
msgstr "gamma(x)：伽马函数"

#: ../../doc/src/intrinsics/numeric/gamma.md:3
msgid "Gamma function."
msgstr "伽马函数。"

#: ../../doc/src/intrinsics/numeric/gamma.md:16
msgid ""
"`x` the input value must be of type real. It should not be zero or a "
"negative integer."
msgstr "`x` 输入值必须是实数类型。它不应为零或负整数。"

#: ../../doc/src/intrinsics/numeric/gamma.md:21
msgid "The return value is of same type and kind as of `x`."
msgstr "返回值与 `x` 的类型和种类相同。"

#: ../../doc/src/intrinsics/numeric/gamma.md:25
msgid ""
"**gamma(x)** computes $\\gamma(x)$. For positive, integer value of `x`, "
"the Gamma function simplifies to factorial function:"
msgstr "**gamma(x)** 计算 $\\gamma(x)$。对于 `x` 的正整数值，Gamma "
"函数简化为阶乘函数："

#: ../../doc/src/intrinsics/numeric/gamma.md:28
msgid "$\\gamma(x) = (x-1)!$"
msgstr "$\\gamma(x) = (x-1)!$"

#: ../../doc/src/intrinsics/numeric/gamma.md:30
msgid "In general, if $x > 0$:"
msgstr "一般来说，如果 $x > 0$："

#: ../../doc/src/intrinsics/numeric/gamma.md:32
msgid "$\\gamma(x) = \\int_{0}^{\\infty} e^{-t} dt$"
msgstr "$\\gamma(x) = \\int_{0}^{\\infty} e^{-t} dt$"

#: ../../doc/src/intrinsics/numeric/gamma.md:34
msgid "and if $-n-1 < x < -n$ where n is an integer >= 0:"
msgstr "如果 $-n-1 < x < -n$ 其中 n 是整数 >= 0："

#: ../../doc/src/intrinsics/numeric/gamma.md:36
msgid ""
"$\\gamma(x) = \\int_{0}^{\\infty}(e ^{-t} - \\sum\\limits_{k=0}^n "
"\\frac{(-t)^k}{k!} dt)$"
msgstr ""
"$\\gamma(x) = \\int_{0}^{\\infty}(e ^{-t} - \\sum\\limits_{k=0}^n \\frac"
"{(-t)^k}{k!} dt)$"

#: ../../doc/src/intrinsics/numeric/gamma.md:76
msgid "[epsilon](epsilon.md)"
msgstr "[epsilon](epsilon.md)"

#: ../../doc/src/intrinsics/numeric/mod.md:1
msgid "mod(x, y): Modulus"
msgstr "mod(x, y)：模数"

#: ../../doc/src/intrinsics/numeric/mod.md:3
msgid "Modulus or remainder function."
msgstr "模数或余数函数。"

#: ../../doc/src/intrinsics/numeric/mod.md:17
msgid "`x` the input value, can be integer or real."
msgstr "`x` 输入值，可以是整数或实数。"

#: ../../doc/src/intrinsics/numeric/mod.md:19
msgid ""
"`y` second input parameter should be same type and kind as `x` and not "
"equal to 0."
msgstr "`y` 第二个输入参数的类型和种类应与 `x` 相同且不等于 0。"

#: ../../doc/src/intrinsics/numeric/mod.md:24
msgid ""
"The return value is of type and kind same as of `x`. The result is "
"calculated using mathematical modulo or remainder as:"
msgstr "返回值的类型和种类与 `x` 相同。结果使用数学模或余数计算为："

#: ../../doc/src/intrinsics/numeric/mod.md:27
msgid "`x - INT (x / y) * y`."
msgstr "`x - INT (x / y) * y`."

#: ../../doc/src/intrinsics/numeric/mod.md:29
msgid "If `y` is 0, the result is undefined like `any integer value / 0`."
msgstr "如果 `y` 为 0，则结果未定义，如 `any integer value / 0`。"

#: ../../doc/src/intrinsics/numeric/mod.md:33
msgid ""
"**mod(x, y)** calculates and returns modulo or remainder when `x` is "
"divided by `y`. The result is calculated using"
msgstr "**mod(x, y)** 当 `x` 除以 `y` 时计算并返回模数或余数。结果计算使用"

#: ../../doc/src/intrinsics/numeric/mod.md:36
msgid "`x - INT(x / y) * y`"
msgstr "`x - INT(x / y) * y`"

#: ../../doc/src/intrinsics/numeric/mod.md:38
msgid ""
"i.e., result is remainder when first argument is mathematically divided "
"by second argument."
msgstr "即，当第一个参数在数学上除以第二个参数时，结果是余数。"

#: ../../doc/src/intrinsics/numeric/mod.md:41
msgid "The return value should be less than `y`."
msgstr "返回值应该小于`y`。"

#: ../../doc/src/language.md:1
msgid "Fortran Language"
msgstr "Fortran 语言"

#: ../../doc/src/language.md:3
msgid "Background and Motivation"
msgstr "背景和动机"

#: ../../doc/src/language.md:5
msgid ""
"Fortran was designed from the ground up to naturally and simply translate"
" mathematics to code that compiles and runs at maximum speed. And being "
"specifically targeted for such fundamentally computational tasks, it "
"contains a broad range of key functionality within the language itself, "
"standard across all platforms, with no need for external libraries that "
"may or may not be well optimized or maintained, at present or down the "
"road."
msgstr ""
"Fortran 的设计从一开始就自然而简单地将数学转换为以最高速度编译和运行的代码。"
"并且专门针对此类基本计算任务，它在语言本身中包含广泛的关键功能，在所有平台上"
"都是标准的，不需要目前或未来可能会或可能不会得到很好优化或维护的外部库路。"

#: ../../doc/src/language.md:12
msgid "Some highlights:"
msgstr "一些亮点："

#: ../../doc/src/language.md:14
msgid ""
"Multidimensional arrays which can be allocated and indexed as the "
"math/science dictates (not restricted to start at 0 or 1) and can be "
"sliced as desired (as, e.g., in MATLAB);"
msgstr "多维数组，可以根据数学/科学的要求进行分配和索引（不限于从 0 或 1 "
"开始），并且可以根据需要进行切片（例如，在 MATLAB 中）；"

#: ../../doc/src/language.md:17
msgid ""
"Operators which operate naturally upon the aforementioned "
"arrays/matrices, as they do scalars;"
msgstr "像对标量一样自然地对上述数组/矩阵进行操作的运算符；"

#: ../../doc/src/language.md:19
msgid "Complex numbers;"
msgstr "复数；"

#: ../../doc/src/language.md:20
msgid "Special functions;"
msgstr "特殊函数；"

#: ../../doc/src/language.md:21
msgid "Structures and pointers for more general data representation."
msgstr "用于更通用数据表示的结构和指针。"

#: ../../doc/src/language.md:23
msgid ""
"Because the essentials are contained in the language itself, it is simple"
" to read and write, without need of choosing from among or deciphering a "
"proliferation of external classes to do the same thing. And because the "
"essentials are self-contained, compilers can provide detailed compile-"
"time (e.g., argument mismatch) and run-time (e.g., memory access) checks,"
" as well as highly optimized executables, directly from natural, readable"
" code without need of extensive optimization heroics by the developer."
msgstr ""
"因为基本内容包含在语言本身中，所以阅读和编写都很简单，无需从大量的外部类中进"
"行选择或破译来做同样的事情。由于这些要素是自包含的，编译器可以直接从自然、可"
"读的代码中提供详细的编译时（例如，参数不匹配）和运行时（例如，内存访问）检查"
"，以及高度优化的可执行文件。开发人员的广泛优化英雄。"

#: ../../doc/src/language.md:31
msgid "See our blog posts for more information:"
msgstr "有关更多信息，请参阅我们的博客文章："

#: ../../doc/src/language.md:33
msgid ""
"[Why We Created LFortran](https://lfortran.org/blog/2019/04/why-we-"
"created-lfortran/)"
msgstr ""
"[我们为什么创建 LFortran](https://lfortran.org/blog/2019/04/"
"why-we-created-lfortran/)"

#: ../../doc/src/language.md:34
msgid ""
"[Why to Use Fortran For New Projects](https://lfortran.org/blog/2019/05"
"/why-to-use-fortran-for-new-projects/)"
msgstr ""
"[为什么在新项目中使用 Fortran](https://lfortran.org/blog/2019/05/"
"why-to-use-fortran-for-new-projects/)"

#: ../../doc/src/language.md:36
msgid "How to Learn Fortran"
msgstr "如何学习 Fortran"

#: ../../doc/src/language.md:38
msgid ""
"Fortran is relatively quick to learn because it is so much simpler and "
"smaller than C/C++ (in practice, that is, with all needed libraries "
"included). If you are interested in learning more, please see our webpage"
" at [fortran90.org] with recommended practices for writing code, side by "
"side comparison with Python/NumPy, links to other online Fortran "
"resources and books, and an FAQ."
msgstr ""
"Fortran 学习起来相对较快，因为它比 C/C++ "
"简单得多，也更小（实际上，包括所有需要的库）。如果你有兴趣了解更多信息，"
"请参阅我们的网页 [fortran90.org]，其中包含编写代码的推荐做法、与 Python/"
"NumPy 的并排比较、其他在线 Fortran 资源和书籍的链接以及常见问题解答。"

#: ../../doc/src/progress.md:3
msgid ""
"This page documents what Fortran features are supported by LFortran. For "
"each feature we list a short description, the filename with the test and "
"current status for each parts of the compiler:"
msgstr ""
"此页面记录了 LFortran 支持的 Fortran 功能。对于每个特性，我们列出了一个简短的"
"描述，以及编译器每个部分的测试和当前状态的文件名："

#: ../../doc/src/progress.md:7
msgid "AST: The code can be parsed to AST (`lfortran --show-ast test.f90`)"
msgstr "AST：代码可以解析为 AST (`lfortran --show-ast test.f90`)"

#: ../../doc/src/progress.md:8
msgid "ASR: The code can be transformed to ASR (`lfortran --show-asr test.f90`)"
msgstr "ASR：代码可以转换为 ASR (`lfortran --show-asr test.f90`)"

#: ../../doc/src/progress.md:9
msgid "LLVM: LFortran can generate LLVM IR (`lfortran --show-llvm test.f90`)"
msgstr "LLVM：LFortran 可以生成 LLVM IR (`lfortran --show-llvm test.f90`)"

#: ../../doc/src/progress.md:10
msgid "BIN: The LLVM IR can compile to a binary"
msgstr "BIN：LLVM IR 可以编译为二进制文件"

#: ../../doc/src/progress.md:11
msgid "RUN: The binary runs without errors"
msgstr "RUN：二进制运行没有错误"

#: ../../doc/src/progress.md:13
msgid ""
"If all are green it means the feature fully works and you can use it in "
"your codes. Otherwise you can see what the status is of each feature."
msgstr "如果全部为绿色，则表示该功能完全有效，你可以在代码中使用它。否则，你可以查看"
"每个功能的状态。"

#: ../../doc/src/progress.md:16
msgid ""
"This page is generated automatically using the [Compiler "
"Tester](https://gitlab.com/lfortran/compiler_tester) repository which "
"contains all the Fortran tests and scripts to run LFortran to produce the"
" tables below. We are looking for contributors to contribute more tests. "
"Our goal is to have a comprehensive Fortran testsuite that can be used to"
" test any Fortran compiler."
msgstr ""
"此页面是使用 [Compiler Tester](https://gitlab.com/lfortran/compiler_tester) "
"存储库自动生成的，该存储库包含所有 Fortran 测试和脚本，用于运行 LFortran "
"以生成下表。我们正在寻找贡献者来贡献更多的测试。我们的目标是拥有一个全面的 "
"Fortran 测试套件，可用于测试任何 Fortran 编译器。"

#: ../../doc/src/progress.md:23
msgid "Testing the LFortran compiler version:"
msgstr "测试 LFortran 编译器版本："

#: ../../doc/src/progress.md:32
msgid "Topics"
msgstr "话题"

#: ../../doc/src/progress.md:34
msgid "Full programs that compute something interesting"
msgstr "计算有趣事物的完整程序"

#: ../../doc/src/progress.md:36
msgid "Basic Numerics"
msgstr "基本数值"

#: ../../doc/src/progress.md:38
msgid "Directory: `tests/programs/numerics`"
msgstr "路径：`tests/programs/numerics`"

#: ../../doc/src/progress.md
msgid "LLVM"
msgstr "LLVM"

#: ../../doc/src/progress.md
msgid "BIN"
msgstr "BIN"

#: ../../doc/src/progress.md
msgid "RUN"
msgstr "RUN"

#: ../../doc/src/progress.md
msgid "Filename"
msgstr "文件名"

#: ../../doc/src/progress.md
msgid "`Pure Fortran sin(x) implementation`"
msgstr "`纯 Fortran sin(x) 实现`"

#: ../../doc/src/progress.md
msgid "✅"
msgstr "✅"

#: ../../doc/src/progress.md
msgid "[t01_sin_implementation.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/programs/numerics/t01_sin_implementation.f90)"
msgstr ""
"[t01_sin_implementation.f90](https://gitlab.com/lfortran/compiler_tester/-/"
"blob/master/tests/programs/numerics/t01_sin_implementation.f90)"

#: ../../doc/src/progress.md:45
msgid "Modules"
msgstr "模块"

#: ../../doc/src/progress.md:47
msgid "Basic Usage"
msgstr "基本用法"

#: ../../doc/src/progress.md:49
msgid "Directory: `tests/modules/basic`"
msgstr "路径：`tests/modules/basic`"

#: ../../doc/src/progress.md
msgid "`Basic modules`"
msgstr "`基本模块`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/modules/basic/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"modules/basic/t01.f90)"

#: ../../doc/src/progress.md:56
msgid "Module Functions and Subroutines"
msgstr "模块函数和子程序"

#: ../../doc/src/progress.md:58
msgid "Directory: `tests/modules/procedures`"
msgstr "路径：`tests/modules/procedures`"

#: ../../doc/src/progress.md
msgid "`Module functions`"
msgstr "`模块函数`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/modules/procedures/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"modules/procedures/t01.f90)"

#: ../../doc/src/progress.md
msgid "`Module subroutines`"
msgstr "`模块子程序`"

#: ../../doc/src/progress.md
msgid "[t02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/modules/procedures/t02.f90)"
msgstr ""
"[t02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"modules/procedures/t02.f90)"

#: ../../doc/src/progress.md
msgid "`Nested subroutines`"
msgstr "`嵌套子程序`"

#: ../../doc/src/progress.md
msgid "[t03.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/modules/procedures/t03.f90)"
msgstr ""
"[t03.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"modules/procedures/t03.f90)"

#: ../../doc/src/progress.md:67
msgid "Expressions"
msgstr "表达式"

#: ../../doc/src/progress.md:69
msgid "Arithmetic Operations"
msgstr "算术运算"

#: ../../doc/src/progress.md:71
msgid "Directory: `tests/expressions/arit`"
msgstr "路径：`tests/expressions/arit`"

#: ../../doc/src/progress.md
msgid "`+,-,*,/,**`"
msgstr "`+,-,*,/,**`"

#: ../../doc/src/progress.md
msgid "[basic_operations.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/arit/basic_operations.f90)"
msgstr ""
"[basic_operations.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/expressions/arit/basic_operations.f90)"

#: ../../doc/src/progress.md:78
msgid "Integers"
msgstr "整型"

#: ../../doc/src/progress.md:80
msgid "Directory: `tests/expressions/integers`"
msgstr "路径：`tests/expressions/integers`"

#: ../../doc/src/progress.md
msgid "`integers`"
msgstr "`整型`"

#: ../../doc/src/progress.md
msgid "[integer_kind.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/integers/integer_kind.f90)"
msgstr ""
"[integer_kind.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/"
"tests/expressions/integers/integer_kind.f90)"

#: ../../doc/src/progress.md
msgid "`relational operations`"
msgstr "`关系运算`"

#: ../../doc/src/progress.md
msgid "[t01_rel_operations.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/integers/t01_rel_operations.f90)"
msgstr ""
"[t01_rel_operations.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/expressions/integers/t01_rel_operations.f90)"

#: ../../doc/src/progress.md
msgid "`logical operations`"
msgstr "`逻辑运算`"

#: ../../doc/src/progress.md
msgid "[t02_logical_operations.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/integers/t02_logical_operations.f90)"
msgstr ""
"[t02_logical_operations.f90](https://gitlab.com/lfortran/compiler_tester/-/"
"blob/master/tests/expressions/integers/t02_logical_operations.f90)"

#: ../../doc/src/progress.md:89
msgid "Real Numbers"
msgstr "实数"

#: ../../doc/src/progress.md:91
msgid "Directory: `tests/expressions/reals`"
msgstr "路径：`tests/expressions/reals`"

#: ../../doc/src/progress.md
msgid "`single/double reals`"
msgstr "`单/双精度实数`"

#: ../../doc/src/progress.md
msgid "[real_kind.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/reals/real_kind.f90)"
msgstr ""
"[real_kind.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/"
"tests/expressions/reals/real_kind.f90)"

#: ../../doc/src/progress.md
msgid "`defined operator`"
msgstr "`定义的运算符`"

#: ../../doc/src/progress.md
msgid "❌"
msgstr "❌"

#: ../../doc/src/progress.md
msgid "[t01_def_op.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/reals/t01_def_op.f90)"
msgstr ""
"[t01_def_op.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/"
"tests/expressions/reals/t01_def_op.f90)"

#: ../../doc/src/progress.md:99
msgid "Complex Numbers"
msgstr "复数"

#: ../../doc/src/progress.md:101
msgid "Directory: `tests/expressions/complex`"
msgstr "路径：`tests/expressions/complex`"

#: ../../doc/src/progress.md
msgid "`single/double complex`"
msgstr "`单/双复数`"

#: ../../doc/src/progress.md
msgid "[complex_kind.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/complex/complex_kind.f90)"
msgstr ""
"[complex_kind.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/"
"tests/expressions/complex/complex_kind.f90)"

#: ../../doc/src/progress.md:108
msgid "Strings"
msgstr "字符串"

#: ../../doc/src/progress.md:110
msgid "Directory: `tests/expressions/character`"
msgstr "路径：`tests/expressions/character`"

#: ../../doc/src/progress.md
msgid "`character`"
msgstr "`字符`"

#: ../../doc/src/progress.md
msgid "[t01_character.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/character/t01_character.f90)"
msgstr ""
"[t01_character.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/expressions/character/t01_character.f90)"

#: ../../doc/src/progress.md
msgid "`string concatenation`"
msgstr "`字符串连接`"

#: ../../doc/src/progress.md
msgid "[t02_concat_operation.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/character/t02_concat_operation.f90)"
msgstr ""
"[t02_concat_operation.f90](https://gitlab.com/lfortran/compiler_tester/-/"
"blob/master/tests/expressions/character/t02_concat_operation.f90)"

#: ../../doc/src/progress.md:118
msgid "Derived Types"
msgstr "派生类型"

#: ../../doc/src/progress.md:120
msgid "Directory: `tests/expressions/derived_type`"
msgstr "路径：`tests/expressions/derived_type`"

#: ../../doc/src/progress.md
msgid "`basic derived types`"
msgstr "`基本派生类型`"

#: ../../doc/src/progress.md
msgid "[t01_derived_type.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/expressions/derived_type/t01_derived_type.f90)"
msgstr ""
"[t01_derived_type.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/expressions/derived_type/t01_derived_type.f90)"

#: ../../doc/src/progress.md:127
msgid "Statements"
msgstr "声明"

#: ../../doc/src/progress.md:129
msgid "Allocate Statement"
msgstr "分配语句"

#: ../../doc/src/progress.md:131
msgid "Directory: `tests/statements/allocate`"
msgstr "路径：`tests/statements/allocate`"

#: ../../doc/src/progress.md
msgid "`allocate statement`"
msgstr "`分配语句`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/allocate/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/allocate/t01.f90)"

#: ../../doc/src/progress.md:138
msgid "Block Statement"
msgstr "块语句"

#: ../../doc/src/progress.md:140
msgid "Directory: `tests/statements/block`"
msgstr "路径：`tests/statements/block`"

#: ../../doc/src/progress.md
msgid "`block statement`"
msgstr "`块语句`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/block/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/block/t01.f90)"

#: ../../doc/src/progress.md:147
msgid "Goto Statement"
msgstr "转到语句"

#: ../../doc/src/progress.md:149
msgid "Directory: `tests/statements/goto`"
msgstr "路径：`tests/statements/goto`"

#: ../../doc/src/progress.md
msgid "`computed go-to statement`"
msgstr "`计算的首选语句`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/goto/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/goto/t01.f90)"

#: ../../doc/src/progress.md
msgid "`go-to statement`"
msgstr "`首选声明`"

#: ../../doc/src/progress.md
msgid "[t02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/goto/t02.f90)"
msgstr ""
"[t02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/goto/t02.f90)"

#: ../../doc/src/progress.md:157
msgid "If Statement"
msgstr "如果语句"

#: ../../doc/src/progress.md:159
msgid "Directory: `tests/statements/if`"
msgstr "路径：`tests/statements/if`"

#: ../../doc/src/progress.md
msgid "`Test .false.`"
msgstr "`Test .false.`"

#: ../../doc/src/progress.md
msgid "[if_01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/if/if_01.f90)"
msgstr ""
"[if_01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/if/if_01.f90)"

#: ../../doc/src/progress.md
msgid "`single line if statement`"
msgstr "`单行 if 语句`"

#: ../../doc/src/progress.md
msgid "[if_02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/if/if_02.f90)"
msgstr ""
"[if_02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/if/if_02.f90)"

#: ../../doc/src/progress.md
msgid "`multi line if statement`"
msgstr "`多行 if 语句`"

#: ../../doc/src/progress.md
msgid "[if_03.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/if/if_03.f90)"
msgstr ""
"[if_03.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/if/if_03.f90)"

#: ../../doc/src/progress.md
msgid "`nested if statements`"
msgstr "`嵌套的 if 语句`"

#: ../../doc/src/progress.md
msgid "[if_04.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/if/if_04.f90)"
msgstr ""
"[if_04.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/if/if_04.f90)"

#: ../../doc/src/progress.md:169
msgid "While Statement"
msgstr "While 语句"

#: ../../doc/src/progress.md:171
msgid "Directory: `tests/statements/while`"
msgstr "路径：`tests/statements/while`"

#: ../../doc/src/progress.md
msgid "`Simple while loops`"
msgstr "`简单的 while 循环`"

#: ../../doc/src/progress.md
msgid "[while_01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/while/while_01.f90)"
msgstr ""
"[while_01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/"
"tests/statements/while/while_01.f90)"

#: ../../doc/src/progress.md
msgid "`exit / cycle in while loops`"
msgstr "`从 while 循环退出/跳过`"

#: ../../doc/src/progress.md
msgid "[while_02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/while/while_02.f90)"
msgstr ""
"[while_02.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/"
"tests/statements/while/while_02.f90)"

#: ../../doc/src/progress.md:179
msgid "Print Statement"
msgstr "Print 声明"

#: ../../doc/src/progress.md:181
msgid "Directory: `tests/statements/print`"
msgstr "路径：`tests/statements/print`"

#: ../../doc/src/progress.md
msgid "`Basic print`"
msgstr "`基本 Print`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/print/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/print/t01.f90)"

#: ../../doc/src/progress.md:188
msgid "Open, Read, Write, Close Statement"
msgstr "Open、Read、Write、Close语句"

#: ../../doc/src/progress.md:190
msgid "Directory: `tests/statements/file_io`"
msgstr "路径：`tests/statements/file_io`"

#: ../../doc/src/progress.md
msgid "`open/read/write/close`"
msgstr "`open/read/write/close`"

#: ../../doc/src/progress.md
msgid "[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/statements/file_io/t01.f90)"
msgstr ""
"[t01.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/"
"statements/file_io/t01.f90)"

#: ../../doc/src/progress.md:197
msgid "Intrinsic Functions"
msgstr "内置函数"

#: ../../doc/src/progress.md:199
msgid "abs"
msgstr "abs"

#: ../../doc/src/progress.md:201
msgid "Directory: `tests/intrinsic/abs`"
msgstr "路径：`tests/intrinsic/abs`"

#: ../../doc/src/progress.md
msgid "`scalar single/double real`"
msgstr "`scalar single/double real`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/abs/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/abs/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "`scalar single/double complex`"
msgstr "`scalar single/double complex`"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/abs/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/abs/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "`array 1D single/double real`"
msgstr "`array 1D single/double real`"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/abs/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/abs/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:210
msgid "exp"
msgstr "exp"

#: ../../doc/src/progress.md:212
msgid "Directory: `tests/intrinsic/exp`"
msgstr "路径：`tests/intrinsic/exp`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/exp/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/exp/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/exp/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/exp/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/exp/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/exp/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:221
msgid "log"
msgstr "日志"

#: ../../doc/src/progress.md:223
msgid "Directory: `tests/intrinsic/log`"
msgstr "路径：`tests/intrinsic/log`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/log/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/log/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/log/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/log/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/log/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/log/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:232
msgid "sqrt"
msgstr "平方"

#: ../../doc/src/progress.md:234
msgid "Directory: `tests/intrinsic/sqrt`"
msgstr "路径：`tests/intrinsic/sqrt`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sqrt/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sqrt/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sqrt/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sqrt/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sqrt/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sqrt/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:243
msgid "sin"
msgstr "sin"

#: ../../doc/src/progress.md:245
msgid "Directory: `tests/intrinsic/sin`"
msgstr "路径：`tests/intrinsic/sin`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sin/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sin/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sin/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sin/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sin/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sin/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:254
msgid "cos"
msgstr "cos"

#: ../../doc/src/progress.md:256
msgid "Directory: `tests/intrinsic/cos`"
msgstr "路径：`tests/intrinsic/cos`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/cos/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/cos/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/cos/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/cos/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/cos/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/cos/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:265
msgid "tan"
msgstr "tan"

#: ../../doc/src/progress.md:267
msgid "Directory: `tests/intrinsic/tan`"
msgstr "路径：`tests/intrinsic/tan`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/tan/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/tan/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/tan/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/tan/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/tan/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/tan/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:276
msgid "sinh"
msgstr "sinh"

#: ../../doc/src/progress.md:278
msgid "Directory: `tests/intrinsic/sinh`"
msgstr "路径：`tests/intrinsic/sinh`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sinh/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sinh/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sinh/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sinh/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/sinh/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/sinh/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:287
msgid "cosh"
msgstr "cosh"

#: ../../doc/src/progress.md:289
msgid "Directory: `tests/intrinsic/cosh`"
msgstr "路径：`tests/intrinsic/cosh`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/cosh/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/cosh/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/cosh/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/cosh/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/cosh/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/cosh/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:298
msgid "tanh"
msgstr "tanh"

#: ../../doc/src/progress.md:300
msgid "Directory: `tests/intrinsic/tanh`"
msgstr "路径：`tests/intrinsic/tanh`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/tanh/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/tanh/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/tanh/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/tanh/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/tanh/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/tanh/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:309
msgid "asin"
msgstr "asin"

#: ../../doc/src/progress.md:311
msgid "Directory: `tests/intrinsic/asin`"
msgstr "路径：`tests/intrinsic/asin`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/asin/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/asin/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/asin/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/asin/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/asin/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/asin/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:320
msgid "acos"
msgstr "acos"

#: ../../doc/src/progress.md:322
msgid "Directory: `tests/intrinsic/acos`"
msgstr "路径：`tests/intrinsic/acos`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/acos/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/acos/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/acos/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/acos/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/acos/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/acos/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:331
msgid "atan"
msgstr "atan"

#: ../../doc/src/progress.md:333
msgid "Directory: `tests/intrinsic/atan`"
msgstr "路径：`tests/intrinsic/atan`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/atan/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/atan/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/atan/t02_scalar_complex.f90)"
msgstr ""
"[t02_scalar_complex.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/atan/t02_scalar_complex.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/atan/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/atan/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:342
msgid "modulo"
msgstr "modulo"

#: ../../doc/src/progress.md:344
msgid "Directory: `tests/intrinsic/modulo`"
msgstr "路径：`tests/intrinsic/modulo`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/modulo/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/modulo/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/modulo/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/modulo/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:352
msgid "mod"
msgstr "mod"

#: ../../doc/src/progress.md:354
msgid "Directory: `tests/intrinsic/mod`"
msgstr "路径：`tests/intrinsic/mod`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/mod/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/mod/t01_scalar_real.f90)"

#: ../../doc/src/progress.md
msgid "[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/mod/t03_array1d_real.f90)"
msgstr ""
"[t03_array1d_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/mod/t03_array1d_real.f90)"

#: ../../doc/src/progress.md:362
msgid "min"
msgstr "min"

#: ../../doc/src/progress.md:364
msgid "Directory: `tests/intrinsic/min`"
msgstr "路径：`tests/intrinsic/min`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/min/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/min/t01_scalar_real.f90)"

#: ../../doc/src/progress.md:371
msgid "max"
msgstr "max"

#: ../../doc/src/progress.md:373
msgid "Directory: `tests/intrinsic/max`"
msgstr "路径：`tests/intrinsic/max`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/max/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/max/t01_scalar_real.f90)"

#: ../../doc/src/progress.md:380
msgid "int"
msgstr "int"

#: ../../doc/src/progress.md:382
msgid "Directory: `tests/intrinsic/int`"
msgstr "路径：`tests/intrinsic/int`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/int/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/int/t01_scalar_real.f90)"

#: ../../doc/src/progress.md:389
msgid "real"
msgstr "real"

#: ../../doc/src/progress.md:391
msgid "Directory: `tests/intrinsic/real`"
msgstr "路径：`tests/intrinsic/real`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/real/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/real/t01_scalar_real.f90)"

#: ../../doc/src/progress.md:398
msgid "floor"
msgstr "floor"

#: ../../doc/src/progress.md:400
msgid "Directory: `tests/intrinsic/floor`"
msgstr "路径：`tests/intrinsic/floor`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/floor/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/floor/t01_scalar_real.f90)"

#: ../../doc/src/progress.md:407
msgid "nint"
msgstr "nint"

#: ../../doc/src/progress.md:409
msgid "Directory: `tests/intrinsic/nint`"
msgstr "路径：`tests/intrinsic/nint`"

#: ../../doc/src/progress.md
msgid "[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/master/tests/intrinsic/nint/t01_scalar_real.f90)"
msgstr ""
"[t01_scalar_real.f90](https://gitlab.com/lfortran/compiler_tester/-/blob/"
"master/tests/intrinsic/nint/t01_scalar_real.f90)"
